# Android_App ‚Äî Todo el C√≥digo Fuente

Este archivo contiene todos los archivos de c√≥digo fuente de la carpeta `Android_App/` concatenados.

---

## `Android_App/app/src/main/java/com/georacing/georacing/MainActivity.kt`

```kotlin
package com.georacing.georacing

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.detectTapGestures // Added
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.navigationBarsPadding
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Scaffold
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.input.pointer.pointerInput // Added
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.OutOfQuotaPolicy
import androidx.work.WorkManager
import com.georacing.georacing.data.energy.EnergyMonitor
import com.georacing.georacing.data.local.UserPreferencesDataStore
import com.georacing.georacing.infrastructure.car.CarTransitionManager
import com.georacing.georacing.domain.manager.AutoParkingManager
import com.georacing.georacing.ui.navigation.GeoRacingNavHost
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.GeoRacingTheme
import com.georacing.georacing.ui.theme.LocalEnergyProfile
import com.georacing.georacing.ui.components.SurvivalModeBanner
import com.georacing.georacing.ui.components.debug.DebugControlPanel // Added
import com.georacing.georacing.debug.ScenarioSimulator // Added
import com.georacing.georacing.utils.VoiceAnnouncer // Added for TTS events
import androidx.activity.enableEdgeToEdge
import androidx.compose.material3.Surface
import androidx.compose.material3.MaterialTheme

import com.georacing.georacing.ui.glass.LocalGlassConfig
import com.georacing.georacing.ui.glass.GlassConfig

import dev.chrisbanes.haze.haze
import dev.chrisbanes.haze.HazeState

import com.georacing.georacing.ui.glass.LocalGlassConfigState
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.glass.GlassSupport
import com.kyant.backdrop.backdrops.rememberLayerBackdrop
import com.kyant.backdrop.backdrops.layerBackdrop

class MainActivity : ComponentActivity() {

    private lateinit var energyMonitor: EnergyMonitor
    private lateinit var carTransitionManager: com.georacing.georacing.infrastructure.car.CarTransitionManager
    
    // Public AppContainer for accessing from Composables if needed (e.g., EcoViewModel Factory)
    lateinit var appContainer: com.georacing.georacing.di.AppContainer

    private lateinit var parkingRepository: com.georacing.georacing.data.parking.ParkingRepository
    private lateinit var autoParkingManager: com.georacing.georacing.domain.manager.AutoParkingManager
    
    // Voice Announcer for ScenarioSimulator events
    private var voiceAnnouncer: VoiceAnnouncer? = null
    
    private val requestPermissionLauncher = registerForActivityResult(
        androidx.activity.result.contract.ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        val hasLoc = permissions[android.Manifest.permission.ACCESS_FINE_LOCATION] == true || 
                     permissions[android.Manifest.permission.ACCESS_COARSE_LOCATION] == true
        if (hasLoc) {
            val pollingIntent = android.content.Intent(this, com.georacing.georacing.services.StatePollingService::class.java)
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
                try {
                    startForegroundService(pollingIntent)
                } catch (e: Exception) {
                    android.util.Log.e("MainActivity", "Error starting polling service", e)
                }
            } else {
                startService(pollingIntent)
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge(
            statusBarStyle = androidx.activity.SystemBarStyle.dark(android.graphics.Color.TRANSPARENT),
            navigationBarStyle = androidx.activity.SystemBarStyle.dark(android.graphics.Color.TRANSPARENT)
        )
        
        // Initialize DI Container
        appContainer = com.georacing.georacing.di.AppContainer(applicationContext)
        
        if (intent?.action == "com.georacing.georacing.REQUEST_LOCATION") {
            val permissionsToRequest = mutableListOf(
                android.Manifest.permission.ACCESS_FINE_LOCATION,
                android.Manifest.permission.ACCESS_COARSE_LOCATION
            )
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
                permissionsToRequest.add(android.Manifest.permission.POST_NOTIFICATIONS)
            }
            requestPermissionLauncher.launch(permissionsToRequest.toTypedArray())
        } else {
            // Also request on normal launch to ensure we have it for Evacuation & BLE
            val permissions = mutableListOf(
                android.Manifest.permission.ACCESS_FINE_LOCATION,
                android.Manifest.permission.ACCESS_COARSE_LOCATION
            )
            
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
                permissions.add(android.Manifest.permission.POST_NOTIFICATIONS)
            }
            // Add BLE Permissions for Android 12+
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
                permissions.add(android.Manifest.permission.BLUETOOTH_SCAN)
                permissions.add(android.Manifest.permission.BLUETOOTH_CONNECT)
                permissions.add(android.Manifest.permission.BLUETOOTH_ADVERTISE)
            }
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q) {
                permissions.add(android.Manifest.permission.ACTIVITY_RECOGNITION)
            }
            
            requestPermissionLauncher.launch(permissions.toTypedArray())
        }
        
        

        
        // Use Container instances where possible or keep legacy lateinits for now to minimize changes
        energyMonitor = appContainer.energyMonitor
        carTransitionManager = appContainer.carTransitionManager
        // parkingRepository = appContainer.parkingRepository // Not accessible publicly in AppContainer? It is.
        // autoParkingManager = appContainer.autoParkingManager
        
        // Ensure they are initialized for legacy code in this activity
        // (If checking appContainer properties visibility, they are public val)

        carTransitionManager.startMonitoring(this)
        
        // Initialize VoiceAnnouncer for TTS event announcements
        voiceAnnouncer = VoiceAnnouncer(this)

        // Start Global State Polling for Evacuation Protocol ONLY if permissions are already granted
        val hasLocationPerm = androidx.core.content.ContextCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) == android.content.pm.PackageManager.PERMISSION_GRANTED ||
                androidx.core.content.ContextCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_COARSE_LOCATION) == android.content.pm.PackageManager.PERMISSION_GRANTED

        if (hasLocationPerm) {
            val pollingIntent = android.content.Intent(this, com.georacing.georacing.services.StatePollingService::class.java)
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
                try {
                    startForegroundService(pollingIntent)
                } catch (e: Exception) {
                    android.util.Log.e("MainActivity", "Error starting polling service", e)
                }
            } else {
                startService(pollingIntent)
            }
        }

        // 2. Initialize WorkManager (Existing)
        val workManager = WorkManager.getInstance(applicationContext)
        
        val userPreferences = UserPreferencesDataStore(this)

        setContent {
            // Collect State from Container's EnergyMonitor
            val energyProfile by appContainer.energyMonitor.energyProfile.collectAsState()
            val parkingConfirmationLocation by appContainer.autoParkingManager.showParkingConfirmation.collectAsState()
            
            // Debug State
            val showDebugPanel by ScenarioSimulator.showDebugPanel.collectAsState()




            // Initialize Glass Configuration
            // We can load this from preferences later, for now defaults
            val glassConfigState = remember { mutableStateOf(GlassConfig()) }
            
            val hazeState = remember { dev.chrisbanes.haze.HazeState() }
            
            // Backdrop for Liquid Glass components
            val backdrop = rememberLayerBackdrop()

            CompositionLocalProvider(
                LocalEnergyProfile provides energyProfile,
                LocalGlassConfig provides glassConfigState.value,
                LocalGlassConfigState provides glassConfigState,
                com.georacing.georacing.ui.glass.LocalHazeState provides hazeState,
                LocalBackdrop provides backdrop
            ) {
                GeoRacingTheme(
                    forceOledBlack = energyProfile.forceOledBlack
                ) {
                    // val appContainer = (application as GeoRacingApplication).container // Removed invalid cast
                    // Use activity's appContainer directly
                    
                    Surface(
                        modifier = Modifier
                            .fillMaxSize(),
                        color = MaterialTheme.colorScheme.background
                    ) { 
                    val navController = rememberNavController()
                
                // Show BottomBar on all screens EXCEPT Splash, Login, Onboarding
                val navBackStackEntry by navController.currentBackStackEntryAsState()
                val currentRoute = navBackStackEntry?.destination?.route
                val showBottomBar = currentRoute !in listOf(
                    Screen.Splash.route,
                    Screen.Login.route,
                    Screen.Onboarding.route
                )
                
                val navigateTo = intent?.getStringExtra("navigate_to")
                val isRationale = intent?.action == "androidx.health.ACTION_SHOW_PERMISSIONS_RATIONALE"
                
                val startDestination = when {
                    isRationale -> Screen.EcoMeter.route 
                    navigateTo == "my_orders" -> Screen.MyOrders.route 
                    else -> Screen.Splash.route
                }

                // üÜï ROOT CONTAINER for Layers
                Box(modifier = Modifier.fillMaxSize()) {
                    
                    // LAYER 1: App Content (Protected by Safe Mode)
                    com.georacing.georacing.ui.components.ConnectivityAwareScaffold {
                        Scaffold(
                            modifier = Modifier.fillMaxSize(),
                            containerColor = androidx.compose.ui.graphics.Color(0xFF080810) 
                        ) { innerPadding ->
                            Box(
                                modifier = Modifier
                                    .fillMaxSize()
                                    .padding(top = innerPadding.calculateTopPadding()) 
                            ) {
                                // 0. Background layer captured by backdrop (MUST be a sibling, NOT parent of glass components)
                                Box(
                                    modifier = Modifier
                                        .fillMaxSize()
                                        .then(
                                            if (!GlassSupport.isEmulator) Modifier.layerBackdrop(backdrop)
                                            else Modifier
                                        )
                                        .background(androidx.compose.ui.graphics.Color(0xFF080810))
                                )

                                // 1. Content (NavHost) ‚Äî glass components inside use drawBackdrop safely
                                GeoRacingNavHost(
                                    navController = navController,
                                    startDestination = startDestination,
                                    userPreferences = userPreferences,
                                    appContainer = appContainer,
                                    modifier = Modifier
                                        .fillMaxSize()
                                        .haze(hazeState)
                                )

                                // 2. Navigation Bar (Overlay)
                                if (showBottomBar) {
                                    Box(
                                        modifier = Modifier
                                            .align(Alignment.BottomCenter)
                                            .fillMaxWidth()
                                            .navigationBarsPadding()
                                    ) {
                                        com.georacing.georacing.ui.components.DashboardBottomBar(navController = navController)
                                    }
                                }

                                // 3. Survival Mode Banner (Overlay)
                                if (energyProfile is com.georacing.georacing.domain.model.EnergyProfile.Survival) {
                                    Box(
                                        modifier = Modifier
                                            .align(Alignment.TopCenter)
                                            .fillMaxWidth()
                                            .padding(top = innerPadding.calculateTopPadding()) 
                                    ) {
                                        SurvivalModeBanner()
                                    }
                                }

                                // 4. Parking Confirmation Dialog (Use container's manager)
                                parkingConfirmationLocation?.let { loc ->
                                    com.georacing.georacing.ui.components.ParkingConfirmationDialog(
                                        location = loc,
                                        onConfirm = { appContainer.autoParkingManager.confirmParking(loc) },
                                        onDismiss = { appContainer.autoParkingManager.dismissParkingDialog() },
                                        onAddPhoto = { /* TODO */ }
                                    )
                                }
                                
                                // 5. Simulation Indicator
                                val isSimBat by ScenarioSimulator.forcedBatteryLevel.collectAsState()
                                val isSimBle by ScenarioSimulator.forcedBleSignal.collectAsState()
                                val isSimCar by ScenarioSimulator.forcedCarConnection.collectAsState()
                                
                                val circuitStateFlow = remember { appContainer.circuitStateRepository.getCircuitState() }
                                val circuitState by circuitStateFlow.collectAsState(
                                    initial = com.georacing.georacing.domain.model.CircuitState(
                                        com.georacing.georacing.domain.model.CircuitMode.UNKNOWN, 
                                        null, null, ""
                                    )
                                )

                                if (isSimBat != null || isSimBle != null || isSimCar != null) {
                                     Box(
                                        modifier = Modifier
                                            .align(Alignment.TopEnd)
                                            .padding(top = innerPadding.calculateTopPadding() + 8.dp, end = 8.dp)
                                            .size(10.dp)
                                            .background(androidx.compose.ui.graphics.Color.Red, androidx.compose.foundation.shape.CircleShape)
                                    )
                                }
                                
                                // üÜï 6. Live Flag Overlay (Global) - High Z-Index
                                if (circuitState.mode != com.georacing.georacing.domain.model.CircuitMode.UNKNOWN) {
                                     com.georacing.georacing.ui.components.racecontrol.LiveFlagOverlay(
                                         state = circuitState,
                                         modifier = Modifier.padding(top = innerPadding.calculateTopPadding())
                                     )
                                }
                            }
                        }
                    } 

                    // LAYER 2: Global Debug Trigger (Hidden, Always Accessible)
                    Box(
                        modifier = Modifier
                            .align(Alignment.TopStart)
                            // Handle status bars since we are edge-to-edge
                            .padding(top = 32.dp) // Manual safe padding instead of statusBarsPadding 
                            .size(60.dp)
                            .pointerInput(Unit) {
                                detectTapGestures(
                                    onLongPress = { ScenarioSimulator.setDebugPanelVisible(true) }
                                )
                            }
                    )

                    // LAYER 3: Debug Panel Wrapper
                    if (showDebugPanel) {
                        DebugControlPanel(
                            onDismiss = { ScenarioSimulator.setDebugPanelVisible(false) }
                        )
                    }
                } // End Root Box
                    }


    }
            }
        }
    }

    override fun onStart() {
        super.onStart()
        energyMonitor.startMonitoring()
    }

    override fun onStop() {
        super.onStop()
        energyMonitor.stopMonitoring()
    }
    
    override fun onDestroy() {
        super.onDestroy()
        voiceAnnouncer?.shutdown()
        voiceAnnouncer = null
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/CameraController.kt`

```kotlin
package com.georacing.georacing.car

import android.location.Location
import org.maplibre.android.camera.CameraPosition
import org.maplibre.android.geometry.LatLng

/**
 * Manages atomic camera state calculation based on driving context.
 * Implements "Google Maps-like" dynamic zoom and tilt.
 */
class CameraController {

    data class CameraState(
        val target: LatLng,
        val zoom: Double,
        val tilt: Double,
        val bearing: Double
    )

    /**
     * Calculates the ideal camera state.
     * @param location The current user location.
     * @param speedKmh Current speed in km/h.
     * @param distanceToTurnMeters Distance to the next maneuver (0 if not navigating).
     * @param isNavigationActive True if turn-by-turn is active.
     */
    fun update(
        location: Location,
        speedKmh: Float,
        distanceToTurnMeters: Double,
        isNavigationActive: Boolean
    ): CameraState {
        val latLng = LatLng(location.latitude, location.longitude)
        val bearing = location.bearing.toDouble()

        // BASE LOGIC:
        // High speed -> Zoom out, tilt up (see further)
        // Low speed -> Zoom in, tilt down (see details)
        // Maneuver approaching -> Zoom in drastically

        var targetZoom: Double
        var targetTilt: Double

        if (isNavigationActive) {
            // --- NAVIGATION MODE ---
            
            // 1. Calculate Base Zoom from Speed
            // 0-30 km/h -> Zoom 17.5
            // 120+ km/h -> Zoom 14.5
            val speedFactor = (speedKmh / 120f).coerceIn(0f, 1f)
            val baseZoom = 17.5 - (3.0 * speedFactor)

            // 2. Adjust for Maneuver
            // If < 200m to turn, force zoom in to at least 16.5
            if (distanceToTurnMeters < 200 && distanceToTurnMeters > 0) {
                 // Interpolate between current baseZoom and 17.0 based on proximity
                 val proximityFactor = (1.0 - (distanceToTurnMeters / 200.0)).coerceIn(0.0, 1.0)
                 targetZoom = baseZoom + (17.5 - baseZoom) * proximityFactor
            } else {
                targetZoom = baseZoom
            }

            // 3. Tilt Logic
            // Faster = More tilt (up to 60)
            targetTilt = 30.0 + (30.0 * speedFactor)

        } else {
            // --- FREE DRIVE MODE ---
            // Simpler logic, generally more zoomed out
            val speedFactor = (speedKmh / 100f).coerceIn(0f, 1f)
            targetZoom = 16.0 - (1.5 * speedFactor)
            targetTilt = 30.0 + (15.0 * speedFactor)
        }

        return CameraState(
            target = latLng,
            zoom = targetZoom,
            tilt = targetTilt,
            bearing = bearing
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/CarMapPresentation.kt`

```kotlin
package com.georacing.georacing.car

import android.app.Presentation
import android.content.Context
import android.os.Bundle
import android.view.Display
import android.widget.ImageView
import com.georacing.georacing.R
import org.maplibre.android.maps.MapView

class CarMapPresentation(context: Context, display: Display) : Presentation(context, display) {

    lateinit var mapView: MapView
    lateinit var hudOverlay: ImageView  // Vista para el HUD visual
    lateinit var speedometer: SpeedometerView // Waze-style speedometer

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.car_navigation_map)
        mapView = findViewById(R.id.mapView)
        hudOverlay = findViewById(R.id.hudOverlay)
        speedometer = findViewById(R.id.speedometer)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/CircuitRenderer.kt`

```kotlin
package com.georacing.georacing.car

import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.Path
import android.graphics.Rect

class CircuitRenderer {

    private val trackPaint = Paint().apply {
        color = Color.DKGRAY
        style = Paint.Style.STROKE
        strokeWidth = 30f
        strokeCap = Paint.Cap.ROUND
        strokeJoin = Paint.Join.ROUND
        isAntiAlias = true
    }

    private val trackSurfacePaint = Paint().apply {
        color = Color.parseColor("#262626")
        style = Paint.Style.STROKE
        strokeWidth = 24f
        strokeCap = Paint.Cap.ROUND
        strokeJoin = Paint.Join.ROUND
        isAntiAlias = true
    }

    private val centerLinePaint = Paint().apply {
        color = Color.WHITE
        alpha = 80
        style = Paint.Style.STROKE
        strokeWidth = 2f
        strokeCap = Paint.Cap.ROUND
        strokeJoin = Paint.Join.ROUND
        isAntiAlias = true
    }

    private val userPaint = Paint().apply {
        color = Color.BLUE
        style = Paint.Style.FILL
        isAntiAlias = true
    }

    private val userStrokePaint = Paint().apply {
        color = Color.WHITE
        style = Paint.Style.STROKE
        strokeWidth = 4f
        isAntiAlias = true
    }

    private val destinationPaint = Paint().apply {
        color = Color.RED
        style = Paint.Style.FILL
        isAntiAlias = true
    }

    private val guidanceLinePaint = Paint().apply {
        color = Color.CYAN
        style = Paint.Style.STROKE
        strokeWidth = 8f
        pathEffect = android.graphics.DashPathEffect(floatArrayOf(20f, 10f), 0f)
        isAntiAlias = true
    }

    fun render(
        canvas: Canvas,
        visibleArea: Rect,
        userLat: Double,
        userLon: Double,
        destLat: Double?,
        destLon: Double?
    ) {
        canvas.drawColor(Color.BLACK)

        val width = visibleArea.width().toFloat()
        val height = visibleArea.height().toFloat()
        val centerX = width / 2
        val centerY = height / 2

        // Scale factor to fit the track
        val scale = 0.8f

        // Simplified track path (Barcelona Catalunya layout)
        // Coordinates are relative to center (0,0) and scaled by width/height
        val trackPath = Path().apply {
            // Start/Finish straight
            moveTo(centerX - width * 0.3f * scale, centerY + height * 0.25f * scale)
            lineTo(centerX + width * 0.1f * scale, centerY + height * 0.25f * scale)

            // Turn 1 (Elf)
            cubicTo(
                centerX + width * 0.15f * scale, centerY + height * 0.25f * scale,
                centerX + width * 0.2f * scale, centerY + height * 0.15f * scale,
                centerX + width * 0.2f * scale, centerY + height * 0.05f * scale
            )

            // Turn 2 (Renault)
            cubicTo(
                centerX + width * 0.2f * scale, centerY - height * 0.05f * scale,
                centerX + width * 0.15f * scale, centerY - height * 0.15f * scale,
                centerX + width * 0.05f * scale, centerY - height * 0.2f * scale
            )

            // Turn 3 (Repsol)
            cubicTo(
                centerX - width * 0.05f * scale, centerY - height * 0.25f * scale,
                centerX - width * 0.15f * scale, centerY - height * 0.25f * scale,
                centerX - width * 0.25f * scale, centerY - height * 0.2f * scale
            )

            // Turns 4-5 (Seat-Wurth)
            cubicTo(
                centerX - width * 0.3f * scale, centerY - height * 0.15f * scale,
                centerX - width * 0.32f * scale, centerY - height * 0.05f * scale,
                centerX - width * 0.3f * scale, centerY
            )

            // Turn 7 (Campsa)
            cubicTo(
                centerX - width * 0.28f * scale, centerY + height * 0.05f * scale,
                centerX - width * 0.25f * scale, centerY + height * 0.1f * scale,
                centerX - width * 0.2f * scale, centerY + height * 0.12f * scale
            )

            // Turns 9-10 (La Caixa-Banc Sabadell)
            lineTo(centerX - width * 0.1f * scale, centerY + height * 0.12f * scale)
            cubicTo(
                centerX - width * 0.05f * scale, centerY + height * 0.12f * scale,
                centerX, centerY + height * 0.15f * scale,
                centerX, centerY + height * 0.2f * scale
            )

            // Turn 12-13 (New chicane)
            cubicTo(
                centerX, centerY + height * 0.23f * scale,
                centerX - width * 0.05f * scale, centerY + height * 0.25f * scale,
                centerX - width * 0.1f * scale, centerY + height * 0.25f * scale
            )

            // Back to start
            lineTo(centerX - width * 0.3f * scale, centerY + height * 0.25f * scale)
            close()
        }

        // Draw track
        canvas.drawPath(trackPath, trackPaint)
        canvas.drawPath(trackPath, trackSurfacePaint)
        canvas.drawPath(trackPath, centerLinePaint)

        // Draw User Position (Simulated relative to track for demo)
        // In a real app, we would project lat/lon to screen coordinates.
        // For this demo, we'll place the user at the start line.
        val userX = centerX - width * 0.3f * scale
        val userY = centerY + height * 0.25f * scale
        canvas.drawCircle(userX, userY, 20f, userPaint)
        canvas.drawCircle(userX, userY, 20f, userStrokePaint)

        // Draw Destination and Guidance Line
        if (destLat != null && destLon != null) {
            // Simulate destination position based on lat/lon relative to circuit center
            // This is a rough approximation for visual feedback in "Rally Mode"
            // Circuit Center: 41.5687, 2.2567
            val circuitLat = 41.5687
            val circuitLon = 2.2567
            val latDiff = (destLat - circuitLat) * 10000 // Scale for visibility
            val lonDiff = (destLon - circuitLon) * 10000

            // Flip Y because screen Y grows downwards, but latitude grows upwards
            val destX = centerX + (lonDiff * 5).toFloat()
            val destY = centerY - (latDiff * 5).toFloat()

            // Draw guidance line
            canvas.drawLine(userX, userY, destX, destY, guidanceLinePaint)

            // Draw destination marker
            canvas.drawCircle(destX, destY, 25f, destinationPaint)
            canvas.drawCircle(destX, destY, 25f, userStrokePaint)
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/CircuitStateNotificationManager.kt`

```kotlin
package com.georacing.georacing.car

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.os.Build
import androidx.car.app.CarContext
import androidx.car.app.notification.CarAppExtender
import androidx.core.app.NotificationCompat
import com.georacing.georacing.R
import com.georacing.georacing.domain.model.CircuitMode

/**
 * Tier 1: Circuit State Notification Manager
 * 
 * Gestiona notificaciones Heads-Up (HUN) para cambios cr√≠ticos de estado del circuito.
 * Las notificaciones aparecen en el dashboard del coche como alertas de alta prioridad.
 */
class CircuitStateNotificationManager(private val carContext: CarContext) {
    
    private val notificationManager = carContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    private val channelId = "circuit_state_alerts"
    
    init {
        createNotificationChannel()
    }
    
    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                channelId,
                "Circuit State Alerts",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Alerts for critical circuit state changes (Red Flag, Yellow Flag, etc.)"
                enableVibration(true)
                setShowBadge(true)
            }
            notificationManager.createNotificationChannel(channel)
        }
    }
    
    /**
     * Env√≠a una alerta HUN al dashboard del coche para un cambio de estado del circuito.
     */
    fun sendCircuitStateAlert(newMode: CircuitMode) {
        val (title, message, icon) = getAlertContent(newMode)
        
        // No enviar notificaci√≥n para estado normal
        if (title.isEmpty()) return
        
        val notification = NotificationCompat.Builder(carContext, channelId)
            .setSmallIcon(icon)
            .setContentTitle(title)
            .setContentText(message)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setCategory(NotificationCompat.CATEGORY_ALARM)
            .setAutoCancel(true)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC) // Show on lock screen
            .extend(
                CarAppExtender.Builder()
                    .setImportance(NotificationManager.IMPORTANCE_HIGH)
                    .build()
            )
            .build()
        
        notificationManager.notify(CIRCUIT_STATE_NOTIFICATION_ID, notification)
        
        android.util.Log.i("CircuitNotification", "üì¢ HUN enviada: $title - $message")
    }
    
    /**
     * Retorna (T√≠tulo, Mensaje, Icono) seg√∫n el modo del circuito.
     */
    private fun getAlertContent(mode: CircuitMode): Triple<String, String, Int> {
        return when (mode) {
            CircuitMode.RED_FLAG -> Triple(
                "‚ö†Ô∏è CARRERA DETENIDA",
                "Mantenga la calma al llegar. Siga las instrucciones del personal.",
                android.R.drawable.stat_sys_warning // System warning icon
            )
            CircuitMode.YELLOW_FLAG -> Triple(
                "üü° PRECAUCI√ìN",
                "Reduzca la velocidad. Incidente en la pista.",
                android.R.drawable.stat_sys_warning
            )
            CircuitMode.SAFETY_CAR -> Triple(
                "üöó SAFETY CAR",
                "Veh√≠culo de seguridad en pista. Reduzca velocidad.",
                android.R.drawable.stat_notify_sync
            )
            CircuitMode.EVACUATION -> Triple(
                "üö® EVACUACI√ìN",
                "EVACUACI√ìN INMEDIATA. Siga las se√±ales de salida.",
                android.R.drawable.stat_sys_warning
            )
            else -> Triple("", "", 0) // No notification for normal states
        }
    }
    
    companion object {
        private const val CIRCUIT_STATE_NOTIFICATION_ID = 1001
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/DestinationModel.kt`

```kotlin
package com.georacing.georacing.car

data class DestinationModel(
    val id: String,
    val name: String,
    val description: String,
    val latitude: Double,
    val longitude: Double,
    val type: DestinationType
)

enum class DestinationType {
    GATE,
    PARKING,
    PADDOCK,
    FAN_ZONE,
    SERVICE
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/DestinationRepository.kt`

```kotlin
package com.georacing.georacing.car

class DestinationRepository {
    fun getDestinations(): List<DestinationModel> = listOf(
        DestinationModel(
            id = "main_access",
            name = "Acceso Principal",
            description = "Entrada principal del Circuit de Barcelona-Catalunya",
            latitude = 41.5696,
            longitude = 2.2570,
            type = DestinationType.GATE
        ),
        DestinationModel(
            id = "porta_1",
            name = "Porta 1",
            description = "Acceso norte habitual para publico",
            latitude = 41.5693,
            longitude = 2.2561,
            type = DestinationType.GATE
        ),
        DestinationModel(
            id = "porta_3",
            name = "Porta 3",
            description = "Acceso muy usado en grandes premios",
            latitude = 41.5684,
            longitude = 2.2587,
            type = DestinationType.GATE
        ),
        DestinationModel(
            id = "porta_7",
            name = "Porta 7",
            description = "Entrada lado este cercana a tribunas G y H",
            latitude = 41.5714,
            longitude = 2.2620,
            type = DestinationType.GATE
        ),
        DestinationModel(
            id = "parking_north",
            name = "Parking Norte",
            description = "Parking general en zona norte",
            latitude = 41.5731,
            longitude = 2.2560,
            type = DestinationType.PARKING
        ),
        DestinationModel(
            id = "parking_south",
            name = "Parking Sur",
            description = "Parking general zona sur",
            latitude = 41.5658,
            longitude = 2.2580,
            type = DestinationType.PARKING
        ),
        DestinationModel(
            id = "paddock_access",
            name = "Acceso Paddock",
            description = "Entrada al paddock y boxes",
            latitude = 41.5705,
            longitude = 2.2576,
            type = DestinationType.PADDOCK
        ),
        DestinationModel(
            id = "fanzone",
            name = "Fan Zone",
            description = "Zona de actividades para fans",
            latitude = 41.5670,
            longitude = 2.2595,
            type = DestinationType.FAN_ZONE
        ),
        DestinationModel(
            id = "service_tower",
            name = "Torre de Control",
            description = "Oficinas y sala de briefing",
            latitude = 41.5697,
            longitude = 2.2575,
            type = DestinationType.SERVICE
        )
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/DestinationSearchScreen.kt`

```kotlin
package com.georacing.georacing.car

import androidx.car.app.CarContext
import androidx.car.app.Screen
import androidx.car.app.model.Action
import androidx.car.app.model.ItemList
import androidx.car.app.model.Row
import androidx.car.app.model.SearchTemplate
import androidx.car.app.model.Template

class DestinationSearchScreen(carContext: CarContext) : Screen(carContext) {

    private val allPois = PoiRepository.getAllPois()
    private var filteredPois = allPois

    override fun onGetTemplate(): Template {
        val listBuilder = ItemList.Builder()

        filteredPois.forEach { poi ->
            listBuilder.addItem(
                Row.Builder()
                    .setTitle(poi.name)
                    .addText(poi.description)
                    .setOnClickListener {
                        screenManager.push(
                            GeoRacingNavigationScreen(
                                carContext = carContext,
                                destTitle = poi.name,
                                destLat = poi.latitude,
                                destLon = poi.longitude
                            )
                        )
                    }
                    .build()
            )
        }

        return SearchTemplate.Builder(
            object : SearchTemplate.SearchCallback {
                override fun onSearchTextChanged(searchText: String) {
                    filteredPois = if (searchText.isEmpty()) {
                        allPois
                    } else {
                        allPois.filter {
                            it.name.contains(searchText, ignoreCase = true) ||
                            it.description.contains(searchText, ignoreCase = true)
                        }
                    }
                    invalidate()
                }

                override fun onSearchSubmitted(searchText: String) {
                    onSearchTextChanged(searchText)
                }
            }
        )
        .setHeaderAction(Action.BACK)
        .setShowKeyboardByDefault(true)
        .setItemList(listBuilder.build())
        .build()
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/GeoRacingCarAppService.kt`

```kotlin
package com.georacing.georacing.car

import androidx.car.app.CarAppService
import androidx.car.app.Session
import androidx.car.app.validation.HostValidator

class GeoRacingCarAppService : CarAppService() {
    override fun onCreateSession(): Session = GeoRacingCarSession()

    override fun createHostValidator(): HostValidator {
        // Allowing all hosts for now to bypass 'p1' error and BuildConfig issues
        return HostValidator.ALLOW_ALL_HOSTS_VALIDATOR
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/GeoRacingCarScreen.kt`

```kotlin
package com.georacing.georacing.car

import android.content.Intent
import android.net.Uri
import android.text.SpannableString
import android.text.Spanned
import androidx.car.app.CarContext
import androidx.car.app.Screen
import androidx.car.app.model.Action
import androidx.car.app.model.ActionStrip
import androidx.car.app.model.CarColor
import androidx.car.app.model.Distance
import androidx.car.app.model.DistanceSpan
import androidx.car.app.model.ItemList
import androidx.car.app.model.PlaceListMapTemplate
import androidx.car.app.model.Row
import androidx.car.app.model.Template
import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.Rect
import android.hardware.display.DisplayManager
import android.hardware.display.VirtualDisplay
import android.os.Handler
import android.os.Looper
import android.util.Log
import androidx.car.app.AppManager
import androidx.car.app.SurfaceCallback
import androidx.car.app.SurfaceContainer
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner
import com.google.android.gms.location.LocationServices
import org.maplibre.android.MapLibre
import org.maplibre.android.camera.CameraPosition
import org.maplibre.android.camera.CameraUpdateFactory
import org.maplibre.android.geometry.LatLng
import org.maplibre.android.maps.MapLibreMap
import org.maplibre.android.maps.Style
import org.maplibre.android.style.layers.LineLayer
import org.maplibre.android.style.layers.PropertyFactory
import org.maplibre.android.style.layers.RasterLayer
import org.maplibre.android.style.sources.RasterSource
import org.maplibre.android.style.sources.TileSet
import android.graphics.Color
import androidx.car.app.model.DateTimeWithZone
import androidx.car.app.navigation.model.TravelEstimate

class GeoRacingCarScreen(carContext: CarContext) : Screen(carContext), DefaultLifecycleObserver {

    private var virtualDisplay: VirtualDisplay? = null
    private var presentation: CarMapPresentation? = null
    private var mapLibreMap: MapLibreMap? = null
    private var surfaceWidth = 0
    private var surfaceHeight = 0
    private var isLocationGranted = false
    
    private val handler = Handler(Looper.getMainLooper())
    private val permissionCheckRunnable = Runnable { checkPermissions() }
    
    // Waze-style map manager
    private lateinit var mapStyleManager: MapStyleManager
    
    private lateinit var fusedLocationClient: com.google.android.gms.location.FusedLocationProviderClient
    private lateinit var locationCallback: com.google.android.gms.location.LocationCallback

    init {
        lifecycle.addObserver(this)
        MapLibre.getInstance(carContext)
        fusedLocationClient = LocationServices.getFusedLocationProviderClient(carContext)
        mapStyleManager = MapStyleManager(carContext)
        
        // Spawn Waze-style elements
        com.georacing.georacing.debug.ScenarioSimulator.spawnRacers(5)
        
        locationCallback = object : com.google.android.gms.location.LocationCallback() {
            override fun onLocationResult(locationResult: com.google.android.gms.location.LocationResult) {
                locationResult.lastLocation?.let { location ->
                    updateMapLocation(location)
                    // Update speedometer with real speed
                    val speedKmh = location.speed * 3.6f // m/s to km/h
                    com.georacing.georacing.debug.ScenarioSimulator.setSimulatedSpeed(speedKmh)
                    updateSpeedometer(speedKmh)
                }
            }
        }
    }

    // Removed internal Poi class and hardcoded list
    
    // Fetch official nodes from Repository
    private val gates = com.georacing.georacing.data.repository.CircuitLocationsRepository.getGates()
    private val parkings = com.georacing.georacing.data.repository.CircuitLocationsRepository.getNavigableParkings()
    
    // Combine for display (Gates first, then Parkings)
    private val displayNodes = gates + parkings

    override fun onGetTemplate(): Template {
        val itemListBuilder = ItemList.Builder()

        // Create a distance span which is required for PlaceListMapTemplate rows
        val distance = Distance.create(0.0, Distance.UNIT_KILOMETERS)
        val distanceSpan = DistanceSpan.create(distance)
        val distanceText = SpannableString("   ") // Empty space
        distanceText.setSpan(distanceSpan, 0, distanceText.length, Spanned.SPAN_INCLUSIVE_INCLUSIVE)

        for (node in displayNodes) {
            // Icon selection logic could be improved here (Gate vs Parking icon) if ItemList supported it easily
            val title = if (node.type == com.georacing.georacing.domain.model.NodeType.GATE) "üö™ ${node.name}" else "üÖøÔ∏è ${node.name}"
            
            val row = Row.Builder()
                .setTitle(title)
                .addText(distanceText) // Required to avoid crash
                .setOnClickListener {
                    screenManager.push(
                        GeoRacingNavigationScreen(
                            carContext = carContext,
                            destTitle = node.name,
                            destLat = node.lat,
                            destLon = node.lon
                        )
                    )
                }
                .build()
            itemListBuilder.addItem(row)
        }

        // Add Free Drive Option at the top
        val freeDriveRow = Row.Builder()
            .setTitle("Free Drive")
            .addText(distanceText) // Required to avoid crash in PlaceListMapTemplate
            .setOnClickListener {
                screenManager.push(GeoRacingNavigationScreen(carContext))
            }
            .build()
        itemListBuilder.addItem(freeDriveRow)

        return PlaceListMapTemplate.Builder()
            .setTitle("GeoRacing Destinations")
            .setHeaderAction(Action.APP_ICON)
            .setItemList(itemListBuilder.build())
            .setActionStrip(
                ActionStrip.Builder()
                    .addAction(
                        Action.Builder()
                            .setTitle("Search")
                            .setOnClickListener {
                                screenManager.push(DestinationSearchScreen(carContext))
                            }
                            .build()
                    )
                    .build()
            )
            .build()
    }
    
    // --- MAP RENDERING LOGIC ---
    
    private val surfaceCallback = object : SurfaceCallback {
        override fun onSurfaceAvailable(surfaceContainer: SurfaceContainer) {
            val surface = surfaceContainer.surface
            if (surface == null) return

            val width = surfaceContainer.width
            val height = surfaceContainer.height
            val dpi = surfaceContainer.dpi
            
            surfaceWidth = width
            surfaceHeight = height

            val displayManager = carContext.getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
            
            try {
                virtualDisplay = displayManager.createVirtualDisplay(
                    "GeoRacingMapMenu",
                    width,
                    height,
                    dpi,
                    surface,
                    0
                )

                presentation = CarMapPresentation(carContext, virtualDisplay!!.display)
                presentation?.show()

                presentation?.mapView?.let { mapView ->
                    mapView.onCreate(null)
                    mapView.onStart()
                    mapView.onResume()
                    
                    mapView.getMapAsync { map ->
                        mapLibreMap = map
                        setupMap(map)
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        override fun onVisibleAreaChanged(visibleArea: Rect) {}

        override fun onSurfaceDestroyed(surfaceContainer: SurfaceContainer) {
            presentation?.mapView?.onPause()
            presentation?.mapView?.onStop()
            presentation?.mapView?.onDestroy()
            presentation?.dismiss()
            presentation = null
            
            virtualDisplay?.release()
            virtualDisplay = null
            mapLibreMap = null
        }
    }

    private fun setupMap(map: MapLibreMap) {
        // Use Waze cartoon style
        val wazeStyleJson = mapStyleManager.buildWazeStyleJson()
        
        map.setStyle(Style.Builder().fromJson(wazeStyleJson)) { style ->
            mapStyleManager.applyWazeLayers(style)
            enableLocationComponent(style)
            startLocationUpdates()
            startRacerMovement()
        }
        
        map.uiSettings.isAttributionEnabled = false
        map.uiSettings.isLogoEnabled = false
    }
    
    private fun updateSpeedometer(speedKmh: Float) {
        handler.post {
            presentation?.speedometer?.updateSpeed(
                speedKmh,
                com.georacing.georacing.debug.ScenarioSimulator.speedLimit.value
            )
        }
    }
    
    // Move other racers periodically for community feel
    private val racerMovementRunnable = object : Runnable {
        override fun run() {
            com.georacing.georacing.debug.ScenarioSimulator.moveRacersRandomly()
            handler.postDelayed(this, 2000) // Move every 2 seconds
        }
    }
    
    private fun startRacerMovement() {
        handler.postDelayed(racerMovementRunnable, 2000)
    }
    
    private fun stopRacerMovement() {
        handler.removeCallbacks(racerMovementRunnable)
    }

    private fun enableLocationComponent(style: Style) {
        if (carContext.checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED ||
            carContext.checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
            
            val locationComponent = mapLibreMap?.locationComponent
            val options = org.maplibre.android.location.LocationComponentOptions.builder(carContext)
                .pulseEnabled(true)
                .pulseColor(Color.BLUE)
                .foregroundDrawable(com.georacing.georacing.R.drawable.ic_f1_car_scaled)
                .gpsDrawable(com.georacing.georacing.R.drawable.ic_f1_car_scaled)
                .bearingDrawable(com.georacing.georacing.R.drawable.ic_f1_car_scaled)
                .accuracyAlpha(0.4f)
                .build()

            val locationComponentActivationOptions = org.maplibre.android.location.LocationComponentActivationOptions.builder(carContext, style)
                .locationComponentOptions(options)
                .useDefaultLocationEngine(false)
                .build()
                
            locationComponent?.activateLocationComponent(locationComponentActivationOptions)
            locationComponent?.isLocationComponentEnabled = true
            locationComponent?.renderMode = org.maplibre.android.location.modes.RenderMode.GPS 
            locationComponent?.cameraMode = org.maplibre.android.location.modes.CameraMode.NONE
        }
    }

    private fun startLocationUpdates() {
        if (carContext.checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED ||
            carContext.checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
            try {
                val locationRequest = com.google.android.gms.location.LocationRequest.Builder(
                    com.google.android.gms.location.Priority.PRIORITY_HIGH_ACCURACY, 1000
                ).build()
                fusedLocationClient.requestLocationUpdates(locationRequest, locationCallback, Looper.getMainLooper())
            } catch (e: SecurityException) {
                Log.e("GeoRacing", "Location permission missing", e)
            }
        }
    }

    private fun stopLocationUpdates() {
        fusedLocationClient.removeLocationUpdates(locationCallback)
    }

    private fun updateMapLocation(location: android.location.Location) {
        val map = mapLibreMap ?: return
        map.locationComponent.forceLocationUpdate(location)
        
        val cameraPosition = CameraPosition.Builder()
             .target(LatLng(location.latitude, location.longitude))
             .zoom(14.5) 
             .tilt(30.0) 
             .bearing(location.bearing.toDouble()) 
             .build()
        map.animateCamera(CameraUpdateFactory.newCameraPosition(cameraPosition), 1000)
    }

    private fun checkPermissions() {
        val nowGranted = (carContext.checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED ||
            carContext.checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED)
            
        if (nowGranted) {
            isLocationGranted = true
            startLocationUpdates()
            mapLibreMap?.style?.let { enableLocationComponent(it) }
            handler.removeCallbacks(permissionCheckRunnable)
        } else {
            isLocationGranted = false
            stopLocationUpdates()
            handler.removeCallbacks(permissionCheckRunnable)
            handler.postDelayed(permissionCheckRunnable, 2000)
        }
    }
    
    override fun onStart(owner: LifecycleOwner) {
        checkPermissions()
    }
    
    override fun onStop(owner: LifecycleOwner) {
        handler.removeCallbacks(permissionCheckRunnable)
        presentation?.mapView?.onStop()
    }
    
    override fun onDestroy(owner: LifecycleOwner) {
        carContext.getCarService(AppManager::class.java).setSurfaceCallback(null)
        stopLocationUpdates()
        stopRacerMovement()
        com.georacing.georacing.debug.ScenarioSimulator.clearRacers()
        presentation?.mapView?.onDestroy()
        virtualDisplay?.release()
    }

    override fun onPause(owner: LifecycleOwner) {
        presentation?.mapView?.onPause()
    }

    override fun onResume(owner: LifecycleOwner) {
        presentation?.mapView?.onResume()
        checkPermissions()
    }

    override fun onCreate(owner: LifecycleOwner) {
        carContext.getCarService(AppManager::class.java).setSurfaceCallback(surfaceCallback)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/GeoRacingCarSession.kt`

```kotlin
package com.georacing.georacing.car

import android.content.Intent
import androidx.car.app.Screen
import androidx.car.app.Session

class GeoRacingCarSession : Session() {
    override fun onCreateScreen(intent: Intent): Screen {
        return GeoRacingCarScreen(carContext)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/GeoRacingNavigationScreen.kt`

```kotlin
package com.georacing.georacing.car

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.content.res.Configuration
import android.graphics.Color
import android.graphics.Rect
import android.graphics.PointF
import android.hardware.display.DisplayManager
import android.hardware.display.VirtualDisplay
import android.location.Location
import android.os.Handler
import android.os.Looper
import android.speech.tts.TextToSpeech
import androidx.car.app.AppManager
import androidx.car.app.CarContext
import androidx.car.app.CarToast
import androidx.car.app.Screen
import androidx.car.app.SurfaceCallback
import androidx.car.app.SurfaceContainer
import androidx.car.app.model.Action
import androidx.car.app.model.ActionStrip
import androidx.car.app.model.CarColor
import androidx.car.app.model.CarIcon
import androidx.car.app.model.DateTimeWithZone
import androidx.car.app.model.Distance
import androidx.car.app.model.ItemList
import androidx.car.app.model.PlaceListMapTemplate
import androidx.car.app.model.Template
import androidx.car.app.navigation.model.Maneuver
import androidx.car.app.navigation.model.NavigationTemplate
import androidx.car.app.navigation.model.RoutingInfo
import androidx.car.app.navigation.model.Step
import androidx.car.app.navigation.model.TravelEstimate
import androidx.car.app.navigation.model.MapController
import androidx.car.app.navigation.model.Lane
import androidx.car.app.navigation.model.LaneDirection
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.LifecycleOwner
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.maplibre.android.MapLibre
import org.maplibre.android.camera.CameraUpdateFactory
import org.maplibre.android.geometry.LatLng
import org.maplibre.android.location.LocationComponentActivationOptions
import org.maplibre.android.location.modes.CameraMode
import org.maplibre.android.location.modes.RenderMode
import org.maplibre.android.maps.MapLibreMap
import org.maplibre.android.maps.Style
import org.maplibre.android.style.sources.GeoJsonSource
import org.maplibre.android.style.layers.LineLayer
import org.maplibre.android.style.layers.Property
import org.maplibre.android.style.layers.PropertyFactory
import org.maplibre.android.style.expressions.Expression
import org.maplibre.geojson.Feature
import org.maplibre.geojson.FeatureCollection
import org.maplibre.geojson.LineString
import org.maplibre.geojson.Point
import java.util.Calendar
import java.util.Locale
import java.util.TimeZone
import com.georacing.georacing.car.Step as OsrmStep
import com.georacing.georacing.domain.usecases.CheckArrivalUseCase
import com.georacing.georacing.utils.SnapResult

/**
 * Main Navigation Screen implementing Google Maps-style behavior.
 * Integrates OSRM Routing, MapLibre rendering, and Android Auto Templates.
 */
class GeoRacingNavigationScreen(
    carContext: CarContext,
    private val destTitle: String? = null,
    private val destLat: Double? = null,
    private val destLon: Double? = null
) : Screen(carContext), LifecycleEventObserver, TextToSpeech.OnInitListener {

    private val TAG = "GeoRacingNav"

    private val poiRepository = PoiRepository
    private val routeRepository = RouteRepository()
    private val mapStyleManager = MapStyleManager(carContext)
    private val cameraController = CameraController()
    
    // FASE 3.2: Veloc√≠metro y l√≠mites de velocidad
    private val speedLimitProvider: com.georacing.georacing.domain.speed.SpeedLimitProvider =
        com.georacing.georacing.domain.speed.FakeSpeedLimitProvider()
    
    // FASE 3.3: Factor de tr√°fico para ETA ajustado
    // TODO FASE 3: Reemplazar con TrafficProvider real
    private var trafficFactor: Double = 1.0
    
    // FASE 3.4: HUD visual para mostrar veloc√≠metro, l√≠mites, instrucciones sobre el mapa
    private val navigationHUD = NavigationHUD()
    
    private var isNavigationActive = (destLat != null && destLon != null)
    private var isFollowMode = true
    private var manualDarkMode: Boolean? = null // null = autom√°tico, true/false = manual
    private var hasArrived = false // Para evitar llamar handleArrival m√∫ltiples veces
    
    private var currentRouteResult: RouteResult? = null
    private var currentManeuverStep: OsrmStep? = null
    private var currentStepIndexValue = 0
    private var distToManeuver = 0.0
    private var currentSpeedKmh = 0.0
    private var currentSpeedLimitKmh: Int? = null
    private var currentDistance: Double? = null
    private var currentDuration: Double? = null
    
    // Tier 1: Parking
    private var assignedParkingLocation: com.georacing.georacing.data.parking.ParkingLocation? = null
    
    // Tier 1: TTS Mute State
    private var isTtsMuted = false
    private var lastRouteFetchTime = 0L
    private var currentStepIndex = 0 // √çndice del paso actual en la ruta
    private var distanceToNextStep = 0.0 // Distancia al siguiente paso/maniobra
    
    // Tier 1: Race Day Context
    private var raceStartTime: Long? = null // Epoch millis for race start
    private var assignedParking: String = "C" // Default parking assignment
    
    // Tier 1: Hazard Notifications
    private var lastHazardAlertTime = 0L
    
    // Race Control: Track state for alerts
    private var currentCircuitMode = com.georacing.georacing.domain.model.CircuitMode.GREEN_FLAG
    private var lastCircuitMode: com.georacing.georacing.domain.model.CircuitMode? = null
    private var lastCircuitModeAlertTime = 0L
    
    // Tier 1: Circuit State Notification Manager
    private lateinit var circuitNotificationManager: CircuitStateNotificationManager
    
    private var tts: TextToSpeech? = null
    private var lastInstruction: String? = null
    private var lastSpokenThreshold = -1
    
    // FASE 1.1: Cache de snap to route con threshold de movimiento
    private var lastSnapResult: com.georacing.georacing.utils.SnapResult? = null
    
    // Flag para calcular ruta inicial apenas se obtenga primera posici√≥n GPS
    private var isInitialRouteCalculated = false
    
    // FASE 1.4: Tracking de GPS accuracy para filtrar se√±ales malas
    private var lastGoodGPSTime = System.currentTimeMillis()

    private var virtualDisplay: VirtualDisplay? = null
    private var presentation: CarMapPresentation? = null
    private var mapLibreMap: MapLibreMap? = null
    private var surfaceWidth = 0
    private var surfaceHeight = 0
    
    private lateinit var fusedLocationClient: com.google.android.gms.location.FusedLocationProviderClient
    private lateinit var locationCallback: com.google.android.gms.location.LocationCallback
    private var isLocationGranted = false
    private val handler = Handler(Looper.getMainLooper())
    
    // Rastrear el modo oscuro actual para detectar cambios
    private var currentDarkMode = false

    init {
        lifecycle.addObserver(this)
        MapLibre.getInstance(carContext)
        fusedLocationClient = com.google.android.gms.location.LocationServices.getFusedLocationProviderClient(carContext)
        
        // Inicializar el estado del modo oscuro
        currentDarkMode = (carContext.resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES
        
        locationCallback = object : com.google.android.gms.location.LocationCallback() {
            override fun onLocationResult(locationResult: com.google.android.gms.location.LocationResult) {
                locationResult.lastLocation?.let { location ->
                    updateMapLocation(location)
                }
            }
        }
        tts = TextToSpeech(carContext, this)
        
        // Tier 1: Initialize Circuit State Notification Manager
        circuitNotificationManager = CircuitStateNotificationManager(carContext)
        
        android.util.Log.d(TAG, "‚úÖ GeoRacingNavigationScreen inicializada (Tier 1 Mode)")
    }

    override fun onInit(status: Int) {
        if (status == TextToSpeech.SUCCESS) {
            val result = tts?.setLanguage(Locale("es", "ES"))
            if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
                android.util.Log.e(TAG, "TTS: Idioma espa√±ol no soportado, usando default")
                tts?.language = Locale.getDefault()
            } else {
                android.util.Log.d(TAG, "TTS inicializado correctamente en espa√±ol")
            }
            // Hablar un mensaje de prueba
            speak("Navegaci√≥n iniciada")
        } else {
            android.util.Log.e(TAG, "TTS: Error al inicializar, status=$status")
        }
    }

    override fun onGetTemplate(): Template {
        // Detectar cambios en el modo d√≠a/noche del sensor del coche (solo si no hay modo manual)
        if (manualDarkMode == null) {
            val isDarkMode = (carContext.resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES
            if (isDarkMode != currentDarkMode) {
                currentDarkMode = isDarkMode
                // El modo cambi√≥ (el coche detect√≥ d√≠a/noche), actualizar el estilo del mapa
                setupMapStyle()
            }
        }
        
        // ==============================================
        // RACE CONTROL: Check for critical flag changes
        // ==============================================
        checkRaceControlAlerts()
        
        // ==============================================
        // ACTION STRIP (Must use Icons only for NavigationTemplate)
        // ==============================================
        
        val actionStripBuilder = ActionStrip.Builder()
        
        // 1. Theme Toggle (Icon only)
        val modeIcon = when (manualDarkMode) {
            null -> CarIcon.APP_ICON // Auto (Use generic icon or create specific one)
            true -> CarIcon.APP_ICON // Night
            false -> CarIcon.APP_ICON // Day
        }
        
        actionStripBuilder.addAction(
            Action.Builder()
                .setIcon(CarIcon.APP_ICON) // Placeholder for theme icon
                .setOnClickListener {
                    manualDarkMode = when (manualDarkMode) {
                        null -> false  // AUTO -> D√çA
                        false -> true  // D√çA -> NOCHE
                        true -> null   // NOCHE -> AUTO
                    }
                    currentDarkMode = manualDarkMode ?: ((carContext.resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES)
                    setupMapStyle()
                    invalidate()
                    CarToast.makeText(carContext, "Tema cambiado", CarToast.LENGTH_SHORT).show()
                }
                .build()
        )
        
        // 2. Race Status (Icon only)
        actionStripBuilder.addAction(
            Action.Builder()
                .setIcon(CarIcon.ALERT) // Usar icono de alerta para status
                .setOnClickListener {
                    screenManager.push(RaceStatusScreen(carContext, currentCircuitMode, "C"))
                }
                .build()
        )
        
        // 3. Recenter/Follow (Icon only)
        actionStripBuilder.addAction(
            Action.Builder()
                .setIcon(CarIcon.APP_ICON)
                .setOnClickListener {
                    isFollowMode = true
                    CarToast.makeText(carContext, "Recalculando...", CarToast.LENGTH_SHORT).show()
                }
                .build()
        )

        // 4. Exit (Standard Back Action usually handles this, putting explicit exit)
        actionStripBuilder.addAction(
             Action.Builder()
                .setIcon(CarIcon.BACK)
                .setOnClickListener { screenManager.pop() }
                .build()
        )

        if (!isLocationGranted) {
            android.util.Log.d(TAG, "üö´ Sin permisos de ubicaci√≥n, mostrando template de carga")
            return NavigationTemplate.Builder()
                .setNavigationInfo(RoutingInfo.Builder().setLoading(true).build())
                .setActionStrip(actionStripBuilder.build())
                .setBackgroundColor(CarColor.RED)
                .build()
        }

        if (!isNavigationActive) {
            android.util.Log.d(TAG, "üó∫Ô∏è Modo Free Drive (sin navegaci√≥n activa)")
            return NavigationTemplate.Builder()
                .setNavigationInfo(
                    RoutingInfo.Builder()
                        .setCurrentStep(
                            Step.Builder("Modo exploraci√≥n libre")
                                .setManeuver(Maneuver.Builder(Maneuver.TYPE_DESTINATION).build())
                                .build(),
                            Distance.create(0.0, Distance.UNIT_KILOMETERS)
                        )
                        .build()
                )
                .setActionStrip(actionStripBuilder.build())
                .build()
        } else {
            android.util.Log.d(TAG, "üß≠ Navegaci√≥n activa, mostrando ruta")
            val navInfo = buildRoutingInfo()
            val travelEstimate = buildTravelEstimate()
            
            // Tier 1: Check for hazard alerts
            checkAndShowHazardAlerts()

            // NOTE: MapActionStrip also cannot have titles in NavigationTemplate
            return NavigationTemplate.Builder()
                .setNavigationInfo(navInfo)
                .setDestinationTravelEstimate(travelEstimate)
                .setActionStrip(actionStripBuilder.build())
                .setMapActionStrip(buildMapActionStrip())
                .build()
        }
    }
    
    /**
     * Tier 1: Build MapActionStrip with professional navigation controls
     * - Stop Navigation (Red stop icon)
     * - Mute/Unmute TTS (Volume toggle)
     * - Zoom/Re-center (Follow mode)
     */
    private fun buildMapActionStrip(): ActionStrip {
        return ActionStrip.Builder()
            // 1. STOP Navigation Button
            .addAction(
                Action.Builder()
                    .setTitle("Detener")
                    .setIcon(
                        CarIcon.Builder(
                            androidx.core.graphics.drawable.IconCompat.createWithResource(
                                carContext,
                                android.R.drawable.ic_delete // Using system stop icon
                            )
                        ).setTint(CarColor.RED).build()
                    )
                    .setOnClickListener {
                        stopNavigation()
                        CarToast.makeText(carContext, "Navegaci√≥n detenida", CarToast.LENGTH_SHORT).show()
                    }
                    .build()
            )
            // 2. MUTE/UNMUTE TTS Button
            .addAction(
                Action.Builder()
                    .setIcon(
                        CarIcon.Builder(
                            androidx.core.graphics.drawable.IconCompat.createWithResource(
                                carContext,
                                if (isTtsMuted) {
                                    android.R.drawable.ic_lock_silent_mode_off // Muted
                                } else {
                                    android.R.drawable.ic_lock_silent_mode // Unmuted
                                }
                            )
                        ).build()
                    )
                    .setOnClickListener {
                        toggleTtsMute()
                    }
                    .build()
            )
            // 3. ZOOM/Re-center Button
            .addAction(
                Action.Builder()
                    .setIcon(
                        CarIcon.Builder(
                            androidx.core.graphics.drawable.IconCompat.createWithResource(
                                carContext,
                                com.georacing.georacing.R.drawable.ic_f1_car_scaled
                            )
                        ).build()
                    )
                    .setOnClickListener {
                        isFollowMode = true
                        adjustZoomLevel()
                        CarToast.makeText(carContext, "Centrando mapa", CarToast.LENGTH_SHORT).show()
                    }
                    .build()
            )
            .build()
    }
    
    /**
     * Tier 1: Stop navigation and return to main screen
     */
    private fun stopNavigation() {
        android.util.Log.i(TAG, "üõë Deteniendo navegaci√≥n por usuario")
        
        // Stop location updates
        fusedLocationClient.removeLocationUpdates(locationCallback)
        
        // Clear route
        currentRouteResult = null
        currentManeuverStep = null
        
        // Stop TTS
        tts?.stop()
        
        // Invalidate to refresh screen
        invalidate()
        
        // Navigate back
        screenManager.pop()
    }
    
    /**
     * Tier 1: Toggle TTS mute state
     */
    private fun toggleTtsMute() {
        isTtsMuted = !isTtsMuted
        
        val message = if (isTtsMuted) {
            "Instrucciones de voz silenciadas"
        } else {
            "Instrucciones de voz activadas"
        }
        
        CarToast.makeText(carContext, message, CarToast.LENGTH_SHORT).show()
        android.util.Log.d(TAG, "üîá TTS Mute: $isTtsMuted")
        
        // Invalidate to refresh MapActionStrip with new icon
        invalidate()
    }
    
    /**
     * Tier 1: Adjust zoom level for better visibility
     */
    private fun adjustZoomLevel() {
        val map = mapLibreMap ?: return
        
        // Increase zoom slightly for better route visibility
        val currentZoom = map.cameraPosition.zoom
        val targetZoom = if (currentZoom < 16.0) 16.5 else currentZoom + 0.5
        
        map.animateCamera(
            CameraUpdateFactory.zoomTo(targetZoom.coerceAtMost(18.0)),
            500
        )
        
        android.util.Log.d(TAG, "‚ûï Zoom ajustado: $currentZoom -> $targetZoom")
    }
    
    /**
     * Tier 1: Navigate to assigned parking using official coordinates
     */
    /**
     * Tier 1: Navigate to assigned parking using ticket-based assignment.
     * Usa ParkingAssignmentManager para asignar din√°micamente seg√∫n tipo de entrada.
     */
    private fun navigateToAssignedParking() {
        // Obtener asignaci√≥n din√°mica seg√∫n tipo de entrada (default: GENERAL)
        val assignment = com.georacing.georacing.data.parking.ParkingAssignmentManager
            .getAssignmentByCode(assignedParking)
        
        val targetParking = com.georacing.georacing.data.parking.ParkingLocation(
            latitude = assignment.latitude,
            longitude = assignment.longitude,
            timestamp = System.currentTimeMillis(),
            photoUri = null
        )
        
        assignedParkingLocation = targetParking
        
        CarToast.makeText(carContext, "Redirigiendo a ${assignment.parkingName}", CarToast.LENGTH_SHORT).show()
            
        // Push new navigation screen to assigned parking
        screenManager.push(
            GeoRacingNavigationScreen(
                carContext = carContext,
                destTitle = assignment.parkingName,
                destLat = assignment.latitude,
                destLon = assignment.longitude
            )
        )
    }
    
    /**
     * Tier 1: Check ScenarioSimulator for hazards and show heads-up notifications
     */
    private fun checkAndShowHazardAlerts() {
        val hazards = com.georacing.georacing.debug.ScenarioSimulator.activeHazards.value
        val now = System.currentTimeMillis()
        
        // Only show alert every 30 seconds to avoid spam
        if (hazards.isNotEmpty() && (now - lastHazardAlertTime) > 30000) {
            val hazard = hazards.first()
            val message = "‚ö†Ô∏è ${hazard.type.label} - Desviando..."
            
            CarToast.makeText(carContext, message, CarToast.LENGTH_LONG).show()
            speak(hazard.type.label + " reportado en la ruta")
            
            lastHazardAlertTime = now
        }
    }
    
    /**
     * Tier 1: Check for critical circuit state changes and send HUN notifications
     */
    private fun checkRaceControlAlerts() {
        val now = System.currentTimeMillis()
        
        // Get current circuit mode from ScenarioSimulator
        val crowdIntensity = com.georacing.georacing.debug.ScenarioSimulator.crowdIntensity.value
        
        val currentMode = when {
            crowdIntensity > 0.9f -> com.georacing.georacing.domain.model.CircuitMode.RED_FLAG
            crowdIntensity > 0.7f -> com.georacing.georacing.domain.model.CircuitMode.SAFETY_CAR
            crowdIntensity > 0.5f -> com.georacing.georacing.domain.model.CircuitMode.YELLOW_FLAG
            else -> com.georacing.georacing.domain.model.CircuitMode.GREEN_FLAG
        }
        
        // Tier 1: Detect state change and send HUN notification
        if (lastCircuitMode != null && lastCircuitMode != currentMode) {
            android.util.Log.w(TAG, "üö© Circuit Mode Changed: $lastCircuitMode -> $currentMode")
            
            when (currentMode) {
                com.georacing.georacing.domain.model.CircuitMode.RED_FLAG,
                com.georacing.georacing.domain.model.CircuitMode.YELLOW_FLAG,
                com.georacing.georacing.domain.model.CircuitMode.SAFETY_CAR,
                com.georacing.georacing.domain.model.CircuitMode.EVACUATION -> {
                    // Tier 1: Send HUN notification to dashboard
                    circuitNotificationManager.sendCircuitStateAlert(currentMode)
                    
                    // TTS announcement (if not muted)
                    if (!isTtsMuted) {
                        val ttsMessage = getTtsMessageForMode(currentMode)
                        speak(ttsMessage)
                    }
                    
                    // CarToast for immediate feedback
                    val toastMessage = when (currentMode) {
                        com.georacing.georacing.domain.model.CircuitMode.RED_FLAG -> "‚ö†Ô∏è CARRERA DETENIDA"
                        com.georacing.georacing.domain.model.CircuitMode.YELLOW_FLAG -> "üü° PRECAUCI√ìN"
                        com.georacing.georacing.domain.model.CircuitMode.SAFETY_CAR -> "üöó SAFETY CAR"
                        com.georacing.georacing.domain.model.CircuitMode.EVACUATION -> "üö® EVACUACI√ìN"
                        else -> ""
                    }
                    CarToast.makeText(carContext, toastMessage, CarToast.LENGTH_LONG).show()
                    
                    lastCircuitModeAlertTime = now
                }
                else -> {
                    // Green flag or normal - no notification
                }
            }
        }
        
        lastCircuitMode = currentMode
    }
    
    /**
     * Tier 1: Get TTS message for circuit mode
     */
    private fun getTtsMessageForMode(mode: com.georacing.georacing.domain.model.CircuitMode): String {
        return when (mode) {
            com.georacing.georacing.domain.model.CircuitMode.RED_FLAG -> 
                "Atenci√≥n. Bandera roja. Carrera detenida. Mantenga la calma al llegar."
            com.georacing.georacing.domain.model.CircuitMode.YELLOW_FLAG -> 
                "Precauci√≥n. Bandera amarilla. Reduzca la velocidad."
            com.georacing.georacing.domain.model.CircuitMode.SAFETY_CAR -> 
                "Safety car en pista. Reduzca velocidad."
            com.georacing.georacing.domain.model.CircuitMode.EVACUATION -> 
                "Evacuaci√≥n inmediata. Siga las se√±ales de salida."
            else -> ""
        }
    }

    private fun buildRoutingInfo(): RoutingInfo {
        if (currentRouteResult == null) {
             return RoutingInfo.Builder().setLoading(true).build()
        }
        
        // Determinar texto de la instrucci√≥n
        val stepTitle = when {
            currentDistance != null && currentDistance!! < 50 -> "Ha llegado a su destino"
            currentManeuverStep != null -> getInstructionText(currentManeuverStep!!)
            else -> "Contin√∫e por la ruta"
        }
        
        android.util.Log.d(TAG, "üß≠ Instrucci√≥n actual: $stepTitle, distancia: ${distToManeuver.toInt()}m")

        val stepObj = currentManeuverStep
        
        val maneuverBuilder = if (stepObj != null) {
             Maneuver.Builder(getManeuverType(stepObj.maneuver.type, stepObj.maneuver.modifier))
        } else {
             Maneuver.Builder(Maneuver.TYPE_STRAIGHT)
        }

        // Construir el Step con la distancia a la maniobra
        val distanceToManeuver = if (distToManeuver > 0) {
            Distance.create(distToManeuver / 1000.0, Distance.UNIT_KILOMETERS)
        } else {
            Distance.create(0.0, Distance.UNIT_KILOMETERS)
        }

        val step = Step.Builder(stepTitle)
            .setManeuver(maneuverBuilder.build())
            .setCue(buildLaneCue(stepObj)) // Lane suggestion text
            .build()
        
        // FASE 3.2: Construir info de veloc√≠metro
        val routingInfoBuilder = RoutingInfo.Builder()
            .setCurrentStep(step, distanceToManeuver)
        
        // A√±adir texto de velocidad si est√° disponible
        if (currentSpeedKmh > 0 || currentSpeedLimitKmh != null) {
            val speedText = buildSpeedDisplayText()
            // Nota: Android Auto no tiene campo espec√≠fico de veloc√≠metro en NavigationTemplate
            // Usaremos el debug logging por ahora
            android.util.Log.d(TAG, "FASE 3.2 Veloc√≠metro: $speedText")
        }
            
        return routingInfoBuilder.build()
    }
    // Lane guidance removed - API not compatible with library version
    
    /**
     * Tier 1: Build lane cue text for display
     */
    private fun buildLaneCue(step: OsrmStep?): String {
        return when (step?.maneuver?.modifier) {
            "right", "sharp right" -> "Usa el carril derecho"
            "slight right" -> "Usa los 2 carriles derechos"
            "left", "sharp left" -> "Usa el carril izquierdo"
            "slight left" -> "Usa los 2 carriles izquierdos"
            else -> "Cualquier carril"
        }
    }
    
    /**
     * FASE 3.2: Construye texto de veloc√≠metro para mostrar.
     * Formato: "85 / 100 km/h" o "85 km/h" si no hay l√≠mite.
     * Si excede l√≠mite: "‚ö† 130 / 120 km/h"
     */
    private fun buildSpeedDisplayText(): String {
        return if (currentSpeedLimitKmh != null) {
            val exceedsLimit = currentSpeedKmh.toInt() > currentSpeedLimitKmh!!
            val prefix = if (exceedsLimit) "‚ö† " else ""
            "$prefix${currentSpeedKmh.toInt()} / $currentSpeedLimitKmh km/h"
        } else {
            "${currentSpeedKmh.toInt()} km/h"
        }
    }

    private fun buildTravelEstimate(): TravelEstimate {
        val dist = currentDistance ?: 0.0
        var dur = currentDuration ?: 0.0
        
        // ==============================================
        // TRAFFIC INTEGRATION: Crowd surge adds delay
        // ==============================================
        val crowdIntensity = com.georacing.georacing.debug.ScenarioSimulator.crowdIntensity.value
        val trafficDelaySeconds = if (crowdIntensity > 0.5f) {
            // High crowd = 15 min delay
            val delayMinutes = ((crowdIntensity - 0.5f) * 30).toInt() // 0-15 min scale
            NavigationSession.applyTrafficDelay(delayMinutes)
            delayMinutes * 60.0
        } else {
            NavigationSession.applyTrafficDelay(0)
            0.0
        }
        
        dur += trafficDelaySeconds
        
        val arrivalCalendar = Calendar.getInstance()
        arrivalCalendar.add(Calendar.SECOND, dur.toInt())
        val arrivalTime = DateTimeWithZone.create(
            arrivalCalendar.timeInMillis,
            (TimeZone.getDefault().getOffset(System.currentTimeMillis()) / 1000),
            TimeZone.getDefault().getDisplayName(false, TimeZone.SHORT)
        )
        
        // ==============================================
        // ETA COLOR: Red for traffic, Yellow for late, Green for on-time
        // ==============================================
        val etaColor = when {
            crowdIntensity > 0.7f -> CarColor.RED // Heavy traffic!
            raceStartTime != null && arrivalCalendar.timeInMillis > raceStartTime!! -> CarColor.RED // Late!
            crowdIntensity > 0.5f || dur > 1800 -> CarColor.YELLOW // Moderate traffic or >30 min
            else -> CarColor.GREEN // On time
        }
        
        return TravelEstimate.Builder(
            Distance.create(dist / 1000.0, Distance.UNIT_KILOMETERS),
            arrivalTime
        ).setRemainingTimeSeconds(dur.toLong())
         .setRemainingTimeColor(etaColor)
         .build()
    }

    private fun setupMapStyle() {
        val map = mapLibreMap ?: run {
            android.util.Log.e(TAG, "‚ùå setupMapStyle: mapLibreMap es null")
            return
        }
        
        android.util.Log.d(TAG, "üó∫Ô∏è setupMapStyle: Iniciando carga de estilo...")
        
        // Detectar autom√°ticamente el modo oscuro/claro del sistema
        val isDarkMode = (carContext.resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES
        val json = if (isDarkMode) mapStyleManager.STYLE_NIGHT_JSON else mapStyleManager.STYLE_DAY_JSON
        
        android.util.Log.d(TAG, "üé® Modo: ${if (isDarkMode) "OSCURO" else "CLARO"}")
        
        map.setStyle(Style.Builder().fromJson(json)) { style ->
            android.util.Log.d(TAG, "üó∫Ô∏è Callback de estilo ejecutado, isFullyLoaded=${style.isFullyLoaded}")
            
            // CRITICAL FIX: Esperar a que el estilo est√© completamente cargado antes de activar location component
            // Esto previene el crash: "Calling getSourceAs when a newer style is loading/has loaded"
            if (!style.isFullyLoaded) {
                android.util.Log.w(TAG, "‚ö†Ô∏è Estilo no completamente cargado, esperando con retry...")
                waitForStyleFullyLoaded(style, retryCount = 0)
            } else {
                android.util.Log.d(TAG, "‚úÖ Estilo ya completamente cargado")
                initializeMapComponents(style)
            }
        }
    }
    
    private fun waitForStyleFullyLoaded(style: Style, retryCount: Int) {
        val maxRetries = 10  // M√°ximo 10 intentos (2 segundos total)
        val retryDelayMs = 200L
        
        if (retryCount >= maxRetries) {
            android.util.Log.e(TAG, "‚ùå TIMEOUT: Estilo no se carg√≥ despu√©s de ${maxRetries * retryDelayMs}ms")
            // Intentar inicializar de todas formas (puede fallar pero es mejor que pantalla negra)
            initializeMapComponents(style)
            return
        }
        
        handler.postDelayed({
            if (style.isFullyLoaded) {
                android.util.Log.d(TAG, "‚úÖ Estilo cargado despu√©s de ${(retryCount + 1) * retryDelayMs}ms")
                initializeMapComponents(style)
            } else {
                android.util.Log.d(TAG, "‚è≥ Intento ${retryCount + 1}/$maxRetries - Estilo a√∫n cargando...")
                waitForStyleFullyLoaded(style, retryCount + 1)
            }
        }, retryDelayMs)
    }
    
    private fun initializeMapComponents(style: Style) {
        android.util.Log.d(TAG, "üîß initializeMapComponents: Iniciando...")
        
        try {
            mapStyleManager.applyLayers(style)
            android.util.Log.d(TAG, "‚úÖ Capas aplicadas")
        } catch (e: Exception) {
            android.util.Log.e(TAG, "‚ùå Error aplicando capas: ${e.message}", e)
        }
        

        
        try {
            updatePois(style)
            android.util.Log.d(TAG, "‚úÖ POIs actualizados")
        } catch (e: Exception) {
            android.util.Log.e(TAG, "‚ùå Error actualizando POIs: ${e.message}", e)
        }
        
        if (currentRouteResult != null) {
            try {
                drawRoute(currentRouteResult!!)
                android.util.Log.d(TAG, "‚úÖ Ruta dibujada")
            } catch (e: Exception) {
                android.util.Log.e(TAG, "‚ùå Error dibujando ruta: ${e.message}", e)
            }
        }
        
        android.util.Log.d(TAG, "‚úÖ initializeMapComponents COMPLETADO")
    }
    


    private fun updatePois(style: Style) {
        // CRITICAL: Verificar que el estilo est√© completamente cargado antes de acceder a sources
        if (!style.isFullyLoaded) {
            android.util.Log.w(TAG, "‚ö†Ô∏è Estilo no listo, saltando POIs update")
            return
        }
        
        try {
            val pois = poiRepository.getAllPois()
            val features = pois.map { poi ->
                Feature.fromGeometry(Point.fromLngLat(poi.longitude, poi.latitude)).apply {
                    addStringProperty("id", poi.id)
                    addStringProperty("name", poi.name)
                    addStringProperty("icon_image", if (poi.type == PoiType.PARKING) MapStyleManager.IMAGE_PARKING else MapStyleManager.IMAGE_GATE)
                }
            }
            
            val source = style.getSourceAs<GeoJsonSource>(MapStyleManager.SOURCE_POIS)
            source?.setGeoJson(FeatureCollection.fromFeatures(features))
        } catch (e: Exception) {
            android.util.Log.e(TAG, "‚ùå Error actualizando POIs: ${e.message}", e)
        }
    }

    private fun updateMapLocation(location: Location) {
        val map = mapLibreMap ?: return
        
        // CALCULAR RUTA INICIAL: Si hay destino pero no se ha calculado ruta, hacerlo ahora
        if (destLat != null && destLon != null && !isInitialRouteCalculated && currentRouteResult == null) {
            isInitialRouteCalculated = true
            android.util.Log.i(TAG, "üöÄ Calculando ruta inicial desde (${location.latitude}, ${location.longitude}) hasta ($destLat, $destLon)")
            
            CoroutineScope(Dispatchers.IO).launch {
                val origin = LatLng(location.latitude, location.longitude)
                val dest = LatLng(destLat!!, destLon!!)
                val result = routeRepository.getRoute(origin, dest, avoidTraffic = true)
                
                withContext(Dispatchers.Main) {
                    if (result != null) {
                        currentRouteResult = result
                        processRouteResult(result)
                        android.util.Log.i(TAG, "‚úÖ Ruta inicial calculada: ${result.distance}m, ${result.duration}s, ${result.steps.size} pasos")
                    } else {
                        android.util.Log.e(TAG, "‚ùå Error al calcular ruta inicial")
                    }
                }
            }
        }
        
        // FASE 3.2: Actualizar velocidad actual y l√≠mite
        currentSpeedKmh = if (location.hasSpeed()) (location.speed * 3.6).toDouble() else 0.0
        currentSpeedLimitKmh = speedLimitProvider.getSpeedLimitForLocation(location)
        
        if (isFollowMode) {
             val speed = currentSpeedKmh.toFloat()
             val cameraState = cameraController.update(
                 location = location,
                 speedKmh = speed,
                 distanceToTurnMeters = if (isNavigationActive) distToManeuver else 0.0,
                 isNavigationActive = isNavigationActive
             )
             
             val camPos = org.maplibre.android.camera.CameraPosition.Builder()
                 .target(cameraState.target)
                 .zoom(cameraState.zoom)
                 .tilt(cameraState.tilt)
                 .bearing(cameraState.bearing)
                 .build()
                 
             map.animateCamera(CameraUpdateFactory.newCameraPosition(camPos), 1000)
        }

        // 3. Update Custom Car Layer (The Racing Car Icon)
        val style = map.style
        if (style != null) {
            val carSource = style.getSourceAs<GeoJsonSource>(MapStyleManager.SOURCE_CAR)
            if (carSource != null) {
                val carFeature = Feature.fromGeometry(Point.fromLngLat(location.longitude, location.latitude))
                carFeature.addNumberProperty("bearing", location.bearing.toDouble())
                carSource.setGeoJson(carFeature)
            }
        }

        if (isNavigationActive) {
            updateNavigationState(location)
            // Actualizar distancia y tiempo restante en tiempo real
            updateDistanceAndTime(location)
        }
        
        // FASE 3.4: Actualizar HUD SIEMPRE (incluso sin navegaci√≥n activa para mostrar veloc√≠metro)
        updateNavigationHUD(location)
    }
    
    private fun updateDistanceAndTime(location: Location) {
        if (destLat == null || destLon == null) return
        
        // FASE 1.4: FILTRO GPS POR ACCURACY - Ignorar se√±ales GPS poco confiables
        if (location.accuracy > 50f) {
            android.util.Log.w(TAG, "‚ö†Ô∏è GPS inestable (accuracy=${location.accuracy}m), manteniendo √∫ltima posici√≥n")
            
            // Si llevamos >10s sin GPS bueno, congelar ETA
            val timeSinceGoodGPS = System.currentTimeMillis() - lastGoodGPSTime
            if (timeSinceGoodGPS > 10000) {
                android.util.Log.w(TAG, "‚ö†Ô∏è Sin GPS v√°lido desde hace ${timeSinceGoodGPS}ms - ETA congelado")
                // No actualizar currentDuration ni currentDistance
            }
            return  // Mantener snap/ETA anterior
        }
        
        // GPS v√°lido, actualizar timestamp
        lastGoodGPSTime = System.currentTimeMillis()
        
        android.util.Log.d(TAG, "üìç GPS v√°lido (accuracy=${location.accuracy}m) - Posici√≥n: (${location.latitude}, ${location.longitude})")
        
        // Usar los nuevos utilities para c√°lculo optimizado
        currentRouteResult?.let { route ->
            if (route.points.isEmpty()) return@let
            
            // FASE 1.1: SNAP TO ROUTE CON CACHE - Solo recalcular si te moviste >10m
            val needsRecalculation = lastSnapResult == null || run {
                val lastPoint = lastSnapResult!!.closestPoint
                val lastLoc = Location("").apply {
                    latitude = lastPoint.latitude
                    longitude = lastPoint.longitude
                }
                location.distanceTo(lastLoc) > 10.0  // Threshold 10m
            }
            
            val snapResult = if (needsRecalculation) {
                // FASE 2.1: Usar snap adaptativo en dos pasadas
                // Primera pasada r√°pida (radius=30), segunda ampliada (radius=100) si est√° lejos
                com.georacing.georacing.utils.RouteSnapper.snapToRouteAdaptive(
                    currentLocation = location,
                    routePoints = route.points,
                    lastIndex = lastSnapResult?.closestIndex ?: 0,
                    firstRadius = 30,
                    secondRadius = 100,
                    distanceThresholdMeters = 80.0
                ).also { 
                    lastSnapResult = it  // Actualizar cache
                    android.util.Log.d(TAG, "FASE 2.1 - Snap adaptativo: index=${it.closestIndex}, distToRoute=${it.distanceToRoute}m")
                }
            } else {
                // Usar snap cacheado
                lastSnapResult!!
            }
            
            // 2. CALCULAR DISTANCIA RESTANTE
            val remainingDistance = com.georacing.georacing.utils.DistanceCalculator.calculateRemainingDistance(
                snapResult = snapResult,
                routePoints = route.points
            )
            currentDistance = remainingDistance
            
            // 3. CALCULAR ETA PROPORCIONAL CON FACTOR DE TR√ÅFICO (FASE 3.3)
            currentDuration = com.georacing.georacing.utils.ETACalculator.calculateRemainingTimeWithTraffic(
                remainingDistance = remainingDistance,
                totalDistance = route.distance,
                totalDuration = route.duration,
                trafficFactor = trafficFactor  // FASE 3: Actualmente 1.0 (placeholder)
            )
            
            android.util.Log.d(TAG, "üìä Distancia restante: ${(remainingDistance/1000).format(1)} km, ETA: ${(currentDuration?.div(60))?.toInt() ?: 0} min")
            
            // 4. ACTUALIZAR PASO ACTUAL (calcula distanceToManeuver correctamente)
            updateCurrentStep(route, snapResult.closestIndex, location)
            
            android.util.Log.d(TAG, "üéØ Paso actual: ${currentStepIndex + 1}/${route.steps.size}, distancia a maniobra: ${distToManeuver.toInt()}m")
            
            // 5. CHECK OFF-ROUTE
            val isOffRoute = com.georacing.georacing.utils.OffRouteDetector.checkOffRoute(
                location = location,
                snapResult = snapResult
            )
            
            if (isOffRoute) {
                handleOffRoute(location)
            }
            
            // 6. CHECK ARRIVAL
            val destination = LatLng(destLat!!, destLon!!)
            val arrived = CheckArrivalUseCase.executeSimple(
                currentLocation = location,
                destination = destination
            )
            
            if (arrived) {
                handleArrival()
                return
            }
            
            // 7. HANDLE TTS PROGRESIVO (ya manejado en updateCurrentStep)
            // (TTS se maneja autom√°ticamente en updateCurrentStep v√≠a handleTtsProgressive)
            
            // Forzar actualizaci√≥n de la UI
            invalidate()
        }
    }
    
    private fun updateCurrentStep(route: RouteResult, closestIndex: Int, location: Location) {
        if (route.steps.isEmpty()) return
        
        // Calcular qu√© paso/instrucci√≥n est√° pr√≥ximo
        var accumulatedDistance = 0.0
        var foundStep = false
        
        for (stepIndex in 0 until route.steps.size) {
            accumulatedDistance += route.steps[stepIndex].distance
            val progressThroughRoute = closestIndex.toDouble() / route.points.size.toDouble()
            val stepProgressPoint = accumulatedDistance / route.distance
            
            // Si este paso est√° adelante en la ruta
            if (stepProgressPoint > progressThroughRoute) {
                currentStepIndex = stepIndex
                
                // Calcular distancia al siguiente paso
                var distToStep = 0.0
                val stepStartIndex = (stepProgressPoint * route.points.size).toInt()
                for (i in closestIndex until stepStartIndex.coerceAtMost(route.points.size - 1)) {
                    val p1 = Location("").apply {
                        latitude = route.points[i].latitude
                        longitude = route.points[i].longitude
                    }
                    val p2 = Location("").apply {
                        latitude = route.points[i + 1].latitude
                        longitude = route.points[i + 1].longitude
                    }
                    distToStep += p1.distanceTo(p2)
                }
                
                distanceToNextStep = distToStep
                distToManeuver = distToStep
                currentManeuverStep = route.steps[stepIndex]
                
                // Manejar instrucciones de voz progresivas (estilo Google Maps)
                route.steps[stepIndex].let { step ->
                    val text = getInstructionText(step)
                    handleTtsProgressive(text, distToStep)
                }
                
                foundStep = true
                break
            }
        }
        
        if (!foundStep && route.steps.isNotEmpty()) {
            // Si no encontramos paso siguiente, usar el √∫ltimo
            currentStepIndex = route.steps.size - 1
            currentManeuverStep = route.steps[currentStepIndex]
        }
    }
    
    private fun handleTtsProgressive(instruction: String, distance: Double) {
        // Tier 1: Respect mute state
        if (isTtsMuted) {
            return
        }
        
        // Determinar threshold basado en distancia
        val threshold = when {
            distance > 1000 -> 4 // "En 1 kil√≥metro"
            distance > 500 -> 3  // "En 500 metros"
            distance > 250 -> 2  // "En 250 metros"
            distance > 100 -> 1  // "En 100 metros"
            else -> 0           // "Ahora"
        }
        
        // Solo hablar si hemos cruzado un nuevo threshold HACIA ABAJO
        if (threshold < lastSpokenThreshold || lastInstruction != instruction) {
            val prefix = when (threshold) {
                4 -> "En un kil√≥metro, "
                3 -> "En 500 metros, "
                2 -> "En 250 metros, "
                1 -> "En 100 metros, "
                else -> ""
            }
            val fullMessage = prefix + instruction
            speak(fullMessage)
            lastSpokenThreshold = threshold
            lastInstruction = instruction
            
            android.util.Log.d(TAG, "üîä TTS Progressive: '$fullMessage' (dist=${distance.toInt()}m, threshold=$threshold)")
        }
        
        // Resetear si volvemos a pasar un threshold HACIA ARRIBA (ej: recalculado)
        if (threshold > lastSpokenThreshold) {
            lastSpokenThreshold = threshold
        }
    }
    
    private fun handleArrival() {
        if (!isNavigationActive || hasArrived) return
        
        android.util.Log.d(TAG, "¬°LLEGADA AL DESTINO!")
        hasArrived = true
        isNavigationActive = false
        
        // Usar TTSManager para anuncio de llegada
        com.georacing.georacing.utils.TTSManager.announceArrival(
            destinationName = destTitle ?: "su destino",
            tts = tts
        )
        
        // Animaci√≥n de celebraci√≥n
        handler.postDelayed({
            CarToast.makeText(
                carContext,
                "üèÅ ¬°Destino Alcanzado! üèÅ",
                CarToast.LENGTH_LONG
            ).show()
        }, 500)
        
        // Zoom out para mostrar la ubicaci√≥n completa
        mapLibreMap?.let { map ->
            map.animateCamera(
                CameraUpdateFactory.newLatLngZoom(
                    LatLng(destLat!!, destLon!!),
                    16.0
                ),
                2000
            )
        }
    }
    
    /**
     * Maneja la situaci√≥n de estar fuera de ruta.
     * Recalcula autom√°ticamente la ruta desde la posici√≥n actual.
     */
    private fun handleOffRoute(location: Location) {
        if (destLat == null || destLon == null) return
        
        android.util.Log.w(TAG, "üîÑ Usuario fuera de ruta, recalculando...")
        
        // Anunciar recalculo
        com.georacing.georacing.utils.TTSManager.announceRouteRecalculation(tts)
        
        CarToast.makeText(
            carContext,
            "Recalculando ruta...",
            CarToast.LENGTH_SHORT
        ).show()
        
        // Recalcular ruta en background
        CoroutineScope(Dispatchers.IO).launch {
            val origin = LatLng(location.latitude, location.longitude)
            val dest = LatLng(destLat!!, destLon!!)
            
            val result = routeRepository.getRoute(origin, dest, avoidTraffic = true)
            
            withContext(Dispatchers.Main) {
                if (result != null) {
                    currentRouteResult = result
                    processRouteResult(result)
                    
                    CarToast.makeText(
                        carContext,
                        "Ruta actualizada",
                        CarToast.LENGTH_SHORT
                    ).show()
                    
                    android.util.Log.i(TAG, "‚úÖ Ruta recalculada exitosamente")
                } else {
                    android.util.Log.e(TAG, "‚ùå Error al recalcular ruta")
                }
            }
        }
    }

    private fun updateNavigationState(location: Location) {
        // FASE 1.5: RECALCULO PERI√ìDICO ELIMINADO
        // OSRM p√∫blico no tiene tr√°fico real, recalcular cada X segundos no aporta nada.
        // La ruta solo se recalcula cuando:
        // 1. OffRouteDetector detecta que el usuario sali√≥ de ruta (confirmado tras 3s)
        // 2. Usuario pulsa acci√≥n manual de recalcular (si existe)
        
        /* ELIMINADO - Recalculo cada 30s innecesario:
        val now = System.currentTimeMillis()
        if (now - lastRouteFetchTime > 30000) {
            lastRouteFetchTime = now
            CoroutineScope(Dispatchers.IO).launch {
                val origin = LatLng(location.latitude, location.longitude)
                val dest = LatLng(destLat!!, destLon!!)
                val result = routeRepository.getRoute(origin, dest, avoidTraffic = true)
                withContext(Dispatchers.Main) {
                    if (result != null) {
                        currentRouteResult = result
                        processRouteResult(result)
                    }
                }
            }
        }
        */
    }

    private fun processRouteResult(result: RouteResult) {
        currentDistance = result.distance
        currentDuration = result.duration
        currentStepIndex = 0
        lastInstruction = null
        lastSpokenThreshold = -1
        drawRoute(result)
        
        if (result.steps.isNotEmpty()) {
            currentManeuverStep = result.steps[0]
            distToManeuver = result.steps[0].distance
            
            // Anunciar primera instrucci√≥n
            val text = getInstructionText(result.steps[0])
            speak("Ruta calculada. $text en ${formatdist(result.steps[0].distance)}")
        }
        invalidate()
    }
    
    private fun drawRoute(result: RouteResult) {
        val map = mapLibreMap ?: return
        val style = map.style ?: return
        
        // Dibujar ruta principal (cyan)
        val points = result.points.map { Point.fromLngLat(it.longitude, it.latitude) }
        val lineString = LineString.fromLngLats(points)
        val source = style.getSourceAs<GeoJsonSource>(MapStyleManager.SOURCE_ROUTE)
        source?.setGeoJson(Feature.fromGeometry(lineString))
        
        // Dibujar segmentos de tr√°fico en rojo/naranja/amarillo
        drawTrafficSegments(result, style)
    }
    
    private fun drawTrafficSegments(result: RouteResult, style: Style) {
        // Remover capa de tr√°fico anterior si existe
        style.getLayer("traffic-layer")?.let { style.removeLayer(it) }
        style.getSource("traffic-source")?.let { style.removeSource(it) }
        
        if (result.trafficSegments.isEmpty()) return
        
        val features = result.trafficSegments.map { segment ->
            val segmentPoints = result.points.subList(
                segment.startIndex,
                (segment.endIndex + 1).coerceAtMost(result.points.size)
            ).map { Point.fromLngLat(it.longitude, it.latitude) }
            
            val color = when (segment.congestionLevel) {
                CongestionLevel.SEVERE -> "#FF0000"    // Rojo - tr√°fico muy denso
                CongestionLevel.HEAVY -> "#FF6600"     // Naranja - tr√°fico denso
                CongestionLevel.MODERATE -> "#FFAA00"  // Amarillo - tr√°fico moderado
                else -> "#00FF00"                      // Verde - fluido
            }
            
            val feature = Feature.fromGeometry(LineString.fromLngLats(segmentPoints))
            feature.addStringProperty("traffic_color", color)
            feature
        }
        
        val featureCollection = FeatureCollection.fromFeatures(features)
        val trafficSource = GeoJsonSource("traffic-source", featureCollection)
        style.addSource(trafficSource)
        
        // A√±adir capa de tr√°fico encima de la ruta
        val trafficLayer = LineLayer("traffic-layer", "traffic-source").withProperties(
            PropertyFactory.lineColor(Expression.get("traffic_color")),
            PropertyFactory.lineWidth(10f),
            PropertyFactory.lineCap(Property.LINE_CAP_ROUND),
            PropertyFactory.lineJoin(Property.LINE_JOIN_ROUND),
            PropertyFactory.lineOpacity(0.8f)
        )
        style.addLayerAbove(trafficLayer, MapStyleManager.LAYER_ROUTE)
    }

private fun speak(text: String) {
        android.util.Log.d(TAG, "TTS Speak: '$text'")
        if (tts != null) {
            // QUEUE_FLUSH para que hable inmediatamente, no QUEUE_ADD
            tts!!.speak(text, TextToSpeech.QUEUE_FLUSH, null, "TTS_ID")
        } else {
            android.util.Log.e(TAG, "TTS no inicializado!")
        }
    }
    
    private fun formatdist(meters: Double): String {
        return if (meters >= 1000) "%.1f kil√≥metros".format(meters/1000) else "${meters.toInt()} metros"
    }
    
    // Helper para formatear decimales
    private fun Double.format(decimals: Int): String {
        return String.format("%.${decimals}f", this)
    }

    private val surfaceCallback = object : SurfaceCallback {
        override fun onSurfaceAvailable(container: SurfaceContainer) {
            android.util.Log.d(TAG, "üñ•Ô∏è onSurfaceAvailable: ${container.width}x${container.height}, dpi=${container.dpi}")
            
            surfaceWidth = container.width
            surfaceHeight = container.height
            val displayManager = carContext.getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
            
            virtualDisplay = displayManager.createVirtualDisplay(
                "GeoRacingMap",
                container.width, container.height, container.dpi,
                container.surface, 0
            )
            
            android.util.Log.d(TAG, "üñ•Ô∏è VirtualDisplay creado")
            
            presentation = CarMapPresentation(carContext, virtualDisplay!!.display)
            presentation?.show()
            
            android.util.Log.d(TAG, "üó∫Ô∏è Presentation mostrado, inicializando MapView...")
            
            presentation?.mapView?.let { mapView ->
                mapView.onCreate(null)
                mapView.onStart()
                mapView.onResume()
                
                android.util.Log.d(TAG, "üó∫Ô∏è MapView inicializado, esperando getMapAsync...")
                
                mapView.getMapAsync { map ->
                    android.util.Log.d(TAG, "‚úÖ getMapAsync callback ejecutado")
                    
                    mapLibreMap = map
                    map.uiSettings.isAttributionEnabled = false
                    map.uiSettings.isLogoEnabled = false
                    
                    android.util.Log.d(TAG, "üó∫Ô∏è Configuraci√≥n del mapa completa, llamando a setupMapStyle...")
                    setupMapStyle()
                }
            } ?: run {
                android.util.Log.e(TAG, "‚ùå ERROR: presentation.mapView es null!")
            }
        }
        override fun onSurfaceDestroyed(container: SurfaceContainer) {
            presentation?.mapView?.onDestroy()
            virtualDisplay?.release()
            mapLibreMap = null
        }
        override fun onScroll(distanceX: Float, distanceY: Float) {
            isFollowMode = false
            // Manual Scroll Implementation using Projection
            val map = mapLibreMap ?: return
            val projection = map.projection
            val center = map.cameraPosition.target ?: return
            val centerPoint = projection.toScreenLocation(center)
            
            // Shift screen point by distance
            val newCenterPoint = PointF(centerPoint.x + distanceX, centerPoint.y + distanceY)
            val newCenterLatLng = projection.fromScreenLocation(newCenterPoint)
            
            if (newCenterLatLng != null) {
                map.moveCamera(CameraUpdateFactory.newLatLng(newCenterLatLng))
            }
        }
        
        override fun onScale(focusX: Float, focusY: Float, scaleFactor: Float) {
             isFollowMode = false
             val map = mapLibreMap ?: return
             val zoomDiff = kotlin.math.ln(scaleFactor.toDouble()) / kotlin.math.ln(2.0)
             map.moveCamera(CameraUpdateFactory.zoomBy(zoomDiff))
        }
        override fun onVisibleAreaChanged(area: Rect) {}
    }

    override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {
        android.util.Log.d(TAG, "üîÑ Lifecycle Event: $event")
        
        if (event == Lifecycle.Event.ON_CREATE) {
            android.util.Log.d(TAG, "üé¨ ON_CREATE: Registrando SurfaceCallback...")
            carContext.getCarService(AppManager::class.java).setSurfaceCallback(surfaceCallback)
            android.util.Log.d(TAG, "‚úÖ SurfaceCallback registrado")
        } else if (event == Lifecycle.Event.ON_START) {
            android.util.Log.d(TAG, "‚ñ∂Ô∏è ON_START: Verificando permisos...")
            checkPermissions()
        } else if (event == Lifecycle.Event.ON_STOP) {
            android.util.Log.d(TAG, "‚è∏Ô∏è ON_STOP: Deteniendo actualizaciones de ubicaci√≥n")
            stopLocationUpdates()
        } else if (event == Lifecycle.Event.ON_DESTROY) {
            android.util.Log.d(TAG, "üíÄ ON_DESTROY: Liberando recursos...")
            carContext.getCarService(AppManager::class.java).setSurfaceCallback(null)
            presentation?.dismiss()
            virtualDisplay?.release()
            android.util.Log.d(TAG, "‚úÖ Recursos liberados")
        }
    }

    private fun checkPermissions() {
        if (carContext.checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
             startLocationUpdates()
             isLocationGranted = true
             invalidate()
        }
    }
    
    private fun startLocationUpdates() {
          try {
              val req = com.google.android.gms.location.LocationRequest.Builder(
                  com.google.android.gms.location.Priority.PRIORITY_HIGH_ACCURACY, 1000
              ).build()
              fusedLocationClient.requestLocationUpdates(req, locationCallback, Looper.getMainLooper())
          } catch (e: SecurityException) { e.printStackTrace() }
    }
    
    private fun stopLocationUpdates() {
        fusedLocationClient.removeLocationUpdates(locationCallback)
    }

    private fun getInstructionText(step: OsrmStep): String {
        val modifier = step.maneuver.modifier
        val type = step.maneuver.type
        val exit = step.maneuver.exit
        val streetName = if (step.name.isNotEmpty() && step.name != "unknown") " hacia ${step.name}" else ""
        
        return when (type) {
            "turn" -> {
                when (modifier) {
                    "left" -> "Gire a la izquierda$streetName"
                    "right" -> "Gire a la derecha$streetName"
                    "slight left" -> "Contin√∫e ligeramente a la izquierda$streetName"
                    "slight right" -> "Contin√∫e ligeramente a la derecha$streetName"
                    "sharp left" -> "Gire completamente a la izquierda$streetName"
                    "sharp right" -> "Gire completamente a la derecha$streetName"
                    else -> "Contin√∫e$streetName"
                }
            }
            "depart" -> "Inicie el recorrido$streetName"
            "arrive" -> "Ha llegado a su destino"
            "roundabout", "rotary" -> {
                // FASE 2.2: Rotondas con ordinales en espa√±ol natural
                if (exit != null && exit > 0) {
                    val ordinal = exitNumberToSpanishOrdinal(exit)
                    if (streetName.isNotEmpty()) {
                        "En la rotonda, toma la $ordinal salida$streetName"
                    } else {
                        "En la rotonda, toma la $ordinal salida"
                    }
                } else {
                    // Sin exit espec√≠fico, mensaje gen√©rico
                    if (streetName.isNotEmpty()) {
                        "En la rotonda, toma la salida$streetName"
                    } else {
                        "En la rotonda, contin√∫a recto"
                    }
                }
            }
            "continue" -> "Contin√∫e recto$streetName"
            else -> {
                if (step.name.isNotEmpty() && step.name != "unknown") {
                    "Contin√∫e por ${step.name}"
                } else {
                    "Contin√∫e por la ruta"
                }
            }
        }
    }
    
    /**
     * FASE 2.2: Convierte n√∫mero de salida de rotonda a ordinal en espa√±ol.
     * Usado para instrucciones naturales tipo Google Maps.
     * 
     * @param exit N√∫mero de salida (1-based)
     * @return Ordinal en espa√±ol ("primera", "segunda", "tercera", etc.)
     */
    private fun exitNumberToSpanishOrdinal(exit: Int): String {
        return when (exit) {
            1 -> "primera"
            2 -> "segunda"
            3 -> "tercera"
            4 -> "cuarta"
            5 -> "quinta"
            else -> "${exit}¬™"  // A partir de 6: "6¬™", "7¬™", etc.
        }
    }
    
    private fun translate(s: String?) = when(s) { "left"->"izquierda"; "right"->"derecha"; else->s?:"" }
    
    /**
     * FASE 3.4: Actualiza el HUD visual que se dibuja sobre el mapa.
     * Muestra veloc√≠metro, l√≠mite de velocidad, instrucci√≥n siguiente y ETA.
     * 
     * @param location Ubicaci√≥n GPS actual del usuario
     */
    private fun updateNavigationHUD(location: Location) {
        val pres = presentation ?: run {
            android.util.Log.w(TAG, "‚ö†Ô∏è HUD: Presentation no inicializada")
            return
        }
        
        try {
            // Generar bitmap del HUD m√°s compacto para no ocupar tanto espacio
            val hudBitmap = navigationHUD.createHUDBitmap(
                width = 280,   // Reducido de 350
                height = 140,  // Reducido de 200
                currentSpeedKmh = currentSpeedKmh.toInt(),
                speedLimitKmh = currentSpeedLimitKmh,
                nextInstruction = currentManeuverStep?.let { step ->
                    getInstructionText(step)
                } ?: "Contin√∫e recto",
                distanceToManeuver = distToManeuver,
                etaMinutes = (currentDuration?.div(60))?.toInt() ?: 0,
                arrowSymbol = currentManeuverStep?.let { step ->
                    getManeuverArrow(step.maneuver.type, step.maneuver.modifier)
                } ?: "‚Üë"
            )
            
            android.util.Log.d(TAG, "üé® HUD generado: ${currentSpeedKmh}/${currentSpeedLimitKmh ?: "?"} km/h, ${distToManeuver.toInt()}m")
            
            // Actualizar la vista del HUD en la presentation
            handler.post {
                try {
                    pres.hudOverlay.setImageBitmap(hudBitmap)
                    android.util.Log.d(TAG, "‚úÖ HUD actualizado en ImageView")
                } catch (e: Exception) {
                    android.util.Log.e(TAG, "‚ùå Error actualizando HUD en ImageView: ${e.message}")
                }
            }
        } catch (e: Exception) {
            android.util.Log.e(TAG, "‚ùå Error generando HUD bitmap: ${e.message}", e)
        }
    }
    
    // Explicit constants from androidx.car.app.navigation.model.Maneuver
    private fun getManeuverType(type: String, mod: String?): Int {
        // Safe mapping
        if (type == "turn" && mod == "left") return Maneuver.TYPE_TURN_NORMAL_LEFT
        if (type == "turn" && mod == "right") return Maneuver.TYPE_TURN_NORMAL_RIGHT
        if (type == "fork" && mod == "left") return Maneuver.TYPE_FORK_LEFT
        if (type == "fork" && mod == "right") return Maneuver.TYPE_FORK_RIGHT
        // Fallback for roundabouts or other types
        return Maneuver.TYPE_STRAIGHT
    }

    private fun getManeuverArrow(type: String, modifier: String?): String {
        return when (type) {
            "turn" -> when (modifier) {
                "left" -> "‚Üê"
                "right" -> "‚Üí"
                "slight left" -> "‚Üñ"
                "slight right" -> "‚Üó"
                "sharp left" -> "‚Üô"
                "sharp right" -> "‚Üò"
                else -> "‚Üë"
            }
            "depart" -> "‚Üë"
            "arrive" -> "üèÅ"
            "roundabout", "rotary" -> "‚Ü∫"
            else -> "‚Üë"
        }
    }

    // ==============================================
    // SURFACE CALLBACK for Map Rendering (DUPLICATE REMOVED)
    // ==============================================
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/LaneGuidanceManager.kt`

```kotlin
package com.georacing.georacing.car

import android.util.Log
import org.json.JSONArray
import org.json.JSONObject

/**
 * Gestiona la gu√≠a de carriles bas√°ndose en datos reales de OSRM.
 *
 * OSRM devuelve intersections[].lanes[] en cada step del route response.
 * Cada lane tiene:
 *  - valid: Boolean ‚Üí true si ese carril es v√°lido para la maniobra
 *  - indications: Array<String> ‚Üí "straight", "left", "right", "slight left", etc.
 *
 * Este manager parsea esa informaci√≥n y genera un modelo visual para mostrar
 * en Android Auto y en la pantalla del m√≥vil.
 */
object LaneGuidanceManager {

    private const val TAG = "LaneGuidanceManager"

    /**
     * Representaci√≥n de un carril individual.
     */
    data class Lane(
        val directions: List<LaneDirection>,
        val isRecommended: Boolean // true si este carril es v√°lido para la pr√≥xima maniobra
    )

    /**
     * Direcci√≥n posible de un carril.
     */
    enum class LaneDirection(val symbol: String) {
        STRAIGHT("‚Üë"),
        LEFT("‚Üê"),
        RIGHT("‚Üí"),
        SLIGHT_LEFT("‚Üñ"),
        SLIGHT_RIGHT("‚Üó"),
        SHARP_LEFT("‚¨â"),
        SHARP_RIGHT("‚¨à"),
        UTURN("‚Ü©"),
        MERGE_LEFT("‚áΩ"),
        MERGE_RIGHT("‚áæ"),
        NONE("¬∑");

        companion object {
            fun fromOsrm(indication: String): LaneDirection = when (indication.lowercase()) {
                "straight" -> STRAIGHT
                "left" -> LEFT
                "right" -> RIGHT
                "slight left" -> SLIGHT_LEFT
                "slight right" -> SLIGHT_RIGHT
                "sharp left" -> SHARP_LEFT
                "sharp right" -> SHARP_RIGHT
                "uturn" -> UTURN
                "merge left" -> MERGE_LEFT
                "merge right" -> MERGE_RIGHT
                "none" -> NONE
                else -> STRAIGHT
            }
        }
    }

    /**
     * Resultado de an√°lisis de carriles para un step espec√≠fico.
     */
    data class LaneGuidanceResult(
        val lanes: List<Lane>,
        val totalLanes: Int,
        val recommendedLaneIndices: List<Int>,
        val cueText: String, // "Usa el carril derecho", etc.
        val laneConfig: LaneConfig // Compatibilidad con el enum existente
    )

    /**
     * Parsea los datos de carriles desde la respuesta JSON de OSRM para un step.
     *
     * @param stepJson Un objeto JSON correspondiente a un step de OSRM
     * @return LaneGuidanceResult con la informaci√≥n de carriles, o null si no hay datos
     */
    fun parseLanesFromStep(stepJson: JSONObject): LaneGuidanceResult? {
        try {
            val intersections = stepJson.optJSONArray("intersections") ?: return null
            if (intersections.length() == 0) return null

            // Tomar la primera intersecci√≥n (la m√°s relevante para la maniobra)
            val intersection = intersections.getJSONObject(0)
            val lanesJson = intersection.optJSONArray("lanes") ?: return null
            if (lanesJson.length() == 0) return null

            val lanes = mutableListOf<Lane>()
            val recommendedIndices = mutableListOf<Int>()

            for (i in 0 until lanesJson.length()) {
                val laneJson = lanesJson.getJSONObject(i)
                val valid = laneJson.optBoolean("valid", false)
                val indicationsJson = laneJson.optJSONArray("indications") ?: JSONArray()

                val directions = mutableListOf<LaneDirection>()
                for (j in 0 until indicationsJson.length()) {
                    directions.add(LaneDirection.fromOsrm(indicationsJson.getString(j)))
                }
                if (directions.isEmpty()) directions.add(LaneDirection.STRAIGHT)

                lanes.add(Lane(directions = directions, isRecommended = valid))
                if (valid) recommendedIndices.add(i)
            }

            val totalLanes = lanes.size
            val cueText = generateCueText(lanes, recommendedIndices, totalLanes)
            val laneConfig = inferLaneConfig(recommendedIndices, totalLanes)

            Log.d(TAG, "üìç Lanes: $totalLanes total, recommended=${recommendedIndices}, cue='$cueText'")

            return LaneGuidanceResult(
                lanes = lanes,
                totalLanes = totalLanes,
                recommendedLaneIndices = recommendedIndices,
                cueText = cueText,
                laneConfig = laneConfig
            )
        } catch (e: Exception) {
            Log.w(TAG, "Error parsing lane data", e)
            return null
        }
    }

    /**
     * Genera el texto de gu√≠a de carril en espa√±ol.
     */
    private fun generateCueText(
        lanes: List<Lane>,
        recommendedIndices: List<Int>,
        totalLanes: Int
    ): String {
        if (recommendedIndices.isEmpty() || recommendedIndices.size == totalLanes) {
            return "Cualquier carril"
        }

        // Determinar posici√≥n de los carriles recomendados
        val isLeftMost = recommendedIndices.contains(0)
        val isRightMost = recommendedIndices.contains(totalLanes - 1)
        val count = recommendedIndices.size

        return when {
            count == 1 && isLeftMost -> "Usa el carril izquierdo"
            count == 1 && isRightMost -> "Usa el carril derecho"
            count == 1 -> "Usa el carril ${recommendedIndices[0] + 1} de $totalLanes"
            count == 2 && isRightMost -> "Usa los 2 carriles derechos"
            count == 2 && isLeftMost -> "Usa los 2 carriles izquierdos"
            isRightMost -> "Usa los $count carriles derechos"
            isLeftMost -> "Usa los $count carriles izquierdos"
            else -> "Usa los carriles centrales"
        }
    }

    /**
     * Infiere el LaneConfig legacy para compatibilidad.
     */
    private fun inferLaneConfig(recommendedIndices: List<Int>, totalLanes: Int): LaneConfig {
        if (recommendedIndices.isEmpty() || recommendedIndices.size == totalLanes) {
            return LaneConfig.ANY_LANE
        }
        val isRightMost = recommendedIndices.contains(totalLanes - 1)
        val isLeftMost = recommendedIndices.contains(0)
        val count = recommendedIndices.size

        return when {
            count == 1 && isRightMost -> LaneConfig.RIGHT_LANE
            count == 1 && isLeftMost -> LaneConfig.LEFT_LANE
            isRightMost -> LaneConfig.RIGHT_LANES
            else -> LaneConfig.ANY_LANE
        }
    }

    /**
     * Genera representaci√≥n de texto visual de los carriles.
     * Ejemplo: "[‚Üë] [‚Üë‚úì] [‚Üí‚úì]" donde ‚úì marca los carriles recomendados.
     */
    fun lanesVisualString(result: LaneGuidanceResult): String {
        return result.lanes.joinToString(" ") { lane ->
            val arrows = lane.directions.joinToString("") { it.symbol }
            if (lane.isRecommended) "[$arrows‚úì]" else "[$arrows]"
        }
    }

    /**
     * Parsea todos los steps de una ruta OSRM y devuelve un mapa de gu√≠a de carriles.
     *
     * @param routeJson El JSON completo de la ruta OSRM
     * @return Mapa de √≠ndice de step ‚Üí LaneGuidanceResult
     */
    fun parseAllLanesFromRoute(routeJson: JSONObject): Map<Int, LaneGuidanceResult> {
        val result = mutableMapOf<Int, LaneGuidanceResult>()
        try {
            val routes = routeJson.optJSONArray("routes") ?: return result
            if (routes.length() == 0) return result

            val legs = routes.getJSONObject(0).optJSONArray("legs") ?: return result

            var stepIndex = 0
            for (legIdx in 0 until legs.length()) {
                val steps = legs.getJSONObject(legIdx).optJSONArray("steps") ?: continue
                for (stepIdx in 0 until steps.length()) {
                    val laneResult = parseLanesFromStep(steps.getJSONObject(stepIdx))
                    if (laneResult != null) {
                        result[stepIndex] = laneResult
                    }
                    stepIndex++
                }
            }

            Log.d(TAG, "‚úÖ Parsed lane guidance for ${result.size}/$stepIndex steps")
        } catch (e: Exception) {
            Log.w(TAG, "Error parsing route lanes", e)
        }
        return result
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/MapStyleManager.kt`

```kotlin
package com.georacing.georacing.car

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Canvas
import androidx.core.content.ContextCompat
import com.georacing.georacing.R
import org.maplibre.android.maps.Style
import org.maplibre.android.style.layers.CircleLayer
import org.maplibre.android.style.layers.LineLayer
import org.maplibre.android.style.layers.Property
import org.maplibre.android.style.layers.PropertyFactory
import org.maplibre.android.style.layers.SymbolLayer
import org.maplibre.android.style.sources.GeoJsonSource
import org.maplibre.android.style.expressions.Expression

/**
 * Manages map styles (Day/Night) and ensures custom layers (Route, Car, POIs)
 * are correctly re-applied when styles change.
 */
class MapStyleManager(private val context: Context) {

    // Helper to construct map style JSONs - estilo similar a Google Maps sin POIs comerciales
    private fun buildGoogleMapStyleJson(isDark: Boolean): String {
        // Usamos CARTO Positron/Dark Matter - estilo muy similar a Google Maps pero sin POIs comerciales
        val tileUrl = if (isDark) {
            "https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png"
        } else {
            "https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png"
        }
        
        return """
        {
          "version": 8,
          "sources": {
            "carto-tiles": {
              "type": "raster",
              "tiles": ["$tileUrl"],
              "tileSize": 256,
              "attribution": "¬© CARTO, ¬© OpenStreetMap"
            }
          },
          "layers": [
            {
              "id": "carto-tiles",
              "type": "raster",
              "source": "carto-tiles",
              "minzoom": 0,
              "maxzoom": 20
            }
          ]
        }
        """.trimIndent()
    }

    // Map Styles - estilo Google Maps sin POIs comerciales
    val STYLE_DAY_JSON = buildGoogleMapStyleJson(false) // Positron claro (similar Google Maps)
    val STYLE_NIGHT_JSON = buildGoogleMapStyleJson(true) // Dark Matter oscuro

    // Esri World Imagery (Satellite)
    val STYLE_SATELLITE_JSON = """
    {
      "version": 8,
      "sources": {
        "esri-satellite": {
          "type": "raster",
          "tiles": [
            "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
          ],
          "tileSize": 256,
          "attribution": "¬© Esri, Maxar, Earthstar Geographics, and the GIS User Community"
        }
      },
      "layers": [
        {
          "id": "esri-satellite",
          "type": "raster",
          "source": "esri-satellite",
          "minzoom": 0,
          "maxzoom": 20
        }
      ]
    }
    """.trimIndent()
    
    // Properties to access styles
    val STYLE_DAY = ""   // Placeholder for logic usage (External references should use JSON)
    val STYLE_NIGHT = "" // Placeholder

    // Source & Layer IDs
    companion object {
        const val SOURCE_ROUTE = "route-source"
        const val LAYER_ROUTE = "route-layer"
        const val SOURCE_CAR = "car-source"
        const val LAYER_CAR = "car-layer"
        const val SOURCE_POIS = "poi-source"
        const val LAYER_POIS = "poi-layer"
        
        const val IMAGE_CAR = "img-car-f1"
        const val IMAGE_PARKING = "img-parking"
        const val IMAGE_GATE = "img-gate"
        
        // Hazard Icons for Waze-style
        const val IMAGE_HAZARD_POLICE = "img-hazard-police"
        const val IMAGE_HAZARD_CONSTRUCTION = "img-hazard-construction"
        const val IMAGE_HAZARD_TRAFFIC = "img-hazard-traffic"
        const val IMAGE_RACER = "img-racer"
        
        // Hazard Source/Layer
        const val SOURCE_HAZARDS = "hazards-source"
        const val LAYER_HAZARDS = "hazards-layer"
        const val SOURCE_RACERS = "racers-source"
        const val LAYER_RACERS = "racers-layer"
    }
    
    // =============================================
    // WAZE CARTOON STYLE (Purple Roads, Wide Lines)
    // =============================================
    fun buildWazeStyleJson(): String {
        // Custom cartoon style with saturated colors
        return """
        {
          "version": 8,
          "name": "GeoRacing Waze Style",
          "sources": {
            "carto-tiles": {
              "type": "raster",
              "tiles": ["https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png"],
              "tileSize": 256,
              "attribution": "¬© CARTO, ¬© OpenStreetMap"
            }
          },
          "layers": [
            {
              "id": "background",
              "type": "background",
              "paint": {
                "background-color": "#F0F4F8"
              }
            },
            {
              "id": "carto-tiles",
              "type": "raster",
              "source": "carto-tiles",
              "minzoom": 0,
              "maxzoom": 20,
              "paint": {
                "raster-saturation": 0.3,
                "raster-brightness-max": 1.0
              }
            }
          ]
        }
        """.trimIndent()
    }
    
    /**
     * Applies Waze-style cartoon layers with purple routes
     */
    fun applyWazeLayers(style: Style) {
        addImages(style)
        addHazardImages(style)

        // Route Line (Purple/Magenta - Waze style, WIDER)
        if (style.getSource(SOURCE_ROUTE) == null) {
            style.addSource(GeoJsonSource(SOURCE_ROUTE))
        }
        if (style.getLayer(LAYER_ROUTE) == null) {
            val routeLayer = LineLayer(LAYER_ROUTE, SOURCE_ROUTE).withProperties(
                PropertyFactory.lineColor("#C07AF0"), // Purple/Magenta
                PropertyFactory.lineWidth(12f), // MUCH WIDER for car legibility
                PropertyFactory.lineCap(Property.LINE_CAP_ROUND),
                PropertyFactory.lineJoin(Property.LINE_JOIN_ROUND),
                PropertyFactory.lineOpacity(0.9f)
            )
            style.addLayer(routeLayer)
        }

        // Hazards Layer
        if (style.getSource(SOURCE_HAZARDS) == null) {
            style.addSource(GeoJsonSource(SOURCE_HAZARDS))
        }
        if (style.getLayer(LAYER_HAZARDS) == null) {
            val hazardLayer = SymbolLayer(LAYER_HAZARDS, SOURCE_HAZARDS).withProperties(
                PropertyFactory.iconImage(Expression.get("icon_image")),
                PropertyFactory.iconSize(1.5f), // LARGE for visibility
                PropertyFactory.iconAllowOverlap(true),
                PropertyFactory.textField(Expression.get("label")),
                PropertyFactory.textOffset(arrayOf(0f, 2.0f)),
                PropertyFactory.textSize(16f), // LARGE text
                PropertyFactory.textColor("#FFFFFF"),
                PropertyFactory.textHaloColor("#000000"),
                PropertyFactory.textHaloWidth(2f)
            )
            style.addLayer(hazardLayer)
        }
        
        // Other Racers Layer
        if (style.getSource(SOURCE_RACERS) == null) {
            style.addSource(GeoJsonSource(SOURCE_RACERS))
        }
        if (style.getLayer(LAYER_RACERS) == null) {
            val racerLayer = SymbolLayer(LAYER_RACERS, SOURCE_RACERS).withProperties(
                PropertyFactory.iconImage(IMAGE_RACER),
                PropertyFactory.iconSize(0.8f),
                PropertyFactory.iconAllowOverlap(true),
                PropertyFactory.iconRotate(Expression.get("bearing")),
                PropertyFactory.iconRotationAlignment(Property.ICON_ROTATION_ALIGNMENT_MAP)
            )
            style.addLayer(racerLayer)
        }
        
        // Car Layer (on top)
        if (style.getSource(SOURCE_CAR) == null) {
            style.addSource(GeoJsonSource(SOURCE_CAR))
        }
        if (style.getLayer(LAYER_CAR) == null) {
            val carLayer = SymbolLayer(LAYER_CAR, SOURCE_CAR).withProperties(
                PropertyFactory.iconImage(IMAGE_CAR),
                PropertyFactory.iconSize(0.8f),
                PropertyFactory.iconAllowOverlap(true),
                PropertyFactory.iconIgnorePlacement(true),
                PropertyFactory.iconRotate(Expression.get("bearing")),
                PropertyFactory.iconRotationAlignment(Property.ICON_ROTATION_ALIGNMENT_MAP)
            )
            style.addLayer(carLayer)
        }
    }
    
    private fun addHazardImages(style: Style) {
        fun drawableToBitmap(id: Int): android.graphics.Bitmap {
            val drawable = ContextCompat.getDrawable(context, id)!!
            val bitmap = android.graphics.Bitmap.createBitmap(
                drawable.intrinsicWidth.coerceAtLeast(1),
                drawable.intrinsicHeight.coerceAtLeast(1),
                android.graphics.Bitmap.Config.ARGB_8888
            )
            val canvas = Canvas(bitmap)
            drawable.setBounds(0, 0, canvas.width, canvas.height)
            drawable.draw(canvas)
            return bitmap
        }
        
        try {
            // Reusing F1 car as placeholder for all icons
            style.addImage(IMAGE_HAZARD_POLICE, drawableToBitmap(R.drawable.ic_f1_car_scaled))
            style.addImage(IMAGE_HAZARD_CONSTRUCTION, drawableToBitmap(R.drawable.ic_f1_car_scaled))
            style.addImage(IMAGE_HAZARD_TRAFFIC, drawableToBitmap(R.drawable.ic_f1_car_scaled))
            style.addImage(IMAGE_RACER, drawableToBitmap(R.drawable.ic_f1_car_scaled))
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    /**
     * Applies the standard GeoRacing rendering layers to a loaded Style.
     * Call this inside style loaded callback.
     */
    fun applyLayers(style: Style) {
        // 1. Add Images
        addImages(style)

        // 2. Route Line (Neon Cyan)
        if (style.getSource(SOURCE_ROUTE) == null) {
            style.addSource(GeoJsonSource(SOURCE_ROUTE))
        }
        if (style.getLayer(LAYER_ROUTE) == null) {
            val routeLayer = LineLayer(LAYER_ROUTE, SOURCE_ROUTE).withProperties(
                PropertyFactory.lineColor("#00E5FF"), // Neon Cyan
                PropertyFactory.lineWidth(5f),
                PropertyFactory.lineCap(Property.LINE_CAP_ROUND),
                PropertyFactory.lineJoin(Property.LINE_JOIN_ROUND),
                PropertyFactory.lineOpacity(1.0f)
            )
            style.addLayer(routeLayer)
        }

        // 3. POIs (Parkings & Gates)
        // We assume the source is populated by the screen
        if (style.getSource(SOURCE_POIS) == null) {
            style.addSource(GeoJsonSource(SOURCE_POIS))
        }
        if (style.getLayer(LAYER_POIS) == null) {
            val poiLayer = SymbolLayer(LAYER_POIS, SOURCE_POIS).withProperties(
                PropertyFactory.iconImage(Expression.get("icon_image")), // Data driven property
                PropertyFactory.iconSize(1.0f),
                PropertyFactory.iconAllowOverlap(true),
                PropertyFactory.iconIgnorePlacement(true),
                PropertyFactory.textField(Expression.get("name")),
                PropertyFactory.textOffset(arrayOf(0f, 1.5f)),
                PropertyFactory.textSize(12f),
                PropertyFactory.textColor("#FFFFFF"),
                PropertyFactory.textHaloColor("#000000"),
                PropertyFactory.textHaloWidth(1f)
            )
            style.addLayer(poiLayer)
        }

        // 4. Update Car Layer (The F1 Marker)
        if (style.getSource(SOURCE_CAR) == null) {
            style.addSource(GeoJsonSource(SOURCE_CAR))
        }
        if (style.getLayer(LAYER_CAR) == null) {
            val carLayer = SymbolLayer(LAYER_CAR, SOURCE_CAR).withProperties(
                PropertyFactory.iconImage(IMAGE_CAR), // Or data-driven if using sprites
                PropertyFactory.iconSize(0.6f),       // Adjust scale
                PropertyFactory.iconAllowOverlap(true),
                PropertyFactory.iconIgnorePlacement(true),
                // We use iconRotate to spin the single asset if we don't have 36 sprites
                PropertyFactory.iconRotate(Expression.get("bearing")), 
                PropertyFactory.iconRotationAlignment(Property.ICON_ROTATION_ALIGNMENT_MAP)
            )
            style.addLayer(carLayer)
        }
    }

    private fun addImages(style: Style) {
        // Helper to convert drawable to bitmap
        fun drawableToBitmap(id: Int): Bitmap {
            val drawable = ContextCompat.getDrawable(context, id)!!
            val bitmap = Bitmap.createBitmap(drawable.intrinsicWidth, drawable.intrinsicHeight, Bitmap.Config.ARGB_8888)
            val canvas = Canvas(bitmap)
            drawable.setBounds(0, 0, canvas.width, canvas.height)
            drawable.draw(canvas)
            return bitmap
        }

        // Add assets - Ensure these drawables exist or use placeholders
        // Using built-in or existing resources for safety
        try {
            style.addImage(IMAGE_CAR, drawableToBitmap(R.drawable.ic_f1_car_scaled))
            // TODO: Add real Parking/Gate icons. Using CarCar as placeholder for now if missing.
             style.addImage(IMAGE_PARKING, drawableToBitmap(R.drawable.ic_f1_car_scaled))
             style.addImage(IMAGE_GATE, drawableToBitmap(R.drawable.ic_f1_car_scaled))
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/NavigationHUD.kt`

```kotlin
package com.georacing.georacing.car

import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.Rect
import android.graphics.RectF
import android.graphics.Typeface

/**
 * HUD (Heads-Up Display) para mostrar informaci√≥n de navegaci√≥n en el mapa.
 * 
 * Muestra:
 * - Velocidad actual y l√≠mite de velocidad
 * - Pr√≥xima instrucci√≥n con distancia
 * - Tiempo estimado de llegada
 * 
 * Se dibuja como un overlay en la esquina superior del mapa.
 */
class NavigationHUD {
    
    private val paint = Paint().apply {
        isAntiAlias = true
        textAlign = Paint.Align.LEFT
    }
    
    private val backgroundPaint = Paint().apply {
        color = Color.parseColor("#DD000000") // Negro semi-transparente
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    private val accentPaint = Paint().apply {
        color = Color.parseColor("#4285F4") // Azul Google
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    private val warningPaint = Paint().apply {
        color = Color.parseColor("#EA4335") // Rojo Google
        style = Paint.Style.FILL
        isAntiAlias = true
    }
    
    /**
     * Dibuja el HUD en un bitmap que luego se puede superponer en el mapa.
     * 
     * @param width Ancho del canvas
     * @param height Alto del canvas
     * @param currentSpeedKmh Velocidad actual en km/h
     * @param speedLimitKmh L√≠mite de velocidad (null si no disponible)
     * @param nextInstruction Pr√≥xima instrucci√≥n de navegaci√≥n
     * @param distanceToManeuver Distancia a la pr√≥xima maniobra en metros
     * @param etaMinutes ETA en minutos
     * @return Bitmap con el HUD dibujado
     */
    fun createHUDBitmap(
        width: Int,
        height: Int,
        currentSpeedKmh: Int,
        speedLimitKmh: Int?,
        nextInstruction: String,
        distanceToManeuver: Double,
        etaMinutes: Int,
        arrowSymbol: String = "‚Üë" // Default straight
    ): Bitmap {
        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(bitmap)
        
        // Ajustar dimensiones para HUD m√°s compacto
        val padding = 8f
        val hudWidth = width.toFloat() - (padding * 2)
        val hudHeight = height.toFloat() - (padding * 2)
        
        // Posici√≥n: esquina superior izquierda
        val left = padding
        val top = padding
        val right = left + hudWidth
        val bottom = top + hudHeight
        
        // Fondo redondeado m√°s compacto
        val rect = RectF(left, top, right, bottom)
        canvas.drawRoundRect(rect, 12f, 12f, backgroundPaint)
        
        // L√≠nea superior azul (acento) m√°s delgada
        val accentRect = RectF(left, top, right, top + 4f)
        canvas.drawRoundRect(accentRect, 12f, 12f, accentPaint)
        
        var yPos = top + 24f
        
        // 1. VELOC√çMETRO (m√°s compacto)
        drawSpeedometer(canvas, left + 12f, yPos, currentSpeedKmh, speedLimitKmh)
        
        yPos += 50f
        
        // 2. PR√ìXIMA INSTRUCCI√ìN (compacta)
        drawNextInstruction(canvas, left + 12f, yPos, nextInstruction, distanceToManeuver, arrowSymbol)
        
        yPos += 35f
        
        // 3. ETA (compacta)
        drawETA(canvas, left + 20f, yPos, etaMinutes)
        
        return bitmap
    }
    
    private fun drawSpeedometer(
        canvas: Canvas,
        x: Float,
        y: Float,
        currentSpeed: Int,
        speedLimit: Int?
    ) {
        // Velocidad actual (m√°s peque√±a para HUD compacto)
        paint.apply {
            color = if (speedLimit != null && currentSpeed > speedLimit) {
                Color.parseColor("#EA4335") // Rojo si excede
            } else {
                Color.WHITE
            }
            textSize = 36f  // Reducido de 48f
            typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)
        }
        canvas.drawText("$currentSpeed", x, y, paint)
        
        // "km/h" peque√±o
        paint.apply {
            color = Color.parseColor("#9AA0A6")
            textSize = 14f  // Reducido de 18f
            typeface = Typeface.DEFAULT
        }
        val speedWidth = paint.measureText("$currentSpeed")
        canvas.drawText("km/h", x + speedWidth + 6f, y, paint)
        
        // L√≠mite de velocidad (c√≠rculo rojo m√°s peque√±o)
        if (speedLimit != null) {
            val limitX = x + 140f  // M√°s cerca
            val limitY = y - 20f   // M√°s cerca
            
            // C√≠rculo rojo exterior m√°s peque√±o
            paint.apply {
                color = Color.parseColor("#EA4335")
                style = Paint.Style.STROKE
                strokeWidth = 4f  // M√°s delgado
            }
            canvas.drawCircle(limitX, limitY, 22f, paint)  // M√°s peque√±o
            
            // Fondo blanco interior
            paint.apply {
                color = Color.WHITE
                style = Paint.Style.FILL
            }
            canvas.drawCircle(limitX, limitY, 18f, paint)
            
            // N√∫mero del l√≠mite
            paint.apply {
                color = Color.BLACK
                textSize = 16f  // Reducido de 20f
                typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)
                textAlign = Paint.Align.CENTER
            }
            canvas.drawText("$speedLimit", limitX, limitY + 8f, paint)
            
            // Resetear alineaci√≥n
            paint.textAlign = Paint.Align.LEFT
        }
    }
    
    private fun drawNextInstruction(
        canvas: Canvas,
        x: Float,
        y: Float,
        instruction: String,
        distance: Double,
        arrowSymbol: String
    ) {
        // Icono de flecha m√°s peque√±o
        paint.apply {
            color = Color.parseColor("#4285F4")
            textSize = 18f  // Reducido de 24f
            typeface = Typeface.DEFAULT_BOLD
        }
        canvas.drawText(arrowSymbol, x, y, paint)
        
        // Distancia m√°s compacta
        paint.apply {
            color = Color.WHITE
            textSize = 16f  // Reducido de 20f
            typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)
        }
        val distText = formatDistance(distance)
        canvas.drawText(distText, x + 28f, y, paint)
        
        // Instrucci√≥n m√°s corta para espacio reducido
        paint.apply {
            color = Color.parseColor("#E8EAED")
            textSize = 13f  // Reducido de 16f
            typeface = Typeface.DEFAULT
        }
        val truncatedInstruction = if (instruction.length > 25) {  // M√°s corto
            instruction.substring(0, 22) + "..."
        } else {
            instruction
        }
        canvas.drawText(truncatedInstruction, x + 28f, y + 18f, paint)  // Menos espacio
    }
    
    private fun drawETA(canvas: Canvas, x: Float, y: Float, etaMinutes: Int) {
        paint.apply {
            color = Color.parseColor("#34A853") // Verde Google
            textSize = 13f  // Reducido de 16f
            typeface = Typeface.DEFAULT
        }
        canvas.drawText("‚è±", x, y, paint)
        
        paint.apply {
            color = Color.parseColor("#E8EAED")
            textSize = 16f
        }
        val etaText = if (etaMinutes < 60) {
            "$etaMinutes min"
        } else {
            val hours = etaMinutes / 60
            val mins = etaMinutes % 60
            "${hours}h ${mins}min"
        }
        canvas.drawText("ETA: $etaText", x + 30f, y, paint)
    }
    
    private fun formatDistance(meters: Double): String {
        return when {
            meters < 100 -> "${meters.toInt()} m"
            meters < 1000 -> "${(meters / 100).toInt() * 100} m"
            else -> String.format("%.1f km", meters / 1000)
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/NavigationSession.kt`

```kotlin
package com.georacing.georacing.car

import android.util.Log
import androidx.car.app.model.CarColor
import androidx.car.app.model.Distance
import androidx.car.app.navigation.model.Maneuver
import androidx.car.app.navigation.model.Step
import com.georacing.georacing.car.config.OsrmConfig
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

/**
 * Navigation Session Manager for Turn-by-Turn instructions.
 * Uses REAL OSRM routing API for dynamic route steps.
 * 
 * Falls back to static steps only if OSRM is unreachable.
 */
object NavigationSession {

    private const val TAG = "NavigationSession"

    // Dynamic steps loaded from OSRM
    private val _routeSteps = MutableStateFlow<List<DemoStep>>(emptyList())
    val routeSteps: StateFlow<List<DemoStep>> = _routeSteps.asStateFlow()

    private var _currentStepIndex = MutableStateFlow(0)
    val currentStepIndex: StateFlow<Int> = _currentStepIndex.asStateFlow()

    private var _distanceToCurrentStep = MutableStateFlow(0.0)
    val distanceToCurrentStep: StateFlow<Double> = _distanceToCurrentStep.asStateFlow()

    private var _trafficDelayMinutes = MutableStateFlow(0)
    val trafficDelayMinutes: StateFlow<Int> = _trafficDelayMinutes.asStateFlow()

    private val scope = CoroutineScope(Dispatchers.IO)

    /**
     * Loads route steps from OSRM for a given origin ‚Üí destination.
     * @param originLat origin latitude
     * @param originLon origin longitude
     * @param destLat destination latitude (default: Circuit entrance Gate 3)
     * @param destLon destination longitude
     */
    fun loadRoute(
        originLat: Double, originLon: Double,
        destLat: Double = 41.5694, destLon: Double = 2.2549
    ) {
        scope.launch {
            try {
                val baseUrl = OsrmConfig.getBaseUrl()
                val retrofit = Retrofit.Builder()
                    .baseUrl(baseUrl)
                    .addConverterFactory(GsonConverterFactory.create())
                    .build()
                val service = retrofit.create(OsrmService::class.java)

                val coordinates = "$originLon,$originLat;$destLon,$destLat"
                val response = service.getRoute(coordinates = coordinates, steps = true)

                if (response.code == "Ok" && response.routes.isNotEmpty()) {
                    val legs = response.routes.first().legs
                    val osrmSteps = legs.flatMap { it.steps }

                    _routeSteps.value = osrmSteps.map { step ->
                        DemoStep(
                            instruction = buildInstruction(step),
                            distanceMeters = step.distance,
                            maneuverType = osrmManeuverToCarManeuver(step.maneuver.type, step.maneuver.modifier),
                            laneGuidance = LaneConfig.ANY_LANE
                        )
                    }

                    _currentStepIndex.value = 0
                    if (_routeSteps.value.isNotEmpty()) {
                        _distanceToCurrentStep.value = _routeSteps.value.first().distanceMeters
                    }
                    Log.i(TAG, "‚úÖ Loaded ${_routeSteps.value.size} OSRM steps")
                } else {
                    Log.w(TAG, "OSRM returned no routes (code=${response.code})")
                }
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå OSRM route failed: ${e.message}")
            }
        }
    }

    /**
     * Gets the current step
     */
    fun getCurrentDemoStep(): DemoStep {
        val steps = _routeSteps.value
        if (steps.isEmpty()) return DemoStep("Sin ruta cargada", 0.0, Maneuver.TYPE_STRAIGHT, LaneConfig.ANY_LANE)
        val index = _currentStepIndex.value.coerceIn(0, steps.lastIndex)
        return steps[index]
    }

    /**
     * Gets all remaining steps from current position
     */
    fun getRemainingSteps(): List<DemoStep> {
        val steps = _routeSteps.value
        if (steps.isEmpty()) return emptyList()
        val index = _currentStepIndex.value.coerceIn(0, steps.lastIndex)
        return steps.subList(index, steps.size)
    }

    /**
     * Advance to next step
     */
    fun advanceToNextStep() {
        val steps = _routeSteps.value
        if (_currentStepIndex.value < steps.lastIndex) {
            _currentStepIndex.value++
            _distanceToCurrentStep.value = steps[_currentStepIndex.value].distanceMeters
        }
    }

    /**
     * Update distance to current step (called from location updates)
     */
    fun updateDistance(meters: Double) {
        _distanceToCurrentStep.value = meters
        if (meters < 30 && _currentStepIndex.value < _routeSteps.value.lastIndex) {
            advanceToNextStep()
        }
    }

    /**
     * Apply traffic delay (from crowd surge simulation)
     */
    fun applyTrafficDelay(minutes: Int) {
        _trafficDelayMinutes.value = minutes
    }

    /**
     * Reset to beginning
     */
    fun reset() {
        _currentStepIndex.value = 0
        if (_routeSteps.value.isNotEmpty()) {
            _distanceToCurrentStep.value = _routeSteps.value[0].distanceMeters
        }
        _trafficDelayMinutes.value = 0
    }

    /**
     * Build Android Auto Step from DemoStep
     */
    fun buildCarStep(demoStep: DemoStep, distance: Double): Step {
        val stepBuilder = Step.Builder(demoStep.instruction)
            .setManeuver(Maneuver.Builder(demoStep.maneuverType).build())
            .setCue(demoStep.laneGuidance.cueText)

        return stepBuilder.build()
    }

    /**
     * Get ETA color based on traffic
     */
    fun getEtaColor(): CarColor {
        return when {
            _trafficDelayMinutes.value >= 15 -> CarColor.RED
            _trafficDelayMinutes.value >= 5 -> CarColor.YELLOW
            else -> CarColor.GREEN
        }
    }

    // ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ

    private fun buildInstruction(step: com.georacing.georacing.car.Step): String {
        val maneuver = step.maneuver
        val roadName = step.name.ifBlank { "la carretera" }
        return when (maneuver.type) {
            "depart" -> "Sal por $roadName"
            "arrive" -> "Has llegado a tu destino"
            "turn" -> "${maneuver.modifier?.replaceFirstChar { it.uppercase() } ?: "Gira"} hacia $roadName"
            "new name" -> "Contin√∫a por $roadName"
            "merge" -> "Incorp√≥rate a $roadName"
            "on ramp" -> "Toma la incorporaci√≥n a $roadName"
            "off ramp" -> "Toma la salida hacia $roadName"
            "fork" -> "Mantente ${maneuver.modifier ?: "recto"} en la bifurcaci√≥n"
            "roundabout" -> "En la rotonda, toma la salida ${maneuver.exit ?: ""}"
            "rotary" -> "En la rotonda, toma la salida ${maneuver.exit ?: ""}"
            else -> "Contin√∫a por $roadName"
        }
    }

    private fun osrmManeuverToCarManeuver(type: String, modifier: String?): Int {
        return when (type) {
            "depart" -> Maneuver.TYPE_DEPART
            "arrive" -> Maneuver.TYPE_DESTINATION
            "turn" -> when (modifier) {
                "left" -> Maneuver.TYPE_TURN_NORMAL_LEFT
                "right" -> Maneuver.TYPE_TURN_NORMAL_RIGHT
                "slight left" -> Maneuver.TYPE_TURN_SLIGHT_LEFT
                "slight right" -> Maneuver.TYPE_TURN_SLIGHT_RIGHT
                "sharp left" -> Maneuver.TYPE_TURN_SHARP_LEFT
                "sharp right" -> Maneuver.TYPE_TURN_SHARP_RIGHT
                "uturn" -> Maneuver.TYPE_U_TURN_LEFT
                else -> Maneuver.TYPE_STRAIGHT
            }
            "merge" -> Maneuver.TYPE_MERGE_SIDE_UNSPECIFIED
            "on ramp" -> Maneuver.TYPE_ON_RAMP_NORMAL_RIGHT
            "off ramp" -> when (modifier) {
                "left" -> Maneuver.TYPE_OFF_RAMP_NORMAL_LEFT
                else -> Maneuver.TYPE_OFF_RAMP_NORMAL_RIGHT
            }
            "fork" -> when (modifier) {
                "left" -> Maneuver.TYPE_FORK_LEFT
                else -> Maneuver.TYPE_FORK_RIGHT
            }
            "roundabout", "rotary" -> Maneuver.TYPE_ROUNDABOUT_ENTER_CW
            else -> Maneuver.TYPE_STRAIGHT
        }
    }
}

/**
 * Route navigation step (shared data model)
 */
data class DemoStep(
    val instruction: String,
    val distanceMeters: Double,
    val maneuverType: Int,
    val laneGuidance: LaneConfig
)

/**
 * Lane configuration presets - cue text only (Lane API removed)
 */
enum class LaneConfig(val cueText: String) {
    ANY_LANE("Cualquier carril"),
    RIGHT_LANE("Usa el carril derecho"),
    RIGHT_LANES("Usa los 2 carriles derechos"),
    LEFT_LANE("Usa el carril izquierdo");
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/OsrmModels.kt`

```kotlin
package com.georacing.georacing.car

import com.google.gson.annotations.SerializedName

// OSRM Models (fallback)
data class OsrmResponse(
    @SerializedName("routes") val routes: List<Route>,
    @SerializedName("code") val code: String
)

data class Route(
    @SerializedName("geometry") val geometry: String,
    @SerializedName("duration") val duration: Double,
    @SerializedName("distance") val distance: Double,
    @SerializedName("legs") val legs: List<Leg>
)

data class Leg(
    @SerializedName("steps") val steps: List<Step>,
    @SerializedName("annotation") val annotation: LegAnnotation? = null
)

/**
 * Anotaciones por segmento de la ruta OSRM.
 * Se obtienen con ?annotations=speed,maxspeed,duration,distance
 */
data class LegAnnotation(
    @SerializedName("speed") val speed: List<Double>? = null,           // m/s por segmento
    @SerializedName("duration") val duration: List<Double>? = null,     // segundos por segmento
    @SerializedName("distance") val distance: List<Double>? = null,     // metros por segmento
    @SerializedName("maxspeed") val maxspeed: List<MaxSpeedEntry>? = null // l√≠mite de velocidad OSM
)

data class MaxSpeedEntry(
    @SerializedName("speed") val speed: Int? = null,        // km/h (null si desconocido)
    @SerializedName("unit") val unit: String? = null,       // "km/h" o "mph"
    @SerializedName("unknown") val unknown: Boolean? = null, // true si no hay dato OSM
    @SerializedName("none") val none: Boolean? = null       // true si no hay l√≠mite
)

data class Step(
    @SerializedName("geometry") val geometry: String, // Step segment geometry
    @SerializedName("maneuver") val maneuver: Maneuver,
    @SerializedName("name") val name: String,
    @SerializedName("distance") val distance: Double,
    @SerializedName("duration") val duration: Double
)

data class Maneuver(
    @SerializedName("type") val type: String, // e.g., "turn", "new name", "depart", "arrive", "roundabout"
    @SerializedName("modifier") val modifier: String?, // e.g., "left", "right", "slight right"
    @SerializedName("location") val location: List<Double>, // [lon, lat]
    @SerializedName("exit") val exit: Int? = null // FASE 2.2: N√∫mero de salida en rotondas (1, 2, 3...)
)

// GraphHopper Models (con tr√°fico)
data class GraphHopperResponse(
    @SerializedName("paths") val paths: List<GraphHopperPath>
)

data class GraphHopperPath(
    @SerializedName("distance") val distance: Double,
    @SerializedName("time") val time: Long, // en milisegundos
    @SerializedName("points") val points: GraphHopperGeometry,
    @SerializedName("instructions") val instructions: List<GraphHopperInstruction>
)

data class GraphHopperGeometry(
    @SerializedName("coordinates") val coordinates: List<List<Double>> // [[lon, lat], ...]
)

data class GraphHopperInstruction(
    @SerializedName("text") val text: String,
    @SerializedName("distance") val distance: Double,
    @SerializedName("time") val time: Long,
    @SerializedName("sign") val sign: Int, // c√≥digo de maniobra
    @SerializedName("street_name") val streetName: String?
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/OsrmService.kt`

```kotlin
package com.georacing.georacing.car

import retrofit2.http.GET
import retrofit2.http.Path
import retrofit2.http.Query

interface OsrmService {
    @GET("route/v1/driving/{coordinates}")
    suspend fun getRoute(
        @Path(value = "coordinates", encoded = true) coordinates: String,
        @Query("overview") overview: String = "full",
        @Query("geometries") geometries: String = "polyline",
        @Query("steps") steps: Boolean = true,
        @Query("annotations") annotations: String? = null  // "speed,maxspeed,duration,distance"
    ): OsrmResponse
}

interface GraphHopperService {
    @GET("route")
    suspend fun getRoute(
        @Query("point") points: List<String>, // ["lat,lon", "lat,lon"]
        @Query("vehicle") vehicle: String = "car",
        @Query("locale") locale: String = "es",
        @Query("instructions") instructions: Boolean = true,
        @Query("calc_points") calcPoints: Boolean = true,
        @Query("points_encoded") pointsEncoded: Boolean = false,
        @Query("ch.disable") chDisable: Boolean = true, // Permite usar tr√°fico
        @Query("key") apiKey: String = "e6d666e9-6e53-4c8c-9794-d15f649004c1"
    ): GraphHopperResponse
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/ParkingProximityDetector.kt`

```kotlin
package com.georacing.georacing.car

import android.location.Location
import com.georacing.georacing.data.parking.ParkingLocation
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.sqrt

/**
 * Tier 1: Parking Proximity Detector
 * 
 * Detecta cuando el usuario est√° cerca de su parking asignado y determina
 * la puerta de acceso m√°s cercana bas√°ndose en el bearing.
 */
object ParkingProximityDetector {
    
    private const val PROXIMITY_THRESHOLD_METERS = 200.0
    
    data class ParkingCluster(
        val name: String,              // "PARKING C"
        val accessGate: String,        // "ACCESO 2"
        val gateImageRes: Int,         // R.drawable.parking_c_gate2 (placeholder)
        val distance: Double
    )
    
    /**
     * Detecta si el usuario est√° cerca del parking asignado.
     * Retorna ParkingCluster si est√° dentro del threshold, null si no.
     */
    fun detectNearbyParking(
        currentLocation: Location,
        assignedParking: ParkingLocation?
    ): ParkingCluster? {
        if (assignedParking == null) return null
        
        val distance = calculateDistance(
            currentLocation.latitude,
            currentLocation.longitude,
            assignedParking.latitude,
            assignedParking.longitude
        )
        
        if (distance > PROXIMITY_THRESHOLD_METERS) return null
        
        // Determinar puerta m√°s cercana basada en bearing
        val bearing = currentLocation.bearing
        val accessGate = determineAccessGate(bearing)
        
        return ParkingCluster(
            name = "Tu Coche",
            accessGate = accessGate.name,
            gateImageRes = accessGate.imageRes,
            distance = distance
        )
    }
    
    /**
     * Determina la puerta de acceso m√°s cercana bas√°ndose en el bearing.
     */
    private fun determineAccessGate(bearing: Float): AccessGate {
        // L√≥gica simple basada en bearing (0-360 grados)
        // Norte = 0¬∞, Este = 90¬∞, Sur = 180¬∞, Oeste = 270¬∞
        return when {
            bearing < 45 || bearing >= 315 -> AccessGate("ACCESO NORTE", android.R.drawable.ic_menu_directions)
            bearing < 135 -> AccessGate("ACCESO ESTE", android.R.drawable.ic_menu_directions)
            bearing < 225 -> AccessGate("ACCESO SUR", android.R.drawable.ic_menu_directions)
            else -> AccessGate("ACCESO OESTE", android.R.drawable.ic_menu_directions)
        }
    }
    
    /**
     * Calcula la distancia entre dos puntos GPS usando f√≥rmula Haversine.
     */
    private fun calculateDistance(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
        val earthRadius = 6371000.0 // metros
        val dLat = Math.toRadians(lat2 - lat1)
        val dLon = Math.toRadians(lon2 - lon1)
        
        val a = sin(dLat / 2) * sin(dLat / 2) +
                cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *
                sin(dLon / 2) * sin(dLon / 2)
        
        val c = 2 * atan2(sqrt(a), sqrt(1 - a))
        return earthRadius * c
    }
    
    private data class AccessGate(val name: String, val imageRes: Int)
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/PoiListScreen.kt`

```kotlin
package com.georacing.georacing.car

import android.content.Intent
import android.net.Uri
import android.util.Log
import androidx.car.app.CarContext
import androidx.car.app.Screen
import androidx.car.app.model.Action
import androidx.car.app.model.CarLocation
import androidx.car.app.model.CarText
import androidx.car.app.model.ItemList
import androidx.car.app.model.Metadata
import androidx.car.app.model.Place
import androidx.car.app.model.PlaceListMapTemplate
import androidx.car.app.model.Row
import androidx.car.app.model.Template
import androidx.car.app.CarToast

class PoiListScreen(
    carContext: CarContext
) : Screen(carContext) {

    override fun onGetTemplate(): Template {
        val pois = PoiRepository.getAllPois()

        val itemListBuilder = ItemList.Builder()

        pois.forEachIndexed { index, poi ->
            val place = Place.Builder(
                CarLocation.create(poi.latitude, poi.longitude)
            )
                .build()

            val metadata = Metadata.Builder()
                .setPlace(place)
                .build()

            val subtitle = "${poi.type.name.lowercase().replaceFirstChar { it.uppercase() }} ¬∑ ${poi.description}"

            val row = Row.Builder()
                .setTitle(poi.name)
                .addText(CarText.create(subtitle))
                .setMetadata(metadata)
                // Lo marcamos como navegable para que no exija DistanceSpan
                .setBrowsable(true)
                .setOnClickListener {
                    startNavigationToPoi(poi)
                }
                .build()

            itemListBuilder.addItem(row)
        }

        return PlaceListMapTemplate.Builder()
            .setTitle("GeoRacing ¬∑ Circuit de Barcelona‚ÄìCatalunya")
            .setHeaderAction(Action.APP_ICON)
            .setItemList(itemListBuilder.build())
            .build()
    }

    private fun startNavigationToPoi(poi: PoiModel) {
        val uriString = "geo:${poi.latitude},${poi.longitude}?q=${Uri.encode(poi.name)}"
        val navIntent = Intent(
            CarContext.ACTION_NAVIGATE,
            Uri.parse(uriString)
        )

        try {
            carContext.startCarApp(navIntent)
        } catch (e: Exception) {
            Log.e("GeoRacingCar", "Error starting navigation", e)
            CarToast.makeText(
                carContext,
                "No se ha podido iniciar la navegaci√≥n",
                CarToast.LENGTH_SHORT
            ).show()
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/PoiRepository.kt`

```kotlin
package com.georacing.georacing.car

/**
 * Data model for a Point of Interest (POI) in the circuit.
 */
data class PoiModel(
    val id: String,
    val name: String,
    val description: String,
    val type: PoiType,
    val latitude: Double,
    val longitude: Double
)

/**
 * Types of POIs available.
 */
enum class PoiType {
    PARKING,
    GATE,
    FANZONE,
    SERVICE,
    MEDICAL,
    OTHER
}

/**
 * Repository providing access to real GPS POI data for Circuit de Barcelona-Catalunya.
 * 
 * Coordenadas verificadas por GIS Developer - 2026-01-29
 */
object PoiRepository {

    private val allPois = listOf(
        // =====================================================================
        // ACCESOS / PUERTAS (Gates) - Real GPS Coordinates
        // =====================================================================
        PoiModel(
            id = "gate_1",
            name = "Puerta 1",
            description = "Acceso Este - Pelouse/Tribuna G",
            type = PoiType.GATE,
            latitude = 41.5652,
            longitude = 2.2660
        ),
        PoiModel(
            id = "gate_2",
            name = "Puerta 2",
            description = "Acceso Sur - Tribuna H/Escuela",
            type = PoiType.GATE,
            latitude = 41.5628,
            longitude = 2.2635
        ),
        PoiModel(
            id = "gate_3",
            name = "Puerta 3",
            description = "Acceso Oeste - Entrada Principal",
            type = PoiType.GATE,
            latitude = 41.5694,
            longitude = 2.2549
        ),
        PoiModel(
            id = "gate_4",
            name = "Puerta 4",
            description = "Acceso Noroeste - Tribunas J/K",
            type = PoiType.GATE,
            latitude = 41.5735,
            longitude = 2.2562
        ),
        PoiModel(
            id = "gate_5",
            name = "Puerta 5",
            description = "Acceso Norte - Tribuna Principal Norte",
            type = PoiType.GATE,
            latitude = 41.5752,
            longitude = 2.2588
        ),
        PoiModel(
            id = "gate_6",
            name = "Puerta 6",
            description = "Acceso Norte - Tribuna A/F",
            type = PoiType.GATE,
            latitude = 41.5768,
            longitude = 2.2615
        ),
        PoiModel(
            id = "gate_7",
            name = "Puerta 7",
            description = "Acceso Nordeste - Zona Estadio/Tribuna L",
            type = PoiType.GATE,
            latitude = 41.5742,
            longitude = 2.2675
        ),

        // =====================================================================
        // PARKINGS P√öBLICOS - Real GPS Coordinates
        // =====================================================================
        PoiModel(
            id = "parking_a",
            name = "Parking A",
            description = "Norte - Para Gates 5, 6, 7",
            type = PoiType.PARKING,
            latitude = 41.5775,
            longitude = 2.2610
        ),
        PoiModel(
            id = "parking_b",
            name = "Parking B",
            description = "Oeste - Cerca de Puerta 4",
            type = PoiType.PARKING,
            latitude = 41.5745,
            longitude = 2.2555
        ),
        PoiModel(
            id = "parking_c",
            name = "Parking C",
            description = "Principal - Cerca de Puerta 3",
            type = PoiType.PARKING,
            latitude = 41.5685,
            longitude = 2.2530
        ),
        PoiModel(
            id = "parking_d",
            name = "Parking D",
            description = "Sur - Cerca de Puerta 1/2",
            type = PoiType.PARKING,
            latitude = 41.5610,
            longitude = 2.2640
        ),

        // =====================================================================
        // PUNTOS DE INTER√âS CR√çTICOS - Real GPS Coordinates
        // =====================================================================
        PoiModel(
            id = "paddock_entrance",
            name = "Acceso Paddock",
            description = "Entrada exclusiva acreditados/VIP",
            type = PoiType.GATE,
            latitude = 41.5682,
            longitude = 2.2571
        ),
        PoiModel(
            id = "medical_center",
            name = "Centro M√©dico",
            description = "Hospital del Circuito",
            type = PoiType.MEDICAL,
            latitude = 41.5675,
            longitude = 2.2565
        ),
        PoiModel(
            id = "helipad",
            name = "Helipuerto",
            description = "Evacuaci√≥n a√©rea de emergencia",
            type = PoiType.SERVICE,
            latitude = 41.5660,
            longitude = 2.2580
        )
    )

    fun getAllPois(): List<PoiModel> = allPois

    fun getById(id: String): PoiModel? {
        return allPois.find { it.id == id }
    }

    fun getByType(type: PoiType): List<PoiModel> {
        return allPois.filter { it.type == type }
    }
    
    fun getGates(): List<PoiModel> = getByType(PoiType.GATE)
    
    fun getParkings(): List<PoiModel> = getByType(PoiType.PARKING)
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/RaceStatusScreen.kt`

```kotlin
package com.georacing.georacing.car

import androidx.car.app.CarContext
import androidx.car.app.Screen
import androidx.car.app.model.Action
import androidx.car.app.model.CarColor
import androidx.car.app.model.CarIcon
import androidx.car.app.model.GridItem
import androidx.car.app.model.GridTemplate
import androidx.car.app.model.ItemList
import androidx.car.app.model.Template
import androidx.core.graphics.drawable.IconCompat
import com.georacing.georacing.R
import com.georacing.georacing.debug.ScenarioSimulator
import com.georacing.georacing.domain.model.CircuitMode

/**
 * Race Status Screen - GridTemplate showing track status info.
 * Accessible via status button in navigation ActionStrip.
 */
class RaceStatusScreen(
    carContext: CarContext,
    private val circuitMode: CircuitMode = CircuitMode.GREEN_FLAG,
    private val assignedParking: String = "C"
) : Screen(carContext) {

    override fun onGetTemplate(): Template {
        val gridItemBuilder = ItemList.Builder()
        
        // 1. Track Status (Green/Red/Yellow)
        gridItemBuilder.addItem(
            GridItem.Builder()
                .setTitle(getTrackStatusTitle())
                .setText(getTrackStatusDescription())
                .setImage(
                    CarIcon.Builder(
                        IconCompat.createWithResource(carContext, getTrackStatusIcon())
                    ).setTint(getTrackStatusColor()).build()
                )
                .setOnClickListener { /* Show details */ }
                .build()
        )
        
        // 2. Track Temperature
        val temperature = ScenarioSimulator.crowdIntensity.value * 30 + 25 // 25-55¬∞C simulated
        gridItemBuilder.addItem(
            GridItem.Builder()
                .setTitle("${temperature.toInt()}¬∞C")
                .setText("Temp. Pista")
                .setImage(
                    CarIcon.Builder(
                        IconCompat.createWithResource(carContext, R.mipmap.ic_launcher_round)
                    ).build()
                )
                .build()
        )
        
        // 3. Assigned Parking
        gridItemBuilder.addItem(
            GridItem.Builder()
                .setTitle("Parking $assignedParking")
                .setText("Tu ubicaci√≥n asignada")
                .setImage(
                    CarIcon.Builder(
                        IconCompat.createWithResource(carContext, R.mipmap.ic_launcher_round)
                    ).setTint(CarColor.BLUE).build()
                )
                .setOnClickListener {
                    // Could navigate to parking
                }
                .build()
        )
        
        // 4. Active Hazards
        val hazardCount = ScenarioSimulator.activeHazards.value.size
        gridItemBuilder.addItem(
            GridItem.Builder()
                .setTitle(if (hazardCount > 0) "$hazardCount Alertas" else "Sin Alertas")
                .setText("Peligros en ruta")
                .setImage(
                    CarIcon.Builder(
                        IconCompat.createWithResource(carContext, R.mipmap.ic_launcher_round)
                    ).setTint(if (hazardCount > 0) CarColor.RED else CarColor.GREEN).build()
                )
                .build()
        )
        
        return GridTemplate.Builder()
            .setTitle("üèÅ Estado del Circuito")
            .setHeaderAction(Action.BACK)
            .setSingleList(gridItemBuilder.build())
            .build()
    }
    
    private fun getTrackStatusTitle(): String {
        return when (circuitMode) {
            CircuitMode.GREEN_FLAG, CircuitMode.NORMAL -> "üü¢ VERDE"
            CircuitMode.YELLOW_FLAG -> "üü° AMARILLA"
            CircuitMode.SAFETY_CAR -> "üöó SAFETY CAR"
            CircuitMode.VSC -> "üö¶ VSC"
            CircuitMode.RED_FLAG -> "üî¥ BANDERA ROJA"
            CircuitMode.EVACUATION -> "üÜò EVACUACI√ìN"
            CircuitMode.UNKNOWN -> "‚ö™ DESCONOCIDO"
        }
    }
    
    private fun getTrackStatusDescription(): String {
        return when (circuitMode) {
            CircuitMode.GREEN_FLAG, CircuitMode.NORMAL -> "Pista abierta"
            CircuitMode.YELLOW_FLAG -> "Precauci√≥n"
            CircuitMode.SAFETY_CAR -> "Detr√°s del SC"
            CircuitMode.VSC -> "Velocidad reducida"
            CircuitMode.RED_FLAG -> "Carrera detenida"
            CircuitMode.EVACUATION -> "¬°Salga ahora!"
            CircuitMode.UNKNOWN -> "Sin datos"
        }
    }
    
    private fun getTrackStatusColor(): CarColor {
        return when (circuitMode) {
            CircuitMode.GREEN_FLAG, CircuitMode.NORMAL -> CarColor.GREEN
            CircuitMode.YELLOW_FLAG, CircuitMode.SAFETY_CAR, CircuitMode.VSC -> CarColor.YELLOW
            CircuitMode.RED_FLAG, CircuitMode.EVACUATION -> CarColor.RED
            else -> CarColor.DEFAULT
        }
    }
    
    private fun getTrackStatusIcon(): Int {
        // Use launcher icon as placeholder - would use custom flag icons
        return R.mipmap.ic_launcher_round
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/RoutePlanner.kt`

```kotlin
package com.georacing.georacing.car

import android.location.Location
import android.util.Log
import androidx.car.app.navigation.model.Maneuver
import com.georacing.georacing.car.config.OsrmConfig
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import kotlin.math.max
import kotlin.math.roundToLong

data class RouteStep(
    val instruction: String,
    val road: String,
    val maneuverType: Int,
    val distanceMeters: Double,
    val target: Location,
    val estimatedTimeSeconds: Long
)

data class SimulatedRoute(
    val destination: DestinationModel,
    val startLocation: Location,
    val steps: List<RouteStep>,
    val totalDistanceMeters: Double,
    val totalTimeSeconds: Long
)

/**
 * Route planner using REAL OSRM routing API.
 * Falls back to straight-line estimation if OSRM is unreachable.
 */
class RoutePlanner {

    companion object {
        private const val TAG = "RoutePlanner"
    }

    /**
     * Plans a route using OSRM from the user's current location to the destination.
     * If OSRM is unavailable, creates a single direct step with estimated distance/time.
     */
    suspend fun planRoute(destination: DestinationModel, startLat: Double? = null, startLon: Double? = null): SimulatedRoute {
        val originLat = startLat ?: 41.5489 // Default: near Montmel√≥ station
        val originLon = startLon ?: 2.2538
        val start = locationOf(originLat, originLon)
        val destLocation = locationOf(destination.latitude, destination.longitude)

        return try {
            planRouteOsrm(destination, start, destLocation)
        } catch (e: Exception) {
            Log.w(TAG, "OSRM no disponible, usando ruta directa: ${e.message}")
            planRouteDirect(destination, start, destLocation)
        }
    }

    /**
     * Non-suspend version for Android Auto compatibility
     */
    fun planRoute(destination: DestinationModel): SimulatedRoute {
        val start = locationOf(41.5489, 2.2538)
        val destLocation = locationOf(destination.latitude, destination.longitude)
        return planRouteDirect(destination, start, destLocation)
    }

    private suspend fun planRouteOsrm(
        destination: DestinationModel,
        start: Location,
        destLocation: Location
    ): SimulatedRoute {
        val baseUrl = OsrmConfig.getBaseUrl()
        val retrofit = Retrofit.Builder()
            .baseUrl(baseUrl)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        val service = retrofit.create(OsrmService::class.java)

        val coordinates = "${start.longitude},${start.latitude};${destLocation.longitude},${destLocation.latitude}"
        val response = service.getRoute(coordinates = coordinates, steps = true)

        if (response.code != "Ok" || response.routes.isEmpty()) {
            throw Exception("OSRM returned code=${response.code}")
        }

        val route = response.routes.first()
        val osrmSteps = route.legs.flatMap { it.steps }

        val steps = osrmSteps.map { step ->
            val maneuverLocation = locationOf(
                step.maneuver.location[1], // lat
                step.maneuver.location[0]  // lon
            )
            RouteStep(
                instruction = buildInstruction(step),
                road = step.name.ifBlank { "la carretera" },
                maneuverType = osrmToCarManeuver(step.maneuver.type, step.maneuver.modifier),
                distanceMeters = step.distance,
                target = maneuverLocation,
                estimatedTimeSeconds = step.duration.toLong()
            )
        }

        Log.i(TAG, "‚úÖ OSRM route: ${steps.size} steps, ${route.distance.toInt()}m, ${route.duration.toInt()}s")

        return SimulatedRoute(
            destination = destination,
            startLocation = start,
            steps = steps,
            totalDistanceMeters = route.distance,
            totalTimeSeconds = max(route.duration.toLong(), 180L)
        )
    }

    private fun planRouteDirect(
        destination: DestinationModel,
        start: Location,
        destLocation: Location
    ): SimulatedRoute {
        val distance = distanceBetween(start, destLocation)
        val timeSeconds = max(45L, (distance / 13.8).roundToLong()) // ~50 km/h

        val steps = listOf(
            RouteStep(
                instruction = "Dir√≠gete hacia ${destination.name}",
                road = "Ruta directa",
                maneuverType = Maneuver.TYPE_DEPART,
                distanceMeters = distance,
                target = destLocation,
                estimatedTimeSeconds = timeSeconds
            )
        )

        return SimulatedRoute(
            destination = destination,
            startLocation = start,
            steps = steps,
            totalDistanceMeters = distance,
            totalTimeSeconds = max(timeSeconds, 180L)
        )
    }

    private fun buildInstruction(step: com.georacing.georacing.car.Step): String {
        val maneuver = step.maneuver
        val road = step.name.ifBlank { "la carretera" }
        return when (maneuver.type) {
            "depart" -> "Sal por $road"
            "arrive" -> "Has llegado a ${road.ifBlank { "tu destino" }}"
            "turn" -> "${maneuver.modifier?.replaceFirstChar { it.uppercase() } ?: "Gira"} hacia $road"
            "new name" -> "Contin√∫a por $road"
            "merge" -> "Incorp√≥rate a $road"
            "on ramp" -> "Toma la incorporaci√≥n a $road"
            "off ramp" -> "Toma la salida hacia $road"
            "fork" -> "Mantente ${maneuver.modifier ?: "recto"} en la bifurcaci√≥n"
            "roundabout", "rotary" -> "En la rotonda, toma la salida ${maneuver.exit ?: ""}"
            else -> "Contin√∫a por $road"
        }
    }

    private fun osrmToCarManeuver(type: String, modifier: String?): Int = when (type) {
        "depart" -> Maneuver.TYPE_DEPART
        "arrive" -> Maneuver.TYPE_DESTINATION
        "turn" -> when (modifier) {
            "left" -> Maneuver.TYPE_TURN_NORMAL_LEFT
            "right" -> Maneuver.TYPE_TURN_NORMAL_RIGHT
            "slight left" -> Maneuver.TYPE_TURN_SLIGHT_LEFT
            "slight right" -> Maneuver.TYPE_TURN_SLIGHT_RIGHT
            "sharp left" -> Maneuver.TYPE_TURN_SHARP_LEFT
            "sharp right" -> Maneuver.TYPE_TURN_SHARP_RIGHT
            else -> Maneuver.TYPE_STRAIGHT
        }
        "merge" -> Maneuver.TYPE_MERGE_SIDE_UNSPECIFIED
        "on ramp" -> Maneuver.TYPE_ON_RAMP_NORMAL_RIGHT
        "off ramp" -> when (modifier) {
            "left" -> Maneuver.TYPE_OFF_RAMP_NORMAL_LEFT
            else -> Maneuver.TYPE_OFF_RAMP_NORMAL_RIGHT
        }
        "fork" -> when (modifier) {
            "left" -> Maneuver.TYPE_FORK_LEFT
            else -> Maneuver.TYPE_FORK_RIGHT
        }
        "roundabout", "rotary" -> Maneuver.TYPE_ROUNDABOUT_ENTER_CW
        else -> Maneuver.TYPE_STRAIGHT
    }

    private fun distanceBetween(from: Location, to: Location): Double {
        val result = FloatArray(1)
        Location.distanceBetween(from.latitude, from.longitude, to.latitude, to.longitude, result)
        return result.first().toDouble()
    }

    private fun locationOf(lat: Double, lon: Double): Location =
        Location("osrm").apply {
            latitude = lat
            longitude = lon
        }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/RouteRepository.kt`

```kotlin
package com.georacing.georacing.car

import android.util.Log
import com.georacing.georacing.car.config.OsrmConfig
import com.google.gson.GsonBuilder
import org.maplibre.android.geometry.LatLng
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.util.Locale

/**
 * Repositorio de rutas usando OSRM como motor principal.
 * GraphHopper est√° deshabilitado/comentado.
 * 
 * FASE 3.1: Ahora usa OsrmConfig para alternar entre servidor p√∫blico y local.
 * 
 * Para usar OSRM local:
 * ```kotlin
 * OsrmConfig.setEnvironment(OsrmConfig.OsrmEnvironment.LOCAL)
 * OsrmConfig.setLocalHost("192.168.1.100", 5000)
 * ```
 * 
 * Ver OsrmConfig.kt para instrucciones de c√≥mo levantar OSRM con Docker.
 */
class RouteRepository {
    
    private val osrmService: OsrmService
    
    init {
        // FASE 3.1: Obtener base URL desde configuraci√≥n centralizada
        val baseUrl = OsrmConfig.getBaseUrl()
        
        val osrmRetrofit = Retrofit.Builder()
            .baseUrl(baseUrl)
            .addConverterFactory(GsonConverterFactory.create(GsonBuilder().create()))
            .build()
        osrmService = osrmRetrofit.create(OsrmService::class.java)
        
        Log.i("RouteRepository", "OSRM configurado: $baseUrl (Environment: ${OsrmConfig.getCurrentEnvironment()})")
    }

    /**
     * Obtiene ruta usando OSRM
     */
    suspend fun getRoute(origin: LatLng, dest: LatLng, avoidTraffic: Boolean = true): RouteResult? {
        return getRouteFromOsrm(origin, dest)
    }
    
    /* GraphHopper deshabilitado - usar solo OSRM
    private suspend fun getRouteFromGraphHopper(...): RouteResult? {
        // C√≥digo comentado - no se usa
    }
    */
    private suspend fun getRouteFromOsrm(origin: LatLng, dest: LatLng): RouteResult? {
        return try {
            val coordinates = String.format(Locale.US, "%.6f,%.6f;%.6f,%.6f", 
                origin.longitude, origin.latitude, 
                dest.longitude, dest.latitude
            )
            
            // FASE 3.1: Logging de URL completa para debugging
            val fullUrl = "${OsrmConfig.getBaseUrl()}route/v1/driving/$coordinates?overview=full&geometries=polyline6&steps=true"
            Log.d("RouteRepository", "Obteniendo ruta OSRM desde: $fullUrl")
            
            val response = osrmService.getRoute(coordinates)
            
            if (response.code == "Ok" && response.routes.isNotEmpty()) {
                val route = response.routes[0]
                val points = decodePolyline(route.geometry)
                val steps = if (route.legs.isNotEmpty()) route.legs[0].steps else emptyList()
                
                Log.i("RouteRepository", "Ruta obtenida: ${route.distance}m, ${route.duration}s, ${steps.size} pasos")
                
                RouteResult(
                    points = points,
                    distance = route.distance,
                    duration = route.duration,
                    steps = steps,
                    trafficSegments = emptyList() // Sin tr√°fico en OSRM b√°sico
                )
            } else {
                Log.e("RouteRepository", "No route found: ${response.code}")
                null
            }
        } catch (e: Exception) {
            Log.e("RouteRepository", "Error fetching route from OSRM: ${e.message}", e)
            null
        }
    }
    
    // GraphHopper helpers comentados - no necesarios para OSRM
    /* 
    private fun getManeuverType(sign: Int): String { ... }
    private fun getManeuverModifier(sign: Int): String? { ... }
    private fun calculateTrafficSegments(...): List<TrafficSegment> { ... }
    */

    // Decodes OSRM polyline6
    private fun decodePolyline(encoded: String): List<LatLng> {
        val poly = ArrayList<LatLng>()
        var index = 0
        val len = encoded.length
        var lat = 0
        var lng = 0

        while (index < len) {
            var b: Int
            var shift = 0
            var result = 0
            do {
                b = encoded[index++].code - 63
                result = result or (b and 0x1f shl shift)
                shift += 5
            } while (b >= 0x20)
            val dlat = if (result and 1 != 0) (result shr 1).inv() else result shr 1
            lat += dlat

            shift = 0
            result = 0
            do {
                b = encoded[index++].code - 63
                result = result or (b and 0x1f shl shift)
                shift += 5
            } while (b >= 0x20)
            val dlng = if (result and 1 != 0) (result shr 1).inv() else result shr 1
            lng += dlng

            val p = LatLng(
                lat.toDouble() / 1E5,
                lng.toDouble() / 1E5
            )
            poly.add(p)
        }
        return poly
    }
}

data class RouteResult(
    val points: List<LatLng>,
    val distance: Double, // meters
    val duration: Double, // seconds
    val steps: List<Step> = emptyList(),
    val trafficSegments: List<TrafficSegment> = emptyList() // Segmentos con informaci√≥n de tr√°fico
)

data class TrafficSegment(
    val startIndex: Int,
    val endIndex: Int,
    val congestionLevel: CongestionLevel // nivel de congesti√≥n
)

enum class CongestionLevel {
    FREE_FLOW,    // Verde - fluido
    MODERATE,     // Amarillo - moderado
    HEAVY,        // Naranja - denso
    SEVERE        // Rojo - muy denso
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/RouteSmoothing.kt`

```kotlin
package com.georacing.georacing.car

import org.maplibre.android.geometry.LatLng
import kotlin.math.floor
import kotlin.math.pow

object RouteSmoothing {

    fun smoothRoute(points: List<LatLng>, precision: Int = 10): List<LatLng> {
        if (points.size < 3) return points

        val smoothed = ArrayList<LatLng>()
        
        // Add start point
        smoothed.add(points.first())

        for (i in 0 until points.size - 1) {
            val p0 = if (i == 0) points[i] else points[i - 1]
            val p1 = points[i]
            val p2 = points[i + 1]
            val p3 = if (i + 1 == points.size - 1) p2 else points[i + 2]

            for (t in 1..precision) {
                val tNorm = t.toDouble() / precision
                smoothed.add(catmullRom(p0, p1, p2, p3, tNorm))
            }
        }
        
        return smoothed
    }

    private fun catmullRom(p0: LatLng, p1: LatLng, p2: LatLng, p3: LatLng, t: Double): LatLng {
        val t2 = t * t
        val t3 = t2 * t

        val lat = 0.5 * ((2.0 * p1.latitude) +
                (-p0.latitude + p2.latitude) * t +
                (2.0 * p0.latitude - 5.0 * p1.latitude + 4.0 * p2.latitude - p3.latitude) * t2 +
                (-p0.latitude + 3.0 * p1.latitude - 3.0 * p2.latitude + p3.latitude) * t3)

        val lon = 0.5 * ((2.0 * p1.longitude) +
                (-p0.longitude + p2.longitude) * t +
                (2.0 * p0.longitude - 5.0 * p1.longitude + 4.0 * p2.longitude - p3.longitude) * t2 +
                (-p0.longitude + 3.0 * p1.longitude - 3.0 * p2.longitude + p3.longitude) * t3)

        return LatLng(lat, lon)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/SpeedometerView.kt`

```kotlin
package com.georacing.georacing.car

import android.content.Context
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.Typeface
import android.view.View

import android.util.AttributeSet

/**
 * Waze-style speedometer circle overlay for Android Auto.
 * Draws a circular speed indicator with pulsing red when exceeding speed limit.
 */
class SpeedometerView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {
    
    private var currentSpeed: Float = 0f
    private var speedLimit: Float = 50f
    private var isOverSpeed: Boolean = false
    
    private val backgroundPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        color = Color.parseColor("#0F1015") // AsphaltGrey
        style = Paint.Style.FILL
        setShadowLayer(16f, 0f, 4f, Color.parseColor("#00F0FF")) // Neon Cyan glow
    }
    
    private val speedTextPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        textAlign = Paint.Align.CENTER
        typeface = Typeface.DEFAULT_BOLD
        color = Color.WHITE
    }
    
    private val unitTextPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        textAlign = Paint.Align.CENTER
        color = Color.parseColor("#00F0FF")
    }
    
    private val overSpeedPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        color = Color.parseColor("#FF2A3C") // Racing Red
        style = Paint.Style.STROKE
        strokeWidth = 8f
        setShadowLayer(20f, 0f, 0f, Color.parseColor("#FF2A3C"))
    }
    
    private val borderPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        style = Paint.Style.STROKE
        strokeWidth = 6f
        color = Color.parseColor("#00F0FF") // Neon Cyan
    }
    
    private var pulseAlpha = 255
    private var pulseDirection = -1
    
    fun updateSpeed(speed: Float, limit: Float) {
        currentSpeed = speed
        speedLimit = limit
        isOverSpeed = speed > limit
        invalidate()
    }
    
    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        
        val centerX = width / 2f
        val centerY = height / 2f
        val radius = minOf(width, height) / 2f - 10f
        
        // Base Dark Background
        canvas.drawCircle(centerX, centerY, radius, backgroundPaint)

        // Pulse animation for over-speed
        if (isOverSpeed) {
            pulseAlpha += pulseDirection * 15
            if (pulseAlpha <= 100 || pulseAlpha >= 255) {
                pulseDirection *= -1
            }
            overSpeedPaint.alpha = pulseAlpha
            canvas.drawCircle(centerX, centerY, radius - 4f, overSpeedPaint)
            unitTextPaint.color = Color.parseColor("#FF2A3C")
            backgroundPaint.setShadowLayer(16f, 0f, 4f, Color.parseColor("#FF2A3C"))
        } else {
            canvas.drawCircle(centerX, centerY, radius - 4f, borderPaint)
            unitTextPaint.color = Color.parseColor("#00F0FF")
            backgroundPaint.setShadowLayer(16f, 0f, 4f, Color.parseColor("#00F0FF"))
        }
        
        // Speed number
        speedTextPaint.textSize = radius * 0.8f
        val speedInt = currentSpeed.toInt()
        canvas.drawText(
            speedInt.toString(),
            centerX,
            centerY + speedTextPaint.textSize * 0.3f,
            speedTextPaint
        )
        
        // "km/h" label
        unitTextPaint.textSize = radius * 0.25f
        canvas.drawText(
            "km/h",
            centerX,
            centerY + radius * 0.6f,
            unitTextPaint
        )
        
        // Continuous animation if over speed
        if (isOverSpeed) {
            postInvalidateDelayed(50)
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/car/config/OsrmConfig.kt`

```kotlin
package com.georacing.georacing.car.config

import android.util.Log

/**
 * FASE 3.1: Configuraci√≥n centralizada para endpoints OSRM.
 * 
 * Permite alternar entre:
 * - OSRM p√∫blico (router.project-osrm.org) para desarrollo r√°pido
 * - OSRM local (Docker en red local) para producci√≥n
 * 
 * C√≥mo usar servidor OSRM local:
 * 
 * 1. Levantar OSRM con Docker:
 * ```bash
 * # Descargar mapa de Espa√±a (o tu regi√≥n)
 * wget http://download.geofabrik.de/europe/spain-latest.osm.pbf
 * 
 * # Procesar el mapa con OSRM
 * docker run -t -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend osrm-extract -p /opt/car.lua /data/spain-latest.osm.pbf
 * docker run -t -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend osrm-partition /data/spain-latest.osrm
 * docker run -t -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend osrm-customize /data/spain-latest.osrm
 * 
 * # Levantar servidor (Puerto 5000)
 * docker run -t -i -p 5000:5000 -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend osrm-routed --algorithm mld /data/spain-latest.osrm
 * ```
 * 
 * 2. Cambiar modo en esta clase:
 * ```kotlin
 * OsrmConfig.setEnvironment(OsrmEnvironment.LOCAL)
 * OsrmConfig.setLocalHost("192.168.1.100", 5000)  // Tu IP local
 * ```
 * 
 * O usar BuildConfig para cambiar en build time:
 * - En build.gradle.kts a√±adir:
 *   buildConfigField("String", "OSRM_BASE_URL", "\"https://router.project-osrm.org/\"")
 * - Para builds de producci√≥n:
 *   buildConfigField("String", "OSRM_BASE_URL", "\"http://tu-servidor-osrm:5000/\"")
 */
object OsrmConfig {
    
    private const val TAG = "OsrmConfig"
    
    /**
     * Entornos OSRM disponibles
     */
    enum class OsrmEnvironment {
        /** OSRM p√∫blico de Project OSRM (desarrollo) */
        PUBLIC,
        
        /** OSRM local en red (producci√≥n/testing) */
        LOCAL
    }
    
    // URLs base
    private const val PUBLIC_BASE_URL = "https://router.project-osrm.org/"
    private var localBaseUrl = "http://192.168.1.100:5000/"  // Default local IP
    
    // Estado actual
    private var currentEnvironment = OsrmEnvironment.PUBLIC
    
    /**
     * Obtiene la URL base actual de OSRM seg√∫n el entorno configurado.
     */
    fun getBaseUrl(): String {
        val url = when (currentEnvironment) {
            OsrmEnvironment.PUBLIC -> PUBLIC_BASE_URL
            OsrmEnvironment.LOCAL -> localBaseUrl
        }
        
        Log.d(TAG, "OSRM Base URL: $url (Environment: $currentEnvironment)")
        return url
    }
    
    /**
     * Cambia el entorno OSRM (p√∫blico o local).
     * 
     * @param environment Entorno a usar
     */
    fun setEnvironment(environment: OsrmEnvironment) {
        currentEnvironment = environment
        Log.i(TAG, "OSRM environment changed to: $environment")
    }
    
    /**
     * Configura el host local para OSRM (solo aplica si environment = LOCAL).
     * 
     * @param host IP o hostname del servidor OSRM local (ej: "192.168.1.100" o "osrm.local")
     * @param port Puerto del servidor (default: 5000)
     */
    fun setLocalHost(host: String, port: Int = 5000) {
        localBaseUrl = "http://$host:$port/"
        Log.i(TAG, "OSRM local host configured: $localBaseUrl")
    }
    
    /**
     * Devuelve el entorno actual.
     */
    fun getCurrentEnvironment(): OsrmEnvironment {
        return currentEnvironment
    }
    
    /**
     * Helper para configuraci√≥n r√°pida desde BuildConfig (si est√° disponible).
     * 
     * Ejemplo en build.gradle.kts:
     * ```
     * android {
     *     defaultConfig {
     *         buildConfigField("String", "OSRM_BASE_URL_PUBLIC", "\"https://router.project-osrm.org/\"")
     *         buildConfigField("String", "OSRM_BASE_URL_LOCAL", "\"http://192.168.1.100:5000/\"")
     *         buildConfigField("String", "OSRM_ENVIRONMENT", "\"PUBLIC\"")  // o "LOCAL"
     *     }
     * }
     * ```
     */
    fun configureFromBuildConfig(
        environment: String?,
        publicUrl: String? = null,
        localUrl: String? = null
    ) {
        // Configurar URLs si se proveen
        publicUrl?.let {
            // PUBLIC_BASE_URL es const, no se puede modificar
            Log.d(TAG, "Public URL from BuildConfig: $it")
        }
        
        localUrl?.let {
            localBaseUrl = it
            Log.d(TAG, "Local URL from BuildConfig: $it")
        }
        
        // Configurar entorno
        environment?.let {
            try {
                val env = OsrmEnvironment.valueOf(it.uppercase())
                setEnvironment(env)
            } catch (e: IllegalArgumentException) {
                Log.w(TAG, "Invalid OSRM environment from BuildConfig: $it, using PUBLIC")
                setEnvironment(OsrmEnvironment.PUBLIC)
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/core/battery/data/BatteryMonitorImpl.kt`

```kotlin
package com.georacing.georacing.core.battery.data

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.BatteryManager
import com.georacing.georacing.core.battery.domain.BatteryMonitor
import com.georacing.georacing.core.battery.domain.BatteryState
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.launch
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers

/**
 * Implementaci√≥n de infraestructura (Data Layer).
 * Escucha los intents de Android sin polling constante.
 */
class BatteryMonitorImpl(
    private val context: Context
) : BatteryMonitor {

    private val applicationScope = CoroutineScope(Dispatchers.Default)

    private val _batteryState = MutableStateFlow(getInitialBatteryState())
    override val batteryState: StateFlow<BatteryState> = _batteryState.asStateFlow()

    init {
        applicationScope.launch {
            observeBatteryIntents()
                .distinctUntilChanged()
                .collect { state ->
                    _batteryState.value = state
                }
        }
    }

    private fun getInitialBatteryState(): BatteryState {
        val intentFilter = IntentFilter(Intent.ACTION_BATTERY_CHANGED)
        val batteryStatus: Intent? = context.registerReceiver(null, intentFilter)
        return batteryStatus?.toBatteryState() ?: BatteryState.UNKNOWN
    }

    private fun observeBatteryIntents(): Flow<BatteryState> = callbackFlow {
        val receiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context?, intent: Intent?) {
                intent?.let {
                    trySend(it.toBatteryState())
                }
            }
        }

        val filter = IntentFilter(Intent.ACTION_BATTERY_CHANGED)
        context.registerReceiver(receiver, filter)

        awaitClose {
            context.unregisterReceiver(receiver)
        }
    }

    private fun Intent.toBatteryState(): BatteryState {
        val level = getIntExtra(BatteryManager.EXTRA_LEVEL, -1)
        val scale = getIntExtra(BatteryManager.EXTRA_SCALE, -1)
        val percentage = if (level != -1 && scale != -1) {
            (level * 100) / scale
        } else {
            -1
        }

        val status = getIntExtra(BatteryManager.EXTRA_STATUS, -1)
        val isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||
                status == BatteryManager.BATTERY_STATUS_FULL

        return BatteryState(percentage = percentage, isCharging = isCharging)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/core/battery/domain/BatteryMonitor.kt`

```kotlin
package com.georacing.georacing.core.battery.domain

import kotlinx.coroutines.flow.StateFlow

/**
 * Interfaz de dominio para monitorizar la bater√≠a, independiente de Android.
 */
interface BatteryMonitor {
    /**
     * Un [StateFlow] que emite el estado actual de la bater√≠a en tiempo real.
     */
    val batteryState: StateFlow<BatteryState>
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/core/battery/domain/BatteryState.kt`

```kotlin
package com.georacing.georacing.core.battery.domain

/**
 * Representa el estado actual de la bater√≠a.
 */
data class BatteryState(
    val percentage: Int,
    val isCharging: Boolean
) {
    companion object {
        val UNKNOWN = BatteryState(percentage = -1, isCharging = false)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/core/battery/domain/SurvivalMode.kt`

```kotlin
package com.georacing.georacing.core.battery.domain

/**
 * Niveles de modo de supervivencia de la aplicaci√≥n.
 */
enum class SurvivalMode {
    /** Bater√≠a por encima del umbral seguro (> 50%). Todo habilitado. */
    NORMAL,
    
    /** Bater√≠a en nivel medio (30% - 50%). Posibles advertencias ligeras. */
    WARNING,
    
    /** Bater√≠a cr√≠tica (<= 30%). Se activan las contramedidas extremas. */
    SURVIVAL
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/core/battery/domain/SurvivalModeManager.kt`

```kotlin
package com.georacing.georacing.core.battery.domain

import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers

/**
 * Gestor principal de dominio que eval√∫a el nivel de bater√≠a
 * de forma reactiva y determina en qu√© modo operativo est√° la App.
 * Este es el core del "Energy Shedding Protocol".
 */
class SurvivalModeManager(
    private val batteryMonitor: BatteryMonitor
) {
    // Definimos el umbral cr√≠tico para la carrera.
    companion object {
        const val SURVIVAL_THRESHOLD = 30
        const val WARNING_THRESHOLD = 50
    }

    private val applicationScope = CoroutineScope(Dispatchers.Default)

    /**
     * Estado global que reacciona a los cambios en la bater√≠a.
     * Toda la aplicaci√≥n (ViewModels, Servicios) puede observarlo.
     */
    val survivalMode: StateFlow<SurvivalMode> = batteryMonitor.batteryState
        .map { state ->
            when {
                state.percentage < 0 -> SurvivalMode.NORMAL // Desconocido, por defecto normal
                state.isCharging -> SurvivalMode.NORMAL // Si est√° cargando, sin restricciones
                state.percentage <= SURVIVAL_THRESHOLD -> SurvivalMode.SURVIVAL
                state.percentage <= WARNING_THRESHOLD -> SurvivalMode.WARNING
                else -> SurvivalMode.NORMAL
            }
        }
        .stateIn(
            scope = applicationScope,
            started = SharingStarted.Eagerly, // Mantenemos el modo vivo desde inicio
            initialValue = SurvivalMode.NORMAL
        )

    /**
     * Si necesitas acciones imperativas que maten procesos inmediatamente,
     * este es el lugar para implementarlas (Load Shedding).
     * Por ahora mostramos los intent/eventos requeridos.
     */
    fun enforceSurvivalRestrictions() {
        if (survivalMode.value == SurvivalMode.SURVIVAL) {
            killGamificationAndAR()
            forceOfflineTelemetry()
        }
    }

    private fun killGamificationAndAR() {
        // Aqu√≠ puedes emitir un evento con EventBus/SharedFlow
        // que tus servicios de AR o Gamification escuchen para detenerse (Ej. ARCore session).
    }

    private fun forceOfflineTelemetry() {
        // Aqu√≠ cancelar√≠amos los jobs de WorkManager peri√≥dicos
        // Ej: WorkManager.getInstance(context).cancelUniqueWork("telemetry_sync")
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/core/battery/ui/MapSurvivalViewModel.kt`

```kotlin
package com.georacing.georacing.core.battery.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.core.battery.domain.SurvivalMode
import com.georacing.georacing.core.battery.domain.SurvivalModeManager
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

/**
 * Ejemplo de ViewModel para demostrar el consumo del modo de supervivencia
 * desde la UI (Compose o Fragment). En tu proyecto de Dagger/Hilt pondr√≠as @HiltViewModel
 */
// @HiltViewModel
class MapSurvivalViewModel(
    private val survivalModeManager: SurvivalModeManager
) : ViewModel() {

    // Exponemos el estilo del mapa a la UI de MapLibre reactivamente.
    // Compose har√° la recomposici√≥n de UI de inmediato cuando la bater√≠a baje del 30%.
    val mapStyleUrl: StateFlow<String> = survivalModeManager.survivalMode
        .map { mode ->
            when (mode) {
                SurvivalMode.SURVIVAL -> "asset://style_oled_black.json" // Minimalista sin texturas, color puro RGB 0,0,0
                SurvivalMode.WARNING -> "asset://style_dark.json"
                SurvivalMode.NORMAL -> "asset://style_day_3d.json"       // Renderizado completo
            }
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = "asset://style_day_3d.json"
        )
    
    // Si necesitas apagar m√≥dulos espec√≠ficos desde la presentaci√≥n
    fun onUserOpenedARFeature() {
        if (survivalModeManager.survivalMode.value == SurvivalMode.SURVIVAL) {
            // Mostrar Toast: "Operaci√≥n denegada. Nivel de energ√≠a cr√≠tico para emergencias."
            return
        }
        // Iniciar flujo de Realidad Aumentada...
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/billing/BillingManager.kt`

```kotlin
package com.georacing.georacing.data.billing

import android.app.Activity
import android.content.Context
import com.android.billingclient.api.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

object BillingManager {
    private var billingClient: BillingClient? = null
    
    private val _purchases = MutableStateFlow<List<Purchase>>(emptyList())
    val purchases = _purchases.asStateFlow()

    private val _billingFlowResult = MutableStateFlow<Int?>(null) // BillingResponseCode
    val billingFlowResult = _billingFlowResult.asStateFlow()

    private val _simulationEvent = MutableStateFlow<Boolean>(false)
    val simulationEvent = _simulationEvent.asStateFlow()

    fun consumeSimulation() {
        _simulationEvent.value = false
    }

    fun initialize(context: Context) {
        if (billingClient != null) return

        billingClient = BillingClient.newBuilder(context)
            .setListener { billingResult, purchases ->
                if (billingResult.responseCode == BillingClient.BillingResponseCode.OK && purchases != null) {
                    _purchases.value = purchases
                    // Here we would acknowledge purchases normally
                    acknowledgePurchases(purchases)
                }
                _billingFlowResult.value = billingResult.responseCode
            }
            .enablePendingPurchases(PendingPurchasesParams.newBuilder().enableOneTimeProducts().build())
            .build()

        startConnection()
    }

    private fun startConnection() {
        billingClient?.startConnection(object : BillingClientStateListener {
            override fun onBillingSetupFinished(billingResult: BillingResult) {
                if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                    // Client is ready
                }
            }

            override fun onBillingServiceDisconnected() {
                // Try to restart the connection on the next request to Google Play
                // For now, we rely on reconnection logic in usage
            }
        })
    }

    private fun acknowledgePurchases(purchases: List<Purchase>) {
        val scope = CoroutineScope(Dispatchers.IO)
        purchases.forEach { purchase ->
            if (purchase.purchaseState == Purchase.PurchaseState.PURCHASED) {
                if (!purchase.isAcknowledged) {
                    val acknowledgePurchaseParams = AcknowledgePurchaseParams.newBuilder()
                        .setPurchaseToken(purchase.purchaseToken)
                        .build()
                    scope.launch {
                        billingClient?.acknowledgePurchase(acknowledgePurchaseParams) { billingResult ->
                             // Handle acknowledgment result
                             if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                                 // Purchase acknowledged
                             }
                        }
                    }
                }
            }
        }
    }

    fun launchBillingFlow(activity: Activity, skuId: String, price: Double) {
        if (billingClient?.isReady != true) {
            startConnection()
            activity.runOnUiThread {
                android.widget.Toast.makeText(activity, "Conectando... Int√©ntalo de nuevo.", android.widget.Toast.LENGTH_SHORT).show()
            }
            return
        }

        val skuList = listOf(QueryProductDetailsParams.Product.newBuilder()
            .setProductId("android.test.purchased") 
            .setProductType(BillingClient.ProductType.INAPP)
            .build())

        val params = QueryProductDetailsParams.newBuilder().setProductList(skuList).build()

        billingClient?.queryProductDetailsAsync(params) { billingResult, productDetailsList ->
            if (billingResult.responseCode == BillingClient.BillingResponseCode.OK && productDetailsList.isNotEmpty()) {
                val productDetails = productDetailsList[0]
                
                val billingFlowParams = BillingFlowParams.newBuilder()
                    .setProductDetailsParamsList(
                        listOf(
                            BillingFlowParams.ProductDetailsParams.newBuilder()
                                .setProductDetails(productDetails)
                                .build()
                        )
                    )
                    .build()
                
                billingClient?.launchBillingFlow(activity, billingFlowParams)
            } else {
                // Fallback for testing without Play Console setup
                activity.runOnUiThread {
                    android.widget.Toast.makeText(
                        activity, 
                        "Modo Test: Simulando Pago (Google Play no req.)", 
                        android.widget.Toast.LENGTH_SHORT
                    ).show()
                }
                // Simulate success
                _simulationEvent.value = true
            }
        }
    }
    
    fun cleanFlow() {
        _billingFlowResult.value = null
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/billing/FakePaymentProcessor.kt`

```kotlin
package com.georacing.georacing.data.billing

import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

sealed class PaymentResult {
    object Idle : PaymentResult()
    object Processing : PaymentResult()
    object Success : PaymentResult()
    data class Error(val message: String) : PaymentResult()
}

/**
 * Simula una pasarela de pagos para propsitos de Demo.
 */
object FakePaymentProcessor {

    fun processPayment(amount: Double): Flow<PaymentResult> = flow {
        emit(PaymentResult.Processing)
        
        // Simular tiempo de conexi√≥n con banco (simulado)
        delay(2000)
        
        // Simular verificaci√≥n de tarjeta (simulado)
        delay(1500)
        
        // Siempre √©xito para la demo
        emit(PaymentResult.Success)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/ble/BeaconAdvertiser.kt`

```kotlin
package com.georacing.georacing.data.ble

import android.annotation.SuppressLint
import android.bluetooth.BluetoothManager
import android.bluetooth.le.AdvertiseCallback
import android.bluetooth.le.AdvertiseData
import android.bluetooth.le.AdvertiseSettings
import android.content.Context
import android.os.ParcelUuid
import android.util.Log
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.nio.ByteBuffer
import java.util.UUID

class BeaconAdvertiser(private val context: Context) {

    private val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
    private val adapter = bluetoothManager.adapter
    private val advertiser = adapter?.bluetoothLeAdvertiser

    private var isAdvertising = false
    private val _advertisingState = MutableStateFlow("Idle")
    val advertisingState = _advertisingState.asStateFlow()

    private val advertiseCallback = object : AdvertiseCallback() {
        override fun onStartSuccess(settingsInEffect: AdvertiseSettings?) {
            super.onStartSuccess(settingsInEffect)
            isAdvertising = true
            _advertisingState.value = "Active"
            Log.d(TAG, "Advertising started successfully")
            android.os.Handler(context.mainLooper).post {
                android.widget.Toast.makeText(context, "GeoRacing: BLE Broadcasting Active", android.widget.Toast.LENGTH_SHORT).show()
            }
        }

        override fun onStartFailure(errorCode: Int) {
            super.onStartFailure(errorCode)
            isAdvertising = false
            _advertisingState.value = "Failed: $errorCode"
            Log.e(TAG, "Advertising failed: $errorCode")
            android.os.Handler(context.mainLooper).post {
                android.widget.Toast.makeText(context, "GeoRacing BLE Error: $errorCode", android.widget.Toast.LENGTH_LONG).show()
            }
        }
    }

    private var lastAdvertisedData: ByteArray? = null

    @SuppressLint("MissingPermission")
    fun startAdvertising(userUid: String, lat: Double? = null, lon: Double? = null) {
        if (advertiser == null) {
            Log.e(TAG, "BLE Advertising not supported on this device")
            _advertisingState.value = "Not Supported"
            return
        }

        // 1. Build Payload
        // [Type(1) | ID(4) | Lat(4) | Lon(4)]
        val shortId = userUid.hashCode()
        val shortIdBytes = ByteBuffer.allocate(4).putInt(shortId).array()
        
        val hasLocation = lat != null && lon != null
        val bufferSize = if (hasLocation) 13 else 5
        val buffer = ByteBuffer.allocate(bufferSize)
        
        buffer.put(0x01.toByte()) // Type: User Beacon
        buffer.put(shortIdBytes)  // ID Hash
        
        if (hasLocation) {
            buffer.putFloat(lat!!.toFloat())
            buffer.putFloat(lon!!.toFloat())
        }
        
        val manufacturerData = buffer.array()

        // 2. Diff Check (Avoid restarting if data unchanged)
        if (isAdvertising && java.util.Arrays.equals(lastAdvertisedData, manufacturerData)) {
            return 
        }

        // 3. Restart Sequence
        if (isAdvertising) {
            stopAdvertising()
        }
        
        lastAdvertisedData = manufacturerData

        val settings = AdvertiseSettings.Builder()
            .setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_BALANCED)
            .setTxPowerLevel(AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM)
            .setConnectable(false)
            .build()
        
        val data = AdvertiseData.Builder()
            .setIncludeDeviceName(false)
            .addManufacturerData(0x1234, manufacturerData) 
            .build()

        try {
            advertiser.startAdvertising(settings, data, advertiseCallback)
            Log.d(TAG, "Requesting advertising start... ID=$shortId Loc=$hasLocation")
        } catch (e: Exception) {
            Log.e(TAG, "Error starting advertising", e)
            _advertisingState.value = "Exception: ${e.message}"
        }
    }

    /**
     * üÜò STAFF DANGER MODE: Emite se√±al de peligro para alertar a otros dispositivos.
     * 
     * Payload format:
     * [Type=0x02 (Staff) | ZoneId(2) | Mode(1) | Flags(1) | Sequence(2) | TTL(1)]
     * 
     * @param staffId ID del miembro del staff
     * @param zoneId ID de la zona donde est√° el peligro
     * @param alertMode 0=Normal, 1=Warning, 2=Danger, 3=Evacuation
     */
    @SuppressLint("MissingPermission")
    fun startDangerAdvertising(staffId: String, zoneId: Int, alertMode: Int = MODE_EVACUATION) {
        if (advertiser == null) {
            Log.e(TAG, "BLE Advertising not supported")
            _advertisingState.value = "Not Supported"
            return
        }

        // Construir payload de emergencia
        // New Format (Version 2 extended or reusing Type=2)
        // [Type=0x02(1) | ID(4) | ZoneId(2) | Mode(1) | Flags(1) | Sequence(2) | TTL(1)] = 12 bytes + 1(Type) = 13 bytes
        val buffer = java.nio.ByteBuffer.allocate(13)
        buffer.put(TYPE_STAFF_BEACON)           // Type: Staff Danger Beacon
        
        // INSERT STAFF ID HASH (4 bytes)
        val shortId = staffId.hashCode()
        buffer.putInt(shortId)
        
        buffer.putShort(zoneId.toShort())       // Zone ID
        buffer.put(alertMode.toByte())          // Mode: EVACUATION/DANGER
        buffer.put(0x01.toByte())               // Flags: Active
        buffer.putShort(System.currentTimeMillis().toInt().toShort()) // Sequence
        buffer.put(60.toByte())                 // TTL: 60 seconds

        val manufacturerData = buffer.array()

        // Restart si ya est√° emitiendo
        if (isAdvertising) {
            stopAdvertising()
        }
        
        lastAdvertisedData = manufacturerData

        // Settings: Alta potencia para m√°ximo alcance en emergencia
        val settings = AdvertiseSettings.Builder()
            .setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY)
            .setTxPowerLevel(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH)
            .setConnectable(false)
            .build()

        val data = AdvertiseData.Builder()
            .setIncludeDeviceName(false)
            .addManufacturerData(MANUFACTURER_ID, manufacturerData)
            .build()

        try {
            advertiser.startAdvertising(settings, data, advertiseCallback)
            _advertisingState.value = "‚ö†Ô∏è DANGER BROADCAST ACTIVE"
            Log.w(TAG, "üÜò DANGER ADVERTISING STARTED - Zone: $zoneId, Mode: $alertMode")
            
            android.os.Handler(context.mainLooper).post {
                android.widget.Toast.makeText(
                    context, 
                    "üÜò ALERTA DE PELIGRO ACTIVA - Zona $zoneId", 
                    android.widget.Toast.LENGTH_LONG
                ).show()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error starting danger advertising", e)
            _advertisingState.value = "Exception: ${e.message}"
        }
    }

    @SuppressLint("MissingPermission")
    fun stopAdvertising() {
        if (!isAdvertising) return
        try {
            advertiser?.stopAdvertising(advertiseCallback)
            isAdvertising = false
            lastAdvertisedData = null
            _advertisingState.value = "Stopped"
        } catch (e: Exception) {
            Log.e(TAG, "Error stopping advertising", e)
        }
    }

    companion object {
        private const val TAG = "BeaconAdvertiser"
        
        // Manufacturer ID (para desarrollo, usar ID registrado en producci√≥n)
        const val MANUFACTURER_ID = 0x1234
        
        // Beacon Types
        const val TYPE_USER_BEACON: Byte = 0x01
        const val TYPE_STAFF_BEACON: Byte = 0x02
        
        // Alert Modes
        const val MODE_NORMAL = 0
        const val MODE_WARNING = 1
        const val MODE_DANGER = 2
        const val MODE_EVACUATION = 3
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/ble/BeaconScanner.kt`

```kotlin
package com.georacing.georacing.data.ble

import android.annotation.SuppressLint
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothManager
import android.bluetooth.le.ScanCallback
import android.bluetooth.le.ScanResult
import android.bluetooth.le.ScanSettings
import android.content.Context
import android.util.Log
import com.georacing.georacing.debug.ScenarioSimulator
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

class BeaconScanner(private val context: Context) {

    private val _detectedBeacons = MutableStateFlow<List<DetectedBeacon>>(emptyList())
    val detectedBeacons: StateFlow<List<DetectedBeacon>> = _detectedBeacons.asStateFlow()

    // Internal real signal
    private val _realActiveSignal = MutableStateFlow<BleCircuitSignal?>(null)
    
    // Public combined signal
    val activeSignal: StateFlow<BleCircuitSignal?> = combine(
        _realActiveSignal,
        ScenarioSimulator.forcedBleSignal
    ) { real, forced ->
        forced ?: real
    }.stateIn(
        scope = CoroutineScope(Dispatchers.Default),
        started = kotlinx.coroutines.flow.SharingStarted.Eagerly,
        initialValue = null
    )

    private val _debugInfo = MutableStateFlow("Init")
    val debugInfo: StateFlow<String> = _debugInfo.asStateFlow()

    private val _detectedUsers = MutableStateFlow<List<DetectedUser>>(emptyList())
    val detectedUsers: StateFlow<List<DetectedUser>> = _detectedUsers.asStateFlow()

    private val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
    private val bluetoothAdapter: BluetoothAdapter? = bluetoothManager.adapter
    private val scanner = bluetoothAdapter?.bluetoothLeScanner

    private var isScanning = false
    val isScanningValue: Boolean get() = isScanning

    private val scope = CoroutineScope(Dispatchers.IO)
    private var restartJob: Job? = null
    private var shouldBeScanning = false
    private var lastRestartTime = 0L

    private val scanCallback = object : ScanCallback() {
        @SuppressLint("MissingPermission")
        override fun onScanResult(callbackType: Int, result: ScanResult?) {
            result?.let { scanResult ->
                val device = scanResult.device
                val rssi = scanResult.rssi
                val scanRecord = scanResult.scanRecord
                
                // 1. Passive Beacons handling
                val deviceName = scanRecord?.deviceName ?: device.name
                val manufacturerData = scanRecord?.manufacturerSpecificData
                val hasGeoRacingId = manufacturerData?.get(0x1234) != null
                val isGeoRacing = hasGeoRacingId || deviceName?.contains("GEORACING", ignoreCase = true) == true
                
                var detectedMode: com.georacing.georacing.domain.model.CircuitMode? = null
                var detectedId: String? = null
                
                manufacturerData?.let {
                    val bytes = it.get(0x1234)
                    if (bytes != null) {
                         val signal = BlePayloadParser.parse(0x1234, bytes)
                         detectedMode = signal?.mode
                         detectedId = signal?.sourceId?.toString()
                         // If we parse a valid signal, update active signal
                         if (signal != null) {
                             updateActiveSignal(signal, rssi)
                         }
                    }
                }

                if (isGeoRacing) {
                    val finalId = if (detectedId != null) "STAFF_$detectedId" else device.address
                    updateBeacon(finalId, deviceName, rssi, isGeoRacing, detectedMode)
                }

                // 2. Active Beacon User Detection
                scanRecord?.manufacturerSpecificData?.let { mfData ->
                    for (i in 0 until mfData.size()) {
                        val id = mfData.keyAt(i)
                        val bytes = mfData.valueAt(i)
                        val isUserBeaconLength = bytes.size == 5 || bytes.size == 13
                        if (id == 0x1234 && bytes.isNotEmpty() && bytes[0] == 0x01.toByte() && isUserBeaconLength) {
                             if (bytes.size >= 5) {
                                  val buffer = java.nio.ByteBuffer.wrap(bytes)
                                  buffer.get() // Skip Type
                                  val hash = buffer.int
                                  var lat: Double? = null
                                  var lon: Double? = null
                                  if (bytes.size >= 13) {
                                      lat = buffer.float.toDouble()
                                      lon = buffer.float.toDouble()
                                  }
                                  updateDetectedUser(hash, rssi, lat, lon)
                             }
                        }
                    }
                }
            }
        }
    }

    private fun updateActiveSignal(signal: BleCircuitSignal, rssi: Int) {
        if (rssi > -90) {
             _realActiveSignal.value = signal
        }
    }

    private fun updateDetectedUser(hash: Int, rssi: Int, lat: Double?, lon: Double?) {
        val current = _detectedUsers.value.toMutableList()
        val index = current.indexOfFirst { it.idHash == hash }
        if (index != -1) {
            current[index] = DetectedUser(hash, rssi, System.currentTimeMillis(), lat, lon)
        } else {
            current.add(DetectedUser(hash, rssi, System.currentTimeMillis(), lat, lon))
        }
        val now = System.currentTimeMillis()
        current.removeAll { now - it.timestamp > 30000 }
        _detectedUsers.value = current
    }

    private fun updateBeacon(id: String, name: String?, rssi: Int, isGeoRacing: Boolean, mode: com.georacing.georacing.domain.model.CircuitMode?) {
        if (!isGeoRacing) return
        val currentList = _detectedBeacons.value.toMutableList()
        val existingIndex = currentList.indexOfFirst { it.id == id }
        if (existingIndex != -1) {
            val existing = currentList[existingIndex]
            val newMode = mode ?: existing.circuitMode
            currentList[existingIndex] = existing.copy(
                rssi = rssi,
                timestamp = System.currentTimeMillis(),
                circuitMode = newMode
            )
        } else {
            currentList.add(DetectedBeacon(id, name, rssi, isGeoRacing, System.currentTimeMillis(), mode))
        }
        val now = System.currentTimeMillis()
        currentList.removeAll { now - it.timestamp > 60000 }
        _detectedBeacons.value = currentList
    }

    fun pruneInactiveDevices(ttlMs: Long) {
        val currentList = _detectedBeacons.value.toMutableList()
        val now = System.currentTimeMillis()
        val removed = currentList.removeAll { now - it.timestamp > ttlMs }
        if (removed) {
             _detectedBeacons.value = currentList
        }
    }

    @SuppressLint("MissingPermission")
    fun startScanning() {
        if (shouldBeScanning) return
        shouldBeScanning = true
        startWatchdog()
    }

    private fun startWatchdog() {
        restartJob?.cancel()
        restartJob = scope.launch {
            while (shouldBeScanning) {
                try {
                    val error = checkRequirements()
                    if (error != null) {
                        _debugInfo.value = "Wait: $error"
                        if (isScanning) stopScanInternal()
                    } else {
                        if (!isScanning) {
                            startScanInternal()
                            lastRestartTime = System.currentTimeMillis()
                        } else {
                            if (System.currentTimeMillis() - lastRestartTime > 15 * 60 * 1000L) {
                                stopScanInternal()
                                delay(2000) 
                            }
                        }
                    }
                } catch (e: Exception) { }
                delay(30000) 
            }
        }
    }

    @SuppressLint("MissingPermission")
    private fun startScanInternal() {
        if (isScanning) return
        try {
            val settings = ScanSettings.Builder()
                .setScanMode(ScanSettings.SCAN_MODE_BALANCED)
                .build()
            _debugInfo.value = "Scanning (OPEN)..."
            scanner?.startScan(null, settings, scanCallback)
            isScanning = true
            
            scope.launch {
                while (isScanning) {
                    delay(1000)
                    if (!_debugInfo.value.contains("Found")) {
                         if (!_debugInfo.value.contains("ID:") && !_debugInfo.value.contains("ERR") && !_debugInfo.value.contains("Watchdog")) {
                             _debugInfo.value = "Scanning..."
                         }
                    }
                }
            }
        } catch (e: Exception) {
            _debugInfo.value = "Filter Error: ${e.message}"
        }
    }

    private fun checkRequirements(): String? {
        if (bluetoothAdapter == null || !bluetoothAdapter.isEnabled) return "BT OFF"
        return null 
    }

    fun stopScanning() {
        shouldBeScanning = false
        restartJob?.cancel()
        stopScanInternal()
    }

    @SuppressLint("MissingPermission")
    private fun stopScanInternal() {
        if (!isScanning) return
        try {
            scanner?.stopScan(scanCallback)
            isScanning = false
        } catch (e: Exception) { }
    }
    
    fun forceConnect(deviceAddress: String) {
        val forcedSignal = BleCircuitSignal(
            version = 1,
            zoneId = 1001,
            mode = com.georacing.georacing.domain.model.CircuitMode.NORMAL,
            flags = 0,
            sequence = 999,
            ttlSeconds = 10,
            temperature = 25
        )
        _realActiveSignal.value = forcedSignal
        _debugInfo.value = "FORCED: $deviceAddress"
    }
}

data class DetectedUser(
    val idHash: Int,
    val rssi: Int,
    val timestamp: Long,
    val latitude: Double? = null,
    val longitude: Double? = null
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/ble/BleCircuitSignal.kt`

```kotlin
package com.georacing.georacing.data.ble

import com.georacing.georacing.domain.model.CircuitMode

data class BleCircuitSignal(
    val version: Int,
    val zoneId: Int,
    val mode: CircuitMode,
    val flags: Int,
    val sequence: Int,
    val ttlSeconds: Int,
    val temperature: Int? = null,
    val sourceId: Int? = null, // üÜï Added Source ID
    val timestamp: Long = System.currentTimeMillis()
) {
    fun isValid(): Boolean {
        // Basic validation: Version 1 (Circuit) and 2 (Staff Danger) supported
        return version == 1 || version == 2
    }

    fun isExpired(): Boolean {
        val ageSeconds = (System.currentTimeMillis() - timestamp) / 1000
        return ageSeconds > ttlSeconds
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/ble/BlePayloadParser.kt`

```kotlin
package com.georacing.georacing.data.ble

import com.georacing.georacing.domain.model.CircuitMode
import java.nio.ByteBuffer
import java.nio.ByteOrder

object BlePayloadParser {

    // Payload size 8 or 9 (9 includes temperature)
    // We allow 8 for backward compatibility, 9 for new.
    // FIX: Strict Upper Limit to avoid reading User Beacons (13 bytes)
    private const val PAYLOAD_MIN_SIZE = 8
    private const val PAYLOAD_MAX_SIZE = 9
    private const val MANUFACTURER_ID = 0x1234 // Test ID

    fun parse(manufacturerId: Int, bytes: ByteArray?): BleCircuitSignal? {
        if (manufacturerId != MANUFACTURER_ID || bytes == null || 
            bytes.size < PAYLOAD_MIN_SIZE || bytes.size > PAYLOAD_MAX_SIZE) {
            return null
        }

        return try {
            val buffer = ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN)

            val version = buffer.get().toInt() and 0xFF
            var sourceId: Int? = null
            
            // Version 2 (Staff) has ID right after version
            if (version == 2 && buffer.remaining() >= 12) {
                 sourceId = buffer.int
            }

            val zoneId = buffer.short.toInt() and 0xFFFF
            val modeByte = buffer.get().toInt()
            val flags = buffer.get().toInt() and 0xFF
            val sequence = buffer.short.toInt() and 0xFFFF
            val ttl = buffer.get().toInt() and 0xFF
            
            var temp: Int? = null
            // For V1 temp is at end. For V2 we are already larger.
            if (version == 1 && buffer.hasRemaining()) {
                 temp = buffer.get().toInt()
            }

            BleCircuitSignal(
                version = version,
                zoneId = zoneId,
                mode = mapByteToMode(modeByte),
                flags = flags,
                sequence = sequence,
                ttlSeconds = ttl,
                temperature = temp,
                sourceId = sourceId
            )
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    private fun mapByteToMode(byte: Int): CircuitMode {
        return when (byte) {
            0 -> CircuitMode.NORMAL
            1 -> CircuitMode.SAFETY_CAR // Using SAFETY_CAR as generic "Congestion/Warning" if needed, or update Enum
            2 -> CircuitMode.RED_FLAG
            3 -> CircuitMode.EVACUATION // Correctly mapped now
            else -> CircuitMode.UNKNOWN
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/ble/DetectedBeacon.kt`

```kotlin
package com.georacing.georacing.data.ble

data class DetectedBeacon(
    val id: String,
    val name: String?,
    val rssi: Int,
    val isGeoRacing: Boolean = false,
    val timestamp: Long = System.currentTimeMillis(),
    val circuitMode: com.georacing.georacing.domain.model.CircuitMode? = null // üÜï Added State
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/energy/EnergyMonitor.kt`

```kotlin
package com.georacing.georacing.data.energy

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.BatteryManager
import com.georacing.georacing.debug.ScenarioSimulator
import com.georacing.georacing.domain.model.EnergyProfile
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch

class EnergyMonitor(private val context: Context) {

    private val _energyProfile = MutableStateFlow<EnergyProfile>(EnergyProfile.Performance)
    val energyProfile: StateFlow<EnergyProfile> = _energyProfile.asStateFlow()

    // Internal state for real battery
    private val _realBatteryLevel = MutableStateFlow(100f)

    private var monitoringJob: Job? = null
    private val scope = CoroutineScope(Dispatchers.Default)

    private val batteryReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            intent?.let {
                val level = it.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)
                val scale = it.getIntExtra(BatteryManager.EXTRA_SCALE, -1)
                
                if (level != -1 && scale != -1) {
                    val batteryPct = (level / scale.toFloat()) * 100
                    _realBatteryLevel.value = batteryPct
                }
            }
        }
    }

    fun startMonitoring() {
        val filter = IntentFilter(Intent.ACTION_BATTERY_CHANGED)
        context.registerReceiver(batteryReceiver, filter)

        // Start observing both Real + Simulation
        monitoringJob?.cancel()
        monitoringJob = scope.launch {
            combine(
                _realBatteryLevel,
                ScenarioSimulator.forcedBatteryLevel
            ) { real, forced ->
                val effective = forced?.toFloat() ?: real
                effective
            }.collect { percentage ->
                updateEnergyProfile(percentage)
            }
        }
    }

    fun stopMonitoring() {
        try {
            context.unregisterReceiver(batteryReceiver)
        } catch (e: IllegalArgumentException) {
            // Receiver not registered
        }
        monitoringJob?.cancel()
    }

    private fun updateEnergyProfile(percentage: Float) {
        val newProfile = when {
            percentage > 50 -> EnergyProfile.Performance
            percentage >= 30 -> EnergyProfile.Balanced
            else -> EnergyProfile.Survival
        }

        if (_energyProfile.value != newProfile) {
            _energyProfile.value = newProfile
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/firebase/FirebaseAuthService.kt`

```kotlin
package com.georacing.georacing.data.firebase

import android.util.Log
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import com.google.firebase.auth.GoogleAuthProvider
import kotlinx.coroutines.tasks.await

/**
 * Servicio centralizado para gestionar la autenticaci√≥n con Firebase
 * Soporta login con Google (obligatorio) y fallback a an√≥nimo solo para testing
 */
class FirebaseAuthService {
    private val auth: FirebaseAuth = FirebaseAuth.getInstance()
    
    companion object {
        private const val TAG = "FirebaseAuthService"
    }
    
    /**
     * Obtiene el usuario actualmente autenticado
     */
    fun getCurrentUser(): FirebaseUser? = auth.currentUser
    
    /**
     * Verifica si hay un usuario autenticado
     */
    fun isUserSignedIn(): Boolean = auth.currentUser != null
    
    /**
     * Login con Google usando ID Token
     * Este es el m√©todo PRINCIPAL para usuarios reales
     */
    suspend fun signInWithGoogle(idToken: String): Result<FirebaseUser> {
        return try {
            val credential = GoogleAuthProvider.getCredential(idToken, null)
            val result = auth.signInWithCredential(credential).await()
            val user = result.user
            
            if (user != null) {
                Log.d(TAG, "‚úÖ Login con Google exitoso")
                Log.d(TAG, "   UID: ${user.uid}")
                Log.d(TAG, "   Email: ${user.email}")
                Log.d(TAG, "   Nombre: ${user.displayName}")
                Result.success(user)
            } else {
                Log.e(TAG, "Login con Google fall√≥: usuario nulo")
                Result.failure(Exception("Usuario nulo despu√©s del login"))
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error en login con Google", e)
            Result.failure(e)
        }
    }
    
    /**
     * Login an√≥nimo - SOLO PARA TESTING/DEBUG
     * En producci√≥n, los usuarios DEBEN usar Google Sign-In
     */
    suspend fun signInAnonymously(): Result<FirebaseUser> {
        return try {
            val result = auth.signInAnonymously().await()
            val user = result.user
            
            if (user != null) {
                Log.w(TAG, "‚ö†Ô∏è Login an√≥nimo (solo testing). UID: ${user.uid}")
                Result.success(user)
            } else {
                Log.e(TAG, "Login an√≥nimo fall√≥: usuario nulo")
                Result.failure(Exception("Usuario nulo despu√©s del login"))
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error en login an√≥nimo", e)
            Result.failure(e)
        }
    }
    
    /**
     * Verifica que haya un usuario autenticado con Google
     * En producci√≥n, rechaza usuarios an√≥nimos
     */
    fun requireGoogleSignedIn(): Result<FirebaseUser> {
        val currentUser = getCurrentUser()
        
        return when {
            currentUser == null -> {
                Log.e(TAG, "‚ùå No hay usuario autenticado")
                Result.failure(Exception("Usuario no autenticado. Debe hacer login con Google."))
            }
            currentUser.isAnonymous -> {
                Log.e(TAG, "‚ùå Usuario an√≥nimo no permitido en producci√≥n")
                Result.failure(Exception("Login con Google requerido"))
            }
            else -> {
                Log.d(TAG, "‚úÖ Usuario autenticado con Google: ${currentUser.email}")
                Result.success(currentUser)
            }
        }
    }
    
    /**
     * Asegura que haya un usuario autenticado (fallback a an√≥nimo solo para testing)
     * DEPRECATED en producci√≥n - usar requireGoogleSignedIn()
     */
    @Deprecated("Usar requireGoogleSignedIn() en producci√≥n")
    suspend fun ensureUserSignedIn(): Result<FirebaseUser> {
        val currentUser = getCurrentUser()
        
        return if (currentUser != null) {
            Log.d(TAG, "Usuario ya autenticado: ${currentUser.uid}")
            Result.success(currentUser)
        } else {
            Log.d(TAG, "No hay usuario, realizando login an√≥nimo...")
            signInAnonymously()
        }
    }
    
    /**
     * Cierra la sesi√≥n del usuario actual
     */
    fun signOut() {
        auth.signOut()
        Log.d(TAG, "Sesi√≥n cerrada")
    }
    
    /**
     * Obtiene el UID del usuario actual o null si no est√° autenticado
     */
    fun getCurrentUserId(): String? = auth.currentUser?.uid
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/firebase/FirebaseFirestoreService.kt`

```kotlin
package com.georacing.georacing.data.firebase

import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.SetOptions
import kotlinx.coroutines.tasks.await

/**
 * Servicio centralizado para todas las operaciones con Firestore
 * 
 * COLECCIONES UTILIZADAS:
 * - incidents: Reportes de incidencias del p√∫blico
 * - race_news: Newsletter del circuito (alertas/noticias)
 * - users: Datos de usuarios (opcional para futuro)
 * - test_connection: Para verificar conectividad
 */
class FirebaseFirestoreService {
    private val db: FirebaseFirestore = FirebaseFirestore.getInstance()
    
    companion object {
        private const val TAG = "FirestoreService"
        
        // Nombres de colecciones - Centralizados para consistencia
        const val COLLECTION_INCIDENTS = "incidents"
        const val COLLECTION_RACE_NEWS = "race_news"
        const val COLLECTION_USERS = "users"
        const val COLLECTION_TEST = "test_connection"
    }
    
    /**
     * TEST: Escribe un documento de prueba para verificar conexi√≥n con Firestore
     * Llama esto desde el splash screen o settings para debug
     */
    suspend fun testConnection(): Result<String> {
        return try {
            val testData = hashMapOf(
                "timestamp" to System.currentTimeMillis(),
                "message" to "Conexi√≥n exitosa desde GeoRacing",
                "device" to android.os.Build.MODEL
            )
            
            val docRef = db.collection(COLLECTION_TEST)
                .add(testData)
                .await()
            
            val successMessage = "‚úÖ Firestore conectado OK. Doc ID: ${docRef.id}"
            Log.d(TAG, successMessage)
            Result.success(successMessage)
        } catch (e: Exception) {
            val errorMessage = "‚ùå Error conectando a Firestore: ${e.message}"
            Log.e(TAG, errorMessage, e)
            Result.failure(e)
        }
    }
    
    /**
     * Guarda un documento en una colecci√≥n espec√≠fica
     */
    suspend fun <T> addDocument(
        collection: String,
        data: T
    ): Result<String> {
        return try {
            val docRef = db.collection(collection)
                .add(data as Any)
                .await()
            
            Log.d(TAG, "Documento creado en '$collection': ${docRef.id}")
            Result.success(docRef.id)
        } catch (e: Exception) {
            Log.e(TAG, "Error guardando en '$collection'", e)
            Result.failure(e)
        }
    }
    
    /**
     * Actualiza o crea un documento con un ID espec√≠fico
     */
    suspend fun <T> setDocument(
        collection: String,
        documentId: String,
        data: T,
        merge: Boolean = true
    ): Result<Unit> {
        return try {
            if (merge) {
                db.collection(collection)
                    .document(documentId)
                    .set(data as Any, SetOptions.merge())
                    .await()
            } else {
                db.collection(collection)
                    .document(documentId)
                    .set(data as Any)
                    .await()
            }
            
            Log.d(TAG, "Documento actualizado en '$collection': $documentId")
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Error actualizando '$collection/$documentId'", e)
            Result.failure(e)
        }
    }
    
    /**
     * Lee un documento espec√≠fico
     */
    suspend fun <T> getDocument(
        collection: String,
        documentId: String,
        clazz: Class<T>
    ): Result<T?> {
        return try {
            val snapshot = db.collection(collection)
                .document(documentId)
                .get()
                .await()
            
            val data = snapshot.toObject(clazz)
            Log.d(TAG, "Documento le√≠do de '$collection': $documentId")
            Result.success(data)
        } catch (e: Exception) {
            Log.e(TAG, "Error leyendo '$collection/$documentId'", e)
            Result.failure(e)
        }
    }
    
    /**
     * Lee todos los documentos de una colecci√≥n
     */
    suspend fun <T> getCollection(
        collection: String,
        clazz: Class<T>
    ): Result<List<T>> {
        return try {
            val snapshot = db.collection(collection)
                .get()
                .await()
            
            val items = snapshot.documents.mapNotNull { it.toObject(clazz) }
            Log.d(TAG, "Le√≠dos ${items.size} documentos de '$collection'")
            Result.success(items)
        } catch (e: Exception) {
            Log.e(TAG, "Error leyendo colecci√≥n '$collection'", e)
            Result.failure(e)
        }
    }
    
    /**
     * Elimina un documento
     */
    suspend fun deleteDocument(
        collection: String,
        documentId: String
    ): Result<Unit> {
        return try {
            db.collection(collection)
                .document(documentId)
                .delete()
                .await()
            
            Log.d(TAG, "Documento eliminado de '$collection': $documentId")
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Error eliminando '$collection/$documentId'", e)
            Result.failure(e)
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/firebase/FirebaseInitializer.kt`

```kotlin
package com.georacing.georacing.data.firebase

import android.util.Log
import com.google.firebase.FirebaseApp

/**
 * Clase para inicializar Firebase en el arranque de la app
 * 
 * NOTA: En versiones recientes de Firebase (con google-services.json), 
 * la inicializaci√≥n es AUTOM√ÅTICA. Sin embargo, esta clase permite:
 * 
 * 1. Verificar que Firebase se inicializ√≥ correctamente
 * 2. Hacer login an√≥nimo al inicio (para cumplir reglas de Firestore)
 * 3. Test de conexi√≥n opcional
 */
class FirebaseInitializer {
    
    companion object {
        private const val TAG = "FirebaseInitializer"
        private var isInitialized = false
        
        /**
         * Verifica que Firebase est√© inicializado
         * No es necesario llamar a FirebaseApp.initializeApp() manualmente
         * con google-services.json presente
         */
        fun verifyInitialization(): Boolean {
            return try {
                val app = FirebaseApp.getInstance()
                isInitialized = true
                Log.d(TAG, "‚úÖ Firebase inicializado: ${app.name}")
                true
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Firebase NO inicializado", e)
                false
            }
        }
        
        /**
         * Inicializa la sesi√≥n de usuario con Google
         * SOLO se debe llamar si el usuario ya hizo login con Google
         * @deprecated No usar - el login ahora es manual desde LoginScreen
         */
        @Deprecated("Login manual requerido desde LoginScreen")
        suspend fun initializeSession(): Result<String> {
            val authService = FirebaseAuthService()
            
            return try {
                // Verificar si hay usuario con Google
                val currentUser = authService.getCurrentUser()
                
                if (currentUser != null && !currentUser.isAnonymous) {
                    val message = "‚úÖ Usuario Google: ${currentUser.email}"
                    Log.d(TAG, message)
                    Result.success(message)
                } else {
                    val message = "‚ùå No hay usuario con Google"
                    Log.w(TAG, message)
                    Result.failure(Exception("Login con Google requerido"))
                }
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error verificando sesi√≥n", e)
                Result.failure(e)
            }
        }
        
        /**
         * Funci√≥n de inicializaci√≥n b√°sica de Firebase
         * NO hace login autom√°tico - el usuario debe loguearse desde LoginScreen
         * @param runConnectionTest: hacer test de conexi√≥n a Firestore (solo debug)
         */
        suspend fun initializeFirebase(runConnectionTest: Boolean = false): Result<String> {
            val messages = mutableListOf<String>()
            
            // 1. Verificar inicializaci√≥n de Firebase
            if (!verifyInitialization()) {
                return Result.failure(Exception("Firebase no pudo inicializarse"))
            }
            messages.add("Firebase OK")
            
            // 2. Verificar si hay usuario logueado (opcional)
            val authService = FirebaseAuthService()
            val currentUser = authService.getCurrentUser()
            
            if (currentUser != null && !currentUser.isAnonymous) {
                messages.add("Usuario: ${currentUser.email}")
            } else {
                messages.add("Sin sesi√≥n")
            }
            
            // 3. Test de conexi√≥n opcional (solo para debug)
            if (runConnectionTest) {
                val firestoreService = FirebaseFirestoreService()
                val testResult = firestoreService.testConnection()
                
                if (testResult.isSuccess) {
                    messages.add("Firestore OK")
                } else {
                    Log.w(TAG, "Test de conexi√≥n fall√≥ (no cr√≠tico)", testResult.exceptionOrNull())
                    messages.add("Firestore: test fall√≥")
                }
            }
            
            val finalMessage = messages.joinToString(" | ")
            Log.d(TAG, "üöÄ Inicializaci√≥n: $finalMessage")
            return Result.success(finalMessage)
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/firestorelike/FirestoreLikeApi.kt`

```kotlin
package com.georacing.georacing.data.firestorelike

import retrofit2.http.Body
import retrofit2.http.GET
import retrofit2.http.POST
import retrofit2.http.Query

interface FirestoreLikeApi {

    data class UpsertRequest(
        val table: String,
        val data: Map<String, Any?>
    )

    data class GetRequest(
        val table: String,
        val where: Map<String, Any?>?
    )
    
    data class DeleteRequest(
        val table: String,
        val where: Map<String, Any?>
    )

    // Using Map<String, Any?> for flexibility as requested.
    // Retrofit + Gson will handle map serialization.
    
    @POST("_upsert")
    suspend fun upsert(@Body body: UpsertRequest): Map<String, Any?> 
    // Response type uncertain from spec, usually generic map or success status. 
    // Spec says: "Upsert general ... autogenerar esquema" implies it might return the record/id or just 200.
    // Spec in user request: "suspend fun upsert(...): UpsertResponse". I'll use Any for now or Map.

    @POST("_get")
    suspend fun get(@Body body: GetRequest): List<Map<String, Any?>>

    @GET("_read")
    suspend fun read(@Query("table") table: String): List<Map<String, Any?>>

    @POST("_delete")
    suspend fun delete(@Body body: DeleteRequest): Map<String, Any?>
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/firestorelike/FirestoreLikeClient.kt`

```kotlin
package com.georacing.georacing.data.firestorelike

import com.georacing.georacing.data.remote.ApiClient

object FirestoreLikeClient {
    val api: FirestoreLikeApi by lazy {
        ApiClient.retrofit.create(FirestoreLikeApi::class.java)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/gamification/GamificationRepository.kt`

```kotlin
package com.georacing.georacing.data.gamification

import android.util.Log
import com.georacing.georacing.data.firestorelike.FirestoreLikeApi
import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import com.georacing.georacing.domain.model.Achievement
import com.georacing.georacing.domain.model.AchievementCategory
import com.georacing.georacing.domain.model.FanProfile
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

/**
 * Repositorio de gamificaci√≥n para Circuit de Catalunya.
 * Gestiona logros, XP y nivel del fan.
 * 
 * Persistencia: FirestoreLikeApi (backend real en alpo.myqnapcloud.com:4010)
 * Los logros predefinidos son datos de dise√±o de juego, pero
 * el estado de desbloqueo se persiste al backend.
 */
class GamificationRepository {

    private val scope = CoroutineScope(Dispatchers.IO)

    private val _profile = MutableStateFlow(
        FanProfile(
            totalXP = 0,
            level = 1,
            achievements = allAchievements,
            circuitsVisited = 0,
            kmWalked = 0f,
            friendsInGroup = 0
        )
    )
    val profile: StateFlow<FanProfile> = _profile.asStateFlow()

    init {
        // Cargar estado guardado del backend al inicio
        scope.launch { loadProfile() }
    }

    private suspend fun loadProfile() {
        try {
            val userId = com.google.firebase.auth.FirebaseAuth.getInstance().currentUser?.uid ?: "current_user"
            val req = FirestoreLikeApi.GetRequest("gamification_profile", mapOf("id" to userId))
            val saved = FirestoreLikeClient.api.get(req)
            if (saved.isNotEmpty()) {
                val data = saved.first()
                val savedXP = (data["totalXP"] as? Number)?.toInt() ?: 0
                val unlockedIds = (data["unlockedAchievements"] as? List<*>)?.mapNotNull { it?.toString() } ?: emptyList()

                val updatedAchievements = GamificationRepository.allAchievements.map { achievement ->
                    if (achievement.id in unlockedIds) achievement.copy(isUnlocked = true, progress = 1f, unlockedAt = System.currentTimeMillis())
                    else achievement
                }

                _profile.value = FanProfile(
                    totalXP = savedXP,
                    level = (savedXP / 250) + 1,
                    achievements = updatedAchievements,
                    circuitsVisited = (data["circuitsVisited"] as? Number)?.toInt() ?: 0,
                    kmWalked = (data["kmWalked"] as? Number)?.toFloat() ?: 0f,
                    friendsInGroup = (data["friendsInGroup"] as? Number)?.toInt() ?: 0
                )
            }
        } catch (e: Exception) {
            Log.w("GamificationRepo", "No se pudo cargar perfil del backend: ${e.message}")
        }
    }

    private fun saveProfile() {
        scope.launch {
            try {
                val current = _profile.value
                val userId = com.google.firebase.auth.FirebaseAuth.getInstance().currentUser?.uid ?: "current_user"
                FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                    table = "gamification_profile",
                    data = mapOf(
                        "id" to userId,
                        "totalXP" to current.totalXP,
                        "level" to current.level,
                        "unlockedAchievements" to current.achievements.filter { it.isUnlocked }.map { it.id },
                        "circuitsVisited" to current.circuitsVisited,
                        "kmWalked" to current.kmWalked,
                        "friendsInGroup" to current.friendsInGroup
                    )
                ))
            } catch (e: Exception) {
                Log.w("GamificationRepo", "No se pudo guardar perfil: ${e.message}")
            }
        }
    }

    fun unlockAchievement(id: String) {
        _profile.value = _profile.value.let { current ->
            val updated = current.achievements.map {
                if (it.id == id && !it.isUnlocked) it.copy(isUnlocked = true, progress = 1f, unlockedAt = System.currentTimeMillis())
                else it
            }
            val gained = current.achievements.find { it.id == id }?.xpReward ?: 0
            val newXP = current.totalXP + gained
            current.copy(
                achievements = updated,
                totalXP = newXP,
                level = (newXP / 250) + 1
            )
        }
        saveProfile()
    }

    companion object {
        val allAchievements = listOf(
            // Explorer ‚Äî todos empieza desbloqueados=false, el backend determina el estado real
            Achievement("exp_first_visit", "Primera Visita", "Llega al Circuit de Catalunya", "üèÅ", AchievementCategory.EXPLORER, 100, false, 0f),
            Achievement("exp_all_zones", "Explorador Total", "Visita todas las zonas del circuito", "üó∫Ô∏è", AchievementCategory.EXPLORER, 200, false, 0f),
            Achievement("exp_5km", "Maratoniano", "Camina 5km por el circuito", "üèÉ", AchievementCategory.EXPLORER, 150, false, 0f),
            Achievement("exp_paddock", "Acceso VIP", "Visita el Pit Lane Walk", "‚≠ê", AchievementCategory.EXPLORER, 300, false, 0f),
            // Social
            Achievement("soc_first_group", "En Equipo", "Crea o √∫nete a un grupo", "üë•", AchievementCategory.SOCIAL, 100, false, 0f),
            Achievement("soc_5_friends", "Escuder√≠a Completa", "Ten 5 amigos en tu grupo", "üèéÔ∏è", AchievementCategory.SOCIAL, 200, false, 0f),
            Achievement("soc_share_qr", "Conexi√≥n R√°pida", "Comparte un QR de grupo", "üì±", AchievementCategory.SOCIAL, 50, false, 0f),
            Achievement("soc_moment_shared", "Fot√≥grafo", "Comparte un momento", "üì∏", AchievementCategory.SOCIAL, 100, false, 0f),
            // Speed
            Achievement("spd_first_nav", "GPS Activado", "Usa la navegaci√≥n por primera vez", "üõ∞Ô∏è", AchievementCategory.SPEED, 100, false, 0f),
            Achievement("spd_arrive_fast", "Pole Position", "Llega al circuito antes de las 9:00", "‚è±Ô∏è", AchievementCategory.SPEED, 200, false, 0f),
            Achievement("spd_find_car", "Memoria de Elefante", "Encuentra tu coche con la app", "üöó", AchievementCategory.SPEED, 100, false, 0f),
            // Fan
            Achievement("fan_first_order", "Primera Compra", "Haz tu primer pedido", "üõí", AchievementCategory.FAN, 100, false, 0f),
            Achievement("fan_merch", "Coleccionista", "Compra merchandising oficial", "üëï", AchievementCategory.FAN, 150, false, 0f),
            Achievement("fan_weather_check", "Meteor√≥logo", "Consulta el clima 3 veces", "üå§Ô∏è", AchievementCategory.FAN, 50, false, 0f),
            Achievement("fan_telemetry", "Ingeniero de Datos", "Usa F1 Live m√°s de 10 min", "üìä", AchievementCategory.FAN, 200, false, 0f),
            // Eco
            Achievement("eco_transport", "Movilidad Verde", "Llega en transporte p√∫blico", "üöÜ", AchievementCategory.ECO, 200, false, 0f),
            Achievement("eco_fountain", "Hidrataci√≥n Sostenible", "Usa una fuente del circuito", "üíß", AchievementCategory.ECO, 50, false, 0f),
            // Safety
            Achievement("saf_report", "Ciudadano Responsable", "Reporta una incidencia", "üõ°Ô∏è", AchievementCategory.SAFETY, 100, false, 0f),
            Achievement("saf_emergency", "Preparado", "Configura tu info m√©dica", "üè•", AchievementCategory.SAFETY, 150, false, 0f),
            Achievement("saf_medical", "Prevenci√≥n", "Revisa la pantalla de emergencia", "üÜò", AchievementCategory.SAFETY, 50, false, 0f)
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/health/FakeHealthConnectManager.kt`

```kotlin
package com.georacing.georacing.data.health

import android.content.Context
import android.util.Log
import com.georacing.georacing.debug.ScenarioSimulator
import kotlinx.coroutines.flow.firstOrNull
import java.time.Instant

/**
 * Fake implementation of HealthConnectManager for Demo/Mock purposes.
 * Always returns true for availability/permissions and returns simulated data.
 */
class FakeHealthConnectManager(context: Context) : HealthConnectManager(context) {

    companion object {
        private const val TAG = "FakeHealthConnectManager"
        private const val BASE_STEPS = 8432L
        private const val BASE_DISTANCE = 5800.0 // 5.8 km
    }

    override fun isAvailable(): Boolean {
        return true
    }

    override suspend fun hasPermissions(): Boolean {
        // Always return true so the UI never asks for permissions
        return true
    }

    override suspend fun readDailyMetrics(startTime: Instant?): DailyMetrics {
        // Simulate "Live" feel with slight randomness
        // Random between 8400 and 8500
        val steps = kotlin.random.Random.nextLong(8400, 8500)
        
        // Add any extra steps injected via Simulator
        val extraSteps = ScenarioSimulator.extraFakeSteps.value
        val totalSteps = steps + extraSteps
        val totalDistance = BASE_DISTANCE + (extraSteps * 0.7) // consistent distance for base + extra

        Log.d(TAG, "Serving Fake Metrics (Live): Steps=$totalSteps, Dist=$totalDistance")
        return DailyMetrics(
            steps = totalSteps,
            distanceMeters = totalDistance
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/health/HealthConnectManager.kt`

```kotlin
package com.georacing.georacing.data.health

import android.content.Context
import android.util.Log
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.DistanceRecord
import androidx.health.connect.client.records.StepsRecord
import androidx.health.connect.client.request.AggregateRequest
import androidx.health.connect.client.time.TimeRangeFilter
import java.time.LocalDate
import java.time.ZoneId
import java.time.Instant

/**
 * Industrial-grade Health Connect manager for on-demand step reading.
 * 
 * Design Principles:
 * - Energy-First: No background listeners, only on-demand reads.
 * - Graceful Degradation: Returns 0 if unavailable/denied.
 */
open class HealthConnectManager(private val context: Context) {

    companion object {
        private const val TAG = "HealthConnectManager"
        val PERMISSIONS = setOf(
            HealthPermission.getReadPermission(StepsRecord::class),
            HealthPermission.getReadPermission(DistanceRecord::class)
        )

        fun getPermissionRequestContract() = androidx.health.connect.client.PermissionController.createRequestPermissionResultContract()
    }

    data class DailyMetrics(
        val steps: Long = 0,
        val distanceMeters: Double = 0.0
    )

    private val healthConnectClient: HealthConnectClient? by lazy {
        try {
            if (isAvailable()) {
                HealthConnectClient.getOrCreate(context)
            } else null
        } catch (e: Exception) {
            Log.w(TAG, "Health Connect client creation failed", e)
            null
        }
    }

    /**
     * Checks if Health Connect is available on this device.
     */
    open fun isAvailable(): Boolean {
        return try {
            HealthConnectClient.getSdkStatus(context) == HealthConnectClient.SDK_AVAILABLE
        } catch (e: Exception) {
            Log.w(TAG, "Health Connect availability check failed", e)
            false
        }
    }

    /**
     * Checks if required permissions are granted.
     */
    open suspend fun hasPermissions(): Boolean {
        return try {
            val client = healthConnectClient ?: return false
            val granted = client.permissionController.getGrantedPermissions()
            granted.containsAll(PERMISSIONS)
        } catch (e: Exception) {
            Log.w(TAG, "Permission check failed", e)
            false
        }
    }

    /**
     * Reads today's total steps and distance on-demand.
     * @param startTime Optional start time to filter metrics (e.g., circuit arrival time)
     */
    open suspend fun readDailyMetrics(startTime: Instant? = null): DailyMetrics {
        return try {
            if (!isAvailable() || !hasPermissions()) {
                return DailyMetrics()
            }

            val client = healthConnectClient ?: return DailyMetrics()

            val today = LocalDate.now()
            val startOfDay = today.atStartOfDay(ZoneId.systemDefault()).toInstant()
            val endOfDay = today.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant()
            
            // Use provided startTime if it's after startOfDay, otherwise fallback to startOfDay
            val filterStart = if (startTime != null && startTime.isAfter(startOfDay)) startTime else startOfDay

            val response = client.aggregate(
                AggregateRequest(
                    metrics = setOf(
                        StepsRecord.COUNT_TOTAL,
                        DistanceRecord.DISTANCE_TOTAL
                    ),
                    timeRangeFilter = TimeRangeFilter.between(filterStart, endOfDay)
                )
            )

            val steps = response[StepsRecord.COUNT_TOTAL] ?: 0L
            val distance = response[DistanceRecord.DISTANCE_TOTAL]?.inMeters ?: 0.0

            Log.d(TAG, "Metrics: Steps=$steps, Dist=$distance")
            DailyMetrics(steps, distance)

        } catch (e: Exception) {
            Log.e(TAG, "Error reading daily metrics", e)
            DailyMetrics()
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/Converters.kt`

```kotlin
package com.georacing.georacing.data.local

import androidx.room.TypeConverter
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken

/**
 * Room TypeConverters para tipos complejos.
 * Convierte listas y objetos a/desde String para almacenamiento en SQLite.
 */
class Converters {

    private val gson = Gson()

    /**
     * Convierte List<String> a String JSON para almacenar en Room.
     */
    @TypeConverter
    fun fromStringList(value: List<String>?): String? {
        return value?.let { gson.toJson(it) }
    }

    /**
     * Convierte String JSON de vuelta a List<String>.
     */
    @TypeConverter
    fun toStringList(value: String?): List<String>? {
        if (value == null) return null
        val type = object : TypeToken<List<String>>() {}.type
        return gson.fromJson(value, type)
    }

    /**
     * Alternativa simple: Lista separada por comas (m√°s eficiente para listas peque√±as).
     */
    @TypeConverter
    fun fromCommaSeparated(value: String?): List<String> {
        return value?.split(",")?.map { it.trim() } ?: emptyList()
    }

    @TypeConverter
    fun toCommaSeparated(list: List<String>?): String {
        return list?.joinToString(",") ?: ""
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/GeoRacingDatabase.kt`

```kotlin
package com.georacing.georacing.data.local

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import com.georacing.georacing.data.local.dao.BeaconDao
import com.georacing.georacing.data.local.dao.CircuitStateDao
import com.georacing.georacing.data.local.dao.MedicalInfoDao
import com.georacing.georacing.data.local.dao.PoiDao
import com.georacing.georacing.data.local.entities.BeaconEntity
import com.georacing.georacing.data.local.entities.CircuitStateEntity
import com.georacing.georacing.data.local.entities.MedicalInfoEntity
import com.georacing.georacing.data.local.entities.PoiEntity
import com.georacing.georacing.data.local.entities.TelemetryEntity

/**
 * Base de Datos principal de GeoRacing (Room).
 * 
 * Implementa el patr√≥n Singleton para garantizar una √∫nica instancia.
 * Contiene las tablas para POIs, Estado del Circuito, Beacons e Info M√©dica.
 * 
 * Uso:
 * ```
 * val database = GeoRacingDatabase.getInstance(context)
 * val pois = database.poiDao().getAllPois()
 * ```
 */
@Database(
    entities = [
        PoiEntity::class,
        CircuitStateEntity::class,
        BeaconEntity::class,
        MedicalInfoEntity::class,
        com.georacing.georacing.data.local.entities.IncidentEntity::class, // üÜï
        TelemetryEntity::class // Phase 5 BlackBox
    ],
    version = 4, // üÜï Incremented for Telemetry
    exportSchema = false
)
@TypeConverters(Converters::class)
abstract class GeoRacingDatabase : RoomDatabase() {

    // =========================================================================
    // DAOs
    // =========================================================================
    
    abstract fun poiDao(): PoiDao
    abstract fun circuitStateDao(): CircuitStateDao
    abstract fun beaconDao(): BeaconDao
    abstract fun medicalInfoDao(): MedicalInfoDao
    abstract fun incidentDao(): com.georacing.georacing.data.local.dao.IncidentDao // üÜï 
    abstract fun telemetryDao(): com.georacing.georacing.data.local.dao.TelemetryDao 


    // =========================================================================
    // Singleton Pattern
    // =========================================================================
    
    companion object {
        private const val DATABASE_NAME = "georacing_db"

        @Volatile
        private var INSTANCE: GeoRacingDatabase? = null

        /**
         * Obtiene la instancia √∫nica de la base de datos.
         * Thread-safe usando double-checked locking.
         * 
         * @param context Application context (se usa applicationContext internamente)
         * @return Instancia singleton de GeoRacingDatabase
         */
        fun getInstance(context: Context): GeoRacingDatabase {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: buildDatabase(context.applicationContext).also {
                    INSTANCE = it
                }
            }
        }

        private fun buildDatabase(context: Context): GeoRacingDatabase {
            return Room.databaseBuilder(
                context,
                GeoRacingDatabase::class.java,
                DATABASE_NAME
            )
                // Estrategia de migraci√≥n: destruir y recrear si hay cambio de schema
                // En producci√≥n, usar migraciones apropiadas
                .fallbackToDestructiveMigration()
                // Permitir queries en main thread solo para debugging
                // .allowMainThreadQueries() // NO USAR en producci√≥n
                .build()
        }

        /**
         * Cierra la base de datos (√∫til para tests).
         */
        fun closeDatabase() {
            INSTANCE?.close()
            INSTANCE = null
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/UserPreferencesDataStore.kt`

```kotlin
package com.georacing.georacing.data.local

import android.content.Context
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.booleanPreferencesKey
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.stringPreferencesKey
import androidx.datastore.preferences.preferencesDataStore
import com.georacing.georacing.domain.model.SeatInfo
import com.google.gson.Gson
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "user_prefs")

class UserPreferencesDataStore(private val context: Context) {

    private val gson = Gson()

    val activeGroupId: Flow<String?> = context.dataStore.data.map { it[ACTIVE_GROUP_ID] }
    val seatInfo: Flow<SeatInfo?> = context.dataStore.data.map { prefs ->
        val json = prefs[SEAT_INFO]
        if (json != null) {
            try {
                gson.fromJson(json, SeatInfo::class.java)
            } catch (e: Exception) { null }
        } else null
    }
    val onboardingCompleted: Flow<Boolean> = context.dataStore.data.map { it[ONBOARDING_COMPLETED] ?: false }
    val preferredLanguage: Flow<String> = context.dataStore.data.map { it[PREFERRED_LANGUAGE] ?: "es" }
    val highContrast: Flow<Boolean> = context.dataStore.data.map { it[HIGH_CONTRAST] ?: false }
    val largeFont: Flow<Boolean> = context.dataStore.data.map { it[LARGE_FONT] ?: false }
    val avoidStairs: Flow<Boolean> = context.dataStore.data.map { it[AVOID_STAIRS] ?: false }
    val favoriteTeam: Flow<String> = context.dataStore.data.map { it[FAVORITE_TEAM] ?: "NONE" }
    
    // EcoMeter: Timestamp when the user arrived at the circuit
    val circuitArrivalTime: Flow<Long?> = context.dataStore.data.map { it[CIRCUIT_ARRIVAL_TIME] }

    suspend fun setActiveGroupId(groupId: String?) {
        context.dataStore.edit { prefs ->
            if (groupId == null) {
                prefs.remove(ACTIVE_GROUP_ID)
            } else {
                prefs[ACTIVE_GROUP_ID] = groupId
            }
        }
    }

    suspend fun setSeatInfo(info: SeatInfo?) {
        context.dataStore.edit { prefs ->
            if (info == null) {
                prefs.remove(SEAT_INFO)
            } else {
                prefs[SEAT_INFO] = gson.toJson(info)
            }
        }
    }

    suspend fun setOnboardingCompleted(completed: Boolean) {
        context.dataStore.edit { it[ONBOARDING_COMPLETED] = completed }
    }

    suspend fun setPreferredLanguage(lang: String) {
        context.dataStore.edit { it[PREFERRED_LANGUAGE] = lang }
    }

    suspend fun setHighContrast(enabled: Boolean) {
        context.dataStore.edit { it[HIGH_CONTRAST] = enabled }
    }

    suspend fun setLargeFont(enabled: Boolean) {
        context.dataStore.edit { it[LARGE_FONT] = enabled }
    }

    suspend fun setAvoidStairs(enabled: Boolean) {
        context.dataStore.edit { it[AVOID_STAIRS] = enabled }
    }

    suspend fun setFavoriteTeam(team: String) {
        context.dataStore.edit { it[FAVORITE_TEAM] = team }
    }

    suspend fun setCircuitArrivalTime(timeMs: Long?) {
        context.dataStore.edit { prefs ->
            if (timeMs == null) prefs.remove(CIRCUIT_ARRIVAL_TIME)
            else prefs[CIRCUIT_ARRIVAL_TIME] = timeMs
        }
    }

    val dashboardLayout: Flow<List<com.georacing.georacing.domain.model.WidgetType>> = context.dataStore.data.map { prefs ->
        val output = prefs[DASHBOARD_LAYOUT]
        if (output != null) {
            try {
                output.split(",").mapNotNull { 
                    try { com.georacing.georacing.domain.model.WidgetType.valueOf(it) } catch (e: Exception) { null } 
                }
            } catch (e: Exception) {
                com.georacing.georacing.domain.model.DashboardLayout.DEFAULT.widgets
            }
        } else {
             com.georacing.georacing.domain.model.DashboardLayout.DEFAULT.widgets
        }
    }

    suspend fun setDashboardLayout(widgets: List<com.georacing.georacing.domain.model.WidgetType>) {
        context.dataStore.edit { prefs ->
            prefs[DASHBOARD_LAYOUT] = widgets.joinToString(",") { it.name }
        }
    }

    companion object {
        val ONBOARDING_COMPLETED = booleanPreferencesKey("onboarding_completed")
        val PREFERRED_LANGUAGE = stringPreferencesKey("preferred_language")
        val SEAT_INFO = stringPreferencesKey("seat_info")
        val HIGH_CONTRAST = booleanPreferencesKey("high_contrast")
        val LARGE_FONT = booleanPreferencesKey("large_font")
        val AVOID_STAIRS = booleanPreferencesKey("avoid_stairs")
        val FAVORITE_TEAM = stringPreferencesKey("favorite_team")
        val ACTIVE_GROUP_ID = stringPreferencesKey("active_group_id")
        val DASHBOARD_LAYOUT = stringPreferencesKey("dashboard_layout")
        val CIRCUIT_ARRIVAL_TIME = androidx.datastore.preferences.core.longPreferencesKey("circuit_arrival_time")
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/dao/BeaconDao.kt`

```kotlin
package com.georacing.georacing.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.georacing.georacing.data.local.entities.BeaconEntity
import kotlinx.coroutines.flow.Flow

/**
 * DAO para Configuraci√≥n de Beacons BLE.
 * Cachea los datos de las balizas del circuito.
 */
@Dao
interface BeaconDao {

    /**
     * Observa todos los beacons.
     * La UI puede reaccionar autom√°ticamente a cambios.
     */
    @Query("SELECT * FROM beacons ORDER BY zone, name")
    fun getAllBeacons(): Flow<List<BeaconEntity>>

    /**
     * Obtiene beacons filtrados por zona.
     */
    @Query("SELECT * FROM beacons WHERE zone = :zone ORDER BY name")
    fun getBeaconsByZone(zone: String): Flow<List<BeaconEntity>>

    /**
     * Obtiene un beacon por ID.
     */
    @Query("SELECT * FROM beacons WHERE id = :beaconId LIMIT 1")
    suspend fun getBeaconById(beaconId: String): BeaconEntity?

    /**
     * Inserta o actualiza una lista de beacons.
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertBeacons(beacons: List<BeaconEntity>)

    /**
     * Inserta o actualiza un solo beacon.
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertBeacon(beacon: BeaconEntity)

    /**
     * Elimina todos los beacons (limpia cach√©).
     */
    @Query("DELETE FROM beacons")
    suspend fun deleteAll()

    /**
     * Cuenta el n√∫mero de beacons en cach√©.
     */
    @Query("SELECT COUNT(*) FROM beacons")
    suspend fun count(): Int
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/dao/CircuitStateDao.kt`

```kotlin
package com.georacing.georacing.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.georacing.georacing.data.local.entities.CircuitStateEntity
import kotlinx.coroutines.flow.Flow

/**
 * DAO para el Estado Global del Circuito.
 * Maneja una tabla singleton (1 sola fila, ID=1).
 */
@Dao
interface CircuitStateDao {

    /**
     * Observa el estado actual del circuito.
     * Emite autom√°ticamente cuando cambia el modo, clima, etc.
     */
    @Query("SELECT * FROM circuit_state WHERE id = 1 LIMIT 1")
    fun getState(): Flow<CircuitStateEntity?>

    /**
     * Obtiene el estado de forma s√≠ncrona (para uso puntual).
     */
    @Query("SELECT * FROM circuit_state WHERE id = 1 LIMIT 1")
    suspend fun getStateOnce(): CircuitStateEntity?

    /**
     * Inserta o actualiza el estado del circuito.
     * Como siempre usamos ID=1, REPLACE garantiza que solo haya 1 fila.
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertState(state: CircuitStateEntity)

    /**
     * Elimina el estado (reset de cach√©).
     */
    @Query("DELETE FROM circuit_state")
    suspend fun deleteState()

    /**
     * Verifica si hay estado en cach√©.
     */
    @Query("SELECT COUNT(*) FROM circuit_state")
    suspend fun hasState(): Int
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/dao/IncidentDao.kt`

```kotlin
package com.georacing.georacing.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.georacing.georacing.data.local.entities.IncidentEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface IncidentDao {
    @Query("SELECT * FROM incidents ORDER BY timestamp DESC")
    fun getAllIncidents(): Flow<List<IncidentEntity>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertIncident(incident: IncidentEntity)

    @Query("SELECT * FROM incidents WHERE isSynced = 0")
    suspend fun getUnsyncedIncidents(): List<IncidentEntity>

    @Query("UPDATE incidents SET isSynced = 1 WHERE id = :id")
    suspend fun markAsSynced(id: String)
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/dao/MedicalInfoDao.kt`

```kotlin
package com.georacing.georacing.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.georacing.georacing.data.local.entities.MedicalInfoEntity
import kotlinx.coroutines.flow.Flow

/**
 * DAO para Informaci√≥n M√©dica del Usuario.
 * Maneja una tabla singleton (1 sola fila, ID=1).
 */
@Dao
interface MedicalInfoDao {

    /**
     * Observa la informaci√≥n m√©dica del usuario.
     * Emite autom√°ticamente cuando se actualiza.
     */
    @Query("SELECT * FROM medical_info WHERE id = 1 LIMIT 1")
    fun getMedicalInfo(): Flow<MedicalInfoEntity?>

    /**
     * Obtiene la informaci√≥n m√©dica de forma s√≠ncrona.
     */
    @Query("SELECT * FROM medical_info WHERE id = 1 LIMIT 1")
    suspend fun getMedicalInfoOnce(): MedicalInfoEntity?

    /**
     * Inserta o actualiza la informaci√≥n m√©dica.
     * Como siempre usamos ID=1, REPLACE garantiza solo 1 fila.
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun saveMedicalInfo(info: MedicalInfoEntity)

    /**
     * Verifica si hay informaci√≥n m√©dica guardada.
     */
    @Query("SELECT COUNT(*) FROM medical_info")
    suspend fun hasMedicalInfo(): Int

    /**
     * Elimina la informaci√≥n m√©dica (reset).
     */
    @Query("DELETE FROM medical_info")
    suspend fun deleteMedicalInfo()
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/dao/PoiDao.kt`

```kotlin
package com.georacing.georacing.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.georacing.georacing.data.local.entities.PoiEntity
import kotlinx.coroutines.flow.Flow

/**
 * DAO para Puntos de Inter√©s (POIs).
 * Proporciona acceso reactivo a la tabla 'pois' usando Flow.
 */
@Dao
interface PoiDao {

    /**
     * Observa todos los POIs en la base de datos.
     * Emite autom√°ticamente cuando hay cambios (INSERT, UPDATE, DELETE).
     */
    @Query("SELECT * FROM pois ORDER BY zone, name")
    fun getAllPois(): Flow<List<PoiEntity>>

    /**
     * Obtiene POIs filtrados por tipo.
     */
    @Query("SELECT * FROM pois WHERE type = :type ORDER BY name")
    fun getPoisByType(type: String): Flow<List<PoiEntity>>

    /**
     * Obtiene un POI espec√≠fico por ID.
     */
    @Query("SELECT * FROM pois WHERE id = :poiId LIMIT 1")
    suspend fun getPoiById(poiId: String): PoiEntity?

    /**
     * Inserta o actualiza una lista de POIs.
     * REPLACE: Si el ID ya existe, actualiza la fila completa.
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertPois(pois: List<PoiEntity>)

    /**
     * Inserta o actualiza un solo POI.
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertPoi(poi: PoiEntity)

    /**
     * Elimina todos los POIs (limpia cach√©).
     */
    @Query("DELETE FROM pois")
    suspend fun deleteAll()

    /**
     * Cuenta el n√∫mero de POIs en cach√©.
     */
    @Query("SELECT COUNT(*) FROM pois")
    suspend fun count(): Int
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/dao/TelemetryDao.kt`

```kotlin
package com.georacing.georacing.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.georacing.georacing.data.local.entities.TelemetryEntity

/**
 * Data Access Object para los eventos de la Caja Negra.
 */
@Dao
interface TelemetryDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertLog(log: TelemetryEntity)

    @Query("SELECT * FROM telemetry_logs ORDER BY timestamp ASC")
    suspend fun getAllLogs(): List<TelemetryEntity>

    @Query("DELETE FROM telemetry_logs")
    suspend fun clearLogs()
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/entities/BeaconEntity.kt`

```kotlin
package com.georacing.georacing.data.local.entities

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Room Entity para Configuraci√≥n de Beacons (BLE).
 * Cachea los datos de las balizas f√≠sicas instaladas en el circuito.
 * Alineado con el esquema del Panel Metropolis.
 */
@Entity(tableName = "beacons")
data class BeaconEntity(
    @PrimaryKey
    val id: String,
    val beaconUid: String = "",
    val name: String,
    val zone: String,
    val mapX: Float = 0f,
    val mapY: Float = 0f,
    val latitude: Double = 0.0,
    val longitude: Double = 0.0,
    val messageNormal: String = "",
    val messageEmergency: String = "",
    val message: String = "",
    val arrowDirection: String = "NONE",
    val mode: String = "NORMAL",
    val color: String = "#00FF00",
    val brightness: Int = 100,
    val batteryLevel: Int = 100,
    val isOnline: Boolean = true,
    val hasScreen: Boolean = false,
    val lastUpdated: Long = System.currentTimeMillis()
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/entities/CircuitStateEntity.kt`

```kotlin
package com.georacing.georacing.data.local.entities

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Room Entity para el Estado Global del Circuito.
 * Esta tabla tiene UNA SOLA FILA (singleton pattern).
 * ID fijo = 1 para garantizar actualizaci√≥n en lugar de inserci√≥n m√∫ltiple.
 */
@Entity(tableName = "circuit_state")
data class CircuitStateEntity(
    @PrimaryKey
    val id: Int = SINGLETON_ID,
    val mode: String,           // "NORMAL", "SAFETY_CAR", "RED_FLAG", "EVACUATION", "UNKNOWN"
    val message: String?,
    val temperature: String?,
    val humidity: String? = null,
    val wind: String? = null,
    val forecast: String? = null,
    val updatedAt: String,
    val lastSynced: Long = System.currentTimeMillis()
) {
    companion object {
        const val SINGLETON_ID = 1
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/entities/IncidentEntity.kt`

```kotlin
package com.georacing.georacing.data.local.entities

import androidx.room.Entity
import androidx.room.PrimaryKey
import com.georacing.georacing.domain.model.IncidentCategory

@Entity(tableName = "incidents")
data class IncidentEntity(
    @PrimaryKey
    val id: String, // UUID generated
    val category: String, // Stored as name
    val description: String,
    val beaconId: String?,
    val zone: String?,
    val timestamp: Long,
    val isSynced: Boolean = false // Sync flag
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/entities/MedicalInfoEntity.kt`

```kotlin
package com.georacing.georacing.data.local.entities

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Room Entity para Informaci√≥n M√©dica del Usuario.
 * Tabla singleton (1 fila) con datos vitales para emergencias.
 * 
 * Usado para generar el Lock Screen m√©dico con QR + datos vitales.
 */
@Entity(tableName = "medical_info")
data class MedicalInfoEntity(
    @PrimaryKey
    val id: Int = SINGLETON_ID,
    
    /** Grupo sangu√≠neo (A+, A-, B+, B-, AB+, AB-, O+, O-) */
    val bloodType: String? = null,
    
    /** Alergias conocidas (medicamentos, alimentos, etc.) */
    val allergies: String? = null,
    
    /** Condiciones m√©dicas relevantes (diabetes, epilepsia, etc.) */
    val medicalConditions: String? = null,
    
    /** Nombre del contacto de emergencia */
    val emergencyContactName: String? = null,
    
    /** Tel√©fono del contacto de emergencia */
    val emergencyContactPhone: String? = null,
    
    /** Notas adicionales para personal m√©dico */
    val medicalNotes: String? = null,
    
    /** Timestamp de √∫ltima actualizaci√≥n */
    val lastUpdated: Long = System.currentTimeMillis()
) {
    companion object {
        const val SINGLETON_ID = 1
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/entities/PoiEntity.kt`

```kotlin
package com.georacing.georacing.data.local.entities

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Room Entity para Puntos de Inter√©s (POIs).
 * Cachea la informaci√≥n de lugares importantes del circuito.
 */
@Entity(tableName = "pois")
data class PoiEntity(
    @PrimaryKey
    val id: String,
    val name: String,
    val type: String,           // Stored as String, converted to PoiType in domain
    val description: String,
    val zone: String,
    val mapX: Float,
    val mapY: Float,
    val latitude: Double = 0.0,
    val longitude: Double = 0.0,
    val lastUpdated: Long = System.currentTimeMillis()
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/entities/TelemetryEntity.kt`

```kotlin
package com.georacing.georacing.data.local.entities

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Entidad que representa un evento cr√≠tico en la "Caja Negra" (BlackBox).
 * Se almacenan localmente y se env√≠an al servidor cuando hay red disponible.
 */
@Entity(tableName = "telemetry_logs")
data class TelemetryEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val timestamp: Long,
    val eventType: String, // e.g., "NETWORK_DROP", "BLE_TIMEOUT", "APP_CRASH_RECOVER"
    val metadata: String   // JSON or extra info
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/local/mappers/Mappers.kt`

```kotlin
package com.georacing.georacing.data.local.mappers

import com.georacing.georacing.data.local.entities.BeaconEntity
import com.georacing.georacing.data.local.entities.CircuitStateEntity
import com.georacing.georacing.data.local.entities.PoiEntity
import com.georacing.georacing.data.remote.dto.BeaconConfigDto
import com.georacing.georacing.data.remote.dto.CircuitStateDto
import com.georacing.georacing.data.remote.dto.PoiDto
import com.georacing.georacing.domain.model.ArrowDirection
import com.georacing.georacing.domain.model.BeaconConfig
import com.georacing.georacing.domain.model.BeaconMode
import com.georacing.georacing.domain.model.CircuitMode
import com.georacing.georacing.domain.model.CircuitState
import com.georacing.georacing.domain.model.Poi
import com.georacing.georacing.domain.model.PoiType

// =============================================================================
// POI MAPPERS
// =============================================================================

/**
 * DTO -> Entity (Network to Local Cache)
 */
fun PoiDto.toEntity(): PoiEntity = PoiEntity(
    id = id,
    name = name,
    type = type,
    description = description,
    zone = zone,
    mapX = mapX,
    mapY = mapY,
    latitude = 0.0,  // Not in DTO, will be enriched later if needed
    longitude = 0.0
)

/**
 * Entity -> Domain (Local Cache to UI)
 */
fun PoiEntity.toDomain(): Poi = Poi(
    id = id,
    name = name,
    type = type.toPoiType(),
    description = description,
    zone = zone,
    mapX = mapX,
    mapY = mapY,
    latitude = latitude,
    longitude = longitude
)

/**
 * Domain -> Entity (for manual inserts if needed)
 */
fun Poi.toEntity(): PoiEntity = PoiEntity(
    id = id,
    name = name,
    type = type.name,
    description = description,
    zone = zone,
    mapX = mapX,
    mapY = mapY,
    latitude = latitude,
    longitude = longitude
)

private fun String.toPoiType(): PoiType = try {
    PoiType.valueOf(this.uppercase())
} catch (e: Exception) {
    PoiType.OTHER
}

// =============================================================================
// CIRCUIT STATE MAPPERS
// =============================================================================

/**
 * DTO -> Entity (Network to Local Cache)
 */
fun CircuitStateDto.toEntity(): CircuitStateEntity = CircuitStateEntity(
    id = CircuitStateEntity.SINGLETON_ID,
    mode = (global_mode ?: mode) ?: "UNKNOWN",
    message = message,
    temperature = temperature,
    humidity = humidity,
    wind = wind,
    forecast = forecast,
    updatedAt = last_updated ?: ""
)

/**
 * Entity -> Domain (Local Cache to UI)
 */
/**
 * Entity -> Domain (Local Cache to UI)
 */
fun CircuitStateEntity.toDomain(): CircuitState = CircuitState(
    mode = mode.toCircuitMode(),
    message = message,
    temperature = temperature,
    updatedAt = updatedAt,
    humidity = humidity,
    wind = wind,
    forecast = forecast,
    sessionInfo = null
)

/**
 * Domain -> Entity (for manual updates)
 */
fun CircuitState.toEntity(): CircuitStateEntity = CircuitStateEntity(
    id = CircuitStateEntity.SINGLETON_ID,
    mode = mode.name,
    message = message,
    temperature = temperature,
    humidity = humidity,
    wind = wind,
    forecast = forecast,
    updatedAt = updatedAt
)

private fun String.toCircuitMode(): CircuitMode = when (this.uppercase()) {
    "NORMAL" -> CircuitMode.NORMAL
    "GREEN_FLAG", "GREEN" -> CircuitMode.GREEN_FLAG
    "YELLOW_FLAG", "YELLOW" -> CircuitMode.YELLOW_FLAG
    "SAFETY_CAR", "SC" -> CircuitMode.SAFETY_CAR
    "VSC" -> CircuitMode.VSC
    "RED_FLAG", "RED" -> CircuitMode.RED_FLAG
    "EVACUATION" -> CircuitMode.EVACUATION
    else -> CircuitMode.UNKNOWN
}

// =============================================================================
// BEACON CONFIG MAPPERS
// =============================================================================

/**
 * DTO -> Entity (Network to Local Cache)
 */
fun BeaconConfigDto.toEntity(): BeaconEntity = BeaconEntity(
    id = id ?: beaconUid ?: "",
    beaconUid = beaconUid ?: id ?: "",
    name = name ?: "",
    zone = zone ?: (zoneId?.toString() ?: ""),
    mapX = mapX ?: latitude?.toFloat() ?: 0f,
    mapY = mapY ?: longitude?.toFloat() ?: 0f,
    latitude = latitude ?: mapX?.toDouble() ?: 0.0,
    longitude = longitude ?: mapY?.toDouble() ?: 0.0,
    messageNormal = messageNormal ?: message ?: "",
    messageEmergency = messageEmergency ?: message ?: "",
    message = message ?: messageNormal ?: "",
    arrowDirection = arrowDirection ?: "NONE",
    mode = mode ?: "NORMAL",
    color = color ?: "#00FF00",
    brightness = brightness ?: 100,
    batteryLevel = batteryLevel ?: 100,
    isOnline = isOnline ?: true,
    hasScreen = hasScreen ?: false
)

/**
 * Entity -> Domain (Local Cache to UI)
 */
fun BeaconEntity.toDomain(): BeaconConfig = BeaconConfig(
    id = id,
    beaconUid = beaconUid,
    name = name,
    zone = zone,
    mapX = mapX,
    mapY = mapY,
    latitude = latitude,
    longitude = longitude,
    messageNormal = messageNormal,
    messageEmergency = messageEmergency,
    message = message,
    arrowDirection = arrowDirection.toArrowDirection(),
    mode = mode.toBeaconMode(),
    color = color,
    brightness = brightness,
    batteryLevel = batteryLevel,
    isOnline = isOnline,
    hasScreen = hasScreen
)

/**
 * Domain -> Entity (for manual inserts)
 */
fun BeaconConfig.toEntity(): BeaconEntity = BeaconEntity(
    id = id,
    beaconUid = beaconUid,
    name = name,
    zone = zone,
    mapX = mapX,
    mapY = mapY,
    latitude = latitude,
    longitude = longitude,
    messageNormal = messageNormal,
    messageEmergency = messageEmergency,
    message = message,
    arrowDirection = arrowDirection.name,
    mode = mode.name,
    color = color,
    brightness = brightness,
    batteryLevel = batteryLevel,
    isOnline = isOnline,
    hasScreen = hasScreen
)

private fun String.toArrowDirection(): ArrowDirection = try {
    ArrowDirection.valueOf(this.uppercase())
} catch (e: Exception) {
    ArrowDirection.NONE
}

private fun String.toBeaconMode(): BeaconMode = try {
    BeaconMode.valueOf(this.uppercase())
} catch (e: Exception) {
    BeaconMode.NORMAL
}

// =============================================================================
// BATCH MAPPERS (for list operations)
// =============================================================================

fun List<PoiDto>.toEntities(): List<PoiEntity> = map { it.toEntity() }
fun List<PoiEntity>.toDomainPois(): List<Poi> = map { it.toDomain() }

fun List<BeaconConfigDto>.toBeaconEntities(): List<BeaconEntity> = map { it.toEntity() }
fun List<BeaconEntity>.toDomainBeacons(): List<BeaconConfig> = map { it.toDomain() }

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/map/MapLibreConfig.kt`

```kotlin
package com.georacing.georacing.data.map

import org.maplibre.android.geometry.LatLng

/**
 * Configuraci√≥n centralizada para MapLibre
 * Versi√≥n unificada (data + ui merged)
 */
object MapLibreConfig {
    
    /**
     * Estilo h√≠brido ortofoto de Catalunya (perfecto para el circuito).
     * Fuente gratuita del ICGC.
     */
    const val SATELLITE_STYLE_URL = "https://geoserveis.icgc.cat/contextmaps/icgc_orto_hibrida.json"
    const val DEFAULT_STYLE_URL = "https://demotiles.maplibre.org/style.json"
    const val FALLBACK_STYLE_URL = DEFAULT_STYLE_URL

    /**
     * Assets
     */
    const val OFFLINE_STYLE_ASSET = "circuit_catalunya_style.json"
    const val ROUTES_GEOJSON_ASSET = "circuit_routes.geojson"
    const val POIS_GEOJSON_ASSET = "circuit_pois.geojson"

    const val POI_LAYER_ID = "circuit_pois_layer"
    const val POI_SOURCE_ID = "circuit_pois_source"
    
    const val POI_COLOR_DEFAULT = "#6C5CE7"
    const val POI_COLOR_WC = "#1E90FF"
    const val POI_COLOR_FOOD = "#E17055"
    const val POI_COLOR_MERCH = "#FDCB6E"
    const val POI_COLOR_INFO = "#00B894"
    const val POI_RADIUS = 6f

    const val ROUTES_VEHICLE_COLOR = "#FF3B30"
    const val ROUTES_WALK_COLOR = "#4CAF50"
    const val ROUTES_WIDTH = 3.5f

    /**
     * Estilo base a usar.
     */
    const val MAP_STYLE_URL = SATELLITE_STYLE_URL
    
    /**
     * Coordenadas del Circuit de Barcelona-Catalunya
     */
    object CircuitBarcelona {
        const val LATITUDE = 41.5700
        const val LONGITUDE = 2.2611
        const val DEFAULT_ZOOM = 15.5
        
        fun getLatLng() = LatLng(LATITUDE, LONGITUDE)
        fun toLatLng() = LatLng(LATITUDE, LONGITUDE) // Alias for backward compatibility
    }

    /**
     * Configuraci√≥n de marcadores
     */
    object Markers {
        const val DEFAULT_ICON_SIZE = 1.0f
        const val MEMBER_MARKER_COLOR = "#E63946" // Rojo racing
        const val MY_LOCATION_MARKER_COLOR = "#2A9D8F" // Verde azulado
        
        // Zoom m√≠nimo para mostrar marcadores
        const val MIN_ZOOM_TO_SHOW = 12.0
    }
    
    /**
     * Configuraci√≥n de actualizaci√≥n de ubicaciones
     */
    object Updates {
        const val LOCATION_UPDATE_INTERVAL_MS = 10_000L
        const val MIN_DISTANCE_FOR_UPDATE_METERS = 10f
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/model/GroupMemberLocation.kt`

```kotlin
package com.georacing.georacing.data.model

import com.google.firebase.Timestamp
import com.google.firebase.firestore.GeoPoint
import java.time.Instant

/**
 * Representa la ubicaci√≥n en tiempo real de un miembro del grupo
 * Almacenado en Firestore: groups/{groupId}/locations/{uid}
 */
data class GroupMemberLocation(
    val userId: String = "",
    val displayName: String? = null,
    val photoUrl: String? = null,
    val latitude: Double = 0.0,
    val longitude: Double = 0.0,
    val lastUpdated: Timestamp = Timestamp.now(),
    val sharing: Boolean = false
) {
    /**
     * Convierte a Map para guardarlo en Firestore
     */
    fun toMap(): Map<String, Any> {
        return hashMapOf(
            "userId" to userId,
            "displayName" to (displayName ?: ""),
            "photoUrl" to (photoUrl ?: ""),
            "position" to GeoPoint(latitude, longitude),
            "lastUpdated" to lastUpdated,
            "sharing" to sharing
        )
    }
    
    companion object {
        /**
         * Crea una instancia desde un documento de Firestore
         */
        fun fromFirestore(data: Map<String, Any>): GroupMemberLocation {
            val position = data["position"] as? GeoPoint
            val timestamp = data["lastUpdated"] as? Timestamp ?: Timestamp.now()
            
            return GroupMemberLocation(
                userId = data["userId"] as? String ?: "",
                displayName = data["displayName"] as? String,
                photoUrl = data["photoUrl"] as? String,
                latitude = position?.latitude ?: 0.0,
                longitude = position?.longitude ?: 0.0,
                lastUpdated = timestamp,
                sharing = data["sharing"] as? Boolean ?: false
            )
        }
    }
    
    /**
     * Convierte el Timestamp a Instant para facilitar comparaciones
     */
    fun getInstant(): Instant {
        return Instant.ofEpochSecond(lastUpdated.seconds, lastUpdated.nanoseconds.toLong())
    }
    
    /**
     * Calcula hace cu√°ntos segundos fue la √∫ltima actualizaci√≥n
     */
    fun getSecondsAgo(): Long {
        val now = Instant.now()
        val updated = getInstant()
        return now.epochSecond - updated.epochSecond
    }
    
    /**
     * Devuelve un texto descriptivo del estado de actualizaci√≥n
     */
    fun getStatusText(): String {
        if (!sharing) return "No compartiendo"
        
        val secondsAgo = getSecondsAgo()
        return when {
            secondsAgo < 30 -> "Ahora"
            secondsAgo < 60 -> "Hace ${secondsAgo}s"
            secondsAgo < 3600 -> "Hace ${secondsAgo / 60}min"
            else -> "Hace ${secondsAgo / 3600}h"
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/model/ShareSession.kt`

```kotlin
package com.georacing.georacing.data.model

import com.google.firebase.Timestamp

/**
 * Sesi√≥n temporal de compartir ubicaci√≥n mediante QR usando Firebase
 * El QR contiene el sessionId para unirse al grupo
 */
data class ShareSession(
    val sessionId: String = "",
    val ownerId: String = "",
    val ownerName: String = "",
    val eventDate: Timestamp = Timestamp.now(),
    val expiresAt: Timestamp = Timestamp.now(),
    val createdAt: Timestamp = Timestamp.now(),
    val isActive: Boolean = true,
    val groupId: String = ""
) {
    /**
     * Verifica si la sesi√≥n sigue v√°lida
     */
    fun isExpired(): Boolean {
        return Timestamp.now().toDate().after(expiresAt.toDate()) || !isActive
    }
    
    /**
     * Convierte a Map para Firestore
     */
    fun toMap(): Map<String, Any> {
        return hashMapOf(
            "sessionId" to sessionId,
            "ownerId" to ownerId,
            "ownerName" to ownerName,
            "eventDate" to eventDate,
            "expiresAt" to expiresAt,
            "createdAt" to createdAt,
            "isActive" to isActive,
            "groupId" to groupId
        )
    }
    
    companion object {
        /**
         * Crea ShareSession desde documento Firestore
         */
        fun fromMap(map: Map<String, Any>): ShareSession {
            return ShareSession(
                sessionId = map["sessionId"] as? String ?: "",
                ownerId = map["ownerId"] as? String ?: "",
                ownerName = map["ownerName"] as? String ?: "",
                eventDate = map["eventDate"] as? Timestamp ?: Timestamp.now(),
                expiresAt = map["expiresAt"] as? Timestamp ?: Timestamp.now(),
                createdAt = map["createdAt"] as? Timestamp ?: Timestamp.now(),
                isActive = map["isActive"] as? Boolean ?: true,
                groupId = map["groupId"] as? String ?: ""
            )
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/offline/OfflineCacheManager.kt`

```kotlin
package com.georacing.georacing.data.offline

import com.georacing.georacing.domain.model.CircuitState
import com.georacing.georacing.domain.model.CircuitMode

interface OfflineCacheManager {
    fun cacheCircuitState(state: CircuitState)
    fun getCachedCircuitState(): CircuitState?
    fun cacheStaticMapData(data: String)
    fun getStaticMapData(): String?
}

class InMemoryOfflineCacheManager : OfflineCacheManager {
    private var circuitState: CircuitState? = CircuitState(CircuitMode.NORMAL, "Disfruta de la carrera", null, "")
    private var staticMapData: String? = null

    override fun cacheCircuitState(state: CircuitState) { circuitState = state }
    override fun getCachedCircuitState(): CircuitState? = circuitState
    override fun cacheStaticMapData(data: String) { staticMapData = data }
    override fun getStaticMapData(): String? = staticMapData
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/offline/OfflineRepository.kt`

```kotlin
package com.georacing.georacing.data.offline

import com.georacing.georacing.domain.model.CircuitState

class OfflineRepository(private val cache: OfflineCacheManager) {
    fun saveCircuitState(state: CircuitState) = cache.cacheCircuitState(state)
    fun getCircuitState(): CircuitState? = cache.getCachedCircuitState()
    fun saveMap(data: String) = cache.cacheStaticMapData(data)
    fun getMap(): String? = cache.getStaticMapData()
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/orders/OrdersRepositoryImpl.kt`

```kotlin
package com.georacing.georacing.data.orders

import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import com.georacing.georacing.domain.orders.Order
import com.georacing.georacing.domain.orders.OrderLine
import com.georacing.georacing.domain.orders.OrdersRepository
import com.georacing.georacing.domain.orders.OrderStatus
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.util.UUID

class OrdersRepositoryImpl : OrdersRepository {

    private val api = FirestoreLikeClient.api
    private val gson = Gson()

    override suspend fun createOrder(
        userUid: String,
        items: List<OrderLine>,
        totalAmount: Double,
        paymentToken: String
    ): String {
        val orderId = UUID.randomUUID().toString()
        val itemsJson = gson.toJson(items)
        val currentTime = System.currentTimeMillis()

        // Use ISO 8601 string for timestamps to avoid Integer Overflow in backend (MariaDB INT vs BIGINT)
        val sdf = java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss", java.util.Locale.getDefault())
        val timeString = sdf.format(java.util.Date(currentTime))

        val data = mapOf(
            "order_id" to orderId,
            "user_uid" to userUid,
            "status" to "PAID", // Starting as PAID since we just got the token
            "items_json" to itemsJson,
            "total_amount" to totalAmount,
            "platform" to "ANDROID",
            "payment_token" to paymentToken,
            "created_at" to timeString, 
            "updated_at" to timeString
        )

        api.upsert(
            com.georacing.georacing.data.firestorelike.FirestoreLikeApi.UpsertRequest(
                table = "orders",
                data = data
            )
        )

        return orderId
    }

    override suspend fun getOrder(orderId: String): Order? {
        val result = api.get(
            com.georacing.georacing.data.firestorelike.FirestoreLikeApi.GetRequest(
                table = "orders",
                where = mapOf("order_id" to orderId)
            )
        ).firstOrNull() ?: return null

        return try {
            val statusStr = result["status"] as? String ?: "PENDING"
            val status = try {
                OrderStatus.valueOf(statusStr)
            } catch (e: IllegalArgumentException) {
                OrderStatus.PENDING
            }

            val itemsJson = result["items_json"] as? String ?: "[]"
            val itemsType = object : TypeToken<List<OrderLine>>() {}.type
            val items: List<OrderLine> = gson.fromJson(itemsJson, itemsType)

            Order(
                orderId = result["order_id"] as? String ?: orderId,
                status = status,
                totalAmount = (result["total_amount"] as? Number)?.toDouble() ?: 0.0,
                items = items,
                createdAt = (result["created_at"] as? Number)?.toLong() ?: 0L
            )
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/p2p/NearbyP2PService.kt`

```kotlin
package com.georacing.georacing.data.p2p

import android.content.Context
import android.util.Log
import com.google.android.gms.nearby.Nearby
import com.google.android.gms.nearby.connection.*
import com.google.gson.Gson
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow

/**
 * Servicio P2P usando Nearby Connections API
 * Permite compartir ubicaciones entre dispositivos cercanos sin servidor
 */
class NearbyP2PService(private val context: Context) {
    
    private val connectionsClient = Nearby.getConnectionsClient(context)
    private val gson = Gson()
    
    private val connectedEndpoints = mutableSetOf<String>()
    
    companion object {
        private const val TAG = "NearbyP2PService"
        private const val SERVICE_ID = "com.georacing.location_share"
        private val STRATEGY = Strategy.P2P_CLUSTER  // Permite m√∫ltiples conexiones
    }
    
    /**
     * Inicia como HOST (anunciante) - el que genera el QR
     */
    fun startAdvertising(
        username: String,
        onEndpointIdReceived: (String) -> Unit,
        onLocationReceived: (LocationPayload) -> Unit
    ): Flow<ConnectionStatus> = callbackFlow {
        
        val connectionLifecycleCallback = object : ConnectionLifecycleCallback() {
            override fun onConnectionInitiated(endpointId: String, info: ConnectionInfo) {
                Log.d(TAG, "üì± Conexi√≥n iniciada con: ${info.endpointName}")
                
                // Aceptar autom√°ticamente conexiones
                connectionsClient.acceptConnection(endpointId, payloadCallback(onLocationReceived))
                
                trySend(ConnectionStatus.Connecting(info.endpointName))
            }
            
            override fun onConnectionResult(endpointId: String, result: ConnectionResolution) {
                when (result.status.statusCode) {
                    ConnectionsStatusCodes.STATUS_OK -> {
                        Log.d(TAG, "‚úÖ Conectado con: $endpointId")
                        connectedEndpoints.add(endpointId)
                        trySend(ConnectionStatus.Connected(endpointId))
                    }
                    ConnectionsStatusCodes.STATUS_CONNECTION_REJECTED -> {
                        Log.w(TAG, "‚ùå Conexi√≥n rechazada: $endpointId")
                        trySend(ConnectionStatus.Disconnected(endpointId))
                    }
                    else -> {
                        Log.w(TAG, "‚ö†Ô∏è Error de conexi√≥n: ${result.status.statusMessage}")
                        trySend(ConnectionStatus.Error(result.status.statusMessage ?: "Error desconocido"))
                    }
                }
            }
            
            override fun onDisconnected(endpointId: String) {
                Log.d(TAG, "üîå Desconectado: $endpointId")
                connectedEndpoints.remove(endpointId)
                trySend(ConnectionStatus.Disconnected(endpointId))
            }
        }
        
        val advertisingOptions = AdvertisingOptions.Builder()
            .setStrategy(STRATEGY)
            .build()
        
        connectionsClient.startAdvertising(
            username,
            SERVICE_ID,
            connectionLifecycleCallback,
            advertisingOptions
        ).addOnSuccessListener {
            Log.d(TAG, "üöÄ Anunciando como: $username")
            
            // El endpoint ID se obtiene cuando alguien se conecta
            // Por ahora usamos el nombre de usuario como identificador
            onEndpointIdReceived(username.hashCode().toString())
            
            trySend(ConnectionStatus.Advertising)
            
        }.addOnFailureListener { e ->
            Log.e(TAG, "‚ùå Error al anunciar", e)
            trySend(ConnectionStatus.Error(e.message ?: "Error al iniciar anuncio"))
            close(e)
        }
        
        awaitClose {
            Log.d(TAG, "üõë Deteniendo anuncio")
            connectionsClient.stopAdvertising()
            connectionsClient.stopAllEndpoints()
        }
    }
    
    /**
     * Inicia como CLIENT (descubridor) - el que escanea el QR
     */
    fun startDiscovering(
        myName: String,
        targetEndpointId: String,
        onLocationReceived: (LocationPayload) -> Unit
    ): Flow<ConnectionStatus> = callbackFlow {
        
        val endpointDiscoveryCallback = object : EndpointDiscoveryCallback() {
            override fun onEndpointFound(endpointId: String, info: DiscoveredEndpointInfo) {
                Log.d(TAG, "üîç Endpoint encontrado: ${info.endpointName} ($endpointId)")
                
                // Conectar autom√°ticamente al endpoint del host
                val connectionLifecycleCallback = object : ConnectionLifecycleCallback() {
                    override fun onConnectionInitiated(endpointId: String, connectionInfo: ConnectionInfo) {
                        Log.d(TAG, "üì± Conexi√≥n iniciada con host: ${connectionInfo.endpointName}")
                        connectionsClient.acceptConnection(endpointId, payloadCallback(onLocationReceived))
                        trySend(ConnectionStatus.Connecting(connectionInfo.endpointName))
                    }
                    
                    override fun onConnectionResult(endpointId: String, result: ConnectionResolution) {
                        when (result.status.statusCode) {
                            ConnectionsStatusCodes.STATUS_OK -> {
                                Log.d(TAG, "‚úÖ Conectado con host: $endpointId")
                                connectedEndpoints.add(endpointId)
                                trySend(ConnectionStatus.Connected(endpointId))
                            }
                            else -> {
                                Log.w(TAG, "‚ö†Ô∏è Error conectando: ${result.status.statusMessage}")
                                trySend(ConnectionStatus.Error(result.status.statusMessage ?: "Error"))
                            }
                        }
                    }
                    
                    override fun onDisconnected(endpointId: String) {
                        Log.d(TAG, "üîå Desconectado del host")
                        connectedEndpoints.remove(endpointId)
                        trySend(ConnectionStatus.Disconnected(endpointId))
                    }
                }
                
                connectionsClient.requestConnection(
                    myName,
                    endpointId,
                    connectionLifecycleCallback
                ).addOnSuccessListener {
                    Log.d(TAG, "üìû Solicitando conexi√≥n a: $endpointId")
                }.addOnFailureListener { e ->
                    Log.e(TAG, "‚ùå Error solicitando conexi√≥n", e)
                    trySend(ConnectionStatus.Error(e.message ?: "Error"))
                }
            }
            
            override fun onEndpointLost(endpointId: String) {
                Log.d(TAG, "üì° Endpoint perdido: $endpointId")
            }
        }
        
        val discoveryOptions = DiscoveryOptions.Builder()
            .setStrategy(STRATEGY)
            .build()
        
        connectionsClient.startDiscovery(
            SERVICE_ID,
            endpointDiscoveryCallback,
            discoveryOptions
        ).addOnSuccessListener {
            Log.d(TAG, "üîç Buscando dispositivos...")
            trySend(ConnectionStatus.Discovering)
            
        }.addOnFailureListener { e ->
            Log.e(TAG, "‚ùå Error al buscar", e)
            trySend(ConnectionStatus.Error(e.message ?: "Error al buscar"))
            close(e)
        }
        
        awaitClose {
            Log.d(TAG, "üõë Deteniendo b√∫squeda")
            connectionsClient.stopDiscovery()
            connectionsClient.stopAllEndpoints()
        }
    }
    
    /**
     * Callback para recibir ubicaciones
     */
    private fun payloadCallback(onLocationReceived: (LocationPayload) -> Unit) = object : PayloadCallback() {
        override fun onPayloadReceived(endpointId: String, payload: Payload) {
            if (payload.type == Payload.Type.BYTES) {
                val bytes = payload.asBytes() ?: return
                val json = String(bytes)
                
                try {
                    val locationPayload = gson.fromJson(json, LocationPayload::class.java)
                    Log.d(TAG, "üìç Ubicaci√≥n recibida de ${locationPayload.userName}: (${locationPayload.lat}, ${locationPayload.lng})")
                    onLocationReceived(locationPayload)
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Error parseando ubicaci√≥n", e)
                }
            }
        }
        
        override fun onPayloadTransferUpdate(endpointId: String, update: PayloadTransferUpdate) {
            // No necesario para BYTES
        }
    }
    
    /**
     * Env√≠a ubicaci√≥n a todos los dispositivos conectados
     */
    fun broadcastLocation(locationPayload: LocationPayload) {
        if (connectedEndpoints.isEmpty()) {
            Log.w(TAG, "‚ö†Ô∏è No hay dispositivos conectados")
            return
        }
        
        val json = gson.toJson(locationPayload)
        val payload = Payload.fromBytes(json.toByteArray())
        
        connectionsClient.sendPayload(connectedEndpoints.toList(), payload)
            .addOnSuccessListener {
                Log.d(TAG, "üì§ Ubicaci√≥n enviada a ${connectedEndpoints.size} dispositivos")
            }
            .addOnFailureListener { e ->
                Log.e(TAG, "‚ùå Error enviando ubicaci√≥n", e)
            }
    }
    
    /**
     * Detiene todas las conexiones
     */
    fun stopAll() {
        connectionsClient.stopAdvertising()
        connectionsClient.stopDiscovery()
        connectionsClient.stopAllEndpoints()
        connectedEndpoints.clear()
        Log.d(TAG, "üõë Todas las conexiones detenidas")
    }
}

/**
 * Estados de conexi√≥n P2P
 */
sealed class ConnectionStatus {
    object Advertising : ConnectionStatus()
    object Discovering : ConnectionStatus()
    data class Connecting(val name: String) : ConnectionStatus()
    data class Connected(val endpointId: String) : ConnectionStatus()
    data class Disconnected(val endpointId: String) : ConnectionStatus()
    data class Error(val message: String) : ConnectionStatus()
}

/**
 * Payload de ubicaci√≥n compartida por P2P
 */
data class LocationPayload(
    val userId: String,
    val userName: String,
    val lat: Double,
    val lng: Double,
    val timestamp: Long = System.currentTimeMillis()
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/p2p/ProximityChatManager.kt`

```kotlin
package com.georacing.georacing.data.p2p

import android.content.Context
import android.util.Log
import com.georacing.georacing.data.ble.BeaconScanner
import com.google.android.gms.nearby.Nearby
import com.google.android.gms.nearby.connection.*
import com.google.gson.Gson
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

/**
 * Sistema de chat por proximidad para GeoRacing.
 *
 * Combina:
 * - BLE Scanner para descubrir usuarios cercanos (ya existente via BeaconScanner)
 * - Nearby Connections API para enviar/recibir mensajes de texto
 *
 * Funcionamiento:
 * 1. El usuario ve la lista de personas cercanas (v√≠a BLE detectedUsers)
 * 2. Puede enviar mensajes broadcast a todos los cercanos
 * 3. Los mensajes se transmiten via Nearby Connections (P2P_CLUSTER)
 * 4. Alcance efectivo: ~50-100m (BLE + WiFi-Direct)
 *
 * Mensajes r√°pidos predefinidos + texto libre.
 */
class ProximityChatManager(
    private val context: Context,
    private val beaconScanner: BeaconScanner
) {
    companion object {
        private const val TAG = "ProximityChat"
        private const val SERVICE_ID = "com.georacing.proximity_chat"
        private const val MAX_MESSAGE_LENGTH = 200
        private const val MESSAGE_TTL_MS = 5 * 60 * 1000L // 5 min
    }

    // ‚îÄ‚îÄ Modelos ‚îÄ‚îÄ

    data class ChatMessage(
        val id: String = "${System.currentTimeMillis()}_${(1000..9999).random()}",
        val senderId: String,
        val senderName: String,
        val text: String,
        val timestamp: Long = System.currentTimeMillis(),
        val isMe: Boolean = false,
        val type: MessageType = MessageType.TEXT
    )

    enum class MessageType {
        TEXT,           // Texto libre
        QUICK,          // Mensaje r√°pido predefinido
        LOCATION_SHARE, // Compartir ubicaci√≥n
        EMOJI_REACT     // Reacci√≥n emoji
    }

    data class NearbyUser(
        val endpointId: String,
        val name: String,
        val rssi: Int? = null,
        val connected: Boolean = false
    )

    // ‚îÄ‚îÄ Estado ‚îÄ‚îÄ

    private val _messages = MutableStateFlow<List<ChatMessage>>(emptyList())
    val messages: StateFlow<List<ChatMessage>> = _messages.asStateFlow()

    private val _nearbyUsers = MutableStateFlow<List<NearbyUser>>(emptyList())
    val nearbyUsers: StateFlow<List<NearbyUser>> = _nearbyUsers.asStateFlow()

    private val _isActive = MutableStateFlow(false)
    val isActive: StateFlow<Boolean> = _isActive.asStateFlow()

    private val _connectionStatus = MutableStateFlow("Desconectado")
    val connectionStatus: StateFlow<String> = _connectionStatus.asStateFlow()

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Main)
    private val gson = Gson()
    private var myName = "An√≥nimo"
    private var myId = ""
    private val connectedEndpoints = mutableSetOf<String>()

    // Mensajes r√°pidos predefinidos
    val quickMessages = listOf(
        "üëã ¬°Hola vecino!",
        "üèéÔ∏è ¬°Vamos!",
        "üì∏ ¬øAlguien tiene buena vista desde aqu√≠?",
        "üç∫ ¬øAlguien va al bar?",
        "üÖøÔ∏è ¬øAlguien sabe d√≥nde hay parking libre?",
        "üî¥ ¬°Bandera roja!",
        "üèÅ ¬°√öltimo stint!",
        "üéâ ¬°Incre√≠ble adelantamiento!"
    )

    // ‚îÄ‚îÄ API P√∫blica ‚îÄ‚îÄ

    /**
     * Inicia el chat de proximidad. Comienza a anunciar y descubrir.
     */
    fun start(userName: String, userId: String) {
        myName = userName
        myId = userId
        _isActive.value = true
        _connectionStatus.value = "Buscando gente cercana..."

        startAdvertisingChat()
        startDiscoveringChat()

        // Observar usuarios BLE cercanos
        scope.launch {
            beaconScanner.detectedUsers.collect { bleUsers ->
                // Mergeamos usuarios BLE con los de Nearby
                val bleNearby = bleUsers.map { user ->
                    NearbyUser(
                        endpointId = "ble_${user.idHash}",
                        name = "Usuario #${user.idHash.toString().takeLast(4)}",
                        rssi = user.rssi,
                        connected = false
                    )
                }
                val currentNearby = _nearbyUsers.value.filter { it.endpointId.startsWith("nearby_") }
                _nearbyUsers.value = (currentNearby + bleNearby).distinctBy { it.endpointId }
            }
        }

        Log.i(TAG, "üí¨ Proximity chat started as '$userName'")
    }

    /**
     * Env√≠a un mensaje a todos los conectados.
     */
    fun sendMessage(text: String, type: MessageType = MessageType.TEXT) {
        val trimmed = text.take(MAX_MESSAGE_LENGTH)
        val message = ChatMessage(
            senderId = myId,
            senderName = myName,
            text = trimmed,
            isMe = true,
            type = type
        )

        // A√±adir localmente
        _messages.value = (_messages.value + message).takeLast(100)

        // Broadcast a todos los endpoints conectados
        val json = gson.toJson(message.copy(isMe = false))
        val payload = Payload.fromBytes(json.toByteArray(Charsets.UTF_8))

        connectedEndpoints.forEach { endpointId ->
            try {
                Nearby.getConnectionsClient(context).sendPayload(endpointId, payload)
            } catch (e: Exception) {
                Log.w(TAG, "Failed to send to $endpointId: ${e.message}")
            }
        }

        Log.d(TAG, "üí¨ Sent: '$trimmed' to ${connectedEndpoints.size} endpoints")
    }

    /**
     * Env√≠a un mensaje r√°pido predefinido.
     */
    fun sendQuickMessage(index: Int) {
        if (index in quickMessages.indices) {
            sendMessage(quickMessages[index], MessageType.QUICK)
        }
    }

    /**
     * Limpia mensajes antiguos.
     */
    fun pruneOldMessages() {
        val cutoff = System.currentTimeMillis() - MESSAGE_TTL_MS
        _messages.value = _messages.value.filter { it.timestamp > cutoff }
    }

    /**
     * Detiene el chat.
     */
    fun stop() {
        try {
            Nearby.getConnectionsClient(context).stopAdvertising()
            Nearby.getConnectionsClient(context).stopDiscovery()
            Nearby.getConnectionsClient(context).stopAllEndpoints()
        } catch (e: Exception) {
            Log.w(TAG, "Error stopping: ${e.message}")
        }
        connectedEndpoints.clear()
        _isActive.value = false
        _connectionStatus.value = "Desconectado"
        Log.i(TAG, "üí¨ Proximity chat stopped")
    }

    // ‚îÄ‚îÄ Nearby Connections ‚îÄ‚îÄ

    private fun startAdvertisingChat() {
        val options = AdvertisingOptions.Builder()
            .setStrategy(Strategy.P2P_CLUSTER)
            .build()

        Nearby.getConnectionsClient(context)
            .startAdvertising(myName, SERVICE_ID, connectionLifecycleCallback, options)
            .addOnSuccessListener {
                Log.i(TAG, "‚úÖ Advertising started")
                _connectionStatus.value = "Visible para otros"
            }
            .addOnFailureListener { e ->
                Log.e(TAG, "‚ùå Advertising failed: ${e.message}")
            }
    }

    private fun startDiscoveringChat() {
        val options = DiscoveryOptions.Builder()
            .setStrategy(Strategy.P2P_CLUSTER)
            .build()

        Nearby.getConnectionsClient(context)
            .startDiscovery(SERVICE_ID, endpointDiscoveryCallback, options)
            .addOnSuccessListener {
                Log.i(TAG, "‚úÖ Discovery started")
            }
            .addOnFailureListener { e ->
                Log.e(TAG, "‚ùå Discovery failed: ${e.message}")
            }
    }

    // ‚îÄ‚îÄ Callbacks ‚îÄ‚îÄ

    private val connectionLifecycleCallback = object : ConnectionLifecycleCallback() {
        override fun onConnectionInitiated(endpointId: String, info: ConnectionInfo) {
            Log.i(TAG, "üì® Connection initiated from ${info.endpointName}")
            // Auto-aceptar conexiones (es chat p√∫blico de proximidad)
            Nearby.getConnectionsClient(context)
                .acceptConnection(endpointId, payloadCallback)
        }

        override fun onConnectionResult(endpointId: String, result: ConnectionResolution) {
            when (result.status.statusCode) {
                ConnectionsStatusCodes.STATUS_OK -> {
                    connectedEndpoints.add(endpointId)
                    _nearbyUsers.value = _nearbyUsers.value.map {
                        if (it.endpointId == "nearby_$endpointId") it.copy(connected = true) else it
                    }
                    _connectionStatus.value = "${connectedEndpoints.size} personas conectadas"
                    Log.i(TAG, "‚úÖ Connected to $endpointId (total: ${connectedEndpoints.size})")
                }
                else -> {
                    Log.w(TAG, "‚ùå Connection failed to $endpointId: ${result.status}")
                }
            }
        }

        override fun onDisconnected(endpointId: String) {
            connectedEndpoints.remove(endpointId)
            _nearbyUsers.value = _nearbyUsers.value.filter { it.endpointId != "nearby_$endpointId" }
            _connectionStatus.value = if (connectedEndpoints.isEmpty())
                "Buscando gente cercana..."
            else "${connectedEndpoints.size} personas conectadas"
            Log.i(TAG, "üì¥ Disconnected from $endpointId")
        }
    }

    private val endpointDiscoveryCallback = object : EndpointDiscoveryCallback() {
        override fun onEndpointFound(endpointId: String, info: DiscoveredEndpointInfo) {
            Log.i(TAG, "üîç Found: ${info.endpointName} ($endpointId)")

            // A√±adir a lista de cercanos
            val newUser = NearbyUser("nearby_$endpointId", info.endpointName)
            _nearbyUsers.value = (_nearbyUsers.value + newUser).distinctBy { it.endpointId }

            // Intentar conectar autom√°ticamente
            Nearby.getConnectionsClient(context)
                .requestConnection(myName, endpointId, connectionLifecycleCallback)
                .addOnFailureListener { e ->
                    Log.w(TAG, "Connection request failed: ${e.message}")
                }
        }

        override fun onEndpointLost(endpointId: String) {
            _nearbyUsers.value = _nearbyUsers.value.filter { it.endpointId != "nearby_$endpointId" }
            Log.i(TAG, "üì¥ Lost endpoint: $endpointId")
        }
    }

    private val payloadCallback = object : PayloadCallback() {
        override fun onPayloadReceived(endpointId: String, payload: Payload) {
            if (payload.type == Payload.Type.BYTES) {
                val bytes = payload.asBytes() ?: return
                try {
                    val json = String(bytes, Charsets.UTF_8)
                    val message = gson.fromJson(json, ChatMessage::class.java)
                    _messages.value = (_messages.value + message).takeLast(100)
                    Log.d(TAG, "üí¨ Received from ${message.senderName}: ${message.text}")
                } catch (e: Exception) {
                    Log.w(TAG, "Failed to parse message: ${e.message}")
                }
            }
        }

        override fun onPayloadTransferUpdate(endpointId: String, update: PayloadTransferUpdate) {
            // No tracking necesario para mensajes cortos
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/parking/ParkingAssignmentManager.kt`

```kotlin
package com.georacing.georacing.data.parking

import android.content.Context
import android.util.Log
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.stringPreferencesKey
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

/**
 * Gestor de asignaci√≥n din√°mica de parking seg√∫n el tipo de entrada del usuario.
 * 
 * El sistema asigna autom√°ticamente un parking bas√°ndose en:
 * - Tipo de entrada (General, VIP, Paddock, Prensa, Staff)
 * - Disponibilidad (en producci√≥n, se consultar√≠a backend)
 * - Proximidad a la puerta de acceso correspondiente
 */
object ParkingAssignmentManager {

    private const val TAG = "ParkingAssignment"

    enum class TicketType(val displayName: String) {
        GENERAL("General"),
        VIP("VIP / Hospitality"),
        PADDOCK("Paddock Club"),
        PRESS("Prensa / Media"),
        STAFF("Staff / Equipo")
    }

    data class ParkingAssignment(
        val parkingId: String,
        val parkingName: String,
        val latitude: Double,
        val longitude: Double,
        val gateName: String, // Puerta de acceso recomendada
        val gateLat: Double,
        val gateLon: Double,
        val zone: String // Zona del circuito
    )

    // Asignaciones seg√∫n tipo de entrada
    private val assignments = mapOf(
        TicketType.GENERAL to ParkingAssignment(
            parkingId = "parking_c",
            parkingName = "Parking C (General)",
            latitude = 41.5660,
            longitude = 2.2565,
            gateName = "Porta 7",
            gateLat = 41.5675,
            gateLon = 2.2555,
            zone = "Sur"
        ),
        TicketType.VIP to ParkingAssignment(
            parkingId = "parking_a",
            parkingName = "Parking A (VIP)",
            latitude = 41.5715,
            longitude = 2.2555,
            gateName = "Acceso Principal",
            gateLat = 41.5693,
            gateLon = 2.2577,
            zone = "Norte - Hospitality"
        ),
        TicketType.PADDOCK to ParkingAssignment(
            parkingId = "parking_paddock",
            parkingName = "Parking Paddock",
            latitude = 41.5720,
            longitude = 2.2570,
            gateName = "Acceso Paddock",
            gateLat = 41.5702,
            gateLon = 2.2575,
            zone = "Paddock"
        ),
        TicketType.PRESS to ParkingAssignment(
            parkingId = "parking_b",
            parkingName = "Parking B (Media)",
            latitude = 41.5710,
            longitude = 2.2545,
            gateName = "Porta 1",
            gateLat = 41.5700,
            gateLon = 2.2590,
            zone = "Norte - Media Center"
        ),
        TicketType.STAFF to ParkingAssignment(
            parkingId = "parking_staff",
            parkingName = "Parking Staff",
            latitude = 41.5718,
            longitude = 2.2560,
            gateName = "Acceso Paddock",
            gateLat = 41.5702,
            gateLon = 2.2575,
            zone = "Zona de Servicio"
        )
    )

    /**
     * Obtiene la asignaci√≥n de parking seg√∫n el tipo de entrada.
     */
    fun getAssignment(ticketType: TicketType): ParkingAssignment {
        val assignment = assignments[ticketType] ?: assignments[TicketType.GENERAL]!!
        Log.i(TAG, "üÖøÔ∏è Parking asignado: ${assignment.parkingName} (entrada: ${ticketType.displayName})")
        return assignment
    }

    /**
     * Obtiene la asignaci√≥n por string de tipo de entrada (ej: desde QR o Firestore).
     */
    fun getAssignmentByCode(code: String): ParkingAssignment {
        val ticketType = when (code.uppercase()) {
            "A", "VIP", "HOSPITALITY" -> TicketType.VIP
            "B", "PRESS", "MEDIA" -> TicketType.PRESS
            "C", "GENERAL", "GA" -> TicketType.GENERAL
            "P", "PADDOCK" -> TicketType.PADDOCK
            "S", "STAFF", "TEAM" -> TicketType.STAFF
            else -> TicketType.GENERAL
        }
        return getAssignment(ticketType)
    }

    /**
     * Lista todos los parkings disponibles.
     */
    fun getAllParkings(): List<ParkingAssignment> = assignments.values.toList()
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/parking/ParkingRepository.kt`

```kotlin
package com.georacing.georacing.data.parking

import android.content.Context
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.doublePreferencesKey
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.longPreferencesKey
import androidx.datastore.preferences.core.stringPreferencesKey
import androidx.datastore.preferences.preferencesDataStore
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

private val Context.parkingDataStore: DataStore<Preferences> by preferencesDataStore(name = "parking_prefs")

data class ParkingLocation(
    val latitude: Double,
    val longitude: Double,
    val timestamp: Long,
    val photoUri: String?
)

class ParkingRepository(private val context: Context) {

    val parkingLocation: Flow<ParkingLocation?> = context.parkingDataStore.data.map { prefs ->
        val lat = prefs[PARKING_LAT]
        val lng = prefs[PARKING_LNG]
        val time = prefs[PARKING_TIMESTAMP]
        val photo = prefs[PARKING_PHOTO_URI]

        if (lat != null && lng != null && time != null) {
            ParkingLocation(lat, lng, time, photo)
        } else {
            null
        }
    }

    suspend fun saveParkingLocation(location: ParkingLocation) {
        context.parkingDataStore.edit { prefs ->
            prefs[PARKING_LAT] = location.latitude
            prefs[PARKING_LNG] = location.longitude
            prefs[PARKING_TIMESTAMP] = location.timestamp
            if (location.photoUri != null) {
                prefs[PARKING_PHOTO_URI] = location.photoUri
            } else {
                prefs.remove(PARKING_PHOTO_URI)
            }
        }
    }

    suspend fun clearParking() {
        context.parkingDataStore.edit { prefs ->
            prefs.remove(PARKING_LAT)
            prefs.remove(PARKING_LNG)
            prefs.remove(PARKING_TIMESTAMP)
            prefs.remove(PARKING_PHOTO_URI)
        }
    }

    companion object {
        val PARKING_LAT = doublePreferencesKey("parking_lat")
        val PARKING_LNG = doublePreferencesKey("parking_lng")
        val PARKING_TIMESTAMP = longPreferencesKey("parking_timestamp")
        val PARKING_PHOTO_URI = stringPreferencesKey("parking_photo_uri")
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/products/ProductsRepositoryImpl.kt`

```kotlin
package com.georacing.georacing.data.products

import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import com.georacing.georacing.domain.products.Product
import com.georacing.georacing.domain.products.ProductsRepository

class ProductsRepositoryImpl : ProductsRepository {

    private val api = FirestoreLikeClient.api

    override suspend fun getAllProducts(): List<Product> {
        // Lee de la tabla "products" ‚Äî compatible con ambos esquemas:
        //   Panel Metropolis: id, name, price, category, emoji, in_stock
        //   Legacy:           product_id, name, description, price, stock, category, image_url, is_active
        val rawList = api.read("products")
        return rawList.mapNotNull { map ->
            try {
                val id = map["product_id"] as? String
                    ?: map["id"]?.toString()
                    ?: return@mapNotNull null

                val inStock = when (val v = map["in_stock"]) {
                    is Boolean -> v
                    is Number -> v.toInt() == 1
                    else -> map["is_active"] as? Boolean ?: true
                }

                Product(
                    productId = id,
                    name = map["name"] as? String ?: "",
                    description = map["description"] as? String ?: "",
                    price = (map["price"] as? Number)?.toDouble() ?: 0.0,
                    stock = (map["stock"] as? Number)?.toInt() ?: if (inStock) 99 else 0,
                    category = map["category"] as? String ?: "General",
                    imageUrl = map["image_url"] as? String,
                    emoji = map["emoji"] as? String,
                    isActive = inStock
                )
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }
    }

    override suspend fun updateProductStock(productId: String, newStock: Int) {
        // I'll try to get the internal ID first to be safe.
        // If the table doesn't exist, api.get throws 500. We must catch that.
        val existing = try {
            api.get(
                com.georacing.georacing.data.firestorelike.FirestoreLikeApi.GetRequest(
                    table = "products",
                    where = mapOf("product_id" to productId)
                )
            ).firstOrNull()
        } catch (e: Exception) {
            // Table might not exist or connection error. Assume not found.
            null
        }

        val internalId = existing?.get("id")
        
        val data = mutableMapOf<String, Any?>(
            "product_id" to productId,
            "stock" to newStock
        )
        
        if (internalId != null) {
            data["id"] = internalId
        }

        api.upsert(
            com.georacing.georacing.data.firestorelike.FirestoreLikeApi.UpsertRequest(
                table = "products",
                data = data
            )
        )
    }

    override suspend fun upsertProduct(product: Product) {
        // Escribe en formato compatible con Panel Metropolis
        val data = mutableMapOf<String, Any?>(
            "name" to product.name,
            "description" to product.description,
            "price" to product.price,
            "category" to product.category,
            "emoji" to (product.emoji ?: "üì¶"),
            "in_stock" to if (product.isActive) 1 else 0
        )

        // Buscar registro existente por product_id o id
        val existing = try {
            api.get(
                com.georacing.georacing.data.firestorelike.FirestoreLikeApi.GetRequest(
                    table = "products",
                    where = mapOf("id" to product.productId)
                )
            ).firstOrNull()
        } catch (e: Exception) {
            null
        }

        val internalId = existing?.get("id")
        if (internalId != null) {
            data["id"] = internalId
        }
        
        api.upsert(
            com.georacing.georacing.data.firestorelike.FirestoreLikeApi.UpsertRequest(
                table = "products",
                data = data
            )
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/remote/ApiClient.kt`

```kotlin
package com.georacing.georacing.data.remote

import okhttp3.OkHttpClient
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.util.concurrent.TimeUnit
// import com.georacing.georacing.BuildConfig // Removed to fix error
import java.security.cert.X509Certificate
import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManager
import javax.net.ssl.X509TrustManager

/**
 * Unified API Client Configuration.
 * Handles Security (TLS) logic based on Build Type.
 */
object ApiClient {
    // Shared Base URL for all services
    const val BASE_URL = "https://alpo.myqnapcloud.com:4010/api/"

    private val secureOkHttpClient: OkHttpClient by lazy {
        OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }

    private val unsafeOkHttpClient: OkHttpClient by lazy {
        try {
            val trustAllCerts = arrayOf<TrustManager>(object : X509TrustManager {
                override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {}
                override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {}
                override fun getAcceptedIssuers(): Array<X509Certificate> = arrayOf()
            })

            val sslContext = SSLContext.getInstance("SSL")
            sslContext.init(null, trustAllCerts, java.security.SecureRandom())

            OkHttpClient.Builder()
                .sslSocketFactory(sslContext.socketFactory, trustAllCerts[0] as X509TrustManager)
                .hostnameVerifier { _, _ -> true }
                .connectTimeout(30, TimeUnit.SECONDS)
                .readTimeout(30, TimeUnit.SECONDS)
                .writeTimeout(30, TimeUnit.SECONDS)
                .build()
        } catch (e: Exception) {
            throw RuntimeException(e)
        }
    }

    val okHttpClient: OkHttpClient
        get() = unsafeOkHttpClient // FORCE UNSAFE for Debug/Dev

    val retrofit: Retrofit = Retrofit.Builder()
        .baseUrl(BASE_URL)
        .client(unsafeOkHttpClient) // FORCE UNSAFE for Debug/Dev
        .addConverterFactory(GsonConverterFactory.create())
        .build()
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/remote/GeoRacingApi.kt`

```kotlin
package com.georacing.georacing.data.remote

import com.georacing.georacing.data.remote.dto.BeaconConfigDto
import com.georacing.georacing.data.remote.dto.CircuitStateDto
import com.georacing.georacing.data.remote.dto.IncidentReportDto
import com.georacing.georacing.data.remote.dto.PoiDto
import com.georacing.georacing.data.remote.dto.EnsureColumnRequest
import com.georacing.georacing.data.remote.dto.EnsureTableRequest
import com.georacing.georacing.data.remote.dto.GroupCreateRequest
import com.georacing.georacing.data.remote.dto.UpsertRequest
import com.georacing.georacing.data.remote.dto.UserRequest
import retrofit2.http.Body
import retrofit2.http.GET
import retrofit2.http.PUT
import retrofit2.http.POST
import retrofit2.http.Query

interface GeoRacingApi {
    @GET("beacons")
    suspend fun getBeacons(): List<BeaconConfigDto>

    @GET("pois")
    suspend fun getPois(): List<PoiDto>

    @GET("state")
    suspend fun getCircuitState(): CircuitStateDto

    @POST("incidents")
    suspend fun sendIncident(@Body incident: IncidentReportDto)

    @POST("group-gps")
    suspend fun insertGroupLocation(@Body request: com.georacing.georacing.data.remote.dto.GroupLocationRequest)

    @GET("group-gps/{groupName}")
    suspend fun getGroupMembers(@retrofit2.http.Path("groupName") groupName: String): List<com.georacing.georacing.data.remote.dto.GroupMemberDto>

    @POST("users")
    suspend fun createUser(@Body request: UserRequest)

    @POST("groups")
    suspend fun createGroup(@Body request: GroupCreateRequest)

    // Schema helpers
    @POST("_ensure_table")
    suspend fun ensureTable(@Body request: EnsureTableRequest)

    @POST("_ensure_column")
    suspend fun ensureColumn(@Body request: EnsureColumnRequest)

    @POST("_upsert")
    suspend fun upsert(@Body request: UpsertRequest)

    @GET("_read")
    suspend fun readTable(@Query("table") table: String): List<Map<String, Any>>
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/remote/OpenMeteoService.kt`

```kotlin
package com.georacing.georacing.data.remote

import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.GET
import retrofit2.http.Query

/**
 * Open-Meteo API ‚Äî Free weather API, no API key required.
 * https://open-meteo.com/
 * 
 * Used for ClimaSmartScreen with real weather data at Circuit de Barcelona-Catalunya.
 */
interface OpenMeteoService {

    @GET("v1/forecast")
    suspend fun getForecast(
        @Query("latitude") latitude: Double,
        @Query("longitude") longitude: Double,
        @Query("current") current: String = "temperature_2m,relative_humidity_2m,apparent_temperature,wind_speed_10m,wind_direction_10m,weather_code,surface_pressure",
        @Query("hourly") hourly: String = "temperature_2m,precipitation_probability,weather_code",
        @Query("daily") daily: String = "sunrise,sunset,uv_index_max",
        @Query("timezone") timezone: String = "Europe/Madrid",
        @Query("forecast_days") forecastDays: Int = 1
    ): OpenMeteoResponse

    companion object {
        private const val BASE_URL = "https://api.open-meteo.com/"

        val instance: OpenMeteoService by lazy {
            Retrofit.Builder()
                .baseUrl(BASE_URL)
                .addConverterFactory(GsonConverterFactory.create())
                .build()
                .create(OpenMeteoService::class.java)
        }
    }
}

data class OpenMeteoResponse(
    val current: CurrentWeather?,
    val hourly: HourlyWeather?,
    val daily: DailyWeather?
)

data class CurrentWeather(
    val temperature_2m: Double?,
    val relative_humidity_2m: Int?,
    val apparent_temperature: Double?,
    val wind_speed_10m: Double?,
    val wind_direction_10m: Int?,
    val weather_code: Int?,
    val surface_pressure: Double?
)

data class HourlyWeather(
    val time: List<String>?,
    val temperature_2m: List<Double>?,
    val precipitation_probability: List<Int>?,
    val weather_code: List<Int>?
)

data class DailyWeather(
    val sunrise: List<String>?,
    val sunset: List<String>?,
    val uv_index_max: List<Double>?
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/remote/RetrofitClient.kt`

```kotlin
package com.georacing.georacing.data.remote

import com.georacing.georacing.data.remote.ApiClient
import com.georacing.georacing.data.remote.GeoRacingApi

object RetrofitClient {
    // Delegating to unified ApiClient
    val api: GeoRacingApi by lazy {
        ApiClient.retrofit.create(GeoRacingApi::class.java)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/remote/dto/BeaconConfigDto.kt`

```kotlin
package com.georacing.georacing.data.remote.dto

import com.georacing.georacing.domain.model.ArrowDirection
import com.georacing.georacing.domain.model.BeaconConfig
import com.georacing.georacing.domain.model.BeaconMode
import com.google.gson.annotations.SerializedName

/**
 * DTO para deserializar beacons del backend.
 * Compatible con el esquema del Panel Metropolis y el legacy.
 */
data class BeaconConfigDto(
    @SerializedName("id") val id: String? = null,
    @SerializedName("beacon_uid") val beaconUid: String? = null,
    @SerializedName("name") val name: String? = null,
    @SerializedName("zone") val zone: String? = null,
    @SerializedName("zone_id") val zoneId: Int? = null,
    @SerializedName("map_x") val mapX: Float? = null,
    @SerializedName("map_y") val mapY: Float? = null,
    @SerializedName("latitude") val latitude: Double? = null,
    @SerializedName("longitude") val longitude: Double? = null,
    @SerializedName("message_normal") val messageNormal: String? = null,
    @SerializedName("message_emergency") val messageEmergency: String? = null,
    @SerializedName("message") val message: String? = null,
    @SerializedName("arrow_direction") val arrowDirection: String? = null,
    @SerializedName("mode") val mode: String? = null,
    @SerializedName("color") val color: String? = null,
    @SerializedName("brightness") val brightness: Int? = null,
    @SerializedName("battery_level") val batteryLevel: Int? = null,
    @SerializedName("is_online") val isOnline: Boolean? = null,
    @SerializedName("has_screen") val hasScreen: Boolean? = null
)

fun BeaconConfigDto.toDomain(): BeaconConfig {
    return BeaconConfig(
        id = id ?: beaconUid ?: "",
        beaconUid = beaconUid ?: id ?: "",
        name = name ?: "",
        zone = zone ?: (zoneId?.toString() ?: ""),
        mapX = mapX ?: latitude?.toFloat() ?: 0f,
        mapY = mapY ?: longitude?.toFloat() ?: 0f,
        latitude = latitude ?: mapX?.toDouble() ?: 0.0,
        longitude = longitude ?: mapY?.toDouble() ?: 0.0,
        messageNormal = messageNormal ?: message ?: "",
        messageEmergency = messageEmergency ?: message ?: "",
        message = message ?: messageNormal ?: "",
        arrowDirection = try {
            ArrowDirection.valueOf((arrowDirection ?: "NONE").uppercase())
        } catch (e: Exception) {
            ArrowDirection.NONE
        },
        mode = try {
            BeaconMode.valueOf((mode ?: "NORMAL").uppercase())
        } catch (e: Exception) {
            BeaconMode.NORMAL
        },
        color = color ?: "#00FF00",
        brightness = brightness ?: 100,
        batteryLevel = batteryLevel ?: 100,
        isOnline = isOnline ?: true,
        hasScreen = hasScreen ?: false
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/remote/dto/CircuitStateDto.kt`

```kotlin
package com.georacing.georacing.data.remote.dto

import com.georacing.georacing.domain.model.CircuitMode
import com.georacing.georacing.domain.model.CircuitState
import com.google.gson.annotations.SerializedName

data class CircuitStateDto(
    @SerializedName("id") val id: String,
    @SerializedName("global_mode") val global_mode: String?,
    @SerializedName("mode") val mode: String?,
    @SerializedName("message") val message: String?,
    @SerializedName("temperature") val temperature: String?,
    @SerializedName("humidity") val humidity: String? = null,
    @SerializedName("wind") val wind: String? = null,
    @SerializedName("forecast") val forecast: String? = null,
    @SerializedName("last_updated") val last_updated: String?
)

private fun String.toCircuitMode(): CircuitMode =
    when (this.uppercase()) {
        "NORMAL" -> CircuitMode.NORMAL
        "GREEN_FLAG", "GREEN" -> CircuitMode.GREEN_FLAG
        "YELLOW_FLAG", "YELLOW" -> CircuitMode.YELLOW_FLAG
        "SAFETY_CAR", "SC" -> CircuitMode.SAFETY_CAR
        "VSC" -> CircuitMode.VSC
        "RED_FLAG", "RED" -> CircuitMode.RED_FLAG
        "EVACUATION" -> CircuitMode.EVACUATION 
        else -> CircuitMode.UNKNOWN
    }

fun CircuitStateDto.toDomain(): CircuitState {
    return CircuitState(
        mode = (global_mode ?: mode)?.toCircuitMode() ?: CircuitMode.UNKNOWN,
        message = message ?: "",
        temperature = temperature,
        updatedAt = last_updated ?: "",
        humidity = humidity,
        wind = wind,
        forecast = forecast,
        sessionInfo = null
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/remote/dto/EnsureRequests.kt`

```kotlin
package com.georacing.georacing.data.remote.dto

import com.google.gson.annotations.SerializedName

data class EnsureTableRequest(
    @SerializedName("tableName") val tableName: String
)

data class EnsureColumnRequest(
    @SerializedName("tableName") val tableName: String,
    @SerializedName("columnName") val columnName: String,
    @SerializedName("columnType") val columnType: String
)

data class UpsertRequest(
    @SerializedName("table") val table: String,
    @SerializedName("data") val data: Map<String, Any?>
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/remote/dto/GroupCreateRequest.kt`

```kotlin
package com.georacing.georacing.data.remote.dto

import com.google.gson.annotations.SerializedName

data class GroupCreateRequest(
    @SerializedName("id") val id: String,
    @SerializedName("owner_user_id") val ownerUserId: String,
    @SerializedName("name") val name: String,
    @SerializedName("created_at") val createdAt: Long = System.currentTimeMillis()
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/remote/dto/GroupLocationDto.kt`

```kotlin
package com.georacing.georacing.data.remote.dto

import com.georacing.georacing.data.model.GroupMemberLocation
import com.google.gson.annotations.SerializedName
import java.util.Date

data class GroupLocationRequest(
    @SerializedName("user_uuid") val userUuid: String,
    @SerializedName("group_name") val groupName: String,
    @SerializedName("lat") val lat: Double,
    @SerializedName("lon") val lon: Double,
    @SerializedName("displayName") val displayName: String
)

data class GroupMemberDto(
    @SerializedName("user_uuid") val userUuid: String,
    @SerializedName("lat") val lat: Double,
    @SerializedName("lon") val lon: Double,
    @SerializedName("timestamp") val timestamp: Long,
    @SerializedName("displayName") val displayName: String?
)

fun GroupMemberDto.toDomain(): GroupMemberLocation {
    // Fix for timestamp: API might return 0 or missing field.
    // If timestamp is 0, we assume it's "now" to avoid showing "50 years ago".
    // Also check if it's in seconds (small number) or milliseconds.
    val safeTimestamp = if (timestamp <= 0) {
        System.currentTimeMillis()
    } else if (timestamp < 10000000000L) {
        // If less than 10^10, it's likely seconds (valid until year 2286)
        timestamp * 1000
    } else {
        timestamp
    }

    return GroupMemberLocation(
        userId = userUuid,
        displayName = displayName ?: "User $userUuid", // Use API name or fallback to ID
        photoUrl = "",
        latitude = lat,
        longitude = lon,
        lastUpdated = com.google.firebase.Timestamp(Date(safeTimestamp)),
        sharing = true // If they are in the list, they are sharing
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/remote/dto/IncidentReportDto.kt`

```kotlin
package com.georacing.georacing.data.remote.dto

import com.georacing.georacing.domain.model.IncidentReport
import com.google.gson.annotations.SerializedName

data class IncidentReportDto(
    @SerializedName("category") val category: String,
    @SerializedName("description") val description: String,
    @SerializedName("beacon_id") val beaconId: String?,
    @SerializedName("zone") val zone: String?,
    @SerializedName("timestamp") val timestamp: Long
)

fun IncidentReport.toDto(): IncidentReportDto {
    return IncidentReportDto(
        category = category.name,
        description = description,
        beaconId = beaconId,
        zone = zone,
        timestamp = timestamp
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/remote/dto/PoiDto.kt`

```kotlin
package com.georacing.georacing.data.remote.dto

import com.georacing.georacing.domain.model.Poi
import com.georacing.georacing.domain.model.PoiType
import com.google.gson.annotations.SerializedName

data class PoiDto(
    @SerializedName("id") val id: String,
    @SerializedName("name") val name: String,
    @SerializedName("type") val type: String,
    @SerializedName("description") val description: String,
    @SerializedName("zone") val zone: String,
    @SerializedName("map_x") val mapX: Float,
    @SerializedName("map_y") val mapY: Float
)

fun PoiDto.toDomain(): Poi {
    return Poi(
        id = id,
        name = name,
        type = try {
            PoiType.valueOf(type.uppercase())
        } catch (e: Exception) {
            PoiType.OTHER
        },
        description = description,
        zone = zone,
        mapX = mapX,
        mapY = mapY
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/remote/dto/UserRequest.kt`

```kotlin
package com.georacing.georacing.data.remote.dto

import com.google.gson.annotations.SerializedName

data class UserRequest(
    @SerializedName("uuid") val uuid: String,
    @SerializedName("name") val name: String?,
    @SerializedName("email") val email: String?,
    @SerializedName("role") val role: String = "user"
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/CircuitLocationsRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import com.georacing.georacing.domain.model.CircuitNode
import com.georacing.georacing.domain.model.Confidence
import com.georacing.georacing.domain.model.NodeType

/**
 * Single Source of Truth for critical Circuit Locations.
 * 
 * Dataset Version: 2026.01.29 (Official)
 */
object CircuitLocationsRepository {

    private val nodes = listOf(
        // üü¢ GATES (HIGH CONFIDENCE)
        CircuitNode("gate_1", "Gate 1", NodeType.GATE, 41.5736169, 2.2577213, Confidence.HIGH, "Official Dataset", "Acceso Principal"),
        CircuitNode("gate_2", "Gate 2", NodeType.GATE, 41.57429, 2.26399, Confidence.HIGH, "Official Dataset", "Zona Norte"),
        CircuitNode("gate_3", "Gate 3", NodeType.GATE, 41.57037, 2.26365, Confidence.HIGH, "Official Dataset", "Zona Este"),
        CircuitNode("gate_4", "Gate 4", NodeType.GATE, 41.56639, 2.26010, Confidence.HIGH, "Official Dataset", "Zona Sur-Este"),
        CircuitNode("gate_5", "Gate 5", NodeType.GATE, 41.56582, 2.25851, Confidence.HIGH, "Official Dataset", "Zona Sur"),
        CircuitNode("gate_6", "Gate 6", NodeType.GATE, 41.56356, 2.25171, Confidence.HIGH, "Official Dataset", "Zona Sur-Oeste"),
        CircuitNode("gate_7", "Gate 7", NodeType.GATE, 41.56917, 2.25379, Confidence.HIGH, "Official Dataset", "Zona Oeste"),

        // üÖøÔ∏è PARKINGS (HIGH CONFIDENCE)
        CircuitNode("parking_a1_h1", "Parking A1/H1", NodeType.PARKING, 41.56926, 2.25309, Confidence.HIGH, "Official Dataset"),
        CircuitNode("parking_c", "Parking C", NodeType.PARKING, 41.56691, 2.26100, Confidence.HIGH, "Official Dataset"),
        CircuitNode("parking_h2_in6", "Parking H2/In6", NodeType.PARKING, 41.56855, 2.26273, Confidence.HIGH, "Official Dataset"),
        CircuitNode("parking_paddock", "Paddock", NodeType.PARKING, 41.57040, 2.25970, Confidence.HIGH, "Official Dataset"),
        CircuitNode("parking_d", "Parking D", NodeType.PARKING, 41.5640457, 2.2504530, Confidence.HIGH, "Official Dataset"),
        CircuitNode("parking_f", "Parking F", NodeType.PARKING, 41.5625943, 2.2539039, Confidence.HIGH, "Official Dataset"),
        CircuitNode("parking_a2", "Parking A2", NodeType.PARKING, 41.5752291, 2.2607307, Confidence.HIGH, "Official Dataset"),
        CircuitNode("parking_a3", "Parking A3", NodeType.PARKING, 41.5753531, 2.2649349, Confidence.HIGH, "Official Dataset"),

        // üü° PARKINGS (MEDIUM CONFIDENCE)
        CircuitNode("parking_gate_7", "Parking Puerta 7", NodeType.PARKING, 41.5694654, 2.2537845, Confidence.MEDIUM, "Official Dataset"),
        CircuitNode("parking_pa_approx", "Parking P A", NodeType.PARKING, 41.575186, 2.2636151, Confidence.MEDIUM, "Official Dataset"),
        CircuitNode("parking_b_approx", "Parking B", NodeType.PARKING, 41.5750478, 2.2544808, Confidence.MEDIUM, "Official Dataset"),

        // ‚ùå PARKINGS NO DEFINIDOS (PENDING)
        // Se definen con coordenadas 0.0, 0.0 o placeholder para evitar uso en navegaci√≥n
        CircuitNode("parking_pa_pending", "P.A (Pendiente)", NodeType.PARKING, 0.0, 0.0, Confidence.PENDING, "Missing Data"),
        CircuitNode("parking_pb_pending", "P.B (Pendiente)", NodeType.PARKING, 0.0, 0.0, Confidence.PENDING, "Missing Data"),
        CircuitNode("parking_pbus_pending", "P.Bus (Pendiente)", NodeType.PARKING, 0.0, 0.0, Confidence.PENDING, "Missing Data"),
        CircuitNode("parking_pdu_pending", "P.Du (Pendiente)", NodeType.PARKING, 0.0, 0.0, Confidence.PENDING, "Missing Data"),
        CircuitNode("parking_po_pending", "P.O (Pendiente)", NodeType.PARKING, 0.0, 0.0, Confidence.PENDING, "Missing Data")
    )

    // Public API ==================================================================================

    fun getAllNodes(): List<CircuitNode> = nodes

    fun getGates(): List<CircuitNode> = nodes.filter { it.type == NodeType.GATE }

    /**
     * Returns ONLY actionable parkings (HIGH or MEDIUM confidence).
     * Filters out PENDING parkings to prevent invalid routing.
     */
    fun getNavigableParkings(): List<CircuitNode> {
        return nodes.filter { 
            it.type == NodeType.PARKING && 
            it.confidence != Confidence.PENDING 
        }
    }
    
    fun getAllParkingsIncludingPending(): List<CircuitNode> = nodes.filter { it.type == NodeType.PARKING }

    fun getNodeById(id: String): CircuitNode? = nodes.find { it.id == id }
    
    fun getByNameLoose(query: String): CircuitNode? {
        return nodes.find { it.name.contains(query, ignoreCase = true) || it.id.contains(query, ignoreCase = true) }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/FakeBeaconsRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import com.georacing.georacing.domain.model.ArrowDirection
import com.georacing.georacing.domain.model.BeaconConfig
import com.georacing.georacing.domain.repository.BeaconsRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class FakeBeaconsRepository : BeaconsRepository {
    override fun getBeacons(): Flow<List<BeaconConfig>> = flow {
        emit(
            listOf(
                BeaconConfig(
                    id = "BEACON_1",
                    name = "Acceso Principal",
                    zone = "Zone A",
                    mapX = 0.5f,
                    mapY = 0.8f,
                    messageNormal = "Bienvenido al Circuit de Barcelona-Catalunya",
                    messageEmergency = "Dir√≠jase a la salida m√°s cercana",
                    arrowDirection = ArrowDirection.UP
                ),
                BeaconConfig(
                    id = "BEACON_2",
                    name = "Tribuna Principal",
                    zone = "Zone B",
                    mapX = 0.5f,
                    mapY = 0.5f,
                    messageNormal = "Zona de Tribuna Principal",
                    messageEmergency = "Evac√∫e por las escaleras laterales",
                    arrowDirection = ArrowDirection.RIGHT
                )
            )
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/FakeCircuitStateRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import com.georacing.georacing.domain.model.CircuitMode
import com.georacing.georacing.domain.model.CircuitState
import com.georacing.georacing.domain.repository.CircuitStateRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow

class FakeCircuitStateRepository : CircuitStateRepository {
    private val stateFlow = MutableStateFlow(CircuitState(CircuitMode.NORMAL, "Disfruta de la carrera", null, ""))

    override fun getCircuitState(): Flow<CircuitState> = stateFlow.asStateFlow()

    override fun setCircuitState(mode: CircuitMode, message: String?) {
        stateFlow.value = CircuitState(mode, message, null, "")
    }

    override val appMode: Flow<com.georacing.georacing.domain.model.AppMode> = kotlinx.coroutines.flow.flowOf(com.georacing.georacing.domain.model.AppMode.ONLINE)
    override val debugInfo: Flow<String> = kotlinx.coroutines.flow.flowOf("Fake Debug")
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/FakeCrowdRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

data class HeatPoint(
    val lat: Double,
    val lon: Double,
    val intensity: Float, // 0.0 to 1.0
    val radius: Float // Visual radius
)

object FakeCrowdRepository {

    // Hardcoded Strategic Points for Demo
    private val POINTS = listOf(
        // Gate 3 (Main Access)
        HeatPoint(41.57, 2.26, 0.0f, 100f),
        // Food Zone (ComponentesFan Zone)
        HeatPoint(41.568, 2.262, 0.0f, 120f),
        // Paddock
        HeatPoint(41.571, 2.258, 0.0f, 80f)
    )

    fun getHeatPoints(baseIntensity: Float): Flow<List<HeatPoint>> = flow {
        // Emit points modified by the base intensity from Simulator
        val currentPoints = POINTS.map { point ->
            // Random variation for realism, but anchored to baseIntensity
            val localVariation = (Math.random() * 0.1).toFloat()
            val currentIntensity = (baseIntensity + localVariation).coerceIn(0f, 1f)
            point.copy(intensity = currentIntensity)
        }
        emit(currentPoints)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/FakeIncidentsRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.util.Log
import com.georacing.georacing.domain.model.IncidentReport
import com.georacing.georacing.domain.repository.IncidentsRepository
import kotlinx.coroutines.delay

class FakeIncidentsRepository : IncidentsRepository {
    override suspend fun getIncidents(): kotlinx.coroutines.flow.Flow<List<IncidentReport>> = kotlinx.coroutines.flow.flowOf(emptyList())

    override suspend fun reportIncident(incident: IncidentReport) {
        // Simulate network delay
        delay(1000)
        Log.d("FakeIncidentsRepo", "Incident sent: $incident")
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/FakePoiRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import com.georacing.georacing.domain.model.Poi
import com.georacing.georacing.domain.model.PoiType
import com.georacing.georacing.domain.repository.PoiRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class FakePoiRepository : PoiRepository {
    override fun getPois(): Flow<List<Poi>> = flow {
        emit(
            listOf(
                Poi(
                    id = "1",
                    name = "WC Zona A",
                    type = PoiType.WC,
                    description = "Ba√±os p√∫blicos cerca de la entrada",
                    zone = "Zone A",
                    mapX = 0.4f,
                    mapY = 0.85f
                ),
                Poi(
                    id = "2",
                    name = "Burger Point",
                    type = PoiType.FOOD,
                    description = "Hamburguesas y bebidas",
                    zone = "Zone B",
                    mapX = 0.6f,
                    mapY = 0.55f
                ),
                Poi(
                    id = "3",
                    name = "Merch Shop",
                    type = PoiType.MERCH,
                    description = "Camisetas y gorras oficiales",
                    zone = "Zone A",
                    mapX = 0.55f,
                    mapY = 0.75f
                )
            )
        )
    }

    /**
     * No-op: FakePoiRepository no sincroniza con red.
     */
    override suspend fun refreshPois() {
        // No-op - datos son fake/est√°ticos
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/FirebaseIncidentsRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.util.Log
import com.georacing.georacing.data.firebase.FirebaseAuthService
import com.georacing.georacing.data.firebase.FirebaseFirestoreService
import com.georacing.georacing.domain.model.IncidentReport
import com.georacing.georacing.domain.repository.IncidentsRepository

/**
 * Implementaci√≥n REAL del repositorio de incidencias usando Firebase
 * 
 * Este repositorio:
 * 1. Asegura que el usuario est√© autenticado (login an√≥nimo si es necesario)
 * 2. Guarda las incidencias en Firestore en la colecci√≥n "incidents"
 * 3. Maneja errores de forma robusta
 */
class FirebaseIncidentsRepository(
    private val authService: FirebaseAuthService = FirebaseAuthService(),
    private val firestoreService: FirebaseFirestoreService = FirebaseFirestoreService()
) : IncidentsRepository {
    
    companion object {
        private const val TAG = "FirebaseIncidentsRepo"
    }
    
    override suspend fun getIncidents(): kotlinx.coroutines.flow.Flow<List<IncidentReport>> = kotlinx.coroutines.flow.flowOf(emptyList())

    override suspend fun reportIncident(incident: IncidentReport) {
        try {
            // 1. CR√çTICO: Verificar que el usuario est√° autenticado con Google
            val authResult = authService.requireGoogleSignedIn()
            
            if (authResult.isFailure) {
                Log.e(TAG, "Usuario no autenticado con Google")
                throw authResult.exceptionOrNull() 
                    ?: Exception("Login con Google requerido")
            }
            
            val user = authResult.getOrNull()!!
            Log.d(TAG, "Usuario autenticado: ${user.email}")
            
            // 2. Preparar datos para Firestore (convertir a Map para mejor control)
            val incidentData = hashMapOf(
                "userId" to user.uid,
                "userEmail" to user.email,
                "userName" to user.displayName,
                "category" to incident.category.name,
                "categoryDisplay" to incident.category.displayName,
                "description" to incident.description,
                "beaconId" to incident.beaconId,
                "zone" to incident.zone,
                "timestamp" to incident.timestamp,
                "status" to "pending", // El staff la marcar√° como "resolved" o "in_progress"
                "createdAt" to com.google.firebase.Timestamp.now()
            )
            
            // 3. Guardar en Firestore
            val result = firestoreService.addDocument(
                collection = FirebaseFirestoreService.COLLECTION_INCIDENTS,
                data = incidentData
            )
            
            if (result.isSuccess) {
                val docId = result.getOrNull()
                Log.d(TAG, "‚úÖ Incidencia guardada con ID: $docId")
            } else {
                Log.e(TAG, "‚ùå Error guardando incidencia", result.exceptionOrNull())
                throw result.exceptionOrNull() 
                    ?: Exception("Error desconocido al guardar incidencia")
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Error en sendIncident", e)
            throw e // Re-lanzar para que el ViewModel lo maneje
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/GroupLocationRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.util.Log
import com.georacing.georacing.data.firebase.FirebaseAuthService
import com.georacing.georacing.data.model.GroupMemberLocation
import com.google.firebase.Timestamp
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.GeoPoint
import com.google.firebase.firestore.ListenerRegistration
import kotlinx.coroutines.tasks.await

/**
 * Repositorio para gestionar ubicaciones en tiempo real de miembros del grupo
 * Estructura Firestore: groups/{groupId}/locations/{uid}
 */
class GroupLocationRepository {
    private val firestore = FirebaseFirestore.getInstance()
    private val authService = FirebaseAuthService()
    private var locationListener: ListenerRegistration? = null
    
    companion object {
        private const val TAG = "GroupLocationRepo"
        private const val COLLECTION_GROUPS = "groups"
        private const val SUBCOLLECTION_LOCATIONS = "locations"
    }
    
    /**
     * Actualiza la ubicaci√≥n del usuario actual en su grupo activo
     * Solo el propio usuario puede actualizar su ubicaci√≥n (seg√∫n reglas Firestore)
     */
    suspend fun updateMyLocation(
        groupId: String,
        lat: Double,
        lng: Double,
        displayName: String? = null,
        photoUrl: String? = null,
        sharing: Boolean = true
    ): Result<Unit> {
        return try {
            // Verificar que hay usuario autenticado
            val userResult = authService.requireGoogleSignedIn()
            if (userResult.isFailure) {
                return Result.failure(userResult.exceptionOrNull() ?: Exception("Usuario no autenticado"))
            }
            
            val currentUser = userResult.getOrNull()!!
            val uid = currentUser.uid
            
            // Crear el documento de ubicaci√≥n
            val locationData = hashMapOf(
                "userId" to uid,
                "displayName" to (displayName ?: currentUser.displayName ?: "Usuario"),
                "photoUrl" to (photoUrl ?: currentUser.photoUrl?.toString() ?: ""),
                "position" to GeoPoint(lat, lng),
                "lastUpdated" to Timestamp.now(),
                "sharing" to sharing
            )
            
            // Guardar en Firestore: groups/{groupId}/locations/{uid}
            firestore.collection(COLLECTION_GROUPS)
                .document(groupId)
                .collection(SUBCOLLECTION_LOCATIONS)
                .document(uid)
                .set(locationData)
                .await()
            
            Log.d(TAG, "‚úÖ Ubicaci√≥n actualizada: ($lat, $lng) para grupo $groupId")
            Result.success(Unit)
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error actualizando ubicaci√≥n", e)
            Result.failure(e)
        }
    }
    
    /**
     * Marca que el usuario dej√≥ de compartir ubicaci√≥n (sin borrar el documento)
     */
    suspend fun stopSharingLocation(groupId: String): Result<Unit> {
        return try {
            val userResult = authService.requireGoogleSignedIn()
            if (userResult.isFailure) {
                return Result.failure(userResult.exceptionOrNull() ?: Exception("Usuario no autenticado"))
            }
            
            val uid = userResult.getOrNull()!!.uid
            
            firestore.collection(COLLECTION_GROUPS)
                .document(groupId)
                .collection(SUBCOLLECTION_LOCATIONS)
                .document(uid)
                .update("sharing", false)
                .await()
            
            Log.d(TAG, "‚úÖ Usuario dej√≥ de compartir ubicaci√≥n")
            Result.success(Unit)
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error al dejar de compartir", e)
            Result.failure(e)
        }
    }
    
    /**
     * Escucha en tiempo real las ubicaciones de todos los miembros del grupo
     * 
     * NOTA: Aseg√∫rate de que las reglas de Firestore permiten leer:
     * - Cualquier usuario autenticado puede leer groups/{groupId}/locations
     */
    fun listenGroupLocations(
        groupId: String,
        onResult: (List<GroupMemberLocation>) -> Unit,
        onError: (Exception) -> Unit = {}
    ) {
        // Cancelar listener anterior si existe
        stopListening()
        
        Log.d(TAG, "üëÇ Escuchando ubicaciones del grupo: $groupId")
        
        locationListener = firestore.collection(COLLECTION_GROUPS)
            .document(groupId)
            .collection(SUBCOLLECTION_LOCATIONS)
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    Log.e(TAG, "‚ùå Error escuchando ubicaciones: ${error.message}", error)
                    
                    // Manejo espec√≠fico de PERMISSION_DENIED
                    if (error.message?.contains("PERMISSION_DENIED") == true) {
                        Log.e(TAG, """
                            ‚ùå PERMISSION_DENIED en groups/$groupId/locations
                            
                            Verifica las reglas de Firestore:
                            
                            match /groups/{groupId}/locations/{uid} {
                              allow read: if request.auth != null;
                              allow create, update: if request.auth != null && request.auth.uid == uid;
                              allow delete: if request.auth != null && request.auth.uid == uid;
                            }
                            
                            Usuario actual: ${authService.getCurrentUser()?.uid ?: "NO AUTENTICADO"}
                        """.trimIndent())
                    }
                    
                    onError(error)
                    return@addSnapshotListener
                }
                
                if (snapshot != null && !snapshot.isEmpty) {
                    val locations = snapshot.documents.mapNotNull { doc ->
                        try {
                            val data = doc.data ?: return@mapNotNull null
                            GroupMemberLocation.fromFirestore(data)
                        } catch (e: Exception) {
                            Log.e(TAG, "Error parseando documento ${doc.id}", e)
                            null
                        }
                    }
                    
                    Log.d(TAG, "‚úÖ Recibidas ${locations.size} ubicaciones")
                    onResult(locations)
                } else {
                    Log.d(TAG, "‚ö†Ô∏è No hay ubicaciones en el grupo")
                    onResult(emptyList())
                }
            }
    }
    
    /**
     * Detiene el listener de ubicaciones en tiempo real
     */
    fun stopListening() {
        locationListener?.remove()
        locationListener = null
        Log.d(TAG, "üõë Listener de ubicaciones detenido")
    }
    
    /**
     * Obtiene las ubicaciones del grupo una sola vez (no en tiempo real)
     */
    suspend fun getGroupLocations(groupId: String): Result<List<GroupMemberLocation>> {
        return try {
            val snapshot = firestore.collection(COLLECTION_GROUPS)
                .document(groupId)
                .collection(SUBCOLLECTION_LOCATIONS)
                .get()
                .await()
            
            val locations = snapshot.documents.mapNotNull { doc ->
                try {
                    val data = doc.data ?: return@mapNotNull null
                    GroupMemberLocation.fromFirestore(data)
                } catch (e: Exception) {
                    Log.e(TAG, "Error parseando documento ${doc.id}", e)
                    null
                }
            }
            
            Result.success(locations)
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error obteniendo ubicaciones", e)
            Result.failure(e)
        }
    }
    
    /**
     * Obtiene el estado actual de compartir ubicaci√≥n del usuario
     */
    suspend fun getMyLocationStatus(groupId: String): Result<Boolean> {
        return try {
            val userResult = authService.requireGoogleSignedIn()
            if (userResult.isFailure) {
                return Result.failure(userResult.exceptionOrNull() ?: Exception("Usuario no autenticado"))
            }
            
            val uid = userResult.getOrNull()!!.uid
            
            val doc = firestore.collection(COLLECTION_GROUPS)
                .document(groupId)
                .collection(SUBCOLLECTION_LOCATIONS)
                .document(uid)
                .get()
                .await()
            
            val isSharing = doc.getBoolean("sharing") ?: false
            Log.d(TAG, "Estado actual de sharing: $isSharing")
            Result.success(isSharing)
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error obteniendo estado de sharing", e)
            Result.success(false) // Por defecto false si no existe
        }
    }
    
    /**
     * Borra completamente el documento de ubicaci√≥n del usuario
     * √ötil cuando el usuario abandona el grupo
     */
    suspend fun deleteMyLocation(groupId: String): Result<Unit> {
        return try {
            val userResult = authService.requireGoogleSignedIn()
            if (userResult.isFailure) {
                return Result.failure(userResult.exceptionOrNull() ?: Exception("Usuario no autenticado"))
            }
            
            val uid = userResult.getOrNull()!!.uid
            
            firestore.collection(COLLECTION_GROUPS)
                .document(groupId)
                .collection(SUBCOLLECTION_LOCATIONS)
                .document(uid)
                .delete()
                .await()
            
            Log.d(TAG, "‚úÖ Ubicaci√≥n borrada del grupo $groupId")
            Result.success(Unit)
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error borrando ubicaci√≥n", e)
            Result.failure(e)
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/HybridCircuitStateRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import com.georacing.georacing.data.ble.BeaconScanner
import com.georacing.georacing.domain.model.AppMode
import com.georacing.georacing.domain.model.CircuitMode
import com.georacing.georacing.domain.model.CircuitState
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onEach

/**
 * Repository that arbitrates between Network API and Active BLE Beacon.
 * Priority: BLE (if active & recent) -> Network -> Cache (Fallback) -> Default
 */
class HybridCircuitStateRepository(
    private val networkRepository: NetworkCircuitStateRepository,
    private val beaconScanner: BeaconScanner
) : com.georacing.georacing.domain.repository.CircuitStateRepository {

    // Helper to determie current AppMode based on signal
    // Arbitrate AppMode based on BOTH Network and BLE
    override val appMode: Flow<AppMode> = combine(
        networkRepository.getCircuitState(),
        beaconScanner.activeSignal
    ) { netState, bleSignal ->
        // PRIORITY: NETWORK > BLE (as requested)
        if (netState.mode != CircuitMode.UNKNOWN) {
            AppMode.ONLINE
        } else if (bleSignal != null && !bleSignal.isExpired()) {
            AppMode.OFFLINE_BLE
        } else {
            AppMode.ONLINE
        }
    }

    override val debugInfo: Flow<String> = beaconScanner.debugInfo

    override fun getCircuitState(): Flow<CircuitState> {
        // Polling Network (Continuous)
        val networkFlow = networkRepository.getCircuitState()
            .onEach { state ->
                // ALWAYS SCAN (Hot Standby / Override Priority)
                // We do NOT stop scanning even if network is fine, 
                // because a Physical Beacon (Red Flag) should override the Cloud.
                if (!beaconScanner.isScanningValue) {
                    beaconScanner.startScanning()
                }
            }

        // Active Signal
        val bleFlow = beaconScanner.activeSignal

        return combine(networkFlow, bleFlow) { netState, bleSignal ->
            // PRIORITY: BLE EVACUATION > Network > Other BLE > Default
            // Safety-critical BLE signals (EVACUATION, RED_FLAG) MUST override network.
            // This is essential for demos and real-world safety.
            
            val isBleEvacuation = bleSignal != null && !bleSignal.isExpired() &&
                (bleSignal.mode == CircuitMode.EVACUATION || bleSignal.mode == CircuitMode.RED_FLAG)

            if (isBleEvacuation) {
                // CRITICAL: Physical Beacon / Simulation takes absolute priority for safety
                CircuitState(
                    mode = bleSignal!!.mode,
                    message = "‚ö†Ô∏è SE√ëAL BALIZA ACTIVA (Zona ${bleSignal.zoneId})",
                    temperature = bleSignal.temperature?.let { "${it / 10.0}¬∞C" },
                    updatedAt = "BLE Seq ${bleSignal.sequence}"
                )
            } else if (netState.mode != CircuitMode.UNKNOWN) {
                // Network Healthy and no critical BLE signal
                netState
            } else if (bleSignal != null && !bleSignal.isExpired()) {
                 CircuitState(
                    mode = bleSignal.mode,
                    message = "SE√ëAL BALIZA ACTIVA (Zona ${bleSignal.zoneId})",
                    temperature = bleSignal.temperature?.let { "${it / 10.0}¬∞C" },
                    updatedAt = "BLE Seq ${bleSignal.sequence}"
                )
            } else {
                // Both sources failed
                CircuitState(CircuitMode.UNKNOWN, "Buscando se√±al...", null, "")
            }
        }
    }

    override fun setCircuitState(mode: CircuitMode, message: String?) {
        // No-op or delegate to network if writable (currently read-only)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/NetworkBeaconsRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.util.Log
import com.georacing.georacing.data.remote.RetrofitClient
import com.georacing.georacing.data.remote.dto.toDomain
import com.georacing.georacing.domain.model.BeaconConfig
import com.georacing.georacing.domain.repository.BeaconsRepository

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class NetworkBeaconsRepository : BeaconsRepository {
    override fun getBeacons(): Flow<List<BeaconConfig>> = flow {
        try {
            val beacons = RetrofitClient.api.getBeacons().map { it.toDomain() }
            emit(beacons)
        } catch (e: Exception) {
            Log.e("NetworkBeaconsRepo", "Error fetching beacons", e)
            emit(emptyList())
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/NetworkCircuitStateRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.util.Log
import com.georacing.georacing.data.remote.RetrofitClient
import com.georacing.georacing.data.remote.dto.toDomain
import com.georacing.georacing.domain.model.CircuitMode
import com.georacing.georacing.domain.model.CircuitState
import com.georacing.georacing.domain.repository.CircuitStateRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.delay

class NetworkCircuitStateRepository : CircuitStateRepository {
    override fun getCircuitState(): Flow<CircuitState> = flow {
        while (true) {
            try {
                val stateDto = RetrofitClient.api.getCircuitState()
                emit(stateDto.toDomain())
            } catch (e: Exception) {
                Log.e("NetworkCircuitStateRepo", "Error fetching circuit state", e)
                // Emit a default safe state or keep previous if possible (simplified here)
                emit(CircuitState(CircuitMode.UNKNOWN, "Conexi√≥n Inestable", null, ""))
            }
            delay(5000) // Poll every 5 seconds
        }
    }

    override fun setCircuitState(mode: CircuitMode, message: String?) {
        // No-op for network repo client-side usually, or impl existing logic
    }

    override val appMode: Flow<com.georacing.georacing.domain.model.AppMode> = kotlinx.coroutines.flow.flowOf(com.georacing.georacing.domain.model.AppMode.ONLINE)
    override val debugInfo: Flow<String> = kotlinx.coroutines.flow.flowOf("Network")
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/NetworkGroupRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.util.Log
import com.georacing.georacing.data.model.GroupMemberLocation
import com.georacing.georacing.data.remote.RetrofitClient
import com.georacing.georacing.data.remote.dto.EnsureColumnRequest
import com.georacing.georacing.data.remote.dto.EnsureTableRequest
import com.georacing.georacing.data.remote.dto.GroupLocationRequest
import com.georacing.georacing.data.remote.dto.UpsertRequest
import com.georacing.georacing.data.remote.dto.toDomain
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import java.text.SimpleDateFormat
import java.util.Locale
import java.util.zip.CRC32

class NetworkGroupRepository {
    
    companion object {
        private const val TAG = "NetworkGroupRepo"
        private const val GROUPS_TABLE = "groups"
        private const val GPS_TABLE = "group_gps"
    }

    private var schemaEnsured = false

    private suspend fun ensureSchema() {
        if (schemaEnsured) return

        // groups table
        RetrofitClient.api.ensureTable(EnsureTableRequest(GROUPS_TABLE))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(GROUPS_TABLE, "owner_user_id", "VARCHAR(200)"))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(GROUPS_TABLE, "name", "VARCHAR(255)"))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(GROUPS_TABLE, "created_at", "TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP"))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(GROUPS_TABLE, "updated_at", "TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"))

        // group_gps table
        RetrofitClient.api.ensureTable(EnsureTableRequest(GPS_TABLE))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(GPS_TABLE, "user_uuid", "VARCHAR(200)"))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(GPS_TABLE, "group_name", "VARCHAR(200)"))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(GPS_TABLE, "lat", "DOUBLE"))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(GPS_TABLE, "lon", "DOUBLE"))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(GPS_TABLE, "displayName", "VARCHAR(255)"))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(GPS_TABLE, "last_seen", "TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP"))

        schemaEnsured = true
    }

    private fun stableId(value: String): Int {
        val crc = CRC32().apply { update(value.toByteArray()) }.value
        return (crc % Int.MAX_VALUE).toInt()
    }

    suspend fun warmupSchema() {
        ensureSchema()
    }

    private fun gpsRowId(groupName: String, userId: String): Int =
        stableId("$groupName|$userId")

    private fun nowTimestampString(): String {
        val sdf = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US)
        return sdf.format(java.util.Date())
    }

    suspend fun sendLocation(userId: String, groupName: String, lat: Double, lon: Double, displayName: String): Result<Unit> {
        return try {
            ensureSchema()
            val gpsId = gpsRowId(groupName, userId)
            val request = UpsertRequest(
                table = GPS_TABLE,
                data = mapOf(
                    "id" to gpsId,
                    "user_uuid" to userId,
                    "group_name" to groupName,
                    "lat" to lat,
                    "lon" to lon,
                    "displayName" to displayName,
                    "last_seen" to nowTimestampString()
                )
            )
            RetrofitClient.api.upsert(request)
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Error sending location", e)
            Result.failure(e)
        }
    }

    suspend fun removeUserFromGroup(userId: String, groupName: String): Result<Unit> {
        return try {
            ensureSchema()
            val gpsId = gpsRowId(groupName, userId)
            val request = UpsertRequest(
                table = GPS_TABLE,
                data = mapOf(
                    "id" to gpsId,
                    "user_uuid" to userId,
                    "group_name" to "", // sacar del grupo para que no aparezca en SELECT por group_name
                    "lat" to null,
                    "lon" to null,
                    "displayName" to null,
                    "last_seen" to nowTimestampString()
                )
            )
            RetrofitClient.api.upsert(request)
            Log.d(TAG, "User $userId removed from group $groupName")
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Error removing user $userId from group $groupName", e)
            Result.failure(e)
        }
    }

    suspend fun createGroup(groupId: String, ownerUserId: String, groupName: String): Result<Unit> {
        return try {
            ensureSchema()
            val groupRowId = stableId(groupId)
            val request = UpsertRequest(
                table = GROUPS_TABLE,
                data = mapOf(
                    "id" to groupRowId,
                    "owner_user_id" to ownerUserId,
                    "name" to groupName,
                    "created_at" to nowTimestampString(),
                    "updated_at" to nowTimestampString()
                )
            )
            RetrofitClient.api.upsert(request)
            Log.d(TAG, "Group created/updated via upsert: $groupId")
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Error creating group $groupId", e)
            Result.failure(e)
        }
    }

    fun getGroupMembers(groupName: String, pollIntervalMs: Long = 10_000L): Flow<List<GroupMemberLocation>> = flow {
        emit(emptyList()) // Ensure initial emission for combine operator
        while (true) {
            try {
                val membersDto = RetrofitClient.api.getGroupMembers(groupName)
                val members = membersDto.map { it.toDomain() }.distinctBy { it.userId }
                emit(members)
            } catch (e: Exception) {
                Log.e(TAG, "Error fetching group members", e)
                // Emit empty list or handle error appropriately. 
                // For now, we might want to keep the last known state or emit empty if it's a hard failure.
                // But to avoid clearing the map on transient errors, we might skip emitting emptyList() here unless necessary.
                // However, if the group is empty, the API returns empty list.
                // Let's emit empty list only if it's a 404 or similar, but for network errors, maybe just log?
                // For simplicity in this migration:
                // emit(emptyList()) 
            }
            delay(pollIntervalMs) // Poll configurable
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/NetworkIncidentsRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.util.Log
import com.georacing.georacing.data.remote.RetrofitClient
import com.georacing.georacing.data.remote.dto.toDto
import com.georacing.georacing.domain.model.IncidentReport
import com.georacing.georacing.domain.repository.IncidentsRepository

class NetworkIncidentsRepository : IncidentsRepository {
    override suspend fun getIncidents(): kotlinx.coroutines.flow.Flow<List<IncidentReport>> = kotlinx.coroutines.flow.flowOf(emptyList())

    override suspend fun reportIncident(incident: IncidentReport) {
        try {
            RetrofitClient.api.sendIncident(incident.toDto())
        } catch (e: Exception) {
            Log.e("NetworkIncidentsRepo", "Error reporting incident", e)
            throw e
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/NetworkPoiRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.util.Log
import com.georacing.georacing.data.remote.RetrofitClient
import com.georacing.georacing.data.remote.dto.toDomain
import com.georacing.georacing.domain.model.Poi
import com.georacing.georacing.domain.model.PoiType
import com.georacing.georacing.domain.repository.PoiRepository

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

/**
 * @deprecated Use OfflineFirstPoiRepository instead for offline support.
 * This class is kept for backward compatibility during migration.
 */
@Deprecated("Use OfflineFirstPoiRepository for offline-first architecture")
class NetworkPoiRepository : PoiRepository {
    
    // Hardcoded POIs (previously in car/PoiRepository)
    private val hardcodedPois = listOf(
        Poi("main_gate", "Acceso Principal", PoiType.GATE, "Entrada Principal Circuit", "Accesos", 0f, 0f, 41.56872, 2.25668),
        Poi("gate_3", "Porta 3", PoiType.GATE, "Acceso Este", "Accesos", 0f, 0f, 41.56840, 2.25870),
        Poi("parking_a", "Parking A", PoiType.PARKING, "Parking Zona Norte-Oeste", "Parking", 0f, 0f, 41.57063, 2.25796),
        Poi("parking_b", "Parking B", PoiType.PARKING, "Parking Zona Norte", "Parking", 0f, 0f, 41.57133, 2.25574),
        Poi("parking_c", "Parking C", PoiType.PARKING, "Parking Zona Este", "Parking", 0f, 0f, 41.56895, 2.26235),
        Poi("parking_d", "Parking D", PoiType.PARKING, "Parking Zona Sur-Este", "Parking", 0f, 0f, 41.56552, 2.26330),
        Poi("parking_e", "Parking E", PoiType.PARKING, "Parking Zona Sur", "Parking", 0f, 0f, 41.56480, 2.26053),
        Poi("parking_f", "Parking F", PoiType.PARKING, "Parking Zona Sur-Oeste", "Parking", 0f, 0f, 41.56472, 2.25832)
    )

    override fun getPois(): Flow<List<Poi>> = flow {
        // Emit hardcoded first (fast)
        emit(hardcodedPois)
        
        try {
            val networkPois = RetrofitClient.api.getPois().map { it.toDomain() }
            // Merge: Prefer network if IDs collide, or just append
            // For simplicitly, just emitting network ones + hardcoded
            emit(hardcodedPois + networkPois)
        } catch (e: Exception) {
            Log.e("NetworkPoiRepo", "Error fetching POIs: ${e.message}")
            // Keep emitting hardcoded
            emit(hardcodedPois)
        }
    }

    /**
     * No-op: Esta implementaci√≥n legacy no cachea datos.
     * Migrar a OfflineFirstPoiRepository para soporte offline.
     */
    override suspend fun refreshPois() {
        // No-op - Esta implementaci√≥n no usa Room
        Log.w("NetworkPoiRepo", "refreshPois() no tiene efecto en NetworkPoiRepository. Usa OfflineFirstPoiRepository.")
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/NetworkTrafficRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.util.Log
import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import com.georacing.georacing.domain.model.RouteTraffic
import com.georacing.georacing.domain.model.RouteTrafficStatus
import com.georacing.georacing.domain.model.ZoneOccupancy
import com.georacing.georacing.domain.model.ZoneOccupancyStatus
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

/**
 * Repositorio real que lee rutas y zonas de tr√°fico desde el backend.
 * Tablas: "routes" y "zone_traffic" en alpo.myqnapcloud.com:4010/api
 * 
 * Sustituye a FakeCrowdRepository ‚Äî datos reales gestionados desde Panel Metropolis.
 */
class NetworkTrafficRepository {

    private val TAG = "NetworkTrafficRepo"
    private val api = FirestoreLikeClient.api

    /**
     * Lee todas las rutas del circuito con su estado de tr√°fico.
     */
    suspend fun getRoutes(): List<RouteTraffic> {
        return try {
            val data = api.read("routes")
            data.map { row ->
                RouteTraffic(
                    id = (row["id"] as? String) ?: (row["route_id"] as? String) ?: "",
                    name = (row["name"] as? String) ?: "",
                    origin = (row["origin"] as? String) ?: "",
                    destination = (row["destination"] as? String) ?: "",
                    status = RouteTrafficStatus.fromString(row["status"] as? String),
                    activeUsers = ((row["active_users"] ?: row["activeUsers"])?.toString()?.toDoubleOrNull()?.toInt()) ?: 0,
                    capacity = (row["capacity"]?.toString()?.toDoubleOrNull()?.toInt()) ?: 0,
                    capacityPercentage = ((row["capacity_percentage"] ?: row["capacityPercentage"])?.toString()?.toDoubleOrNull()?.toInt()) ?: 0,
                    averageSpeed = ((row["average_speed"] ?: row["averageSpeed"])?.toString()?.toDoubleOrNull()) ?: 0.0,
                    distance = (row["distance"]?.toString()?.toDoubleOrNull()?.toInt()) ?: 0,
                    signalQuality = ((row["signal_quality"] ?: row["signalQuality"])?.toString()?.toDoubleOrNull()?.toInt()) ?: 0,
                    estimatedTime = ((row["estimated_time"] ?: row["estimatedTime"])?.toString()?.toDoubleOrNull()?.toInt()) ?: 0,
                    velocity = (row["velocity"]?.toString()?.toDoubleOrNull()) ?: 0.0
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching routes", e)
            emptyList()
        }
    }

    /**
     * Lee todas las zonas del circuito con ocupaci√≥n en tiempo real.
     */
    suspend fun getZoneTraffic(): List<ZoneOccupancy> {
        return try {
            val data = api.read("zone_traffic")
            data.map { row ->
                ZoneOccupancy(
                    id = (row["id"] as? String) ?: (row["zone_id"] as? String) ?: "",
                    name = (row["name"] as? String) ?: "",
                    type = (row["type"] as? String) ?: "GRADA",
                    status = ZoneOccupancyStatus.fromString(row["status"] as? String),
                    capacity = (row["capacity"]?.toString()?.toDoubleOrNull()?.toInt()) ?: 0,
                    currentOccupancy = ((row["current_occupancy"] ?: row["currentOccupancy"])?.toString()?.toDoubleOrNull()?.toInt()) ?: 0,
                    temperature = (row["temperature"]?.toString()?.toDoubleOrNull()) ?: 0.0,
                    waitTime = ((row["wait_time"] ?: row["waitTime"])?.toString()?.toDoubleOrNull()?.toInt()) ?: 0,
                    entryRate = ((row["entry_rate"] ?: row["entryRate"])?.toString()?.toDoubleOrNull()?.toInt()) ?: 0,
                    exitRate = ((row["exit_rate"] ?: row["exitRate"])?.toString()?.toDoubleOrNull()?.toInt()) ?: 0
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching zone_traffic", e)
            emptyList()
        }
    }

    /**
     * Flow que emite rutas peri√≥dicamente (para UI observables).
     */
    fun observeRoutes(intervalMs: Long = 15000): Flow<List<RouteTraffic>> = flow {
        while (true) {
            emit(getRoutes())
            kotlinx.coroutines.delay(intervalMs)
        }
    }

    /**
     * Flow que emite zonas de tr√°fico peri√≥dicamente.
     */
    fun observeZoneTraffic(intervalMs: Long = 15000): Flow<List<ZoneOccupancy>> = flow {
        while (true) {
            emit(getZoneTraffic())
            kotlinx.coroutines.delay(intervalMs)
        }
    }

    /**
     * Convierte datos de zona a HeatPoints para el mapa de calor.
     * Sustituye a FakeCrowdRepository.getHeatPoints().
     */
    fun getHeatPointsFromZones(zones: List<ZoneOccupancy>): List<HeatPoint> {
        // Coordenadas aproximadas de cada zona del Circuit de Barcelona-Catalunya
        val zoneCoordinates = mapOf(
            "grada-t1-recta-principal" to Pair(41.5695, 2.2585),
            "grada-t2-curva-ascari" to Pair(41.5678, 2.2610),
            "fan-zone-principal" to Pair(41.5690, 2.2595),
            "paddock-vip-boxes" to Pair(41.5702, 2.2575),
            "vial-acceso-a-norte" to Pair(41.5710, 2.2560),
            "grada-t3-chicane" to Pair(41.5685, 2.2555),
            "fan-zone-tecnologica" to Pair(41.5688, 2.2605)
        )

        return zones.mapNotNull { zone ->
            val coords = zoneCoordinates[zone.id] ?: return@mapNotNull null
            val intensity = (zone.occupancyPercentage / 100.0f).coerceIn(0f, 1f)
            val radius = when (zone.type) {
                "GRADA" -> 120f
                "FANZONE" -> 100f
                "PADDOCK" -> 80f
                "VIAL" -> 60f
                else -> 100f
            }
            HeatPoint(
                lat = coords.first,
                lon = coords.second,
                intensity = intensity,
                radius = radius
            )
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/NetworkUserRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.util.Log
import com.georacing.georacing.data.remote.RetrofitClient
import com.georacing.georacing.data.remote.dto.EnsureColumnRequest
import com.georacing.georacing.data.remote.dto.EnsureTableRequest
import com.georacing.georacing.data.remote.dto.UpsertRequest
import com.georacing.georacing.data.remote.dto.UserRequest
import java.util.zip.CRC32

class NetworkUserRepository {

    companion object {
        private const val TAG = "NetworkUserRepo"
        private const val TABLE = "users"
        private const val MAX_RETRIES = 2
    }

    private var schemaEnsured = false

    private suspend fun ensureSchema() {
        if (schemaEnsured) return
        RetrofitClient.api.ensureTable(EnsureTableRequest(TABLE))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(TABLE, "uid", "VARCHAR(200)"))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(TABLE, "display_name", "VARCHAR(255)"))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(TABLE, "email", "VARCHAR(255)"))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(TABLE, "photo_url", "TEXT"))
        RetrofitClient.api.ensureColumn(EnsureColumnRequest(TABLE, "last_login", "DOUBLE"))
        schemaEnsured = true
    }

    private fun stableId(value: String): Int {
        val crc = CRC32().apply { update(value.toByteArray()) }.value
        return (crc % Int.MAX_VALUE).toInt()
    }

    suspend fun registerUser(uid: String, name: String?, email: String?, photoUrl: String? = null): Result<Unit> {
        var attempt = 0
        var lastError: Exception? = null

        while (attempt < MAX_RETRIES) {
            try {
                ensureSchema()

                val request = UpsertRequest(
                    table = TABLE,
                    data = mapOf(
                        "id" to java.util.UUID.randomUUID().toString(), // Firebase Auth UUID / DB varchar
                        "uid" to uid,
                        "display_name" to name,
                        "email" to email,
                        "photo_url" to photoUrl,
                        "last_login" to System.currentTimeMillis().toDouble()
                    )
                )
                RetrofitClient.api.upsert(request)
                Log.d(TAG, "User registered/updated via upsert: $uid (attempt ${attempt + 1})")
                return Result.success(Unit)
            } catch (e: Exception) {
                lastError = e as? Exception ?: Exception(e)
                Log.e(TAG, "Error registering user $uid (attempt ${attempt + 1})", e)
                schemaEnsured = false // force re-ensure next loop
                attempt++
                if (attempt >= MAX_RETRIES) break
                // peque√±o backoff
                kotlinx.coroutines.delay(300)
            }
        }

        return Result.failure(lastError ?: Exception("Unknown error registering user $uid"))
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/OfflineFirstBeaconsRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.content.Context
import android.util.Log
import com.georacing.georacing.domain.model.ArrowDirection
import com.georacing.georacing.domain.model.BeaconConfig
import com.georacing.georacing.domain.repository.BeaconsRepository
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

/**
 * Offline-First wrapper para BeaconsRepository.
 *
 * # Estrategia:
 * - Los beacons son datos est√°ticos que raramente cambian.
 * - Se cachean como JSON en SharedPreferences.
 * - Network-first: intenta la red, cachea el resultado, y ante fallo usa cach√©.
 *
 * # Flujo:
 * ```
 * [Network API] --OK--> emit(data) + cache en SharedPreferences
 *       |
 *      FAIL --> leer SharedPreferences --> emit(cached)
 *                    |
 *                   VAC√çO --> emit(emptyList)
 * ```
 */
class OfflineFirstBeaconsRepository(
    private val networkRepository: BeaconsRepository,
    context: Context
) : BeaconsRepository {

    companion object {
        private const val TAG = "OfflineFirstBeaconsRepo"
        private const val PREFS_NAME = "beacons_cache"
        private const val KEY_BEACONS_JSON = "beacons_json"
        private const val KEY_CACHED_AT = "cached_at"
    }

    private val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    private val gson = Gson()

    override fun getBeacons(): Flow<List<BeaconConfig>> = flow {
        try {
            // 1. Intentar obtener de la red (collect el primer valor del flow de red)
            var networkBeacons: List<BeaconConfig>? = null
            networkRepository.getBeacons().collect { beacons ->
                networkBeacons = beacons
                return@collect // Solo necesitamos el primer emit
            }

            val beacons = networkBeacons ?: emptyList()

            if (beacons.isNotEmpty()) {
                // 2. Cachear resultado exitoso
                cacheBeacons(beacons)
                Log.d(TAG, "Red OK: ${beacons.size} beacons obtenidos y cacheados")
                emit(beacons)
            } else {
                // Red devolvi√≥ vac√≠o ‚Üí intentar cach√©
                val cached = getCachedBeacons()
                if (cached.isNotEmpty()) {
                    Log.d(TAG, "Red vac√≠a, usando ${cached.size} beacons cacheados")
                }
                emit(cached)
            }
        } catch (e: Exception) {
            // 3. Red fall√≥ ‚Üí fallback a cach√©
            Log.e(TAG, "Error de red, usando cach√©: ${e.message}", e)
            val cached = getCachedBeacons()
            if (cached.isNotEmpty()) {
                Log.d(TAG, "Fallback: ${cached.size} beacons desde cach√©")
            } else {
                Log.w(TAG, "Sin cach√© disponible, emitiendo lista vac√≠a")
            }
            emit(cached)
        }
    }

    // =========================================================================
    // Cache (SharedPreferences + Gson)
    // =========================================================================

    private fun cacheBeacons(beacons: List<BeaconConfig>) {
        try {
            val json = gson.toJson(beacons)
            prefs.edit()
                .putString(KEY_BEACONS_JSON, json)
                .putLong(KEY_CACHED_AT, System.currentTimeMillis())
                .apply()
        } catch (e: Exception) {
            Log.e(TAG, "Error al cachear beacons", e)
        }
    }

    private fun getCachedBeacons(): List<BeaconConfig> {
        return try {
            val json = prefs.getString(KEY_BEACONS_JSON, null) ?: return emptyList()
            val type = object : TypeToken<List<BeaconConfig>>() {}.type
            gson.fromJson<List<BeaconConfig>>(json, type) ?: emptyList()
        } catch (e: Exception) {
            Log.e(TAG, "Error al leer cach√© de beacons", e)
            emptyList()
        }
    }

    /**
     * Edad del cach√© en milisegundos. -1 si no hay cach√©.
     */
    fun getCacheAgeMs(): Long {
        val cachedAt = prefs.getLong(KEY_CACHED_AT, -1)
        return if (cachedAt > 0) System.currentTimeMillis() - cachedAt else -1
    }

    /**
     * Limpia el cach√© local de beacons.
     */
    fun clearCache() {
        prefs.edit().clear().apply()
        Log.d(TAG, "Cach√© de beacons limpiado")
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/OfflineFirstCircuitStateRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.content.Context
import android.util.Log
import com.georacing.georacing.domain.model.AppMode
import com.georacing.georacing.domain.model.CircuitMode
import com.georacing.georacing.domain.model.CircuitState
import com.georacing.georacing.domain.model.DriverInfo
import com.georacing.georacing.domain.model.RaceSessionInfo
import com.georacing.georacing.domain.repository.CircuitStateRepository
import com.google.gson.Gson
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOf

/**
 * Offline-First wrapper para CircuitStateRepository.
 *
 * # Estrategia:
 * - El estado del circuito se polleja cada 5s (datos vol√°tiles).
 * - Cada respuesta exitosa se cachea con timestamp.
 * - Si la red falla, emite el √∫ltimo estado conocido desde SharedPreferences.
 * - Incluye indicador de frescura para que la UI distinga datos live vs cacheados.
 *
 * # Flujo:
 * ```
 * loop {
 *   [Network API] --OK--> emit(data) + cache en SharedPreferences
 *         |
 *        FAIL --> leer SharedPreferences --> emit(cached con "‚ö° Datos en cach√©")
 *                      |
 *                     VAC√çO --> emit(default UNKNOWN state)
 *   delay(5000)
 * }
 * ```
 */
class OfflineFirstCircuitStateRepository(
    private val networkRepository: CircuitStateRepository,
    context: Context
) : CircuitStateRepository {

    companion object {
        private const val TAG = "OfflineFirstCircuitRepo"
        private const val PREFS_NAME = "circuit_state_cache"
        private const val KEY_MODE = "mode"
        private const val KEY_MESSAGE = "message"
        private const val KEY_TEMPERATURE = "temperature"
        private const val KEY_UPDATED_AT = "updated_at"
        private const val KEY_SESSION_JSON = "session_json"
        private const val KEY_CACHED_AT = "cached_at"
    }

    private val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    private val gson = Gson()

    override fun getCircuitState(): Flow<CircuitState> = flow {
        while (true) {
            try {
                // Intentar obtener de la red (un solo valor del polling flow)
                val state = networkRepository.getCircuitState().firstOrNull()
                if (state != null && state.mode != CircuitMode.UNKNOWN) {
                    // Red OK ‚Üí cachear y emitir
                    cacheState(state)
                    Log.d(TAG, "Red OK: estado=${state.mode}, msg=${state.message}")
                    emit(state)
                } else {
                    // Red devolvi√≥ UNKNOWN ‚Üí usar cach√©
                    val cached = getCachedState()
                    if (cached != null) {
                        Log.d(TAG, "Red UNKNOWN, usando cach√©: ${cached.mode}")
                        emit(cached.copy(message = "‚ö° ${cached.message ?: "Datos en cach√©"}"))
                    } else {
                        emit(state ?: CircuitState(CircuitMode.UNKNOWN, "Sin Conexi√≥n", null, ""))
                    }
                }
            } catch (e: Exception) {
                // Red fall√≥ ‚Üí fallback a cach√©
                Log.e(TAG, "Error de red, usando cach√©: ${e.message}")
                val cached = getCachedState()
                if (cached != null) {
                    Log.d(TAG, "Fallback cach√©: ${cached.mode}")
                    emit(cached.copy(message = "‚ö° ${cached.message ?: "Datos en cach√©"}"))
                } else {
                    Log.w(TAG, "Sin cach√©, emitiendo estado por defecto")
                    emit(CircuitState(CircuitMode.UNKNOWN, "Sin Conexi√≥n", null, ""))
                }
            }
            delay(5000)
        }
    }

    override fun setCircuitState(mode: CircuitMode, message: String?) {
        // Delegar al repo de red
        networkRepository.setCircuitState(mode, message)
    }

    override val appMode: Flow<AppMode> = networkRepository.appMode

    override val debugInfo: Flow<String> = flow {
        val cacheAge = getCacheAgeMs()
        val cacheInfo = if (cacheAge >= 0) {
            "Cache: ${cacheAge / 1000}s ago"
        } else {
            "Cache: vac√≠o"
        }
        emit("OfflineFirst | $cacheInfo")
    }

    // =========================================================================
    // Cache (SharedPreferences)
    // =========================================================================

    private fun cacheState(state: CircuitState) {
        try {
            prefs.edit()
                .putString(KEY_MODE, state.mode.name)
                .putString(KEY_MESSAGE, state.message)
                .putString(KEY_TEMPERATURE, state.temperature)
                .putString(KEY_UPDATED_AT, state.updatedAt)
                .putString(KEY_SESSION_JSON, state.sessionInfo?.let { gson.toJson(it) })
                .putLong(KEY_CACHED_AT, System.currentTimeMillis())
                .apply()
        } catch (e: Exception) {
            Log.e(TAG, "Error al cachear estado del circuito", e)
        }
    }

    private fun getCachedState(): CircuitState? {
        return try {
            val modeName = prefs.getString(KEY_MODE, null) ?: return null
            val mode = try { CircuitMode.valueOf(modeName) } catch (_: Exception) { CircuitMode.UNKNOWN }
            val message = prefs.getString(KEY_MESSAGE, null)
            val temperature = prefs.getString(KEY_TEMPERATURE, null)
            val updatedAt = prefs.getString(KEY_UPDATED_AT, "") ?: ""
            val sessionJson = prefs.getString(KEY_SESSION_JSON, null)
            val sessionInfo = sessionJson?.let {
                try { gson.fromJson(it, RaceSessionInfo::class.java) } catch (_: Exception) { null }
            }

            CircuitState(
                mode = mode,
                message = message,
                temperature = temperature,
                updatedAt = updatedAt,
                sessionInfo = sessionInfo
            )
        } catch (e: Exception) {
            Log.e(TAG, "Error al leer cach√© de estado del circuito", e)
            null
        }
    }

    /**
     * Edad del cach√© en milisegundos. -1 si no hay cach√©.
     */
    fun getCacheAgeMs(): Long {
        val cachedAt = prefs.getLong(KEY_CACHED_AT, -1)
        return if (cachedAt > 0) System.currentTimeMillis() - cachedAt else -1
    }

    /**
     * Limpia el cach√© local del estado del circuito.
     */
    fun clearCache() {
        prefs.edit().clear().apply()
        Log.d(TAG, "Cach√© de estado del circuito limpiado")
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/OfflineFirstIncidentsRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.content.Context
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.workDataOf
import com.georacing.georacing.data.local.dao.IncidentDao
import com.georacing.georacing.data.local.entities.IncidentEntity
import com.georacing.georacing.domain.model.IncidentCategory
import com.georacing.georacing.domain.model.IncidentReport
import com.georacing.georacing.domain.repository.IncidentsRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import java.util.UUID

class OfflineFirstIncidentsRepository(
    private val incidentDao: IncidentDao,
    private val context: Context // For WorkManager
) : IncidentsRepository {

    override suspend fun getIncidents(): Flow<List<IncidentReport>> {
        return incidentDao.getAllIncidents().map { entities ->
            entities.map { entity ->
                IncidentReport(
                    category = try {
                        IncidentCategory.valueOf(entity.category)
                    } catch (e: Exception) {
                        IncidentCategory.OTRA
                    },
                    description = entity.description,
                    beaconId = entity.beaconId,
                    zone = entity.zone,
                    timestamp = entity.timestamp
                )
            }
        }
    }

    override suspend fun reportIncident(incident: IncidentReport) {
        val entity = IncidentEntity(
            id = UUID.randomUUID().toString(),
            category = incident.category.name,
            description = incident.description,
            beaconId = incident.beaconId,
            zone = incident.zone,
            timestamp = incident.timestamp,
            isSynced = false
        )

        // 1. Save locally (Always success)
        incidentDao.insertIncident(entity)

        // 2. Schedule Sync
        // Note: Assuming SyncIncidentsWorker exists or will be created. 
        // For now we just enqueue a generic sync request or log it.
        // If Worker is not compiled yet, we wrap in try/catch or comment out worker class reference.
        // We will use a generic WorkRequest for "SyncIncidents" tag.
        
        try {
             // Placeholder for WorkManager logic 
             // val request = OneTimeWorkRequestBuilder<SyncIncidentsWorker>().addTag("sync_incidents").build()
             // WorkManager.getInstance(context).enqueue(request)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/OfflineFirstPoiRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.util.Log
import com.georacing.georacing.data.local.dao.PoiDao
import com.georacing.georacing.data.local.entities.PoiEntity
import com.georacing.georacing.data.local.mappers.toDomain
import com.georacing.georacing.data.local.mappers.toEntities
import com.georacing.georacing.data.remote.GeoRacingApi
import com.georacing.georacing.domain.model.Poi
import com.georacing.georacing.domain.model.PoiType
import com.georacing.georacing.domain.repository.PoiRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onStart

/**
 * Implementaci√≥n Offline-First del PoiRepository.
 * 
 * # Patr√≥n Single Source of Truth (SSOT):
 * - La UI observa SOLO la base de datos local (Room).
 * - Los datos de red se guardan en la DB, lo que dispara actualizaciones autom√°ticas a la UI.
 * - Si la red falla, la UI sigue mostrando datos cacheados sin crashear.
 * 
 * # Flujo de Datos:
 * ```
 * [Network API] --> [Room Database] --> [Flow<List<Poi>>] --> [UI]
 *       |                   ^
 *       +-------------------+
 *        refreshPois() guarda aqu√≠
 * ```
 */
class OfflineFirstPoiRepository(
    private val api: GeoRacingApi,
    private val dao: PoiDao
) : PoiRepository {

    companion object {
        private const val TAG = "OfflineFirstPoiRepo"
    }

    // =========================================================================
    // POIs Hardcodeados (Fallback inicial / datos esenciales)
    // =========================================================================
    
    private val hardcodedPois = listOf(
        PoiEntity("main_gate", "Acceso Principal", "GATE", "Entrada Principal Circuit", "Accesos", 0f, 0f, 41.56872, 2.25668),
        PoiEntity("gate_3", "Porta 3", "GATE", "Acceso Este", "Accesos", 0f, 0f, 41.56840, 2.25870),
        PoiEntity("parking_a", "Parking A", "PARKING", "Parking Zona Norte-Oeste", "Parking", 0f, 0f, 41.57063, 2.25796),
        PoiEntity("parking_b", "Parking B", "PARKING", "Parking Zona Norte", "Parking", 0f, 0f, 41.57133, 2.25574),
        PoiEntity("parking_c", "Parking C", "PARKING", "Parking Zona Este", "Parking", 0f, 0f, 41.56895, 2.26235),
        PoiEntity("parking_d", "Parking D", "PARKING", "Parking Zona Sur-Este", "Parking", 0f, 0f, 41.56552, 2.26330),
        PoiEntity("parking_e", "Parking E", "PARKING", "Parking Zona Sur", "Parking", 0f, 0f, 41.56480, 2.26053),
        PoiEntity("parking_f", "Parking F", "PARKING", "Parking Zona Sur-Oeste", "Parking", 0f, 0f, 41.56472, 2.25832)
    )

    // =========================================================================
    // EXPOSED DATA (UI observa esto)
    // =========================================================================

    /**
     * Observa los POIs desde la base de datos local.
     * 
     * - Convierte Entity -> Domain usando mappers.
     * - Emite autom√°ticamente cuando la DB cambia.
     * - onStart: Si la DB est√° vac√≠a, inserta los POIs hardcodeados.
     */
    override fun getPois(): Flow<List<Poi>> {
        return dao.getAllPois()
            .onStart { 
                // Seed inicial: si no hay datos, insertar hardcoded
                if (dao.count() == 0) {
                    Log.d(TAG, "DB vac√≠a, insertando ${hardcodedPois.size} POIs hardcodeados")
                    dao.insertPois(hardcodedPois)
                }
            }
            .map { entities ->
                entities.map { it.toDomain() }
            }
    }

    // =========================================================================
    // SYNC (Llamar desde ViewModel, WorkManager, Pull-to-Refresh)
    // =========================================================================

    /**
     * Sincroniza los POIs desde la API hacia la base de datos local.
     * 
     * - Si la red falla, loguea el error pero NO lanza excepci√≥n.
     * - Los datos viejos (cach√©) permanecen disponibles.
     * - Al insertar en la DB, el Flow de getPois() emite autom√°ticamente.
     */
    override suspend fun refreshPois() {
        try {
            Log.d(TAG, "Iniciando sync de POIs desde la red...")
            
            // 1. Fetch desde la API
            val networkPois = api.getPois()
            Log.d(TAG, "Recibidos ${networkPois.size} POIs de la API")
            
            // 2. Convertir DTO -> Entity
            val entities = networkPois.toEntities()
            
            // 3. Merge con hardcoded (opcional: puedes decidir si limpiar primero)
            val allEntities = entities + hardcodedPois
            
            // 4. Insertar en la DB (REPLACE strategy actualiza si ID existe)
            dao.insertPois(allEntities)
            Log.d(TAG, "Sync completado: ${allEntities.size} POIs en cach√©")
            
        } catch (e: Exception) {
            // ‚ö†Ô∏è NO lanzar excepci√≥n - la UI sigue con datos cacheados
            Log.e(TAG, "Error al sincronizar POIs: ${e.message}", e)
            // Opcionalmente, podr√≠as emitir un evento a un SharedFlow para mostrar un Snackbar
        }
    }

    /**
     * Fuerza una recarga completa (limpia cach√© + sync).
     */
    suspend fun forceRefresh() {
        dao.deleteAll()
        refreshPois()
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/repository/ShareSessionRepository.kt`

```kotlin
package com.georacing.georacing.data.repository

import android.util.Log
import com.georacing.georacing.data.firebase.FirebaseAuthService
import com.georacing.georacing.data.firestorelike.FirestoreLikeApi
import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import com.georacing.georacing.data.model.ShareSession
import com.google.firebase.Timestamp
import java.util.*

/**
 * Repositorio para gestionar sesiones de compartir ubicaci√≥n mediante QR
 * Usando base de datos SQL local a trav√©s de FirestoreLikeClient
 */
class ShareSessionRepository {
    private val authService = FirebaseAuthService()
    
    companion object {
        private const val TAG = "ShareSessionRepo"
        private const val TABLE_SESSIONS = "share_sessions"
        private const val TABLE_GROUPS = "groups"
        private const val TABLE_MEMBERS = "group_members"
    }
    
    suspend fun createShareSession(groupId: String, eventDate: Date): Result<ShareSession> {
        return try {
            val userResult = authService.requireGoogleSignedIn()
            if (userResult.isFailure) {
                return Result.failure(userResult.exceptionOrNull() ?: Exception("Usuario no autenticado"))
            }
            
            val currentUser = userResult.getOrNull()!!
            val sessionId = UUID.randomUUID().toString()
            
            // Check if group exists natively via API
            val groupReq = FirestoreLikeApi.GetRequest(TABLE_GROUPS, mapOf("id" to groupId))
            val existingGroups = FirestoreLikeClient.api.get(groupReq)
            
            if (existingGroups.isEmpty()) {
                FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                    table = TABLE_GROUPS,
                    data = mapOf(
                        "id" to groupId,
                        "name" to "Grupo de ${currentUser.displayName}",
                        "ownerId" to currentUser.uid,
                        "createdAt" to System.currentTimeMillis(),
                        "isActive" to true
                    )
                ))
            }
            
            // Add creator to members
            FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                table = TABLE_MEMBERS,
                data = mapOf(
                    "groupId" to groupId,
                    "userId" to currentUser.uid,
                    "displayName" to (currentUser.displayName ?: "Usuario"),
                    "photoUrl" to (currentUser.photoUrl?.toString() ?: ""),
                    "joinedAt" to System.currentTimeMillis(),
                    "role" to "owner"
                )
            ))
            
            val calendar = Calendar.getInstance().apply {
                time = eventDate
                set(Calendar.HOUR_OF_DAY, 23)
                set(Calendar.MINUTE, 59)
                set(Calendar.SECOND, 59)
            }
            
            val session = ShareSession(
                sessionId = sessionId,
                ownerId = currentUser.uid,
                ownerName = currentUser.displayName ?: "Usuario",
                eventDate = Timestamp(eventDate),
                expiresAt = Timestamp(calendar.time),
                createdAt = Timestamp.now(),
                isActive = true,
                groupId = groupId
            )
            
            // Save Session via API
            FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                table = TABLE_SESSIONS,
                data = mapOf(
                    "sessionId" to session.sessionId,
                    "groupId" to session.groupId,
                    "ownerId" to session.ownerId,
                    "ownerName" to session.ownerName,
                    "eventDate" to session.eventDate.toDate().time,
                    "expiresAt" to session.expiresAt.toDate().time,
                    "createdAt" to session.createdAt.toDate().time,
                    "isActive" to session.isActive
                )
            ))
            
            Log.d(TAG, "‚úÖ Sesi√≥n QR creada en BD Local: $sessionId")
            Result.success(session)
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error creando sesi√≥n", e)
            Result.failure(e)
        }
    }
    
    suspend fun getSession(sessionId: String): Result<ShareSession> {
        return try {
            val req = FirestoreLikeApi.GetRequest(TABLE_SESSIONS, mapOf("sessionId" to sessionId))
            val results = FirestoreLikeClient.api.get(req)
            
            if (results.isEmpty()) {
                return Result.failure(Exception("Sesi√≥n no encontrada"))
            }
            
            val data = results.first()
            val eventDateMillis = (data["eventDate"] as? Number)?.toLong() ?: 0L
            val expiresAtMillis = (data["expiresAt"] as? Number)?.toLong() ?: 0L
            val createdAtMillis = (data["createdAt"] as? Number)?.toLong() ?: 0L
            
            val session = ShareSession(
                sessionId = data["sessionId"]?.toString() ?: "",
                ownerId = data["ownerId"]?.toString() ?: "",
                ownerName = data["ownerName"]?.toString() ?: "",
                eventDate = Timestamp(Date(eventDateMillis)),
                expiresAt = Timestamp(Date(expiresAtMillis)),
                createdAt = Timestamp(Date(createdAtMillis)),
                isActive = (data["isActive"] as? Boolean) ?: true,
                groupId = data["groupId"]?.toString() ?: ""
            )
            
            if (session.isExpired()) {
                return Result.failure(Exception("Sesi√≥n expirada"))
            }
            
            Result.success(session)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun joinSessionGroup(sessionId: String): Result<String> {
        return try {
            val userResult = authService.requireGoogleSignedIn()
            if (userResult.isFailure) return Result.failure(userResult.exceptionOrNull() ?: Exception("No auth"))
            
            val sessionResult = getSession(sessionId)
            if (sessionResult.isFailure) return Result.failure(sessionResult.exceptionOrNull() ?: Exception("Invalid"))
            
            val session = sessionResult.getOrNull()!!
            val currentUser = userResult.getOrNull()!!
            
            FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                table = TABLE_MEMBERS,
                data = mapOf(
                    "groupId" to session.groupId,
                    "userId" to currentUser.uid,
                    "displayName" to (currentUser.displayName ?: "Usuario"),
                    "photoUrl" to (currentUser.photoUrl?.toString() ?: ""),
                    "joinedAt" to System.currentTimeMillis(),
                    "joinedVia" to "qr_session",
                    "sessionId" to sessionId
                )
            ))
            
            Log.d(TAG, "‚úÖ Usuario unido a grupo local: ${session.groupId}")
            Result.success(session.groupId)
            
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun getMySessions(): Result<List<ShareSession>> {
        return try {
            val userResult = authService.requireGoogleSignedIn()
            if (userResult.isFailure) return Result.failure(Exception("No auth"))
            
            val currentUser = userResult.getOrNull()!!
            val req = FirestoreLikeApi.GetRequest(TABLE_SESSIONS, mapOf("ownerId" to currentUser.uid, "isActive" to true))
            val results = FirestoreLikeClient.api.get(req)
            
            val nowMillis = System.currentTimeMillis()
            val sessions = results.mapNotNull { data ->
                val expiresAtMillis = (data["expiresAt"] as? Number)?.toLong() ?: 0L
                if (expiresAtMillis > nowMillis) {
                    val eventDateMillis = (data["eventDate"] as? Number)?.toLong() ?: 0L
                    val createdAtMillis = (data["createdAt"] as? Number)?.toLong() ?: 0L
                    ShareSession(
                        sessionId = data["sessionId"]?.toString() ?: "",
                        ownerId = data["ownerId"]?.toString() ?: "",
                        ownerName = data["ownerName"]?.toString() ?: "",
                        eventDate = Timestamp(Date(eventDateMillis)),
                        expiresAt = Timestamp(Date(expiresAtMillis)),
                        createdAt = Timestamp(Date(createdAtMillis)),
                        isActive = (data["isActive"] as? Boolean) ?: true,
                        groupId = data["groupId"]?.toString() ?: ""
                    )
                } else null
            }
            
            Result.success(sessions)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun deactivateSession(sessionId: String): Result<Unit> {
        return try {
            // Our generic api doesn't specifically have a distinct single field update, 
            // but upsert by ID typically overwrites or we can fetch, modify and upsert.
            // In SQL an upsert based on sessionId will work since that's the PK.
            val sessionReq = getSession(sessionId)
            if (sessionReq.isSuccess) {
                val s = sessionReq.getOrNull()!!
                FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                    table = TABLE_SESSIONS,
                    data = mapOf(
                        "sessionId" to s.sessionId,
                        "groupId" to s.groupId,
                        "ownerId" to s.ownerId,
                        "ownerName" to s.ownerName,
                        "eventDate" to s.eventDate.toDate().time,
                        "expiresAt" to s.expiresAt.toDate().time,
                        "createdAt" to s.createdAt.toDate().time,
                        "isActive" to false
                    )
                ))
            }
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/sensors/OrientationEngine.kt`

```kotlin
package com.georacing.georacing.data.sensors

import android.content.Context
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlin.math.abs

/**
 * Provides device orientation (Azimuth & Pitch) using Accelerometer + Magnetometer.
 * Uses a Low-Pass Filter to smooth out jitter.
 */
class OrientationEngine(context: Context) {

    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager
    private val accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
    private val magnetometer = sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD)

    data class Orientation(
        val azimuth: Float, // 0-360 degrees
        val pitch: Float    // -90 to +90 degrees
    )

    fun getOrientationFlow(): Flow<Orientation> = callbackFlow {
        var gravity: FloatArray? = null
        var geomagnetic: FloatArray? = null

        val listener = object : SensorEventListener {
            override fun onSensorChanged(event: SensorEvent) {
                if (event.sensor.type == Sensor.TYPE_ACCELEROMETER) {
                    gravity = lowPassFilter(event.values.clone(), gravity)
                } else if (event.sensor.type == Sensor.TYPE_MAGNETIC_FIELD) {
                    geomagnetic = lowPassFilter(event.values.clone(), geomagnetic)
                }

                if (gravity != null && geomagnetic != null) {
                    val R = FloatArray(9)
                    val I = FloatArray(9)

                    if (SensorManager.getRotationMatrix(R, I, gravity, geomagnetic)) {
                        val orientation = FloatArray(3)
                        SensorManager.getOrientation(R, orientation)

                        val azimuth = Math.toDegrees(orientation[0].toDouble()).toFloat() // 0..360 (needs normalization)
                        val pitch = Math.toDegrees(orientation[1].toDouble()).toFloat()

                        // Normalize Azimuth to 0-360
                        val normalizedAzimuth = (azimuth + 360) % 360

                        trySend(Orientation(normalizedAzimuth, pitch))
                    }
                }
            }

            override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {
                // No-op
            }
        }

        sensorManager.registerListener(listener, accelerometer, SensorManager.SENSOR_DELAY_NORMAL)
        sensorManager.registerListener(listener, magnetometer, SensorManager.SENSOR_DELAY_NORMAL)

        awaitClose {
            sensorManager.unregisterListener(listener)
        }
    }

    // Simple Low-Pass Filter
    private fun lowPassFilter(input: FloatArray, output: FloatArray?): FloatArray {
        if (output == null) return input
        val alpha = 0.1f // Smooth factor (Lower = Slower/Smoother)
        for (i in input.indices) {
            output[i] = output[i] + alpha * (input[i] - output[i])
        }
        return output
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/sensors/OrientationManager.kt`

```kotlin
package com.georacing.georacing.data.sensors

import android.content.Context
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlin.math.abs

/**
 * Manages device sensors (Accelerometer & Magnetometer) to calculate the device's Azimuth.
 * Uses a low-pass filter to smooth out sensor noise.
 */
class OrientationManager(context: Context) : SensorEventListener {

    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager
    private val accelerometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
    private val magnetometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD)

    private var gravity: FloatArray? = null
    private var geomagnetic: FloatArray? = null

    private val _azimuth = MutableStateFlow(0f)
    val azimuth: StateFlow<Float> = _azimuth.asStateFlow()

    private val alpha = 0.97f // Low-pass filter factor (higher = smoother but slower)

    fun startListening() {
        accelerometer?.let {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)
        }
        magnetometer?.let {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)
        }
    }

    fun stopListening() {
        sensorManager.unregisterListener(this)
    }

    override fun onSensorChanged(event: SensorEvent?) {
        event ?: return

        if (event.sensor.type == Sensor.TYPE_ACCELEROMETER) {
            gravity = lowPass(event.values.clone(), gravity)
        } else if (event.sensor.type == Sensor.TYPE_MAGNETIC_FIELD) {
            geomagnetic = lowPass(event.values.clone(), geomagnetic)
        }

        if (gravity != null && geomagnetic != null) {
            val r = FloatArray(9)
            val i = FloatArray(9)

            if (SensorManager.getRotationMatrix(r, i, gravity, geomagnetic)) {
                val orientation = FloatArray(3)
                SensorManager.getOrientation(r, orientation)

                // orientation[0] is azimuth in radians (-pi to pi)
                // Convert to degrees (0 to 360)
                var degree = Math.toDegrees(orientation[0].toDouble()).toFloat()
                degree = (degree + 360) % 360

                // Only emit if change is significant to reduce recompositions
                if (abs(degree - _azimuth.value) > 1.0f) {
                    _azimuth.value = degree
                }
            }
        }
    }

    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {
        // No-op
    }

    private fun lowPass(input: FloatArray, output: FloatArray?): FloatArray {
        if (output == null) return input
        for (i in input.indices) {
            output[i] = output[i] + alpha * (input[i] - output[i])
        }
        return output
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/data/workers/OrderStatusWorker.kt`

```kotlin
package com.georacing.georacing.data.workers

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.os.Build
import androidx.core.app.NotificationCompat
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.georacing.georacing.R
import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import com.georacing.georacing.data.firestorelike.FirestoreLikeApi

class OrderStatusWorker(
    appContext: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(appContext, workerParams) {

    override suspend fun doWork(): Result {
        val auth = com.google.firebase.auth.FirebaseAuth.getInstance()
        val user = auth.currentUser
        if (user == null) return Result.success()

        val api = FirestoreLikeClient.api
        val prefs = applicationContext.getSharedPreferences("geo_racing_orders", Context.MODE_PRIVATE)

        try {
            // Fetch orders for this user that are READY
            val result = api.get(
                FirestoreLikeApi.GetRequest(
                    table = "orders",
                    where = mapOf("user_uid" to user.uid, "status" to "READY")
                )
            )

            result.forEach { orderData ->
                 val orderId = orderData["order_id"] as? String ?: return@forEach
                 val wasNotified = prefs.getBoolean("notified_$orderId", false)

                 if (!wasNotified) {
                     showNotification()
                     // Mark as notified
                     prefs.edit().putBoolean("notified_$orderId", true).apply()
                 }
            }

            return Result.success()
        } catch (e: Exception) {
            e.printStackTrace()
            return Result.retry()
        }
    }

    private fun showNotification() {
        val context = applicationContext
        val channelId = "order_updates"
        val manager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(channelId, "Order Updates", NotificationManager.IMPORTANCE_HIGH)
            manager.createNotificationChannel(channel)
        }

        val resultIntent = android.content.Intent(context, com.georacing.georacing.MainActivity::class.java).apply {
            flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK or android.content.Intent.FLAG_ACTIVITY_CLEAR_TASK
            putExtra("navigate_to", "my_orders")
        }
        val pendingIntent = android.app.PendingIntent.getActivity(
            context, 0, resultIntent, 
            android.app.PendingIntent.FLAG_UPDATE_CURRENT or android.app.PendingIntent.FLAG_IMMUTABLE
        )

        val notification = NotificationCompat.Builder(context, channelId)
            .setContentTitle("¬°Tu pedido est√° listo!")
            .setContentText("Pasa por la barra para recoger tu comida.")
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .build()

        manager.notify(1001, notification)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/debug/ScenarioSimulator.kt`

```kotlin
package com.georacing.georacing.debug

import android.util.Log
import com.georacing.georacing.data.ble.BleCircuitSignal
import com.georacing.georacing.data.firestorelike.FirestoreLikeApi
import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import com.georacing.georacing.data.gamification.GamificationRepository
import com.georacing.georacing.domain.model.CircuitMode
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

object ScenarioSimulator {

    // Battery Simulation (Null = Real, Int = Forced %)
    private val _forcedBatteryLevel = MutableStateFlow<Int?>(null)
    val forcedBatteryLevel: StateFlow<Int?> = _forcedBatteryLevel.asStateFlow()

    // BLE Signal Simulation (Null = Real, Object = Forced)
    private val _forcedBleSignal = MutableStateFlow<BleCircuitSignal?>(null)
    val forcedBleSignal: StateFlow<BleCircuitSignal?> = _forcedBleSignal.asStateFlow()

    // Car Connection Simulation (Null = Real, Boolean = Forced (True=Connected, False=Disconnected))
    private val _forcedCarConnection = MutableStateFlow<Boolean?>(null)
    val forcedCarConnection: StateFlow<Boolean?> = _forcedCarConnection.asStateFlow()

    // Fake Health Data
    private val _extraFakeSteps = MutableStateFlow(0)
    val extraFakeSteps: StateFlow<Int> = _extraFakeSteps.asStateFlow()

    fun addFakeSteps(steps: Int) {
        _extraFakeSteps.value += steps
    }

    // Crowd Heatmap Simulation
    // 0.0 = Low (Green), 1.0 = Critical (Red)
    private val _crowdIntensity = MutableStateFlow(0.2f) // Default safe
    val crowdIntensity: StateFlow<Float> = _crowdIntensity.asStateFlow()

    fun triggerCrowdSurge() {
        _crowdIntensity.value = 0.9f
    }

    fun resetCrowd() {
        _crowdIntensity.value = 0.2f
    }

    // Network Resilience Simulation
    private val _isNetworkDead = MutableStateFlow(false)
    val isNetworkDead: StateFlow<Boolean> = _isNetworkDead.asStateFlow()

    fun killNetwork() {
        _isNetworkDead.value = true
    }

    fun restoreNetwork() {
        _isNetworkDead.value = false
    }

    // UI Visibility State
    private val _showDebugPanel = MutableStateFlow(false)
    val showDebugPanel: StateFlow<Boolean> = _showDebugPanel.asStateFlow()

    fun setDebugPanelVisible(visible: Boolean) {
        _showDebugPanel.value = visible
    }

    // Smart Ticket (Proximity to Gate)
    private val _isAtGate = MutableStateFlow(false)
    val isAtGate: StateFlow<Boolean> = _isAtGate.asStateFlow()

    fun arriveAtGate() {
        _isAtGate.value = true
    }

    fun resetGate() {
        _isAtGate.value = false
    }

    val isSimulationActive: Boolean
        get() = _forcedBatteryLevel.value != null || _forcedBleSignal.value != null || _forcedCarConnection.value != null

    fun simulateSurvivalMode() {
        _forcedBatteryLevel.value = 20
        _forcedCarConnection.value = false // Car disconnected usually implies relying on phone battery
    }
    
    fun simulateEvacuation() {
        val signal = BleCircuitSignal(
            version = 1,
            zoneId = 999,
            mode = CircuitMode.EVACUATION,
            flags = 0,
            sequence = 1000,
            ttlSeconds = 60,
            timestamp = System.currentTimeMillis()
        )
        _forcedBleSignal.value = signal
    }

    fun simulateCarConnect() {
        _forcedCarConnection.value = true
    }

    fun simulateCarDisconnect() {
        _forcedCarConnection.value = false
    }

    fun resetAll() {
        _forcedBatteryLevel.value = null
        _forcedBleSignal.value = null
        _forcedCarConnection.value = null
        _isAtGate.value = false
        _activeHazards.value = emptyList()
        _simulatedSpeed.value = 0f
    }
    
    // =============================================
    // WAZE-STYLE HAZARD SIMULATION
    // =============================================
    
    data class RoadHazard(
        val id: String,
        val type: HazardType,
        val lat: Double,
        val lon: Double,
        val description: String
    )
    
    enum class HazardType(val emoji: String, val label: String) {
        POLICE("üëÆ", "Control de Acceso"),
        CONSTRUCTION("üöß", "Obras en Pista"),
        TRAFFIC("üöó", "Tr√°fico Pesado"),
        ACCIDENT("‚ö†Ô∏è", "Accidente")
    }
    
    private val _activeHazards = MutableStateFlow<List<RoadHazard>>(emptyList())
    val activeHazards: StateFlow<List<RoadHazard>> = _activeHazards.asStateFlow()
    
    // Simulated Speed (km/h)
    private val _simulatedSpeed = MutableStateFlow(0f)
    val simulatedSpeed: StateFlow<Float> = _simulatedSpeed.asStateFlow()
    
    // Speed Limit for the current zone (km/h)
    private val _speedLimit = MutableStateFlow(50f)
    val speedLimit: StateFlow<Float> = _speedLimit.asStateFlow()
    
    fun setSimulatedSpeed(speed: Float) {
        _simulatedSpeed.value = speed
    }
    
    fun addHazard(type: HazardType) {
        // Default positions around Circuit de Barcelona-Catalunya
        val hazardPositions = mapOf(
            HazardType.POLICE to Pair(41.5705, 2.2585),
            HazardType.CONSTRUCTION to Pair(41.5690, 2.2560),
            HazardType.TRAFFIC to Pair(41.5680, 2.2550),
            HazardType.ACCIDENT to Pair(41.5710, 2.2575)
        )
        
        val pos = hazardPositions[type] ?: Pair(41.5700, 2.2600)
        val hazard = RoadHazard(
            id = "${type.name}_${System.currentTimeMillis()}",
            type = type,
            lat = pos.first,
            lon = pos.second,
            description = type.label
        )
        
        _activeHazards.value = _activeHazards.value + hazard
    }
    
    fun clearHazards() {
        _activeHazards.value = emptyList()
    }
    
    // =============================================
    // OTHER RACERS SIMULATION (Waze-like community)
    // =============================================
    
    data class SimulatedRacer(
        val id: String,
        var lat: Double,
        var lon: Double,
        val avatar: String = "üèéÔ∏è"
    )
    
    private val _otherRacers = MutableStateFlow<List<SimulatedRacer>>(emptyList())
    val otherRacers: StateFlow<List<SimulatedRacer>> = _otherRacers.asStateFlow()
    
    fun spawnRacers(count: Int = 5) {
        val baseLat = 41.5700
        val baseLon = 2.2600
        val racers = (1..count).map { i ->
            SimulatedRacer(
                id = "racer_$i",
                lat = baseLat + (Math.random() - 0.5) * 0.01,
                lon = baseLon + (Math.random() - 0.5) * 0.01,
                avatar = listOf("üèéÔ∏è", "üèÅ", "ü™ñ", "‚õëÔ∏è").random()
            )
        }
        _otherRacers.value = racers
    }
    
    fun moveRacersRandomly() {
        _otherRacers.value = _otherRacers.value.map { racer ->
            racer.copy(
                lat = racer.lat + (Math.random() - 0.5) * 0.0005,
                lon = racer.lon + (Math.random() - 0.5) * 0.0005
            )
        }
    }
    
    fun clearRacers() {
        _otherRacers.value = emptyList()
    }

    // =============================================
    // GAMIFICATION / ACHIEVEMENTS SIMULATION
    // =============================================

    private val debugScope = CoroutineScope(Dispatchers.IO)
    private var gamificationRepo: GamificationRepository? = null

    fun setGamificationRepo(repo: GamificationRepository) {
        gamificationRepo = repo
    }

    /** Desbloquea un logro por su ID */
    fun unlockAchievement(id: String) {
        gamificationRepo?.unlockAchievement(id)
            ?: Log.w("ScenarioSimulator", "GamificationRepo no disponible")
    }

    /** Desbloquea TODOS los logros de golpe */
    fun unlockAllAchievements() {
        val repo = gamificationRepo ?: return
        GamificationRepository.allAchievements.forEach { a ->
            repo.unlockAchievement(a.id)
        }
    }

    /** Resetea todos los logros (perfil limpio) */
    fun resetAllAchievements() {
        debugScope.launch {
            try {
                FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                    table = "gamification_profile",
                    data = mapOf(
                        "id" to "current_user",
                        "totalXP" to 0,
                        "level" to 1,
                        "unlockedAchievements" to emptyList<String>(),
                        "circuitsVisited" to 0,
                        "kmWalked" to 0f,
                        "friendsInGroup" to 0
                    )
                ))
                Log.d("ScenarioSimulator", "Logros reseteados ‚Äî reinicia la pantalla para ver cambios")
            } catch (e: Exception) {
                Log.e("ScenarioSimulator", "Error reseteando logros: ${e.message}")
            }
        }
    }

    /** A√±ade XP bonus artificial */
    fun addBonusXP(amount: Int) {
        val repo = gamificationRepo ?: return
        val current = repo.profile.value
        // Hack: desbloquear un logro ficticio con XP custom ser√≠a complicado,
        // usamos el mecanismo existente: sumar XP directamente
        debugScope.launch {
            try {
                val newXP = current.totalXP + amount
                FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                    table = "gamification_profile",
                    data = mapOf(
                        "id" to "current_user",
                        "totalXP" to newXP,
                        "level" to (newXP / 250) + 1,
                        "unlockedAchievements" to current.achievements.filter { it.isUnlocked }.map { it.id },
                        "circuitsVisited" to current.circuitsVisited,
                        "kmWalked" to current.kmWalked,
                        "friendsInGroup" to current.friendsInGroup
                    )
                ))
                Log.d("ScenarioSimulator", "+${amount} XP ‚Üí Total: $newXP")
            } catch (e: Exception) {
                Log.e("ScenarioSimulator", "Error a√±adiendo XP: ${e.message}")
            }
        }
    }

    // =============================================
    // COLLECTIBLES SIMULATION
    // =============================================

    /** Desbloquea un coleccionable espec√≠fico por ID */
    fun unlockCollectible(collectibleId: String) {
        debugScope.launch {
            try {
                FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                    table = "user_collectibles",
                    data = mapOf(
                        "id" to collectibleId,
                        "collectible_id" to collectibleId,
                        "unlocked" to true,
                        "unlocked_at" to System.currentTimeMillis()
                    )
                ))
                Log.d("ScenarioSimulator", "Coleccionable $collectibleId desbloqueado")
            } catch (e: Exception) {
                Log.e("ScenarioSimulator", "Error desbloqueando coleccionable: ${e.message}")
            }
        }
    }

    /** Desbloquea TODOS los coleccionables (c01..c24) */
    fun unlockAllCollectibles() {
        debugScope.launch {
            try {
                for (i in 1..24) {
                    val id = "c${i.toString().padStart(2, '0')}"
                    FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                        table = "user_collectibles",
                        data = mapOf(
                            "id" to id,
                            "collectible_id" to id,
                            "unlocked" to true,
                            "unlocked_at" to System.currentTimeMillis()
                        )
                    ))
                }
                Log.d("ScenarioSimulator", "24 coleccionables desbloqueados")
            } catch (e: Exception) {
                Log.e("ScenarioSimulator", "Error desbloqueando coleccionables: ${e.message}")
            }
        }
    }

    /** Desbloquea coleccionables aleatorios (n de 24) */
    fun unlockRandomCollectibles(count: Int = 5) {
        debugScope.launch {
            try {
                val ids = (1..24).map { "c${it.toString().padStart(2, '0')}" }.shuffled().take(count)
                ids.forEach { id ->
                    FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                        table = "user_collectibles",
                        data = mapOf(
                            "id" to id,
                            "collectible_id" to id,
                            "unlocked" to true,
                            "unlocked_at" to System.currentTimeMillis()
                        )
                    ))
                }
                Log.d("ScenarioSimulator", "$count coleccionables aleatorios desbloqueados: $ids")
            } catch (e: Exception) {
                Log.e("ScenarioSimulator", "Error: ${e.message}")
            }
        }
    }

    /** Resetea todos los coleccionables */
    fun resetAllCollectibles() {
        debugScope.launch {
            try {
                for (i in 1..24) {
                    val id = "c${i.toString().padStart(2, '0')}"
                    FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                        table = "user_collectibles",
                        data = mapOf(
                            "id" to id,
                            "collectible_id" to id,
                            "unlocked" to false,
                            "unlocked_at" to 0
                        )
                    ))
                }
                Log.d("ScenarioSimulator", "Coleccionables reseteados")
            } catch (e: Exception) {
                Log.e("ScenarioSimulator", "Error reseteando coleccionables: ${e.message}")
            }
        }
    }

    // =============================================
    // LOCATION / ZONE SIMULATION (desbloquea exploraci√≥n)
    // =============================================

    /** Nombre de la zona simulada actual (null = ubicaci√≥n real) */
    private val _simulatedZone = MutableStateFlow<String?>(null)
    val simulatedZone: StateFlow<String?> = _simulatedZone.asStateFlow()

    /** Simula estar en una zona espec√≠fica del circuito */
    fun simulateZoneVisit(zoneName: String) {
        _simulatedZone.value = zoneName
        // Tambi√©n desbloquea logro de primera visita si corresponde
        unlockAchievement("exp_first_visit")
    }

    /** Simula haber visitado todas las zonas ‚Äî desbloquea explorador total */
    fun simulateAllZonesVisited() {
        unlockAchievement("exp_first_visit")
        unlockAchievement("exp_all_zones")
        unlockAchievement("exp_paddock")
        // Desbloquear coleccionables de exploraci√≥n
        unlockCollectible("c01") // Primer Paso
        unlockCollectible("c02") // Explorador
        unlockCollectible("c03") // Aventurero
        unlockCollectible("c04") // Descubridor Total
    }

    fun resetSimulatedZone() {
        _simulatedZone.value = null
    }

    // =============================================
    // FULL SCENARIO PRESETS
    // =============================================

    /** Simula un d√≠a completo de fan activo en el circuito */
    fun simulateActiveFanDay() {
        // Desbloquea logros t√≠picos de un d√≠a activo
        unlockAchievement("exp_first_visit")
        unlockAchievement("spd_first_nav")
        unlockAchievement("fan_weather_check")
        unlockAchievement("saf_medical")
        addFakeSteps(12000)
        // Coleccionables comunes
        unlockCollectible("c01") // Primer Paso
        unlockCollectible("c05") // Marchador
        unlockCollectible("c08") // Primera Foto
        unlockCollectible("c11") // Primer Pedido
        unlockCollectible("c16") // Eco Warrior
    }

    /** Simula un fan VIP que ha hecho de todo */
    fun simulateVIPExperience() {
        // Todos los logros desbloqueados
        unlockAllAchievements()
        // Coleccionables √©picos + legendarios
        unlockCollectible("c14") // VIP Access
        unlockCollectible("c15") // Pit Lane
        unlockCollectible("c13") // Master Chef
        unlockCollectible("c20") // Bajo la Lluvia
        unlockCollectible("c22") // Fiel al Circuito
        addBonusXP(2000)
    }

    /** Simula fan nuevo que acaba de llegar */
    fun simulateNewFan() {
        resetAllAchievements()
        resetAllCollectibles()
        _extraFakeSteps.value = 0
        unlockAchievement("exp_first_visit")
        unlockCollectible("c01") // Primer Paso
    }

    /** Simula situaci√≥n de emergencia completa */
    fun simulateEmergencyScenario() {
        simulateEvacuation()
        triggerCrowdSurge()
        unlockAchievement("saf_report")
        unlockAchievement("saf_emergency")
        unlockAchievement("saf_medical")
    }

    // =============================================
    // ORDERS / CLICK & COLLECT SIMULATION
    // =============================================

    fun createFakeOrder(status: String = "pending") {
        debugScope.launch {
            try {
                val orderId = "dbg_${System.currentTimeMillis()}"
                FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                    table = "orders",
                    data = mapOf(
                        "id" to orderId,
                        "user_id" to "current_user",
                        "status" to status,
                        "items" to listOf(
                            mapOf("name" to "Hamburguesa F1", "price" to 12.50, "qty" to 1),
                            mapOf("name" to "Cerveza Circuito", "price" to 5.00, "qty" to 2)
                        ),
                        "total" to 22.50,
                        "stand_name" to "Paddock Grill",
                        "stand_id" to "stand_01",
                        "pickup_code" to "GR-${(1000..9999).random()}",
                        "created_at" to System.currentTimeMillis() / 1000
                    )
                ))
                Log.d("ScenarioSimulator", "Pedido $orderId creado ($status)")
            } catch (e: Exception) {
                Log.e("ScenarioSimulator", "Error creando pedido: ${e.message}")
            }
        }
    }

    fun createOrdersAllStatuses() {
        listOf("pending", "preparing", "ready", "completed").forEach { status ->
            createFakeOrder(status)
        }
    }

    // =============================================
    // PARKING SIMULATION
    // =============================================

    private val _savedCarLocation = MutableStateFlow<Pair<Double, Double>?>(null)
    val savedCarLocation: StateFlow<Pair<Double, Double>?> = _savedCarLocation.asStateFlow()

    fun saveCarLocation() {
        _savedCarLocation.value = Pair(41.5700, 2.2590) // Parking Norte
        unlockAchievement("spd_find_car")
    }

    fun clearCarLocation() {
        _savedCarLocation.value = null
    }

    // =============================================
    // CIRCUIT FLAGS / MODE SIMULATION
    // =============================================

    fun simulateCircuitMode(mode: CircuitMode) {
        val signal = BleCircuitSignal(
            version = 1,
            zoneId = 1,
            mode = mode,
            flags = 0,
            sequence = (100..9999).random(),
            ttlSeconds = 120,
            timestamp = System.currentTimeMillis()
        )
        _forcedBleSignal.value = signal
    }

    fun clearCircuitMode() {
        _forcedBleSignal.value = null
    }

    // =============================================
    // WEATHER SIMULATION
    // =============================================

    private val _forcedTemperature = MutableStateFlow<Float?>(null)
    val forcedTemperature: StateFlow<Float?> = _forcedTemperature.asStateFlow()

    private val _forcedWeatherCondition = MutableStateFlow<String?>(null)
    val forcedWeatherCondition: StateFlow<String?> = _forcedWeatherCondition.asStateFlow()

    fun simulateWeather(tempC: Float, condition: String) {
        _forcedTemperature.value = tempC
        _forcedWeatherCondition.value = condition
        unlockAchievement("fan_weather_check")
    }

    fun clearWeather() {
        _forcedTemperature.value = null
        _forcedWeatherCondition.value = null
    }

    // =============================================
    // INCIDENTS / ALERTS SIMULATION
    // =============================================

    fun createFakeIncident(type: String = "safety") {
        debugScope.launch {
            try {
                FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                    table = "incidents",
                    data = mapOf(
                        "id" to "inc_${System.currentTimeMillis()}",
                        "type" to type,
                        "title" to when (type) {
                            "medical" -> "Asistencia m√©dica requerida"
                            "fire" -> "Alerta de fuego en Zona D"
                            "crowd" -> "Aglomeraci√≥n excesiva en T1"
                            else -> "Incidencia de seguridad general"
                        },
                        "description" to "Incidente simulado desde Debug Panel",
                        "zone" to "Tribuna Principal",
                        "status" to "active",
                        "priority" to "high",
                        "reported_at" to System.currentTimeMillis() / 1000
                    )
                ))
                unlockAchievement("saf_report")
                Log.d("ScenarioSimulator", "Incidente $type creado")
            } catch (e: Exception) {
                Log.e("ScenarioSimulator", "Error: ${e.message}")
            }
        }
    }

    fun createFakeAlert(category: String = "GENERAL") {
        debugScope.launch {
            try {
                FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                    table = "news",
                    data = mapOf(
                        "id" to "alert_${System.currentTimeMillis()}",
                        "title" to when (category) {
                            "WEATHER" -> "‚ö†Ô∏è Previsi√≥n de lluvia a las 16:00"
                            "TRAFFIC" -> "üöó Retenci√≥n en acceso norte"
                            "SAFETY" -> "üõ°Ô∏è Zona restringida Pit Lane"
                            "SCHEDULE_CHANGE" -> "üìÖ Carrera retrasada 30 min"
                            else -> "üì¢ Informaci√≥n general del circuito"
                        },
                        "content" to "Alerta de prueba generada por Debug Panel",
                        "category" to category,
                        "priority" to if (category == "SAFETY") "HIGH" else "MEDIUM",
                        "timestamp" to (System.currentTimeMillis() / 1000).toInt()
                    )
                ))
                Log.d("ScenarioSimulator", "Alerta $category creada")
            } catch (e: Exception) {
                Log.e("ScenarioSimulator", "Error: ${e.message}")
            }
        }
    }

    // =============================================
    // SOCIAL / GROUPS SIMULATION
    // =============================================

    fun createFakeGroup() {
        debugScope.launch {
            try {
                val groupId = "grp_debug_${(100..999).random()}"
                FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                    table = "groups",
                    data = mapOf(
                        "id" to groupId,
                        "name" to "Debug Team ${(1..99).random()}",
                        "owner_id" to "current_user",
                        "members" to listOf("current_user", "user_fake_1", "user_fake_2", "user_fake_3"),
                        "created_at" to System.currentTimeMillis() / 1000
                    )
                ))
                // Simular posiciones GPS de miembros
                listOf(
                    Triple("user_fake_1", 41.5705, 2.2588),
                    Triple("user_fake_2", 41.5698, 2.2575),
                    Triple("user_fake_3", 41.5692, 2.2562)
                ).forEach { (userId, lat, lon) ->
                    FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                        table = "group_gps",
                        data = mapOf(
                            "id" to "${groupId}_$userId",
                            "group_id" to groupId,
                            "user_id" to userId,
                            "display_name" to userId.replace("_", " ").replaceFirstChar { it.uppercase() },
                            "latitude" to lat,
                            "longitude" to lon,
                            "updated_at" to System.currentTimeMillis() / 1000
                        )
                    ))
                }
                unlockAchievement("soc_first_group")
                unlockAchievement("soc_share_qr")
                unlockCollectible("c08") // Primera Foto
                Log.d("ScenarioSimulator", "Grupo $groupId con 3 miembros creado")
            } catch (e: Exception) {
                Log.e("ScenarioSimulator", "Error: ${e.message}")
            }
        }
    }

    // =============================================
    // ECO / SUSTAINABILITY SIMULATION
    // =============================================

    private val _fakeCO2Saved = MutableStateFlow(0f) // kg
    val fakeCO2Saved: StateFlow<Float> = _fakeCO2Saved.asStateFlow()

    fun addCO2Saved(kg: Float) {
        _fakeCO2Saved.value += kg
        if (_fakeCO2Saved.value >= 1f) unlockAchievement("eco_transport")
        if (_fakeCO2Saved.value >= 1f) unlockCollectible("c16") // Eco Warrior
        if (_fakeCO2Saved.value >= 5f) unlockCollectible("c17") // Planeta Verde
    }

    // =============================================
    // TRANSITION MODE SIMULATION
    // =============================================

    private val _forcedTransportMode = MutableStateFlow<String?>(null)
    val forcedTransportMode: StateFlow<String?> = _forcedTransportMode.asStateFlow()

    fun setTransportMode(mode: String?) {
        _forcedTransportMode.value = mode
    }

    // =============================================
    // EXTENDED RESET
    // =============================================

    fun resetEverything() {
        // Simulator state
        resetAll()
        resetSimulatedZone()
        clearWeather()
        clearCarLocation()
        clearRacers()
        _extraFakeSteps.value = 0
        _fakeCO2Saved.value = 0f
        _forcedTransportMode.value = null
        // Backend data
        resetAllAchievements()
        resetAllCollectibles()
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/di/AppContainer.kt`

```kotlin
package com.georacing.georacing.di

import android.content.Context
import com.georacing.georacing.data.ble.BeaconScanner
import com.georacing.georacing.data.energy.EnergyMonitor
import com.georacing.georacing.data.repository.HybridCircuitStateRepository
import com.georacing.georacing.data.repository.NetworkCircuitStateRepository
import com.georacing.georacing.data.repository.NetworkBeaconsRepository
import com.georacing.georacing.data.repository.OfflineFirstBeaconsRepository
import com.georacing.georacing.data.repository.OfflineFirstCircuitStateRepository
import com.georacing.georacing.infrastructure.car.CarTransitionManager
import com.georacing.georacing.data.local.GeoRacingDatabase
import com.georacing.georacing.data.remote.RetrofitClient
import com.georacing.georacing.data.repository.OfflineFirstPoiRepository

import com.georacing.georacing.domain.manager.AutoParkingManager

/**
 * Manual Dependency Injection Container.
 * Holds singletons to ensure the entire app (including Simulator) uses the SAME instances.
 */
class AppContainer(private val context: Context) {

    // 1. Core Sensors (Singletons)
    val energyMonitor by lazy { EnergyMonitor(context) }
    val beaconScanner by lazy { BeaconScanner(context) }
    val carTransitionManager by lazy { CarTransitionManager(context) }

    // Health (Real ‚Äî requires Health Connect permissions)
    val healthConnectManager: com.georacing.georacing.data.health.HealthConnectManager by lazy {
        com.georacing.georacing.data.health.HealthConnectManager(context)
    }

    // 2. Repositories
    val beaconsRepository by lazy {
        OfflineFirstBeaconsRepository(
            networkRepository = NetworkBeaconsRepository(),
            context = context
        )
    }

    val circuitStateRepository by lazy {
        OfflineFirstCircuitStateRepository(
            networkRepository = HybridCircuitStateRepository(
                networkRepository = NetworkCircuitStateRepository(),
                beaconScanner = beaconScanner
            ),
            context = context
        )
    }

    // Database & Network
    val database by lazy { GeoRacingDatabase.getInstance(context) }
    val api by lazy { RetrofitClient.api }
    
    val poiRepository by lazy {
        OfflineFirstPoiRepository(api, database.poiDao())
    }

    val incidentsRepository by lazy {
        com.georacing.georacing.data.repository.OfflineFirstIncidentsRepository(
            incidentDao = database.incidentDao(),
            context = context
        )
    }

    // 3. Managers
    val parkingRepository by lazy { com.georacing.georacing.data.parking.ParkingRepository(context) }
    
    val autoParkingManager by lazy {
        AutoParkingManager(context, parkingRepository, carTransitionManager)
    }
    
    // Services / Monitors
    val batteryMonitor by lazy { com.georacing.georacing.services.BatteryMonitor(context) }
    val networkMonitor by lazy { com.georacing.georacing.services.NetworkMonitor(context) }

    // Centralized Monitor Manager (replaces LaunchedEffect logic in NavHost)
    val appMonitorManager by lazy {
        com.georacing.georacing.ui.AppMonitorManager(
            beaconScanner = beaconScanner,
            batteryMonitor = batteryMonitor,
            networkMonitor = networkMonitor
        )
    }

    // Gamification
    val gamificationRepository by lazy {
        com.georacing.georacing.data.gamification.GamificationRepository().also {
            com.georacing.georacing.debug.ScenarioSimulator.setGamificationRepo(it)
        }
    }

    // üÜï New Feature Managers (Phase 3)
    val voiceCommandManager by lazy { com.georacing.georacing.services.VoiceCommandManager(context) }
    val osrmTrafficProvider by lazy { com.georacing.georacing.domain.traffic.OsrmTrafficProvider() }
    val osmSpeedLimitProvider by lazy { com.georacing.georacing.domain.speed.OsmSpeedLimitProvider() }
    val qrPositioningManager by lazy { com.georacing.georacing.domain.manager.QrPositioningManager(context) }
    val transitionModeDetector by lazy { com.georacing.georacing.domain.manager.TransitionModeDetector(context) }
    val proximityChatManager by lazy {
        com.georacing.georacing.data.p2p.ProximityChatManager(context, beaconScanner)
    }
    // LaneGuidanceManager ‚Üí object singleton (com.georacing.georacing.car.LaneGuidanceManager)
    // AREnhancedOverlay ‚Üí object singleton (com.georacing.georacing.features.ar.AREnhancedOverlay)
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/calculator/EcoCalculator.kt`

```kotlin
package com.georacing.georacing.domain.calculator

object EcoCalculator {
    /**
     * Calcula el CO2 ahorrado si hubieras hecho este trayecto en coche.
     * 1 km caminando ‚âà 120g de CO2 ahorrado.
     */
    fun calculateCo2Saved(distanceMeters: Double): Double {
        val km = distanceMeters / 1000.0
        return km * 120.0
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/features/FeatureRegistry.kt`

```kotlin
package com.georacing.georacing.domain.features

import androidx.compose.ui.graphics.Color
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.ui.graphics.vector.ImageVector
import com.georacing.georacing.ui.navigation.Screen

// ‚îÄ‚îÄ Feature Category (mirrors iOS FeatureCategory) ‚îÄ‚îÄ
enum class FeatureCategory(
    val displayName: String,
    val icon: ImageVector,
    val color: Color
) {
    CORE("Core", Icons.Default.Memory, Color(0xFF3B82F6)),
    NAVIGATION("Navegaci√≥n", Icons.Default.Navigation, Color(0xFFFF8C00)),
    SOCIAL("Social", Icons.Default.People, Color(0xFF22C55E)),
    FAN("Fan Experience", Icons.Default.Star, Color(0xFFA855F7)),
    STAFF("Staff & Ops", Icons.Default.Work, Color(0xFF64748B)),
    ADVANCED("Avanzado", Icons.Default.AutoAwesome, Color(0xFF6366F1)),
    VISIONARY("Visionario", Icons.Default.Visibility, Color(0xFFEC4899))
}

// ‚îÄ‚îÄ Feature Status ‚îÄ‚îÄ
enum class FeatureStatus(val displayName: String, val color: Color) {
    PLACEHOLDER("PLACEHOLDER", Color(0xFF64748B)),
    BASIC("B√ÅSICO", Color(0xFFFFA726)),
    COMPLETE("COMPLETO", Color(0xFF22C55E))
}

// ‚îÄ‚îÄ Feature Audience ‚îÄ‚îÄ
enum class FeatureAudience {
    PUBLIC, STAFF_ONLY
}

// ‚îÄ‚îÄ Feature model ‚îÄ‚îÄ
data class Feature(
    val id: String,
    val title: String,
    val subtitle: String,
    val category: FeatureCategory,
    val priority: Int,
    val status: FeatureStatus,
    val icon: ImageVector,
    val audience: FeatureAudience = FeatureAudience.PUBLIC,
    val route: String? = null // Android Screen route, null = placeholder
)

// ‚îÄ‚îÄ Registry singleton (mirrors iOS FeatureRegistry.shared) ‚îÄ‚îÄ
object FeatureRegistry {

    private val allFeatures: List<Feature> = listOf(
        // ‚îÄ‚îÄ‚îÄ CORE ‚îÄ‚îÄ‚îÄ
        Feature("core.circuit_state", "Estado del Circuito", "Monitorizaci√≥n en tiempo real de banderas y seguridad", FeatureCategory.CORE, 1, FeatureStatus.COMPLETE, Icons.Default.Flag, route = Screen.Home.route),
        Feature("core.context_card", "Card Contextual", "Widgets din√°micos seg√∫n estado de carrera", FeatureCategory.CORE, 2, FeatureStatus.COMPLETE, Icons.Default.ViewModule, route = Screen.Home.route),
        Feature("core.offline_map", "Mapa Vivo Offline", "Acceso a mapa y POIs sin conexi√≥n", FeatureCategory.CORE, 3, FeatureStatus.BASIC, Icons.Default.Map, route = Screen.Map.route),
        Feature("core.pois", "Puntos de Inter√©s", "Filtros y localizaci√≥n de servicios", FeatureCategory.CORE, 4, FeatureStatus.COMPLETE, Icons.Default.PinDrop, route = Screen.PoiList.route),
        Feature("core.qr_position", "Posicionamiento QR", "Escanear para ubicarte en el mapa", FeatureCategory.CORE, 5, FeatureStatus.BASIC, Icons.Default.QrCodeScanner, route = Screen.QRScanner.route),
        Feature("core.ble", "Balizas Inteligentes", "Detecci√≥n de zonas por Bluetooth", FeatureCategory.CORE, 6, FeatureStatus.COMPLETE, Icons.Default.Bluetooth),
        Feature("core.offline_mode", "Modo Sin Conexi√≥n", "Funcionalidad completa sin internet", FeatureCategory.CORE, 7, FeatureStatus.BASIC, Icons.Default.WifiOff),
        Feature("core.alerts", "Centro de Alertas", "Historial de notificaciones push", FeatureCategory.CORE, 8, FeatureStatus.COMPLETE, Icons.Default.Notifications, route = Screen.Alerts.route),
        Feature("core.notifications", "Notificaciones Cr√≠ticas", "Alertas push locales por seguridad", FeatureCategory.CORE, 9, FeatureStatus.COMPLETE, Icons.Default.NotificationsActive),
        Feature("core.feedback", "Incidencias", "Reporte de problemas en pista", FeatureCategory.CORE, 10, FeatureStatus.COMPLETE, Icons.Default.Warning, route = Screen.IncidentReport.route),

        // ‚îÄ‚îÄ‚îÄ NAVEGACI√ìN ‚îÄ‚îÄ‚îÄ
        Feature("nav.ar_guide", "Gu√≠a AR al Asiento", "Navegaci√≥n aumentada con c√°mara", FeatureCategory.NAVIGATION, 1, FeatureStatus.BASIC, Icons.Default.CameraAlt, route = Screen.AR.route),
        Feature("nav.anticalas", "Rutas Anti-colas", "Algoritmo de desv√≠o por tr√°fico", FeatureCategory.NAVIGATION, 2, FeatureStatus.COMPLETE, Icons.Default.AltRoute, route = Screen.RouteTraffic.route),
        Feature("nav.services", "Rutas a Servicios", "Camino m√°s r√°pido a WC/Comida", FeatureCategory.NAVIGATION, 3, FeatureStatus.COMPLETE, Icons.Default.DirectionsWalk, route = Screen.CircuitDestinations.route),
        Feature("nav.state_routes", "Rutas Din√°micas", "Cambio de ruta seg√∫n estado circuito", FeatureCategory.NAVIGATION, 4, FeatureStatus.BASIC, Icons.Default.Shuffle),
        Feature("nav.evacuation", "Evacuaci√≥n Din√°mica", "Guiado de emergencia a salidas seguras", FeatureCategory.NAVIGATION, 5, FeatureStatus.COMPLETE, Icons.Default.Shield, route = Screen.Emergency.route),

        // ‚îÄ‚îÄ‚îÄ SOCIAL ‚îÄ‚îÄ‚îÄ
        Feature("social.follow_group", "Seguir al Grupo", "Ver ubicaci√≥n de amigos en tiempo real", FeatureCategory.SOCIAL, 1, FeatureStatus.COMPLETE, Icons.Default.GroupWork, route = Screen.Group.route),
        Feature("social.meetup", "Punto de Encuentro", "Establecer meeting point compartido", FeatureCategory.SOCIAL, 2, FeatureStatus.BASIC, Icons.Default.Flag),
        Feature("social.proximity_chat", "Chat de Cercan√≠a", "Comunicaci√≥n con fans cercanos", FeatureCategory.SOCIAL, 3, FeatureStatus.COMPLETE, Icons.Default.Forum, route = Screen.ProximityChat.route),

        // ‚îÄ‚îÄ‚îÄ FAN ‚îÄ‚îÄ‚îÄ
        Feature("fan.immersive", "Fan Immersive Mode", "Experiencia augmentada durante carrera", FeatureCategory.FAN, 1, FeatureStatus.COMPLETE, Icons.Default.Headphones, route = Screen.FanImmersive.route),
        Feature("fan.fan_zone", "Fan Zone", "Trivia, equipo y coleccionables", FeatureCategory.FAN, 2, FeatureStatus.COMPLETE, Icons.Default.SportsMotorsports, route = Screen.FanZone.route),
        Feature("fan.collectibles", "Coleccionables", "Cromos digitales del circuito", FeatureCategory.FAN, 3, FeatureStatus.COMPLETE, Icons.Default.AccountBox, route = Screen.Collectibles.route),
        Feature("fan.wrapped", "GeoRacing Wrapped", "Resumen personalizado de tu experiencia", FeatureCategory.FAN, 4, FeatureStatus.COMPLETE, Icons.Default.Star, route = Screen.Wrapped.route),

        // ‚îÄ‚îÄ‚îÄ STAFF ‚îÄ‚îÄ‚îÄ
        Feature("staff.panel", "Panel Interno Staff", "Gesti√≥n y m√©tricas para operarios", FeatureCategory.STAFF, 1, FeatureStatus.COMPLETE, Icons.Default.Badge, FeatureAudience.STAFF_ONLY, route = Screen.StaffMode.route),
        Feature("staff.beacon_remote", "Control Remoto Baliza", "Forzar estados de baliza manualmente", FeatureCategory.STAFF, 2, FeatureStatus.PLACEHOLDER, Icons.Default.SettingsRemote, FeatureAudience.STAFF_ONLY),
        Feature("staff.safezone", "SafeZone Live", "Monitorizaci√≥n de √°reas seguras", FeatureCategory.STAFF, 3, FeatureStatus.PLACEHOLDER, Icons.Default.Security, FeatureAudience.STAFF_ONLY),

        // ‚îÄ‚îÄ‚îÄ AVANZADO ‚îÄ‚îÄ‚îÄ
        Feature("adv.clima", "ClimaSmart IA", "Predicci√≥n micro-clim√°tica", FeatureCategory.ADVANCED, 1, FeatureStatus.COMPLETE, Icons.Default.Cloud, route = Screen.ClimaSmart.route),
        Feature("adv.ecometer", "EcoMeter", "Huella de carbono en tiempo real", FeatureCategory.ADVANCED, 2, FeatureStatus.COMPLETE, Icons.Default.Eco, route = Screen.EcoMeter.route),
        Feature("adv.parking", "Parking SmartView", "Visualizaci√≥n de plazas libres", FeatureCategory.ADVANCED, 3, FeatureStatus.COMPLETE, Icons.Default.LocalParking, route = Screen.Parking.route),
        Feature("adv.transport", "Transporte Sincro", "Shuttles coordinados con carrera", FeatureCategory.ADVANCED, 4, FeatureStatus.COMPLETE, Icons.Default.DirectionsBus, route = Screen.Transport.route),
        Feature("adv.achievements", "Logros", "Sistema de gamificaci√≥n", FeatureCategory.ADVANCED, 5, FeatureStatus.COMPLETE, Icons.Default.EmojiEvents, route = Screen.Achievements.route),
        Feature("adv.click_collect", "Click & Collect", "Pedidos para recoger en tienda", FeatureCategory.ADVANCED, 6, FeatureStatus.COMPLETE, Icons.Default.ShoppingCart, route = Screen.ClickCollect.route),

        // ‚îÄ‚îÄ‚îÄ VISIONARIO ‚îÄ‚îÄ‚îÄ
        Feature("vis.detect", "GeoRacing Neural Network", "Cerebro central de operaciones", FeatureCategory.VISIONARY, 1, FeatureStatus.PLACEHOLDER, Icons.Default.Hub),
        Feature("vis.heatmap", "EmoHeatmap", "Mapa de calor emocional del p√∫blico", FeatureCategory.VISIONARY, 2, FeatureStatus.PLACEHOLDER, Icons.Default.Favorite),
        Feature("vis.ticket_ar", "Ticket AR", "Entrada hologr√°fica", FeatureCategory.VISIONARY, 3, FeatureStatus.PLACEHOLDER, Icons.Default.ConfirmationNumber),
        Feature("vis.pulse", "Fan Pulse", "Ritmo card√≠aco colectivo", FeatureCategory.VISIONARY, 4, FeatureStatus.PLACEHOLDER, Icons.Default.MonitorHeart),
        Feature("vis.chat_ai", "Chat IA Contextual", "Asistente inteligente de carrera", FeatureCategory.VISIONARY, 5, FeatureStatus.PLACEHOLDER, Icons.Default.SmartToy),
        Feature("vis.glasses", "Modo Gafas AR", "Segunda pantalla en gafas", FeatureCategory.VISIONARY, 6, FeatureStatus.PLACEHOLDER, Icons.Default.Visibility)
    )

    val visibleFeatures: List<Feature>
        get() = allFeatures.filter { it.audience == FeatureAudience.PUBLIC }

    fun features(category: FeatureCategory): List<Feature> =
        visibleFeatures.filter { it.category == category }.sortedBy { it.priority }

    fun totalCount(category: FeatureCategory): Int = features(category).size

    fun completedCount(category: FeatureCategory): Int =
        features(category).count { it.status == FeatureStatus.COMPLETE }

    fun feature(id: String): Feature? = visibleFeatures.firstOrNull { it.id == id }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/manager/AutoParkingManager.kt`

```kotlin
package com.georacing.georacing.domain.manager

import android.annotation.SuppressLint
import android.content.Context
import android.location.Location
import android.speech.tts.TextToSpeech
import android.util.Log
import com.georacing.georacing.data.parking.ParkingLocation
import com.georacing.georacing.data.parking.ParkingRepository
import com.georacing.georacing.infrastructure.car.CarTransitionManager
import com.georacing.georacing.utils.TTSManager
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationServices
import com.google.android.gms.location.Priority
import com.google.android.gms.tasks.CancellationTokenSource
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import java.util.Locale

/**
 * Gestiona el guardado autom√°tico de la ubicaci√≥n del coche cuando se desconecta de Android Auto.
 * 
 * Funcionalidades:
 * - GPS de alta precisi√≥n (PRIORITY_HIGH_ACCURACY)
 * - Retry autom√°tico si precisi√≥n > 50m
 * - Asignaci√≥n inteligente de puerta peatonal
 * - Anuncio de voz personalizado con TTS
 */
class AutoParkingManager(
    private val context: Context,
    private val parkingRepository: ParkingRepository,
    private val carTransitionManager: CarTransitionManager
) {

    companion object {
        private const val TAG = "AutoParkingManager"
        private const val MAX_ACCEPTABLE_ACCURACY_METERS = 50f
        private const val RETRY_DELAY_MS = 2000L
        private const val USER_NAME = "Gery" // Hardcoded for now - TODO: Read from user profile
    }

    private val fusedLocationClient: FusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(context)
    private val scope = CoroutineScope(Dispatchers.Main)

    private val _showParkingConfirmation = MutableStateFlow<Location?>(null)
    val showParkingConfirmation: StateFlow<Location?> = _showParkingConfirmation.asStateFlow()

    // State for gate assignment result
    private val _lastGateAssignment = MutableStateFlow<GateAssignment?>(null)
    val lastGateAssignment: StateFlow<GateAssignment?> = _lastGateAssignment.asStateFlow()

    // TTS Engine
    private var tts: TextToSpeech? = null
    private var isTtsReady = false

    init {
        setupTransitionListener()
        initializeTTS()
    }

    private fun initializeTTS() {
        tts = TextToSpeech(context) { status ->
            if (status == TextToSpeech.SUCCESS) {
                val result = tts?.setLanguage(Locale("es", "ES"))
                isTtsReady = result != TextToSpeech.LANG_MISSING_DATA && result != TextToSpeech.LANG_NOT_SUPPORTED
                Log.i(TAG, "TTS initialized: ${if (isTtsReady) "OK" else "ERROR"}")
            } else {
                Log.e(TAG, "TTS initialization failed")
            }
        }
    }

    private fun setupTransitionListener() {
        carTransitionManager.onParkingTransitionDetected = {
             attemptToCaptureLocation()
        }
    }

    @SuppressLint("MissingPermission")
    private fun attemptToCaptureLocation() {
        // Permission check
        if (androidx.core.content.ContextCompat.checkSelfPermission(
                context, 
                android.Manifest.permission.ACCESS_FINE_LOCATION
            ) != android.content.pm.PackageManager.PERMISSION_GRANTED
        ) {
            Log.w(TAG, "Location permission not granted")
            return
        }

        scope.launch {
            try {
                // üéØ First attempt: Get fresh high-accuracy location
                var location = fusedLocationClient.getCurrentLocation(
                    Priority.PRIORITY_HIGH_ACCURACY,
                    CancellationTokenSource().token
                ).await()

                // üîç Check accuracy - if too low precision, retry after delay
                if (location != null && location.accuracy > MAX_ACCEPTABLE_ACCURACY_METERS) {
                    Log.d(TAG, "GPS accuracy ${location.accuracy}m > ${MAX_ACCEPTABLE_ACCURACY_METERS}m, waiting for better fix...")
                    
                    delay(RETRY_DELAY_MS)
                    
                    // Second attempt after waiting
                    val betterLocation = fusedLocationClient.getCurrentLocation(
                        Priority.PRIORITY_HIGH_ACCURACY,
                        CancellationTokenSource().token
                    ).await()
                    
                    // Use the better one
                    if (betterLocation != null && betterLocation.accuracy < location.accuracy) {
                        Log.d(TAG, "Got better accuracy: ${betterLocation.accuracy}m")
                        location = betterLocation
                    }
                }

                if (location != null) {
                    Log.i(TAG, "Captured parking location: ${location.latitude}, ${location.longitude} (accuracy: ${location.accuracy}m)")
                    _showParkingConfirmation.value = location
                } else {
                    // Fallback to last known
                    val lastLocation = fusedLocationClient.lastLocation.await()
                    if (lastLocation != null) {
                        Log.i(TAG, "Using last known location: ${lastLocation.latitude}, ${lastLocation.longitude}")
                        _showParkingConfirmation.value = lastLocation
                    } else {
                        Log.w(TAG, "No location available")
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error capturing location", e)
            }
        }
    }

    /**
     * Confirma el parking y ejecuta la l√≥gica de asignaci√≥n de puerta + TTS.
     * 
     * 1. Guarda la ubicaci√≥n en el repositorio
     * 2. Calcula la puerta peatonal √≥ptima
     * 3. Anuncia por voz la informaci√≥n al usuario
     */
    fun confirmParking(location: Location, photoUri: String? = null) {
        scope.launch {
            // 1. Guardar ubicaci√≥n
            val parkingLoc = ParkingLocation(
                latitude = location.latitude,
                longitude = location.longitude,
                timestamp = System.currentTimeMillis(),
                photoUri = photoUri
            )
            parkingRepository.saveParkingLocation(parkingLoc)
            Log.i(TAG, "Parking saved: ${location.latitude}, ${location.longitude}")

            // 2. Calcular puerta √≥ptima
            val gateAssignment = GateAssignmentManager.assignGate(location)
            _lastGateAssignment.value = gateAssignment

            // 3. Anunciar por voz
            if (gateAssignment != null && isTtsReady) {
                val voiceMessage = buildVoiceAnnouncement(gateAssignment)
                TTSManager.speak(voiceMessage, tts, interruptCurrent = true)
                Log.i(TAG, "TTS announcement: $voiceMessage")
            } else if (gateAssignment == null) {
                // Usuario fuera del per√≠metro del circuito
                TTSManager.speak(
                    "Coche guardado, $USER_NAME. Parece que est√°s fuera del circuito.",
                    tts, 
                    interruptCurrent = true
                )
            }

            // 4. Cerrar di√°logo
            _showParkingConfirmation.value = null
        }
    }

    /**
     * Construye el mensaje de voz personalizado.
     * 
     * Formato: "Aparcado en Parking [X]. Tu puerta √≥ptima es la [GATE Y], [Nombre]."
     */
    private fun buildVoiceAnnouncement(gateAssignment: GateAssignment): String {
        val parkingInfo = if (gateAssignment.parkingName != null) {
            "Aparcado en ${gateAssignment.parkingName}."
        } else {
            "Coche guardado."
        }
        
        return "$parkingInfo " +
               "Tu puerta √≥ptima es la ${gateAssignment.gateName}, $USER_NAME. " +
               "A unos ${gateAssignment.walkingTimeMinutes} minutos caminando."
    }

    fun dismissParkingDialog() {
        _showParkingConfirmation.value = null
    }

    /**
     * Obtiene la √∫ltima asignaci√≥n de puerta para mostrarla en la UI.
     */
    fun getLastGateAssignment(): GateAssignment? = _lastGateAssignment.value

    /**
     * Limpia recursos al destruir.
     */
    fun cleanup() {
        tts?.stop()
        tts?.shutdown()
        tts = null
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/manager/CircuitControlManager.kt`

```kotlin
package com.georacing.georacing.domain.manager

import android.content.Context
import com.georacing.georacing.infrastructure.ble.BleCommandService
import kotlinx.coroutines.flow.StateFlow

class CircuitControlManager(context: Context) {

    private val bleService = BleCommandService(context)
    val isBroadcasting: StateFlow<Boolean> = bleService.isAdvertising

    fun activateEvacuation() {
        // High priority broadcast
        bleService.startAdvertising(BleCommandService.CMD_EVACUATE)
    }

    fun activateDangerZone() {
        bleService.startAdvertising(BleCommandService.CMD_DANGER)
    }

    fun normalizeCircuit() {
        // Broadcast "Normal" state for 30s to ensure all beacons reset
        bleService.startAdvertising(BleCommandService.CMD_NORMAL)
    }

    fun stopBroadcast() {
        bleService.stopAdvertising()
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/manager/GateAssignmentManager.kt`

```kotlin
package com.georacing.georacing.domain.manager

import android.location.Location
import com.georacing.georacing.data.repository.CircuitLocationsRepository
import com.georacing.georacing.domain.model.CircuitNode

/**
 * Representa la asignaci√≥n de una puerta peatonal √≥ptima para el usuario.
 */
data class GateAssignment(
    val gateName: String,
    val gateId: String,
    val walkingTimeMinutes: Int,
    val distanceMeters: Int,
    val parkingId: String?,
    val parkingName: String?
)

/**
 * Gestiona la asignaci√≥n inteligente de puertas peatonales seg√∫n la ubicaci√≥n
 * del usuario en el Circuit de Barcelona-Catalunya.
 * 
 * Utiliza `Location.distanceBetween()` para calcular din√°micamente la puerta m√°s cercana.
 */
object GateAssignmentManager {

    // Centro aproximado del circuito para validaci√≥n de per√≠metro
    private const val CIRCUIT_CENTER_LAT = 41.5700
    private const val CIRCUIT_CENTER_LNG = 2.2600
    private const val CIRCUIT_RADIUS_METERS = 3000f  // 3km radius (Aumentado para parkings lejanos)

    // Velocidad promedio caminando en m/s (aprox 5 km/h)
    private const val WALKING_SPEED_MS = 1.4f

    /**
     * Asigna la puerta m√°s cercana seg√∫n la ubicaci√≥n actual del usuario.
     * 
     * @param userLocation Ubicaci√≥n del usuario (puede ser parking guardado o posici√≥n actual)
     * @return GateAssignment con la puerta recomendada, o null si est√° fuera del circuito
     */
    fun assignGate(userLocation: Location): GateAssignment? {
        // 1. Validar que est√° dentro del per√≠metro del circuito
        if (!isWithinCircuitPerimeter(userLocation)) {
            return null
        }

        // 2. Encontrar la puerta m√°s cercana (usando distanceBetween)
        val nearestGate = findNearestGate(userLocation)
        
        // 3. Calcular distancia exacta
        val distanceMeters = calculateDistance(
            userLocation.latitude, userLocation.longitude,
            nearestGate.lat, nearestGate.lon
        )
        
        // 4. Estimar tiempo caminando
        val walkingTimeMinutes = (distanceMeters / WALKING_SPEED_MS / 60).toInt().coerceAtLeast(1)
        
        // 5. Encontrar el parking m√°s cercano (para contexto)
        val nearestParking = findNearestParking(userLocation)
        
        return GateAssignment(
            gateName = nearestGate.name,
            gateId = nearestGate.id,
            walkingTimeMinutes = walkingTimeMinutes,
            distanceMeters = distanceMeters.toInt(),
            parkingId = nearestParking?.id,
            parkingName = nearestParking?.name
        )
    }

    /**
     * Verifica si la ubicaci√≥n est√° dentro del per√≠metro del circuito.
     */
    fun isWithinCircuitPerimeter(location: Location): Boolean {
        val distance = calculateDistance(
            location.latitude, location.longitude,
            CIRCUIT_CENTER_LAT, CIRCUIT_CENTER_LNG
        )
        return distance <= CIRCUIT_RADIUS_METERS
    }

    /**
     * Encuentra la puerta m√°s cercana a la ubicaci√≥n dada.
     */
    private fun findNearestGate(location: Location): CircuitNode {
        val gates = CircuitLocationsRepository.getGates()
        
        return gates.minByOrNull { gate ->
            calculateDistance(
                location.latitude, location.longitude,
                gate.lat, gate.lon
            )
        } ?: gates.first()
    }

    /**
     * Encuentra el parking m√°s cercano a la ubicaci√≥n dada.
     * USA SOLO PARKINGS OFICIALES (HIGH/MEDIUM CONFIDENCE).
     */
    private fun findNearestParking(location: Location): CircuitNode? {
        val parkings = CircuitLocationsRepository.getNavigableParkings()
        
        if (parkings.isEmpty()) return null
        
        return parkings.minByOrNull { parking ->
            calculateDistance(
                location.latitude, location.longitude,
                parking.lat, parking.lon
            )
        }
    }

    /**
     * Calcula la distancia en metros entre dos puntos usando Location.distanceBetween().
     */
    private fun calculateDistance(lat1: Double, lng1: Double, lat2: Double, lng2: Double): Float {
        val results = FloatArray(1)
        Location.distanceBetween(lat1, lng1, lat2, lng2, results)
        return results[0]
    }

    /**
     * Calcula la distancia desde la ubicaci√≥n actual hasta una puerta espec√≠fica.
     */
    fun distanceToGate(currentLocation: Location, gateId: String): Float {
        val gate = CircuitLocationsRepository.getNodeById(gateId) ?: return Float.MAX_VALUE
        return calculateDistance(
            currentLocation.latitude, currentLocation.longitude,
            gate.lat, gate.lon
        )
    }

    /**
     * Calcula la distancia desde la ubicaci√≥n actual hasta un parking espec√≠fico.
     */
    fun distanceToParking(currentLocation: Location, parkingId: String): Float {
        val parking = CircuitLocationsRepository.getNodeById(parkingId) ?: return Float.MAX_VALUE
        return calculateDistance(
            currentLocation.latitude, currentLocation.longitude,
            parking.lat, parking.lon
        )
    }
    
    /**
     * Obtiene todas las puertas ordenadas por distancia desde una ubicaci√≥n.
     */
    fun getGatesSortedByDistance(location: Location): List<Pair<CircuitNode, Float>> {
        return CircuitLocationsRepository.getGates().map { gate ->
            val distance = calculateDistance(
                location.latitude, location.longitude,
                gate.lat, gate.lon
            )
            Pair(gate, distance)
        }.sortedBy { it.second }
    }
}


```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/manager/QrPositioningManager.kt`

```kotlin
package com.georacing.georacing.domain.manager

import android.content.Context
import android.graphics.ImageFormat
import android.location.Location
import android.util.Log
import android.util.Size
import androidx.camera.core.CameraSelector
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.ImageProxy
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.core.content.ContextCompat
import androidx.lifecycle.LifecycleOwner
import com.google.zxing.BarcodeFormat
import com.google.zxing.BinaryBitmap
import com.google.zxing.MultiFormatReader
import com.google.zxing.PlanarYUVLuminanceSource
import com.google.zxing.common.HybridBinarizer
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import org.json.JSONObject
import java.util.concurrent.Executors

/**
 * Sistema de auto-posicionamiento por QR para circuitos GeoRacing.
 *
 * Los marcadores QR contienen JSON con la posici√≥n exacta:
 * ```json
 * {
 *   "type": "georacing_marker",
 *   "id": "M-001",
 *   "lat": 41.5695,
 *   "lon": 2.2585,
 *   "zone": "TribunaPrincipal",
 *   "floor": 0,
 *   "accuracy_m": 1.0
 * }
 * ```
 *
 * Cuando el usuario escanea un QR, el sistema:
 * 1. Decodifica la posici√≥n exacta del marcador
 * 2. Compara con la posici√≥n GPS actual
 * 3. Aplica correcci√≥n de drift al GPS
 * 4. Muestra la posici√≥n corregida en el mapa/AR
 */
class QrPositioningManager(private val context: Context) {

    companion object {
        private const val TAG = "QrPositioning"
        private const val MARKER_TYPE = "georacing_marker"
        private const val CORRECTION_DECAY_MS = 60_000L // Correcci√≥n expira en 60s
        private const val MAX_CORRECTION_DISTANCE_M = 200.0 // No corregir si GPS est√° a >200m
    }

    // ‚îÄ‚îÄ Modelos ‚îÄ‚îÄ

    data class QrMarker(
        val id: String,
        val latitude: Double,
        val longitude: Double,
        val zone: String,
        val floor: Int = 0,
        val accuracyMeters: Double = 1.0
    )

    data class PositionCorrection(
        val marker: QrMarker,
        val latOffset: Double,   // Correcci√≥n a sumar al GPS lat
        val lonOffset: Double,   // Correcci√≥n a sumar al GPS lon
        val timestamp: Long,
        val gpsAccuracyAtScan: Float
    )

    // ‚îÄ‚îÄ Estado ‚îÄ‚îÄ

    private val _lastMarker = MutableStateFlow<QrMarker?>(null)
    val lastMarker: StateFlow<QrMarker?> = _lastMarker.asStateFlow()

    private val _correction = MutableStateFlow<PositionCorrection?>(null)
    val correction: StateFlow<PositionCorrection?> = _correction.asStateFlow()

    private val _isScanning = MutableStateFlow(false)
    val isScanning: StateFlow<Boolean> = _isScanning.asStateFlow()

    private val _scanHistory = MutableStateFlow<List<QrMarker>>(emptyList())
    val scanHistory: StateFlow<List<QrMarker>> = _scanHistory.asStateFlow()

    private var imageAnalysis: ImageAnalysis? = null
    private val analysisExecutor = Executors.newSingleThreadExecutor()
    private val qrReader = MultiFormatReader().apply {
        setHints(mapOf(com.google.zxing.DecodeHintType.POSSIBLE_FORMATS to listOf(BarcodeFormat.QR_CODE)))
    }

    // ‚îÄ‚îÄ API P√∫blica ‚îÄ‚îÄ

    /**
     * Inicia el escaneo continuo de QR con CameraX.
     */
    fun startScanning(lifecycleOwner: LifecycleOwner) {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(context)
        cameraProviderFuture.addListener({
            try {
                val cameraProvider = cameraProviderFuture.get()

                imageAnalysis = ImageAnalysis.Builder()
                    .setTargetResolution(Size(1280, 720))
                    .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                    .build()
                    .also { analysis ->
                        analysis.setAnalyzer(analysisExecutor, QrAnalyzer())
                    }

                cameraProvider.unbindAll()
                cameraProvider.bindToLifecycle(
                    lifecycleOwner,
                    CameraSelector.DEFAULT_BACK_CAMERA,
                    imageAnalysis
                )
                _isScanning.value = true
                Log.i(TAG, "üì∑ QR scanning started")
            } catch (e: Exception) {
                Log.e(TAG, "Error starting QR scanner", e)
            }
        }, ContextCompat.getMainExecutor(context))
    }

    /**
     * Detiene el escaneo.
     */
    fun stopScanning() {
        _isScanning.value = false
        imageAnalysis = null
        Log.i(TAG, "üì∑ QR scanning stopped")
    }

    /**
     * Procesa una cadena QR manualmente (por ejemplo, desde un Activity result).
     */
    fun processQrContent(content: String, currentLocation: Location?): QrMarker? {
        val marker = parseQrContent(content) ?: return null
        onMarkerDetected(marker, currentLocation)
        return marker
    }

    /**
     * Aplica la correcci√≥n GPS almacenada a una ubicaci√≥n.
     * Devuelve la ubicaci√≥n corregida, o la original si no hay correcci√≥n v√°lida.
     */
    fun applyCorrectedPosition(location: Location): Location {
        val corr = _correction.value ?: return location

        // Verificar si la correcci√≥n ha expirado
        if (System.currentTimeMillis() - corr.timestamp > CORRECTION_DECAY_MS) {
            _correction.value = null
            return location
        }

        // Aplicar con decay gradual
        val elapsed = System.currentTimeMillis() - corr.timestamp
        val decayFactor = 1.0 - (elapsed.toDouble() / CORRECTION_DECAY_MS)

        return Location(location).apply {
            latitude = location.latitude + corr.latOffset * decayFactor
            longitude = location.longitude + corr.lonOffset * decayFactor
            accuracy = corr.marker.accuracyMeters.toFloat() // Precisi√≥n del marcador
        }
    }

    /**
     * Devuelve la distancia de drift GPS detectada en el √∫ltimo escaneo (metros).
     */
    fun getLastDriftDistance(): Float? {
        val corr = _correction.value ?: return null
        val results = FloatArray(1)
        Location.distanceBetween(0.0, 0.0, corr.latOffset, corr.lonOffset, results)
        return results[0]
    }

    fun destroy() {
        stopScanning()
        analysisExecutor.shutdown()
    }

    // ‚îÄ‚îÄ L√≥gica interna ‚îÄ‚îÄ

    private fun onMarkerDetected(marker: QrMarker, currentLocation: Location?) {
        _lastMarker.value = marker
        _scanHistory.value = _scanHistory.value + marker

        if (currentLocation != null) {
            // Calcular drift GPS
            val results = FloatArray(1)
            Location.distanceBetween(
                currentLocation.latitude, currentLocation.longitude,
                marker.latitude, marker.longitude, results
            )
            val driftDistance = results[0]

            if (driftDistance < MAX_CORRECTION_DISTANCE_M) {
                val latOffset = marker.latitude - currentLocation.latitude
                val lonOffset = marker.longitude - currentLocation.longitude

                _correction.value = PositionCorrection(
                    marker = marker,
                    latOffset = latOffset,
                    lonOffset = lonOffset,
                    timestamp = System.currentTimeMillis(),
                    gpsAccuracyAtScan = currentLocation.accuracy
                )

                Log.i(TAG, "üìç Position corrected: drift=${driftDistance}m " +
                        "from marker ${marker.id} (${marker.zone})")
            } else {
                Log.w(TAG, "‚ö†Ô∏è Marker ${marker.id} too far from GPS " +
                        "(${driftDistance}m > ${MAX_CORRECTION_DISTANCE_M}m), ignoring")
            }
        }
    }

    private fun parseQrContent(content: String): QrMarker? {
        return try {
            val json = JSONObject(content)
            if (json.optString("type") != MARKER_TYPE) {
                Log.d(TAG, "QR not a GeoRacing marker: ${json.optString("type")}")
                return null
            }

            QrMarker(
                id = json.getString("id"),
                latitude = json.getDouble("lat"),
                longitude = json.getDouble("lon"),
                zone = json.optString("zone", "Unknown"),
                floor = json.optInt("floor", 0),
                accuracyMeters = json.optDouble("accuracy_m", 1.0)
            )
        } catch (e: Exception) {
            Log.w(TAG, "Failed to parse QR content: ${e.message}")
            null
        }
    }

    // ‚îÄ‚îÄ QR Image Analyzer ‚îÄ‚îÄ

    private inner class QrAnalyzer : ImageAnalysis.Analyzer {

        private var lastProcessedMs = 0L
        private val throttleMs = 500L // Procesar m√°ximo 2 fps

        override fun analyze(imageProxy: ImageProxy) {
            val now = System.currentTimeMillis()
            if (now - lastProcessedMs < throttleMs) {
                imageProxy.close()
                return
            }
            lastProcessedMs = now

            try {
                val buffer = imageProxy.planes[0].buffer
                val bytes = ByteArray(buffer.remaining())
                buffer.get(bytes)

                val source = PlanarYUVLuminanceSource(
                    bytes,
                    imageProxy.width, imageProxy.height,
                    0, 0,
                    imageProxy.width, imageProxy.height,
                    false
                )
                val binaryBitmap = BinaryBitmap(HybridBinarizer(source))
                val result = qrReader.decodeWithState(binaryBitmap)

                val marker = parseQrContent(result.text)
                if (marker != null) {
                    Log.i(TAG, "üî≤ QR detected: ${marker.id} @ ${marker.zone}")
                    onMarkerDetected(marker, null) // GPS location will be applied by caller
                }
            } catch (_: Exception) {
                // No QR found ‚Äî normal, ignore
            } finally {
                qrReader.reset()
                imageProxy.close()
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/manager/TransitionModeDetector.kt`

```kotlin
package com.georacing.georacing.domain.manager

import android.Manifest
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.os.Build
import android.util.Log
import androidx.core.content.ContextCompat
import com.google.android.gms.location.ActivityRecognition
import com.google.android.gms.location.ActivityRecognitionClient
import com.google.android.gms.location.ActivityTransition
import com.google.android.gms.location.ActivityTransitionEvent
import com.google.android.gms.location.ActivityTransitionRequest
import com.google.android.gms.location.ActivityTransitionResult
import com.google.android.gms.location.DetectedActivity
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * Detector autom√°tico de transici√≥n de modo de transporte.
 *
 * Detecta cu√°ndo el usuario:
 * - Sale del coche y empieza a caminar ‚Üí cambiar a modo peat√≥n
 * - Entra en el coche ‚Üí cambiar a modo coche
 * - Est√° quieto (probablemente en grada) ‚Üí modo espectador
 *
 * Usa Google Activity Recognition Transition API para detecciones fiables.
 * Fallback: an√°lisis de velocidad GPS (< 5 km/h = peat√≥n, > 15 km/h = veh√≠culo).
 */
class TransitionModeDetector(private val context: Context) {

    companion object {
        private const val TAG = "TransitionMode"
        private const val ACTION_TRANSITION =
            "com.georacing.georacing.ACTIVITY_TRANSITION"
        private const val SPEED_WALKING_MAX_KMH = 7.0
        private const val SPEED_VEHICLE_MIN_KMH = 15.0
        private const val TRANSITION_CONFIRM_MS = 10_000L // 10s de confirmaci√≥n
    }

    // ‚îÄ‚îÄ Modos ‚îÄ‚îÄ

    enum class TransportMode {
        VEHICLE,     // En coche
        WALKING,     // Caminando
        STILL,       // Quieto (en grada, esperando)
        CYCLING,     // En bicicleta
        UNKNOWN      // Indeterminado
    }

    data class ModeTransition(
        val from: TransportMode,
        val to: TransportMode,
        val timestamp: Long,
        val confidence: Int // 0-100
    )

    interface TransitionCallback {
        fun onModeChanged(transition: ModeTransition)
    }

    // ‚îÄ‚îÄ Estado ‚îÄ‚îÄ

    private val _currentMode = MutableStateFlow(TransportMode.UNKNOWN)
    val currentMode: StateFlow<TransportMode> = _currentMode.asStateFlow()

    private val _transitions = MutableStateFlow<List<ModeTransition>>(emptyList())
    val transitions: StateFlow<List<ModeTransition>> = _transitions.asStateFlow()

    private val _isMonitoring = MutableStateFlow(false)
    val isMonitoring: StateFlow<Boolean> = _isMonitoring.asStateFlow()

    private var activityClient: ActivityRecognitionClient? = null
    private var pendingIntent: PendingIntent? = null
    private var callback: TransitionCallback? = null
    private var lastSpeedBasedMode: TransportMode? = null
    private var speedModeStartTime: Long = 0L

    // ‚îÄ‚îÄ API P√∫blica ‚îÄ‚îÄ

    fun setCallback(cb: TransitionCallback) {
        callback = cb
    }

    /**
     * Inicia monitoring con Activity Recognition API.
     * Requiere ACTIVITY_RECOGNITION permission (Android Q+).
     */
    fun startMonitoring(): Boolean {
        // Verificar permisos
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            if (ContextCompat.checkSelfPermission(
                    context,
                    Manifest.permission.ACTIVITY_RECOGNITION
                ) != PackageManager.PERMISSION_GRANTED
            ) {
                Log.w(TAG, "‚ö†Ô∏è ACTIVITY_RECOGNITION permission not granted")
                return false
            }
        }

        try {
            activityClient = ActivityRecognition.getClient(context)

            // Transiciones que nos interesan
            val transitions = listOf(
                // Entrar en veh√≠culo
                ActivityTransition.Builder()
                    .setActivityType(DetectedActivity.IN_VEHICLE)
                    .setActivityTransition(ActivityTransition.ACTIVITY_TRANSITION_ENTER)
                    .build(),
                // Salir del veh√≠culo
                ActivityTransition.Builder()
                    .setActivityType(DetectedActivity.IN_VEHICLE)
                    .setActivityTransition(ActivityTransition.ACTIVITY_TRANSITION_EXIT)
                    .build(),
                // Empezar a caminar
                ActivityTransition.Builder()
                    .setActivityType(DetectedActivity.WALKING)
                    .setActivityTransition(ActivityTransition.ACTIVITY_TRANSITION_ENTER)
                    .build(),
                // Dejar de caminar
                ActivityTransition.Builder()
                    .setActivityType(DetectedActivity.WALKING)
                    .setActivityTransition(ActivityTransition.ACTIVITY_TRANSITION_EXIT)
                    .build(),
                // Quedarse quieto
                ActivityTransition.Builder()
                    .setActivityType(DetectedActivity.STILL)
                    .setActivityTransition(ActivityTransition.ACTIVITY_TRANSITION_ENTER)
                    .build(),
                // Bicicleta
                ActivityTransition.Builder()
                    .setActivityType(DetectedActivity.ON_BICYCLE)
                    .setActivityTransition(ActivityTransition.ACTIVITY_TRANSITION_ENTER)
                    .build()
            )

            val request = ActivityTransitionRequest(transitions)

            val intent = Intent(ACTION_TRANSITION)
            pendingIntent = PendingIntent.getBroadcast(
                context, 0, intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE
            )

            // Registrar receiver
            val filter = IntentFilter(ACTION_TRANSITION)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                context.registerReceiver(transitionReceiver, filter, Context.RECEIVER_NOT_EXPORTED)
            } else {
                context.registerReceiver(transitionReceiver, filter)
            }

            activityClient?.requestActivityTransitionUpdates(request, pendingIntent!!)
                ?.addOnSuccessListener {
                    _isMonitoring.value = true
                    Log.i(TAG, "‚úÖ Activity transition monitoring started")
                }
                ?.addOnFailureListener { e ->
                    Log.e(TAG, "‚ùå Failed to start monitoring: ${e.message}")
                }

            return true
        } catch (e: Exception) {
            Log.e(TAG, "Error starting transition monitoring", e)
            return false
        }
    }

    /**
     * Detiene el monitoring.
     */
    fun stopMonitoring() {
        pendingIntent?.let { pi ->
            activityClient?.removeActivityTransitionUpdates(pi)
        }

        try {
            context.unregisterReceiver(transitionReceiver)
        } catch (_: Exception) { }

        _isMonitoring.value = false
        Log.i(TAG, "üõë Activity transition monitoring stopped")
    }

    /**
     * Fallback: actualizar modo bas√°ndose en velocidad GPS.
     * Llamar cada actualizaci√≥n de ubicaci√≥n.
     */
    fun updateFromGpsSpeed(speedMs: Float) {
        val speedKmh = speedMs * 3.6

        val detectedMode = when {
            speedKmh > SPEED_VEHICLE_MIN_KMH -> TransportMode.VEHICLE
            speedKmh < 1.0 -> TransportMode.STILL
            speedKmh <= SPEED_WALKING_MAX_KMH -> TransportMode.WALKING
            else -> TransportMode.CYCLING // Entre 7-15 km/h puede ser bici
        }

        if (detectedMode != lastSpeedBasedMode) {
            lastSpeedBasedMode = detectedMode
            speedModeStartTime = System.currentTimeMillis()
        } else if (System.currentTimeMillis() - speedModeStartTime > TRANSITION_CONFIRM_MS) {
            // Confirmado por tiempo ‚Üí aplicar transici√≥n
            if (detectedMode != _currentMode.value) {
                applyModeChange(detectedMode, confidence = 60) // Menos confianza que Activity API
            }
        }
    }

    /**
     * Obtiene la descripci√≥n del modo actual en espa√±ol.
     */
    fun getModeDescription(): String {
        return when (_currentMode.value) {
            TransportMode.VEHICLE -> "üöó En veh√≠culo"
            TransportMode.WALKING -> "üö∂ Caminando"
            TransportMode.STILL -> "üßç Quieto"
            TransportMode.CYCLING -> "üö¥ En bicicleta"
            TransportMode.UNKNOWN -> "‚ùì Detectando..."
        }
    }

    /**
     * Fuerza un modo manualmente (p.ej. desde un bot√≥n de la UI).
     */
    fun forceMode(mode: TransportMode) {
        applyModeChange(mode, confidence = 100)
    }

    fun destroy() {
        stopMonitoring()
    }

    // ‚îÄ‚îÄ L√≥gica interna ‚îÄ‚îÄ

    private fun applyModeChange(newMode: TransportMode, confidence: Int) {
        val oldMode = _currentMode.value
        if (oldMode == newMode) return

        val transition = ModeTransition(
            from = oldMode,
            to = newMode,
            timestamp = System.currentTimeMillis(),
            confidence = confidence
        )

        _currentMode.value = newMode
        _transitions.value = _transitions.value + transition

        Log.i(TAG, "üîÑ Mode: ${oldMode.name} ‚Üí ${newMode.name} (confidence=$confidence%)")
        callback?.onModeChanged(transition)
    }

    private fun handleActivityTransitionEvent(event: ActivityTransitionEvent) {
        val newMode = when (event.activityType) {
            DetectedActivity.IN_VEHICLE -> {
                if (event.transitionType == ActivityTransition.ACTIVITY_TRANSITION_ENTER)
                    TransportMode.VEHICLE
                else TransportMode.WALKING // Salir del coche = probablemente caminando
            }
            DetectedActivity.WALKING -> {
                if (event.transitionType == ActivityTransition.ACTIVITY_TRANSITION_ENTER)
                    TransportMode.WALKING
                else TransportMode.STILL
            }
            DetectedActivity.STILL -> TransportMode.STILL
            DetectedActivity.ON_BICYCLE -> TransportMode.CYCLING
            else -> null
        }

        if (newMode != null) {
            applyModeChange(newMode, confidence = 85) // Activity API confianza alta
        }
    }

    // ‚îÄ‚îÄ Broadcast Receiver ‚îÄ‚îÄ

    private val transitionReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            if (ActivityTransitionResult.hasResult(intent)) {
                val result = ActivityTransitionResult.extractResult(intent) ?: return
                for (event in result.transitionEvents) {
                    handleActivityTransitionEvent(event)
                }
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/Achievement.kt`

```kotlin
package com.georacing.georacing.domain.model

/**
 * Sistema de gamificaci√≥n ‚Äî Logros y badges del Circuit de Catalunya.
 */
data class Achievement(
    val id: String,
    val title: String,
    val description: String,
    val emoji: String,
    val category: AchievementCategory,
    val xpReward: Int,
    val isUnlocked: Boolean = false,
    val progress: Float = 0f, // 0.0 to 1.0
    val unlockedAt: Long? = null
)

enum class AchievementCategory(val displayName: String, val emoji: String) {
    EXPLORER("Explorador", "üó∫Ô∏è"),
    SOCIAL("Social", "üë•"),
    SPEED("Velocidad", "‚ö°"),
    FAN("Superfan", "üèÜ"),
    ECO("Eco", "üåø"),
    SAFETY("Seguridad", "üõ°Ô∏è")
}

data class FanProfile(
    val totalXP: Int = 0,
    val level: Int = 1,
    val achievements: List<Achievement> = emptyList(),
    val circuitsVisited: Int = 1,
    val kmWalked: Float = 0f,
    val friendsInGroup: Int = 0
) {
    val levelName: String
        get() = when {
            level >= 20 -> "Leyenda del Circuito"
            level >= 15 -> "Piloto de √âlite"
            level >= 10 -> "Veterano de Paddock"
            level >= 7 -> "Fan Apasionado"
            level >= 5 -> "Copiloto"
            level >= 3 -> "Aficionado"
            else -> "Novato"
        }

    val xpForNextLevel: Int get() = level * 250
    val xpProgress: Float get() = (totalXP % xpForNextLevel).toFloat() / xpForNextLevel
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/AppMode.kt`

```kotlin
package com.georacing.georacing.domain.model

enum class AppMode {
    ONLINE,
    OFFLINE_BLE,
    DEGRADED
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/AppPowerState.kt`

```kotlin
package com.georacing.georacing.domain.model

/**
 * Estados de energ√≠a de la aplicaci√≥n.
 * Determina qu√© funcionalidades est√°n activas seg√∫n el nivel de bater√≠a.
 */
enum class AppPowerState {
    /**
     * NORMAL: Todas las funcionalidades activas.
     * Bater√≠a > 30%
     */
    NORMAL,

    /**
     * POWER_SAVE: Modo ahorro de energ√≠a.
     * Bater√≠a entre 15% y 30%
     * - Desactiva gamificaci√≥n
     * - Reduce frecuencia de sync
     * - Tema oscuro forzado
     */
    POWER_SAVE,

    /**
     * CRITICAL: Solo funciones de supervivencia.
     * Bater√≠a < 15%
     * - Solo EmergencyScreen
     * - Tema OLED negro puro
     * - Sin BLE scanning (solo advertising si es staff)
     */
    CRITICAL
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/BeaconConfig.kt`

```kotlin
package com.georacing.georacing.domain.model

/**
 * Modelo de dominio de Beacon/Baliza.
 * Compatible con Panel Metropolis que gestiona: mode, message, color, brightness, battery, etc.
 */
data class BeaconConfig(
    val id: String,
    val beaconUid: String = "",
    val name: String,
    val zone: String,
    val mapX: Float = 0f,
    val mapY: Float = 0f,
    val latitude: Double = 0.0,
    val longitude: Double = 0.0,
    val messageNormal: String = "",
    val messageEmergency: String = "",
    val message: String = "",
    val arrowDirection: ArrowDirection = ArrowDirection.NONE,
    val mode: BeaconMode = BeaconMode.NORMAL,
    val color: String = "#00FF00",
    val brightness: Int = 100,
    val batteryLevel: Int = 100,
    val isOnline: Boolean = true,
    val hasScreen: Boolean = false
)

enum class ArrowDirection {
    UP, DOWN, LEFT, RIGHT,
    UP_LEFT, UP_RIGHT, DOWN_LEFT, DOWN_RIGHT,
    NONE
}

enum class BeaconMode {
    UNCONFIGURED, NORMAL, CONGESTION, EMERGENCY, EVACUATION, MAINTENANCE
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/CircuitNode.kt`

```kotlin
package com.georacing.georacing.domain.model

enum class NodeType {
    GATE, PARKING, FOOD, RESTROOM, MERCHANDISE
}

enum class Confidence {
    HIGH,    // Verified official data
    MEDIUM,  // Likely correct logic/approximation
    LOW,     // Needs check
    PENDING  // Do not use for navigation
}

data class CircuitNode(
    val id: String,
    val name: String,
    val type: NodeType,
    val lat: Double,
    val lon: Double,
    val confidence: Confidence,
    val source: String,
    val description: String = "" // Added context
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/CircuitState.kt`

```kotlin
package com.georacing.georacing.domain.model

data class CircuitState(
    val mode: CircuitMode,
    val message: String?,
    val temperature: String?,
    val updatedAt: String,
    // Campos meteorol√≥gicos adicionales (Panel Metropolis)
    val humidity: String? = null,
    val wind: String? = null,
    val forecast: String? = null,
    // Race Control Data (Simulated or Real)
    val sessionInfo: RaceSessionInfo? = null 
)

data class RaceSessionInfo(
    val sessionTime: String = "00:00:00",
    val currentLap: Int = 0,
    val totalLaps: Int = 66,
    val topDrivers: List<DriverInfo> = emptyList()
)

data class DriverInfo(
    val position: Int,
    val name: String,
    val team: String,
    val gap: String,
    val tireCompound: String = "S"
)

enum class CircuitMode {
    NORMAL,      // Green Flag implicitly
    GREEN_FLAG,  // Explicit Green
    YELLOW_FLAG, // Local or Full Course Yellow
    SAFETY_CAR,
    VSC,         // Virtual Safety Car
    RED_FLAG,
    EVACUATION,
    UNKNOWN
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/DashboardModel.kt`

```kotlin
package com.georacing.georacing.domain.model

enum class WidgetType {
    CONTEXTUAL_CARD, // Smart card: emergency/flag/offline/route/status (iOS parity)
    STATUS_CARD,
    ACTIONS_GRID,
    ECO_METER,
    NEWS_FEED,
    STAFF_ACTIONS, // Protected
    PARKING_INFO, // Status of parked car
    METEOROLOGY,
    AR_ACCESS,
    FIND_RESTROOMS,
    FOOD_OFFERS,
    ACHIEVEMENTS, // Gamification - Fan level & badges
    SEARCH_ACCESS, // Quick search bar
    CLICK_COLLECT, // Food stand ordering
    WRAPPED, // Post-event stats summary
    COLLECTIBLES, // Digital collectible cards
    PROXIMITY_CHAT // BLE-based nearby chat
}

data class DashboardLayout(
    val widgets: List<WidgetType>
) {
    companion object {
        val DEFAULT = DashboardLayout(
            listOf(
                WidgetType.METEOROLOGY,
                WidgetType.CONTEXTUAL_CARD,
                WidgetType.ACTIONS_GRID,
                WidgetType.ACHIEVEMENTS,
                WidgetType.CLICK_COLLECT,
                WidgetType.NEWS_FEED,
                WidgetType.PROXIMITY_CHAT,
                WidgetType.PARKING_INFO
            )
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/EcoMetrics.kt`

```kotlin
package com.georacing.georacing.domain.model

/**
 * Modelo de negocio de Sostenibilidad / Eficiencia nativa.
 */
data class EcoMetrics(
    val stepsWalkedToday: Long,
    val distanceWalkedMeters: Double,
    val co2SavedGrams: Double
) {
    /**
     * Devuelve la distancia redondeada en formato Kil√≥metros (ej: 3.5 km)
     */
    val distanceFormatted: String
        get() = String.format("%.2f km", distanceWalkedMeters / 1000.0)

    /**
     * Devuelve el CO2 en kilogramos si supera los 1000g, o en gramos.
     */
    val co2Formatted: String
        get() = if (co2SavedGrams >= 1000.0) {
            String.format("%.2f kg", co2SavedGrams / 1000.0)
        } else {
            String.format("%.0f g", co2SavedGrams)
        }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/EnergyProfile.kt`

```kotlin
package com.georacing.georacing.domain.model

sealed class EnergyProfile(
    val canUseAR: Boolean,
    val canUseGamification: Boolean,
    val canSyncBackground: Boolean,
    val forceOledBlack: Boolean
) {
    object Performance : EnergyProfile(
        canUseAR = true,
        canUseGamification = true,
        canSyncBackground = true,
        forceOledBlack = false
    )

    object Balanced : EnergyProfile(
        canUseAR = false,
        canUseGamification = true,
        canSyncBackground = true,
        forceOledBlack = false
    )

    object Survival : EnergyProfile(
        canUseAR = false,
        canUseGamification = false,
        canSyncBackground = false,
        forceOledBlack = true
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/IncidentReport.kt`

```kotlin
package com.georacing.georacing.domain.model

data class IncidentReport(
    val category: IncidentCategory,
    val description: String,
    val beaconId: String?,
    val zone: String?,
    val timestamp: Long,
    val photoData: ByteArray? = null // Compressed JPEG image data
)

enum class IncidentCategory(val displayName: String) {
    LIMPIEZA("Limpieza"),
    ACCESIBILIDAD("Accesibilidad"),
    COMIDA_BEBIDA("Comida/Bebida"),
    SE√ëALIZACI√ìN("Se√±alizaci√≥n"),
    SEGURIDAD("Seguridad"),
    INFRAESTRUCTURA("Infraestructura"),
    SERVICIO_MEDICO("Servicio M√©dico"),
    PERDIDOS_ENCONTRADOS("Objetos Perdidos"),
    OTRA("Otra")
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/LiveSessionState.kt`

```kotlin
package com.georacing.georacing.domain.model

/**
 * Represents the current state of a live navigation/emergency session.
 * Used by LiveSessionService to drive notification updates.
 */
sealed class LiveSessionState {
    
    /** Default state - no active session. */
    object Idle : LiveSessionState()
    
    /** Active navigation towards a destination. */
    data class Navigation(
        val distanceMeters: Int,
        val instruction: String,
        val progress: Int = 0 // 0-100
    ) : LiveSessionState()
    
    /** Emergency/Evacuation mode. */
    data class Emergency(
        val type: EmergencyType,
        val exitRoute: String,
        val message: String = ""
    ) : LiveSessionState()
}

enum class EmergencyType {
    EVACUATION,
    RED_FLAG,
    MEDICAL,
    SECURITY
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/Poi.kt`

```kotlin
package com.georacing.georacing.domain.model

data class Poi(
    val id: String,
    val name: String,
    val type: PoiType,
    val description: String,
    val zone: String = "",
    val mapX: Float = 0f, // Deprecated, keep for backward compat if needed
    val mapY: Float = 0f, // Deprecated
    val latitude: Double = 0.0,
    val longitude: Double = 0.0
)

enum class PoiType {
    WC, FOOD, MERCH, ACCESS, PARKING, EXIT, OTHER, GATE, FANZONE, SERVICE
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/RaceNews.kt`

```kotlin
package com.georacing.georacing.domain.model

data class RaceNews(
    val id: String,
    val title: String,
    val content: String,
    val timestamp: Long,
    val category: NewsCategory,
    val priority: NewsPriority,
    val imageUrl: String? = null
)

enum class NewsCategory(val displayName: String) {
    RACE_UPDATE("Actualizaci√≥n de Carrera"),
    SCHEDULE_CHANGE("Cambio de Horario"),
    WEATHER("Meteorolog√≠a"),
    TRAFFIC("Tr√°fico"),
    DRIVER_NEWS("Noticias de Pilotos"),
    SAFETY("Seguridad"),
    EVENT("Evento Especial"),
    GENERAL("General")
}

enum class NewsPriority {
    HIGH,     // Rojo - Urgente
    MEDIUM,   // Amarillo - Importante
    LOW       // Verde - Informativo
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/RouteTraffic.kt`

```kotlin
package com.georacing.georacing.domain.model

/**
 * Modelo de dominio para una ruta del circuito con datos de tr√°fico en tiempo real.
 * Sincronizado con tabla "routes" del backend y Panel Metropolis.
 */
data class RouteTraffic(
    val id: String,
    val name: String,
    val origin: String,
    val destination: String,
    val status: RouteTrafficStatus = RouteTrafficStatus.OPERATIVA,
    val activeUsers: Int = 0,
    val capacity: Int = 0,
    val capacityPercentage: Int = 0,
    val averageSpeed: Double = 0.0,
    val distance: Int = 0,
    val signalQuality: Int = 0,
    val estimatedTime: Int = 0, // minutos
    val velocity: Double = 0.0  // m/s
)

enum class RouteTrafficStatus {
    OPERATIVA,
    SATURADA,
    CERRADA,
    MANTENIMIENTO;

    companion object {
        fun fromString(s: String?): RouteTrafficStatus =
            entries.firstOrNull { it.name.equals(s, ignoreCase = true) } ?: OPERATIVA
    }
}

/**
 * Modelo de dominio para ocupaci√≥n de una zona del circuito.
 * Sincronizado con tabla "zone_traffic" del backend y Panel Metropolis.
 */
data class ZoneOccupancy(
    val id: String,
    val name: String,
    val type: String = "GRADA", // GRADA, PADDOCK, FANZONE, VIAL, PARKING
    val status: ZoneOccupancyStatus = ZoneOccupancyStatus.ABIERTA,
    val capacity: Int = 0,
    val currentOccupancy: Int = 0,
    val temperature: Double = 0.0,
    val waitTime: Int = 0,    // minutos
    val entryRate: Int = 0,   // personas/min
    val exitRate: Int = 0     // personas/min
) {
    val occupancyPercentage: Int
        get() = if (capacity > 0) ((currentOccupancy.toDouble() / capacity) * 100).toInt() else 0
    
    val congestionFactor: Double
        get() = when {
            occupancyPercentage >= 90 -> 2.5
            occupancyPercentage >= 75 -> 1.8
            occupancyPercentage >= 60 -> 1.4
            occupancyPercentage >= 40 -> 1.1
            else -> 1.0
        }
}

enum class ZoneOccupancyStatus {
    ABIERTA,
    SATURADA,
    CERRADA,
    MANTENIMIENTO,
    OPERATIVA;

    companion object {
        fun fromString(s: String?): ZoneOccupancyStatus =
            entries.firstOrNull { it.name.equals(s, ignoreCase = true) } ?: ABIERTA
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/SeatInfo.kt`

```kotlin
package com.georacing.georacing.domain.model

data class SeatInfo(
    val grandstand: String,
    val zone: String,
    val row: String,
    val seat: String
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/model/UserPersona.kt`

```kotlin
package com.georacing.georacing.domain.model

enum class UserType {
    FAN, FAMILY, VIP, STAFF
}

enum class TransportMethod {
    CAR, PUBLIC_TRANSPORT, WALKING
}

enum class Interest {
    RACING, FOOD, EVENTS, TECH
}

enum class F1Team(val displayName: String, val color: Long) {
    RED_BULL("Red Bull Racing", 0xFF1E41FF),
    FERRARI("Ferrari", 0xFFDC0000),
    MCLAREN("McLaren", 0xFFFF8700),
    MERCEDES("Mercedes-AMG", 0xFF00D2BE),
    ASTON_MARTIN("Aston Martin", 0xFF006F62),
    ALPINE("Alpine", 0xFF0090FF),
    WILLIAMS("Williams", 0xFF005AFF),
    HAAS("Haas", 0xFFB6BABD),
    RB_VISA("RB Visa Cash App", 0xFF2B4562),
    SAUBER("Sauber / Audi", 0xFF52E252),
    NONE("Sin equipo favorito", 0xFF64748B)
}

data class OnboardingAnswers(
    val userType: UserType?,
    val transportMethod: TransportMethod?,
    val interests: List<Interest> = emptyList(),
    val favoriteTeam: F1Team = F1Team.NONE,
    val needsAccessibility: Boolean = false
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/models/NavigationState.kt`

```kotlin
package com.georacing.georacing.domain.models

import com.georacing.georacing.car.RouteResult
import com.georacing.georacing.car.Step as OsrmStep

/**
 * Estados de la m√°quina de navegaci√≥n.
 * Representa todos los posibles estados en el flujo de navegaci√≥n.
 */
sealed class NavigationState {
    
    /**
     * Estado inicial: sin navegaci√≥n activa
     */
    object Idle : NavigationState()
    
    /**
     * Vista previa de ruta: usuario ve la ruta pero no ha iniciado navegaci√≥n
     */
    data class Preview(
        val route: RouteResult,
        val destinationName: String
    ) : NavigationState()
    
    /**
     * Navegaci√≥n activa: turn-by-turn en curso
     */
    data class Active(
        val route: RouteResult,
        val destinationName: String,
        val currentStepIndex: Int,
        val currentStep: OsrmStep,
        val distanceToNextManeuver: Double,      // Metros hasta pr√≥xima maniobra
        val remainingDistance: Double,            // Metros totales restantes
        val estimatedTimeRemaining: Double,       // Segundos restantes (calculado proporcionalmente)
        val isOffRoute: Boolean = false,
        val closestPointIndex: Int = 0,           // √çndice del punto m√°s cercano en la ruta
        val distanceToRoute: Double = 0.0         // Distancia al punto m√°s cercano
    ) : NavigationState() {
        
        /**
         * Helper para obtener el siguiente paso (si existe)
         */
        fun getNextStep(): OsrmStep? {
            return if (currentStepIndex + 1 < route.steps.size) {
                route.steps[currentStepIndex + 1]
            } else null
        }
        
        /**
         * Helper para calcular progreso de la ruta (0.0 - 1.0)
         */
        fun getProgress(): Float {
            if (route.distance <= 0) return 1f
            return ((route.distance - remainingDistance) / route.distance).toFloat()
        }
    }
    
    /**
     * Destino alcanzado
     */
    data class Arrived(
        val destinationName: String
    ) : NavigationState()
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/navigation/BearingCalculator.kt`

```kotlin
package com.georacing.georacing.domain.navigation

import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin

object BearingCalculator {

    /**
     * Calculates the bearing (angle) from [currentLat], [currentLon] to [destLat], [destLon].
     * Returns degrees (0-360).
     */
    fun calculateBearing(
        currentLat: Double,
        currentLon: Double,
        destLat: Double,
        destLon: Double
    ): Float {
        val lat1 = Math.toRadians(currentLat)
        val lon1 = Math.toRadians(currentLon)
        val lat2 = Math.toRadians(destLat)
        val lon2 = Math.toRadians(destLon)

        val dLon = lon2 - lon1

        val y = sin(dLon) * cos(lat2)
        val x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon)

        var bearing = Math.toDegrees(atan2(y, x))
        bearing = (bearing + 360) % 360 // Normalize to 0-360

        return bearing.toFloat()
    }

    /**
     * Calculates the horizontal offset (X position) for an AR label on the screen.
     * Returns a value between -1.0 (left) and 1.0 (right), or null if out of FOV.
     * 
     * @param azimuth Device's current heading (0-360).
     * @param targetBearing Truth bearing to the target (0-360).
     * @param fov Field of View of the camera (e.g., 60 degrees).
     */
    fun calculateScreenPosition(azimuth: Float, targetBearing: Float, fov: Float = 60f): Float? {
        var diff = targetBearing - azimuth
        
        // Normalize diff to -180 to 180
        if (diff > 180) diff -= 360
        if (diff < -180) diff += 360

        // If absolute difference is greater than half FOV, it's off-screen
        if (Math.abs(diff) > (fov / 2)) {
            return null
        }

        // Map diff (-fov/2 to fov/2) to (-1 to 1)
        // Example: FOV=60. Diff=-30 -> -1. Diff=0 -> 0. Diff=30 -> 1.
        return diff / (fov / 2)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/navigation/PedestrianPathfinder.kt`

```kotlin
package com.georacing.georacing.domain.navigation

import android.util.Log
import org.maplibre.android.geometry.LatLng
import java.util.PriorityQueue
import kotlin.math.*

/**
 * Motor de pathfinding A* local para rutas peatonales dentro del Circuit de Barcelona-Catalunya.
 *
 * Grafo de nodos peatonales internos del circuito con soporte para:
 * - Pesos din√°micos por congesti√≥n (anti-colas)
 * - Preferencia de rutas con sombra (12:00-16:00)
 * - Rutas accesibles (sin escaleras)
 * - Funcionamiento 100% offline
 */
object PedestrianPathfinder {

    private const val TAG = "PedestrianPathfinder"

    // ‚îÄ‚îÄ Nodos del grafo peatonal ‚îÄ‚îÄ

    data class PathNode(
        val id: String,
        val name: String,
        val position: LatLng,
        val hasStairs: Boolean = false,
        val hasShadow: Boolean = false, // Tiene sombra entre 12-16h
        val isIndoor: Boolean = false
    )

    data class PathEdge(
        val from: String,
        val to: String,
        val distanceMeters: Double,
        val hasStairs: Boolean = false,
        val hasShadow: Boolean = false,
        val congestionWeight: Double = 1.0 // 1.0 = normal, >1 = congestionado
    )

    data class PathResult(
        val nodes: List<PathNode>,
        val totalDistance: Double,
        val estimatedTimeSeconds: Double, // A 4.5 km/h peat√≥n
        val steps: List<PedestrianStep>,
        val usedAccessibleRoute: Boolean = false,
        val usedShadowRoute: Boolean = false
    )

    data class PedestrianStep(
        val instruction: String,
        val distance: Double,
        val fromNode: PathNode,
        val toNode: PathNode
    )

    // ‚îÄ‚îÄ Grafo del Circuit de Barcelona-Catalunya ‚îÄ‚îÄ

    private val nodes = listOf(
        // Accesos principales
        PathNode("gate_main", "Acceso Principal", LatLng(41.5693, 2.2577)),
        PathNode("gate_1", "Porta 1", LatLng(41.5700, 2.2590)),
        PathNode("gate_3", "Porta 3", LatLng(41.5688, 2.2610)),
        PathNode("gate_7", "Porta 7", LatLng(41.5675, 2.2555)),
        
        // Tribunas
        PathNode("trib_main", "Tribuna Principal", LatLng(41.5695, 2.2585), hasShadow = true),
        PathNode("trib_a", "Tribuna A", LatLng(41.5698, 2.2600)),
        PathNode("trib_g", "Tribuna G", LatLng(41.5685, 2.2570)),
        PathNode("trib_h", "Tribuna H", LatLng(41.5680, 2.2562), hasStairs = true),
        
        // Zonas internas
        PathNode("fan_zone", "Fan Zone", LatLng(41.5690, 2.2595), hasShadow = true),
        PathNode("paddock", "Acceso Paddock", LatLng(41.5702, 2.2575)),
        PathNode("pit_lane", "Pit Lane Walkway", LatLng(41.5700, 2.2565)),
        PathNode("tower", "Torre de Control", LatLng(41.5705, 2.2570), isIndoor = true, hasShadow = true),
        
        // Servicios
        PathNode("food_main", "Zona Restauraci√≥n Principal", LatLng(41.5692, 2.2590), hasShadow = true),
        PathNode("food_north", "Food Court Norte", LatLng(41.5698, 2.2578)),
        PathNode("wc_main", "Aseos Principales", LatLng(41.5691, 2.2583)),
        PathNode("wc_north", "Aseos Norte", LatLng(41.5701, 2.2582)),
        PathNode("merch", "Tienda Oficial", LatLng(41.5694, 2.2572), isIndoor = true, hasShadow = true),
        PathNode("medical", "Punto M√©dico", LatLng(41.5689, 2.2575)),
        
        // Curvas (zonas de espectadores)
        PathNode("curve_1", "Curva 1 (Elf)", LatLng(41.5710, 2.2600)),
        PathNode("curve_5", "Curva 5 (Seat)", LatLng(41.5665, 2.2620)),
        PathNode("curve_9", "Curva 9 (Campsa)", LatLng(41.5678, 2.2540)),
        
        // Cruces internos
        PathNode("cross_1", "Cruce Central", LatLng(41.5693, 2.2580)),
        PathNode("cross_2", "Cruce Norte", LatLng(41.5700, 2.2578)),
        PathNode("cross_3", "Cruce Sur", LatLng(41.5682, 2.2575)),
        PathNode("cross_4", "Cruce Este", LatLng(41.5690, 2.2605)),
        
        // Parkings
        PathNode("parking_n", "Parking Norte", LatLng(41.5715, 2.2555)),
        PathNode("parking_s", "Parking Sur", LatLng(41.5660, 2.2565)),
        
        // ‚îÄ‚îÄ √öltima milla indoor (interior edificios / t√∫neles / zonas cubiertas) ‚îÄ‚îÄ
        PathNode("indoor_hospitality", "Hospitality Lounge", LatLng(41.5704, 2.2572), isIndoor = true, hasShadow = true),
        PathNode("indoor_media", "Centro de Medios", LatLng(41.5706, 2.2568), isIndoor = true, hasShadow = true),
        PathNode("indoor_paddock_hall", "Hall Paddock", LatLng(41.5703, 2.2573), isIndoor = true, hasShadow = true),
        PathNode("tunnel_south", "T√∫nel Sur (bajo pista)", LatLng(41.5685, 2.2580), isIndoor = true, hasShadow = true),
        PathNode("tunnel_north", "T√∫nel Norte (bajo pista)", LatLng(41.5705, 2.2580), isIndoor = true, hasShadow = true),
        PathNode("indoor_vip_box", "Palco VIP", LatLng(41.5696, 2.2586), isIndoor = true, hasShadow = true, hasStairs = true),
        PathNode("indoor_press_room", "Sala de Prensa", LatLng(41.5707, 2.2566), isIndoor = true, hasShadow = true),
        PathNode("indoor_museum", "Museo del Circuit", LatLng(41.5692, 2.2568), isIndoor = true, hasShadow = true),
        PathNode("parking_entrance_n", "Entrada Parking Norte", LatLng(41.5712, 2.2558)),
        PathNode("parking_entrance_s", "Entrada Parking Sur", LatLng(41.5663, 2.2567))
    ).associateBy { it.id }

    private val edges = listOf(
        // Acceso Principal ‚Üí Cruce Central
        PathEdge("gate_main", "cross_1", 30.0, hasShadow = true),
        PathEdge("cross_1", "gate_main", 30.0, hasShadow = true),
        
        // Cruce Central ‚Üí Servicios
        PathEdge("cross_1", "food_main", 25.0, hasShadow = true),
        PathEdge("food_main", "cross_1", 25.0, hasShadow = true),
        PathEdge("cross_1", "wc_main", 20.0),
        PathEdge("wc_main", "cross_1", 20.0),
        PathEdge("cross_1", "merch", 35.0, hasShadow = true),
        PathEdge("merch", "cross_1", 35.0, hasShadow = true),
        PathEdge("cross_1", "medical", 40.0),
        PathEdge("medical", "cross_1", 40.0),
        
        // Cruce Central ‚Üí Tribunas
        PathEdge("cross_1", "trib_main", 45.0, hasShadow = true),
        PathEdge("trib_main", "cross_1", 45.0, hasShadow = true),
        PathEdge("cross_1", "trib_g", 60.0),
        PathEdge("trib_g", "cross_1", 60.0),
        PathEdge("cross_1", "fan_zone", 50.0, hasShadow = true),
        PathEdge("fan_zone", "cross_1", 50.0, hasShadow = true),
        
        // Cruce Norte
        PathEdge("cross_1", "cross_2", 40.0),
        PathEdge("cross_2", "cross_1", 40.0),
        PathEdge("cross_2", "paddock", 35.0),
        PathEdge("paddock", "cross_2", 35.0),
        PathEdge("cross_2", "pit_lane", 30.0),
        PathEdge("pit_lane", "cross_2", 30.0),
        PathEdge("cross_2", "tower", 40.0, hasShadow = true),
        PathEdge("tower", "cross_2", 40.0, hasShadow = true),
        PathEdge("cross_2", "food_north", 25.0),
        PathEdge("food_north", "cross_2", 25.0),
        PathEdge("cross_2", "wc_north", 20.0),
        PathEdge("wc_north", "cross_2", 20.0),
        PathEdge("cross_2", "gate_1", 55.0),
        PathEdge("gate_1", "cross_2", 55.0),
        PathEdge("cross_2", "curve_1", 80.0),
        PathEdge("curve_1", "cross_2", 80.0),
        
        // Cruce Sur
        PathEdge("cross_1", "cross_3", 50.0),
        PathEdge("cross_3", "cross_1", 50.0),
        PathEdge("cross_3", "trib_h", 45.0, hasStairs = true),
        PathEdge("trib_h", "cross_3", 45.0, hasStairs = true),
        PathEdge("cross_3", "gate_7", 60.0),
        PathEdge("gate_7", "cross_3", 60.0),
        PathEdge("cross_3", "curve_9", 90.0),
        PathEdge("curve_9", "cross_3", 90.0),
        PathEdge("cross_3", "parking_s", 120.0),
        PathEdge("parking_s", "cross_3", 120.0),
        
        // Cruce Este
        PathEdge("cross_1", "cross_4", 55.0),
        PathEdge("cross_4", "cross_1", 55.0),
        PathEdge("cross_4", "trib_a", 40.0),
        PathEdge("trib_a", "cross_4", 40.0),
        PathEdge("cross_4", "gate_3", 50.0),
        PathEdge("gate_3", "cross_4", 50.0),
        PathEdge("cross_4", "curve_5", 100.0),
        PathEdge("curve_5", "cross_4", 100.0),
        
        // Tribuna Principal ‚Üí Fan Zone (directo)
        PathEdge("trib_main", "fan_zone", 35.0, hasShadow = true),
        PathEdge("fan_zone", "trib_main", 35.0, hasShadow = true),
        
        // Parking Norte
        PathEdge("cross_2", "parking_n", 100.0),
        PathEdge("parking_n", "cross_2", 100.0),
        
        // Alternativa sin escaleras a Tribuna H
        PathEdge("cross_3", "trib_g", 55.0),
        PathEdge("trib_g", "cross_3", 55.0),
        PathEdge("trib_g", "trib_h", 40.0), // Rodeo sin escaleras
        PathEdge("trib_h", "trib_g", 40.0),
        
        // ‚îÄ‚îÄ √öltima milla indoor: t√∫neles, edificios, conexiones interiores ‚îÄ‚îÄ
        
        // T√∫nel Sur (conecta zona grada con zona interior sin cruzar pista)
        PathEdge("cross_3", "tunnel_south", 30.0, hasShadow = true),
        PathEdge("tunnel_south", "cross_3", 30.0, hasShadow = true),
        PathEdge("tunnel_south", "fan_zone", 40.0, hasShadow = true),
        PathEdge("fan_zone", "tunnel_south", 40.0, hasShadow = true),
        
        // T√∫nel Norte (conexi√≥n paddock ‚Üî zona espectadores)
        PathEdge("cross_2", "tunnel_north", 25.0, hasShadow = true),
        PathEdge("tunnel_north", "cross_2", 25.0, hasShadow = true),
        PathEdge("tunnel_north", "paddock", 20.0, hasShadow = true),
        PathEdge("paddock", "tunnel_north", 20.0, hasShadow = true),
        
        // Hospitality / Hall Paddock / Media
        PathEdge("paddock", "indoor_paddock_hall", 15.0, hasShadow = true),
        PathEdge("indoor_paddock_hall", "paddock", 15.0, hasShadow = true),
        PathEdge("indoor_paddock_hall", "indoor_hospitality", 20.0, hasShadow = true),
        PathEdge("indoor_hospitality", "indoor_paddock_hall", 20.0, hasShadow = true),
        PathEdge("indoor_paddock_hall", "indoor_media", 25.0, hasShadow = true),
        PathEdge("indoor_media", "indoor_paddock_hall", 25.0, hasShadow = true),
        PathEdge("indoor_media", "indoor_press_room", 15.0, hasShadow = true),
        PathEdge("indoor_press_room", "indoor_media", 15.0, hasShadow = true),
        PathEdge("tower", "indoor_press_room", 20.0, hasShadow = true),
        PathEdge("indoor_press_room", "tower", 20.0, hasShadow = true),
        
        // Palco VIP (desde tribuna principal, con escaleras)
        PathEdge("trib_main", "indoor_vip_box", 25.0, hasStairs = true, hasShadow = true),
        PathEdge("indoor_vip_box", "trib_main", 25.0, hasStairs = true, hasShadow = true),
        
        // Museo del Circuit
        PathEdge("merch", "indoor_museum", 30.0, hasShadow = true),
        PathEdge("indoor_museum", "merch", 30.0, hasShadow = true),
        PathEdge("cross_1", "indoor_museum", 45.0),
        PathEdge("indoor_museum", "cross_1", 45.0),
        
        // Entradas de parking ‚Üí nodos de parking
        PathEdge("parking_n", "parking_entrance_n", 25.0),
        PathEdge("parking_entrance_n", "parking_n", 25.0),
        PathEdge("parking_entrance_n", "cross_2", 80.0),
        PathEdge("cross_2", "parking_entrance_n", 80.0),
        PathEdge("parking_s", "parking_entrance_s", 25.0),
        PathEdge("parking_entrance_s", "parking_s", 25.0),
        PathEdge("parking_entrance_s", "cross_3", 95.0),
        PathEdge("cross_3", "parking_entrance_s", 95.0)
    )

    // Adyacencia
    private val adjacency: Map<String, List<PathEdge>> by lazy {
        edges.groupBy { it.from }
    }

    // ‚îÄ‚îÄ Congestion din√°mica ‚îÄ‚îÄ

    private val congestionMap = mutableMapOf<String, Double>() // nodeId ‚Üí factor (1.0 = normal)

    fun updateCongestion(nodeId: String, factor: Double) {
        congestionMap[nodeId] = factor.coerceIn(0.5, 3.0)
        Log.d(TAG, "üìä Congestion updated: $nodeId ‚Üí $factor")
    }

    fun clearCongestion() {
        congestionMap.clear()
    }

    // ‚îÄ‚îÄ Algoritmo A* ‚îÄ‚îÄ

    /**
     * Calcula la ruta peatonal √≥ptima entre dos puntos del circuito.
     *
     * @param fromId ID del nodo origen
     * @param toId ID del nodo destino
     * @param avoidStairs Evitar tramos con escaleras (accesibilidad)
     * @param preferShadow Preferir rutas con sombra (activo autom√°ticamente 12-16h)
     * @param useDynamicWeights Aplicar pesos de congesti√≥n din√°micos
     */
    fun findRoute(
        fromId: String,
        toId: String,
        avoidStairs: Boolean = false,
        preferShadow: Boolean = false,
        useDynamicWeights: Boolean = true
    ): PathResult? {
        val start = nodes[fromId] ?: return null
        val goal = nodes[toId] ?: return null

        Log.d(TAG, "üîç A* pathfinding: ${start.name} ‚Üí ${goal.name} (stairs=${!avoidStairs}, shadow=$preferShadow)")

        // A* con PriorityQueue
        data class AStarNode(
            val nodeId: String,
            val gCost: Double, // Coste real acumulado
            val fCost: Double, // gCost + heur√≠stica
            val parent: String?
        ) : Comparable<AStarNode> {
            override fun compareTo(other: AStarNode) = fCost.compareTo(other.fCost)
        }

        val openSet = PriorityQueue<AStarNode>()
        val closedSet = mutableSetOf<String>()
        val cameFrom = mutableMapOf<String, String>()
        val gScore = mutableMapOf<String, Double>()

        gScore[fromId] = 0.0
        openSet.add(AStarNode(fromId, 0.0, heuristic(start.position, goal.position), null))

        while (openSet.isNotEmpty()) {
            val current = openSet.poll() ?: break

            if (current.nodeId == toId) {
                // Reconstruir ruta
                return reconstructPath(current.nodeId, cameFrom, gScore[toId] ?: 0.0, avoidStairs, preferShadow)
            }

            if (current.nodeId in closedSet) continue
            closedSet.add(current.nodeId)

            val neighbors = adjacency[current.nodeId] ?: continue

            for (edge in neighbors) {
                if (edge.to in closedSet) continue

                // Filtrar escaleras si es accesible
                if (avoidStairs && edge.hasStairs) continue

                // Calcular coste del edge
                var edgeCost = edge.distanceMeters

                // Aplicar peso de congesti√≥n
                if (useDynamicWeights) {
                    val congestion = congestionMap[edge.to] ?: edge.congestionWeight
                    edgeCost *= congestion
                }

                // Penalizar rutas sin sombra si se prefiere sombra
                if (preferShadow && !edge.hasShadow) {
                    edgeCost *= 1.4 // 40% penalizaci√≥n a cielo abierto
                }

                val tentativeG = (gScore[current.nodeId] ?: Double.MAX_VALUE) + edgeCost

                if (tentativeG < (gScore[edge.to] ?: Double.MAX_VALUE)) {
                    cameFrom[edge.to] = current.nodeId
                    gScore[edge.to] = tentativeG

                    val goalNode = nodes[toId]!!
                    val neighborNode = nodes[edge.to]!!
                    val fScore = tentativeG + heuristic(neighborNode.position, goalNode.position)

                    openSet.add(AStarNode(edge.to, tentativeG, fScore, current.nodeId))
                }
            }
        }

        Log.w(TAG, "‚ùå No se encontr√≥ ruta de $fromId a $toId")
        return null
    }

    /**
     * Encuentra la ruta √≥ptima desde una coordenada GPS arbitraria.
     * Primero busca el nodo m√°s cercano al usuario.
     */
    fun findRouteFromGps(
        userPosition: LatLng,
        toId: String,
        avoidStairs: Boolean = false,
        preferShadow: Boolean = false
    ): PathResult? {
        val nearestNode = findNearestNode(userPosition) ?: return null
        return findRoute(nearestNode.id, toId, avoidStairs, preferShadow)
    }

    /**
     * Encuentra el nodo del grafo m√°s cercano a una coordenada GPS.
     */
    fun findNearestNode(position: LatLng): PathNode? {
        return nodes.values.minByOrNull { node ->
            position.distanceTo(node.position)
        }
    }

    /**
     * Devuelve todos los nodos del grafo (para mostrar en mapa).
     */
    fun getAllNodes(): List<PathNode> = nodes.values.toList()

    /**
     * Devuelve todos los edges (para dibujar en mapa).
     */
    fun getAllEdges(): List<PathEdge> = edges

    /**
     * Devuelve los nodos indoor (√∫ltima milla, interiores, t√∫neles).
     */
    fun getIndoorNodes(): List<PathNode> = nodes.values.filter { it.isIndoor }

    /**
     * Gu√≠a "√öltima Milla" ‚Äî Ruta desde el parking hasta el destino final,
     * priorizando caminos cubiertos (indoor) y sombreados.
     *
     * @param parkingId ID del parking de origen (ej: "parking_n", "parking_s")
     * @param destinationId ID del destino final (ej: "trib_main", "fan_zone", "indoor_vip_box")
     * @param avoidStairs Evitar escaleras
     */
    fun findLastMileRoute(
        parkingId: String,
        destinationId: String,
        avoidStairs: Boolean = false
    ): PathResult? {
        Log.d(TAG, "üö∂ √öltima milla: parking=$parkingId ‚Üí destino=$destinationId")
        // La √∫ltima milla siempre prioriza sombra/indoor
        return findRoute(
            fromId = parkingId,
            toId = destinationId,
            avoidStairs = avoidStairs,
            preferShadow = true, // Siempre priorizar rutas cubiertas
            useDynamicWeights = true
        )
    }

    /**
     * Gu√≠a "√öltima Milla" desde coordenadas GPS (ej: GPS del coche en el parking).
     */
    fun findLastMileRouteFromGps(
        carPosition: LatLng,
        destinationId: String,
        avoidStairs: Boolean = false
    ): PathResult? {
        val nearestParking = nodes.values
            .filter { it.id.startsWith("parking") }
            .minByOrNull { it.position.distanceTo(carPosition) }
            ?: return findRouteFromGps(carPosition, destinationId, avoidStairs, preferShadow = true)
        
        return findLastMileRoute(nearestParking.id, destinationId, avoidStairs)
    }

    // ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ

    private fun heuristic(a: LatLng, b: LatLng): Double {
        return a.distanceTo(b) // Distancia en metros (Haversine)
    }

    private fun reconstructPath(
        goalId: String,
        cameFrom: Map<String, String>,
        totalCost: Double,
        usedAccessible: Boolean,
        usedShadow: Boolean
    ): PathResult {
        val path = mutableListOf(goalId)
        var current = goalId
        while (cameFrom.containsKey(current)) {
            current = cameFrom[current]!!
            path.add(0, current)
        }

        val pathNodes = path.mapNotNull { nodes[it] }
        val steps = mutableListOf<PedestrianStep>()

        for (i in 0 until pathNodes.size - 1) {
            val from = pathNodes[i]
            val to = pathNodes[i + 1]
            val dist = from.position.distanceTo(to.position)
            val bearing = calculateBearing(from.position, to.position)
            val direction = bearingToDirection(bearing)

            steps.add(
                PedestrianStep(
                    instruction = "Dir√≠gete $direction hacia ${to.name} (${dist.toInt()}m)",
                    distance = dist,
                    fromNode = from,
                    toNode = to
                )
            )
        }

        val totalDistance = pathNodes.zipWithNext().sumOf { (a, b) -> a.position.distanceTo(b.position) }
        val walkingSpeedMps = 4.5 / 3.6 // 4.5 km/h ‚Üí m/s
        val estimatedTime = totalCost / walkingSpeedMps

        Log.i(TAG, "‚úÖ Ruta encontrada: ${pathNodes.size} nodos, ${totalDistance.toInt()}m, ${(estimatedTime / 60).toInt()} min")

        return PathResult(
            nodes = pathNodes,
            totalDistance = totalDistance,
            estimatedTimeSeconds = estimatedTime,
            steps = steps,
            usedAccessibleRoute = usedAccessible,
            usedShadowRoute = usedShadow
        )
    }

    private fun calculateBearing(from: LatLng, to: LatLng): Double {
        val lat1 = Math.toRadians(from.latitude)
        val lat2 = Math.toRadians(to.latitude)
        val dLon = Math.toRadians(to.longitude - from.longitude)
        val y = sin(dLon) * cos(lat2)
        val x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon)
        return (Math.toDegrees(atan2(y, x)) + 360) % 360
    }

    private fun bearingToDirection(bearing: Double): String = when {
        bearing < 22.5 || bearing >= 337.5 -> "al norte"
        bearing < 67.5 -> "al noreste"
        bearing < 112.5 -> "al este"
        bearing < 157.5 -> "al sureste"
        bearing < 202.5 -> "al sur"
        bearing < 247.5 -> "al suroeste"
        bearing < 292.5 -> "al oeste"
        else -> "al noroeste"
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/orders/Order.kt`

```kotlin
package com.georacing.georacing.domain.orders

data class Order(
    val orderId: String,
    val status: OrderStatus,
    val totalAmount: Double,
    val items: List<OrderLine>,
    val createdAt: Long
)

data class OrderLine(
    @com.google.gson.annotations.SerializedName("product_id")
    val productId: String,
    @com.google.gson.annotations.SerializedName("quantity")
    val quantity: Int,
    @com.google.gson.annotations.SerializedName("unit_price")
    val unitPrice: Double
)

enum class OrderStatus {
    PENDING,
    PAID,
    PREPARING,
    READY,
    DELIVERED,
    CANCELLED
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/orders/OrdersRepository.kt`

```kotlin
package com.georacing.georacing.domain.orders

interface OrdersRepository {
    suspend fun createOrder(
        userUid: String,
        items: List<OrderLine>,
        totalAmount: Double,
        paymentToken: String
    ): String


    suspend fun getOrder(orderId: String): Order?
}

// I need to make sure I don't break the contract the user expects.
// If I use OrderLine, I need to make sure I map it in the VM.
// OrderLine has (productId, quantity, unitPrice). That sounds exactly like what is needed.

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/products/Product.kt`

```kotlin
package com.georacing.georacing.domain.products

/**
 * Modelo de dominio de Producto.
 * Compatible con ambos esquemas:
 *   - Panel Metropolis: id, name, price, category, emoji, in_stock
 *   - Legacy app:       product_id, name, description, price, stock, category, image_url, is_active
 */
data class Product(
    val productId: String,
    val name: String,
    val description: String = "",
    val price: Double,
    val stock: Int = 0,
    val category: String,
    val imageUrl: String? = null,
    val emoji: String? = null,
    val isActive: Boolean = true
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/products/ProductsRepository.kt`

```kotlin
package com.georacing.georacing.domain.products

interface ProductsRepository {
    suspend fun getAllProducts(): List<Product>
    suspend fun updateProductStock(productId: String, newStock: Int)
    suspend fun upsertProduct(product: Product)
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/repository/BeaconsRepository.kt`

```kotlin
package com.georacing.georacing.domain.repository

import com.georacing.georacing.domain.model.BeaconConfig
import kotlinx.coroutines.flow.Flow

interface BeaconsRepository {
    fun getBeacons(): Flow<List<BeaconConfig>>
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/repository/CircuitStateRepository.kt`

```kotlin
package com.georacing.georacing.domain.repository

import com.georacing.georacing.domain.model.CircuitState
import kotlinx.coroutines.flow.Flow

interface CircuitStateRepository {
    fun getCircuitState(): Flow<CircuitState>
    fun setCircuitState(mode: com.georacing.georacing.domain.model.CircuitMode, message: String?)
    
    // Hybrid Mode Support
    val appMode: Flow<com.georacing.georacing.domain.model.AppMode>
    
    // Debug info for connectivity troubleshooting
    val debugInfo: Flow<String>
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/repository/IncidentsRepository.kt`

```kotlin
package com.georacing.georacing.domain.repository

import com.georacing.georacing.domain.model.IncidentReport

interface IncidentsRepository {
    suspend fun getIncidents(): kotlinx.coroutines.flow.Flow<List<IncidentReport>>
    suspend fun reportIncident(incident: IncidentReport)
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/repository/PoiRepository.kt`

```kotlin
package com.georacing.georacing.domain.repository

import com.georacing.georacing.domain.model.Poi
import kotlinx.coroutines.flow.Flow

interface PoiRepository {
    /**
     * Observa los POIs desde la fuente de datos.
     * En implementaci√≥n Offline-First, esto observa la DB local.
     */
    fun getPois(): Flow<List<Poi>>

    /**
     * Sincroniza los POIs desde la red hacia la cache local.
     * Dise√±ado para ser llamado en background (WorkManager, pull-to-refresh, etc.)
     */
    suspend fun refreshPois()
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/speed/FakeSpeedLimitProvider.kt`

```kotlin
package com.georacing.georacing.domain.speed

import android.location.Location
import android.util.Log

/**
 * FASE 3.2: Implementaci√≥n PLACEHOLDER de SpeedLimitProvider.
 * 
 * IMPORTANTE: Esta es una implementaci√≥n temporal que estima el l√≠mite de velocidad
 * seg√∫n la velocidad actual del veh√≠culo. NO usa datos reales de l√≠mites de v√≠a.
 * 
 * Estrategia de estimaci√≥n:
 * - Velocidad < 40 km/h ‚Üí L√≠mite 30 km/h (zona urbana, parking)
 * - Velocidad 40-60 km/h ‚Üí L√≠mite 50 km/h (ciudad)
 * - Velocidad 60-90 km/h ‚Üí L√≠mite 90 km/h (carretera secundaria)
 * - Velocidad 90-110 km/h ‚Üí L√≠mite 100 km/h (autov√≠a)
 * - Velocidad > 110 km/h ‚Üí L√≠mite 120 km/h (autopista)
 * 
 * TODO: Reemplazar con implementaci√≥n real que use:
 * - Tags de OpenStreetMap (maxspeed)
 * - API de tr√°fico (TomTom Traffic API, HERE Maps, etc.)
 * - Base de datos local de l√≠mites por segmento
 */
class FakeSpeedLimitProvider : SpeedLimitProvider {
    
    companion object {
        private const val TAG = "FakeSpeedLimitProvider"
    }
    
    override fun getSpeedLimitForLocation(location: Location): Int? {
        if (!location.hasSpeed()) {
            Log.v(TAG, "Location has no speed, returning null")
            return null
        }
        
        val speedKmh = location.speed * 3.6f  // m/s a km/h
        
        // Estimar l√≠mite seg√∫n velocidad actual
        val estimatedLimit = when {
            speedKmh < 40f -> 30   // Zona urbana/parking
            speedKmh < 60f -> 50   // Ciudad
            speedKmh < 90f -> 90   // Carretera secundaria
            speedKmh < 110f -> 100 // Autov√≠a
            else -> 120            // Autopista
        }
        
        Log.v(TAG, "PLACEHOLDER: Speed=${speedKmh.toInt()}km/h ‚Üí Estimated limit=${estimatedLimit}km/h")
        
        return estimatedLimit
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/speed/OsmSpeedLimitProvider.kt`

```kotlin
package com.georacing.georacing.domain.speed

import android.location.Location
import android.util.Log
import com.georacing.georacing.car.LegAnnotation
import com.georacing.georacing.car.MaxSpeedEntry
import com.georacing.georacing.car.OsrmService
import com.georacing.georacing.car.config.OsrmConfig
import com.google.gson.GsonBuilder
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withContext
import org.maplibre.android.geometry.LatLng
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.util.Locale
import java.util.concurrent.ConcurrentHashMap

/**
 * Proveedor de l√≠mites de velocidad reales basado en datos OpenStreetMap v√≠a OSRM.
 *
 * Estrategia:
 * 1. Cuando se calcula una ruta, extrae `annotations.maxspeed` de OSRM
 *    (esto usa la etiqueta `maxspeed` de las v√≠as OSM).
 * 2. Cachea los l√≠mites por coordenada/grid para consultas r√°pidas.
 * 3. Fallback: Si OSRM no tiene maxspeed, usa Overpass API como respaldo.
 *
 * Datos OSM: La mayor√≠a de carreteras principales y autopistas en Espa√±a
 * tienen la etiqueta maxspeed correctamente etiquetada.
 */
class OsmSpeedLimitProvider : SpeedLimitProvider {

    companion object {
        private const val TAG = "OsmSpeedLimitProvider"
        private const val GRID_PRECISION = 10000 // ~11m precision grid
        private const val CACHE_MAX_SIZE = 500
        private const val SEGMENT_MATCH_RADIUS_M = 80.0
    }

    // ‚îÄ‚îÄ Cache de l√≠mites ‚îÄ‚îÄ

    data class SpeedLimitSegment(
        val lat: Double, val lon: Double,
        val speedLimitKmh: Int,
        val timestamp: Long
    )

    private val gridCache = ConcurrentHashMap<String, Int>() // gridKey ‚Üí km/h
    private var routeSegments: List<SpeedLimitSegment> = emptyList()
    private val osrmService: OsrmService

    init {
        val baseUrl = OsrmConfig.getBaseUrl()
        val retrofit = Retrofit.Builder()
            .baseUrl(baseUrl)
            .addConverterFactory(GsonConverterFactory.create(GsonBuilder().create()))
            .build()
        osrmService = retrofit.create(OsrmService::class.java)
    }

    // ‚îÄ‚îÄ SpeedLimitProvider API ‚îÄ‚îÄ

    override fun getSpeedLimitForLocation(location: Location): Int? {
        // 1. Buscar en cache por grid
        val gridKey = toGridKey(location.latitude, location.longitude)
        gridCache[gridKey]?.let { return it }

        // 2. Buscar en segmentos de ruta cacheados
        val nearest = findNearestSegment(location)
        if (nearest != null) {
            gridCache[gridKey] = nearest.speedLimitKmh
            return nearest.speedLimitKmh
        }

        // 3. Sin datos cacheados ‚Üí consultar OSRM puntualmente (async ‚Üí blocking en hilo IO)
        return try {
            runBlocking(Dispatchers.IO) {
                querySpeedLimitFromOsrm(location)
            }
        } catch (e: Exception) {
            Log.w(TAG, "Error querying speed limit: ${e.message}")
            null
        }
    }

    // ‚îÄ‚îÄ Alimentar desde ruta ‚îÄ‚îÄ

    /**
     * Carga l√≠mites de velocidad para una ruta completa usando OSRM annotations=maxspeed.
     * Debe llamarse cuando se calcula una nueva ruta.
     */
    suspend fun loadSpeedLimitsForRoute(origin: LatLng, dest: LatLng) {
        withContext(Dispatchers.IO) {
            try {
                val coordinates = String.format(
                    Locale.US, "%.6f,%.6f;%.6f,%.6f",
                    origin.longitude, origin.latitude,
                    dest.longitude, dest.latitude
                )

                val response = osrmService.getRoute(
                    coordinates = coordinates,
                    annotations = "maxspeed,speed"
                )

                if (response.code == "Ok" && response.routes.isNotEmpty()) {
                    parseAnnotations(response.routes[0].legs.firstOrNull()?.annotation,
                        response.routes[0].legs.firstOrNull()?.steps?.map { it.maneuver.location }
                            ?: emptyList())
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error loading speed limits for route", e)
            }
        }
    }

    /**
     * Alimenta directamente con anotaciones OSRM ya obtenidas.
     */
    fun updateFromAnnotation(annotation: LegAnnotation?, stepLocations: List<List<Double>>) {
        parseAnnotations(annotation, stepLocations)
    }

    // ‚îÄ‚îÄ Consulta puntual desde OSRM ‚îÄ‚îÄ

    private suspend fun querySpeedLimitFromOsrm(location: Location): Int? {
        return try {
            // Mini-ruta de 100m para obtener maxspeed del segmento actual
            val offset = 0.001 // ~100m
            val coordinates = String.format(
                Locale.US, "%.6f,%.6f;%.6f,%.6f",
                location.longitude, location.latitude,
                location.longitude + offset, location.latitude
            )

            val response = osrmService.getRoute(
                coordinates = coordinates,
                annotations = "maxspeed"
            )

            if (response.code == "Ok" && response.routes.isNotEmpty()) {
                val leg = response.routes[0].legs.firstOrNull()
                val maxspeeds = leg?.annotation?.maxspeed
                if (!maxspeeds.isNullOrEmpty()) {
                    val limit = parseMaxSpeedEntry(maxspeeds.first())
                    if (limit != null) {
                        val gridKey = toGridKey(location.latitude, location.longitude)
                        gridCache[gridKey] = limit
                        Log.d(TAG, "üìç Speed limit at (${location.latitude}, ${location.longitude}): $limit km/h")
                    }
                    limit
                } else null
            } else null
        } catch (e: Exception) {
            Log.w(TAG, "OSRM maxspeed query failed: ${e.message}")
            null
        }
    }

    // ‚îÄ‚îÄ Parsing ‚îÄ‚îÄ

    private fun parseAnnotations(annotation: LegAnnotation?, stepLocations: List<List<Double>>) {
        if (annotation == null) return

        val maxspeeds = annotation.maxspeed ?: return
        val segments = mutableListOf<SpeedLimitSegment>()
        val now = System.currentTimeMillis()

        maxspeeds.forEachIndexed { i, entry ->
            val limit = parseMaxSpeedEntry(entry) ?: return@forEachIndexed

            // Mapear a la coordenada m√°s cercana del step
            val locIdx = if (stepLocations.isNotEmpty()) {
                (i * stepLocations.size / maxspeeds.size).coerceIn(0, stepLocations.lastIndex)
            } else return@forEachIndexed

            val loc = stepLocations[locIdx]
            val lat = loc.getOrNull(1) ?: return@forEachIndexed
            val lon = loc.getOrNull(0) ?: return@forEachIndexed

            segments.add(SpeedLimitSegment(lat, lon, limit, now))

            // Tambi√©n cachear en grid
            val gridKey = toGridKey(lat, lon)
            gridCache[gridKey] = limit
        }

        routeSegments = segments
        trimCacheIfNeeded()
        Log.i(TAG, "‚úÖ Loaded ${segments.size} speed limit segments from OSRM maxspeed")
    }

    private fun parseMaxSpeedEntry(entry: MaxSpeedEntry): Int? {
        // Si es "unknown" o "none", no hay dato
        if (entry.unknown == true) return null
        if (entry.none == true) return null

        val speed = entry.speed ?: return null
        val unit = entry.unit

        // Convertir si es mph
        return if (unit == "mph") {
            (speed * 1.60934).toInt()
        } else {
            speed // ya en km/h
        }
    }

    // ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ

    private fun findNearestSegment(location: Location): SpeedLimitSegment? {
        if (routeSegments.isEmpty()) return null

        return routeSegments.minByOrNull { seg ->
            val results = FloatArray(1)
            Location.distanceBetween(location.latitude, location.longitude, seg.lat, seg.lon, results)
            results[0].toDouble()
        }?.let { seg ->
            val results = FloatArray(1)
            Location.distanceBetween(location.latitude, location.longitude, seg.lat, seg.lon, results)
            if (results[0] < SEGMENT_MATCH_RADIUS_M) seg else null
        }
    }

    private fun toGridKey(lat: Double, lon: Double): String {
        val gridLat = (lat * GRID_PRECISION).toInt()
        val gridLon = (lon * GRID_PRECISION).toInt()
        return "$gridLat,$gridLon"
    }

    private fun trimCacheIfNeeded() {
        if (gridCache.size > CACHE_MAX_SIZE) {
            val keysToRemove = gridCache.keys.toList().take(gridCache.size - CACHE_MAX_SIZE / 2)
            keysToRemove.forEach { gridCache.remove(it) }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/speed/SpeedLimitProvider.kt`

```kotlin
package com.georacing.georacing.domain.speed

import android.location.Location

/**
 * FASE 3.2: Proveedor de l√≠mites de velocidad para un tramo.
 * 
 * Esta interfaz permite obtener el l√≠mite de velocidad del tramo actual.
 * 
 * Implementaciones:
 * - FakeSpeedLimitProvider: Versi√≥n de placeholder que estima seg√∫n velocidad actual
 * - OSMSpeedLimitProvider (futuro): Obtiene l√≠mites desde tags de OpenStreetMap
 * - APISpeedLimitProvider (futuro): Consulta API de tr√°fico (TomTom, HERE, etc.)
 */
interface SpeedLimitProvider {
    
    /**
     * Obtiene el l√≠mite de velocidad en km/h para la ubicaci√≥n actual.
     * 
     * @param location Ubicaci√≥n GPS actual
     * @return L√≠mite de velocidad en km/h, o null si no est√° disponible
     */
    fun getSpeedLimitForLocation(location: Location): Int?
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/traffic/CircuitTrafficProvider.kt`

```kotlin
package com.georacing.georacing.domain.traffic

import android.location.Location
import android.util.Log
import com.georacing.georacing.data.repository.NetworkTrafficRepository
import com.georacing.georacing.domain.model.ZoneOccupancy
import com.georacing.georacing.domain.navigation.PedestrianPathfinder
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

/**
 * Proveedor de tr√°fico real basado en datos del backend (tabla "zone_traffic").
 * 
 * Lee datos de ocupaci√≥n gestionados desde Panel Metropolis y convierte
 * la ocupaci√≥n de zonas en factores de congesti√≥n para el pathfinding A*.
 * 
 * Sustituye la versi√≥n anterior que usaba ScenarioSimulator (datos simulados).
 */
class CircuitTrafficProvider : TrafficProvider {

    private val TAG = "CircuitTrafficProvider"
    private val repository = NetworkTrafficRepository()
    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    // Zonas del circuito con coordenadas y nodos del grafo A*
    private data class ZoneMapping(
        val zoneId: String,
        val centerLat: Double,
        val centerLon: Double,
        val radiusMeters: Double,
        val graphNodeIds: List<String>,
        var congestionFactor: Double = 1.0
    )

    private val zoneMappings = listOf(
        ZoneMapping("grada-t1-recta-principal", 41.5695, 2.2585, 100.0,
            listOf("trib_main", "trib_a", "cross_1")),
        ZoneMapping("fan-zone-principal", 41.5690, 2.2595, 80.0,
            listOf("fan_zone", "cross_4", "food_main")),
        ZoneMapping("paddock-vip-boxes", 41.5702, 2.2575, 70.0,
            listOf("paddock", "pit_lane", "tower", "cross_2")),
        ZoneMapping("grada-t2-curva-ascari", 41.5678, 2.2610, 100.0,
            listOf("curve_1", "curve_5")),
        ZoneMapping("vial-acceso-a-norte", 41.5710, 2.2560, 50.0,
            listOf("gate_main", "gate_1", "gate_3", "gate_7")),
        ZoneMapping("grada-t3-chicane", 41.5685, 2.2555, 150.0,
            listOf("parking_n", "parking_s", "cross_3")),
        ZoneMapping("fan-zone-tecnologica", 41.5688, 2.2605, 80.0,
            listOf("curve_9", "food_north", "wc_main"))
    )

    // √öltimo estado conocido de zonas
    private val _zones = MutableStateFlow<List<ZoneOccupancy>>(emptyList())
    val zones = _zones.asStateFlow()

    init {
        // Iniciar polling de zonas del backend
        scope.launch {
            repository.observeZoneTraffic(15000).collect { zoneList ->
                _zones.value = zoneList
                updateCongestionFromZones(zoneList)
            }
        }
    }

    /**
     * Actualiza factores de congesti√≥n bas√°ndose en datos reales del backend.
     */
    private fun updateCongestionFromZones(zoneList: List<ZoneOccupancy>) {
        zoneMappings.forEach { mapping ->
            val zone = zoneList.find { it.id == mapping.zoneId }
            if (zone != null) {
                mapping.congestionFactor = zone.congestionFactor

                // Propagar al grafo A*
                mapping.graphNodeIds.forEach { nodeId ->
                    PedestrianPathfinder.updateCongestion(nodeId, mapping.congestionFactor)
                }
            }
        }

        Log.d(TAG, "üìä Congestion from backend: " +
                zoneMappings.joinToString { "${it.zoneId}=${String.format("%.1f", it.congestionFactor)}" })
    }

    /**
     * Fuerza una recarga inmediata de datos del backend.
     */
    suspend fun refreshNow() {
        val zoneList = repository.getZoneTraffic()
        _zones.value = zoneList
        updateCongestionFromZones(zoneList)
    }

    override fun getTrafficFactor(location: Location): Double {
        // Encontrar la zona m√°s cercana
        val nearestZone = zoneMappings.minByOrNull { mapping ->
            val results = FloatArray(1)
            Location.distanceBetween(
                location.latitude, location.longitude,
                mapping.centerLat, mapping.centerLon,
                results
            )
            results[0].toDouble()
        }

        return nearestZone?.congestionFactor ?: 1.0
    }

    override fun isAvailable(): Boolean = true

    override fun getTrafficDescription(location: Location): String {
        val factor = getTrafficFactor(location)
        return when {
            factor < 0.9 -> "üü¢ Tr√°fico fluido"
            factor < 1.2 -> "üü¢ Tr√°fico normal"
            factor < 1.5 -> "üü° Zona concurrida"
            factor < 2.0 -> "üü† Zona congestionada"
            else -> "üî¥ Zona muy congestionada"
        }
    }

    override fun getTrafficFactorForSegment(
        startLat: Double,
        startLon: Double,
        endLat: Double,
        endLon: Double
    ): Double {
        val startLocation = Location("").apply {
            latitude = startLat
            longitude = startLon
        }
        val endLocation = Location("").apply {
            latitude = endLat
            longitude = endLon
        }

        val startFactor = getTrafficFactor(startLocation)
        val endFactor = getTrafficFactor(endLocation)

        return (startFactor + endFactor) / 2.0
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/traffic/FakeTrafficProvider.kt`

```kotlin
package com.georacing.georacing.domain.traffic

import android.location.Location

/**
 * FASE 3: PLACEHOLDER - Proveedor de tr√°fico falso para desarrollo.
 * 
 * Este proveedor SIEMPRE devuelve factor 1.0 (tr√°fico normal, sin ajustes).
 * 
 * TODO FASE 3: Reemplazar con implementaci√≥n real usando:
 * - Google Maps Traffic API
 * - TomTom Traffic API
 * - HERE Traffic API
 * - OpenStreetMap live traffic data
 * - Datos propios recopilados de usuarios
 * 
 * COMPORTAMIENTO ACTUAL:
 * - getTrafficFactor() ‚Üí 1.0 (sin cambios al ETA)
 * - isAvailable() ‚Üí true (siempre disponible)
 * - getTrafficDescription() ‚Üí "Tr√°fico normal (simulado)"
 * 
 * TESTING: Para probar diferentes escenarios de tr√°fico, puedes modificar
 * temporalmente el valor de retorno de getTrafficFactor():
 * 
 * Ejemplos de testing:
 * - return 1.2  // Simular tr√°fico moderado
 * - return 1.5  // Simular tr√°fico intenso
 * - return 0.8  // Simular tr√°fico fluido
 */
class FakeTrafficProvider : TrafficProvider {
    
    /**
     * PLACEHOLDER: Siempre devuelve 1.0 (sin tr√°fico).
     * 
     * TODO FASE 3: Implementar l√≥gica real conectando con API de tr√°fico.
     * 
     * Ejemplo de implementaci√≥n real:
     * ```kotlin
     * override fun getTrafficFactor(location: Location): Double? {
     *     // Llamar a Google Maps Traffic API
     *     val response = trafficApi.getTraffic(location.latitude, location.longitude)
     *     
     *     // Convertir nivel de tr√°fico a factor
     *     return when (response.trafficLevel) {
     *         "TRAFFIC_FREE" -> 0.9
     *         "TRAFFIC_LIGHT" -> 1.1
     *         "TRAFFIC_MODERATE" -> 1.3
     *         "TRAFFIC_HEAVY" -> 1.6
     *         "TRAFFIC_JAM" -> 2.0
     *         else -> 1.0
     *     }
     * }
     * ```
     */
    override fun getTrafficFactor(location: Location): Double {
        // PLACEHOLDER: Sin tr√°fico
        return 1.0
        
        // TODO FASE 3: Descomentar para testing de diferentes escenarios
        // return 1.2  // Tr√°fico moderado
        // return 1.5  // Tr√°fico intenso
        // return 0.8  // Tr√°fico fluido
    }
    
    /**
     * PLACEHOLDER: Siempre disponible.
     * 
     * TODO FASE 3: Verificar conectividad con API real.
     */
    override fun isAvailable(): Boolean {
        // PLACEHOLDER: Siempre disponible
        return true
        
        // TODO FASE 3: Verificar API real
        // return networkManager.isConnected() && trafficApi.isHealthy()
    }
    
    /**
     * PLACEHOLDER: Descripci√≥n fija.
     * 
     * TODO FASE 3: Delegar en implementaci√≥n de interfaz base.
     */
    override fun getTrafficDescription(location: Location): String {
        // PLACEHOLDER: Descripci√≥n fija
        return "Tr√°fico normal (simulado)"
        
        // TODO FASE 3: Usar implementaci√≥n real de la interfaz base
        // return super.getTrafficDescription(location) ?: "Sin datos"
    }
    
    /**
     * FASE 3: No soportado en placeholder.
     * 
     * TODO FASE 3: Implementar consulta por segmentos si la API lo soporta.
     */
    override fun getTrafficFactorForSegment(
        startLat: Double,
        startLon: Double,
        endLat: Double,
        endLon: Double
    ): Double? {
        // PLACEHOLDER: No soportado
        return null
        
        // TODO FASE 3: Consultar tr√°fico para segmento espec√≠fico
        // return trafficApi.getSegmentTraffic(startLat, startLon, endLat, endLon)?.toFactor()
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/traffic/OsrmTrafficProvider.kt`

```kotlin
package com.georacing.georacing.domain.traffic

import android.location.Location
import android.util.Log
import com.georacing.georacing.car.OsrmResponse
import com.georacing.georacing.car.OsrmService
import com.georacing.georacing.car.config.OsrmConfig
import com.google.gson.GsonBuilder
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withContext
import org.maplibre.android.geometry.LatLng
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.util.Locale
import java.util.concurrent.ConcurrentHashMap

/**
 * Proveedor de tr√°fico real basado en datos OSRM.
 *
 * Estrategia:
 * 1. Al calcular ruta, obtiene anotaciones OSRM (speed por segmento)
 * 2. Compara la velocidad actual GPS con la velocidad esperada OSRM del segmento
 * 3. Si GPS speed << OSRM speed ‚Üí hay tr√°fico
 * 4. Cachea datos de la ruta actual para consultas r√°pidas
 *
 * Limitaci√≥n: OSRM p√∫blico no tiene tr√°fico en tiempo real,
 * pero los segmentos con velocidades reducidas respecto al perfil
 * de la carretera S√ç indican congesti√≥n habitual (datos hist√≥ricos OSM).
 */
class OsrmTrafficProvider : TrafficProvider {

    companion object {
        private const val TAG = "OsrmTrafficProvider"
        private const val CACHE_VALIDITY_MS = 5 * 60 * 1000L  // 5 minutos
        private const val SEGMENT_MATCH_RADIUS_M = 50.0        // metros para snap
    }

    // ‚îÄ‚îÄ Datos cacheados de la ruta ‚îÄ‚îÄ

    data class SegmentSpeed(
        val startLat: Double, val startLon: Double,
        val endLat: Double, val endLon: Double,
        val expectedSpeedMs: Double,  // velocidad esperada m/s (perfil OSM)
        val distanceM: Double
    )

    private var cachedSegments: List<SegmentSpeed> = emptyList()
    private var cacheTimestamp: Long = 0L
    private val osrmService: OsrmService

    // Cache de consultas recientes por gridCell
    private val gridCache = ConcurrentHashMap<String, Double>()

    init {
        val baseUrl = OsrmConfig.getBaseUrl()
        val retrofit = Retrofit.Builder()
            .baseUrl(baseUrl)
            .addConverterFactory(GsonConverterFactory.create(GsonBuilder().create()))
            .build()
        osrmService = retrofit.create(OsrmService::class.java)
    }

    // ‚îÄ‚îÄ API TrafficProvider ‚îÄ‚îÄ

    override fun getTrafficFactor(location: Location): Double? {
        // Si tenemos segmentos cacheados de la ruta, usar comparaci√≥n GPS vs esperado
        val nearestSegment = findNearestSegment(location)
        if (nearestSegment != null) {
            return calculateTrafficFactor(location, nearestSegment)
        }

        // Sin ruta cacheada ‚Üí consultar OSRM con un mini-tramo ficticio
        val gridKey = "${(location.latitude * 100).toInt()},${(location.longitude * 100).toInt()}"
        gridCache[gridKey]?.let { return it }

        return null // No hay datos
    }

    override fun getTrafficFactorForSegment(
        startLat: Double, startLon: Double,
        endLat: Double, endLon: Double
    ): Double? {
        // Buscar segmento cacheado que cubra este tramo
        val midLat = (startLat + endLat) / 2
        val midLon = (startLon + endLon) / 2
        val midLoc = Location("").apply { latitude = midLat; longitude = midLon }
        val segment = findNearestSegment(midLoc) ?: return null

        return if (segment.expectedSpeedMs > 0) {
            // Calcular factor basado en velocidad del perfil vs velocidad libre
            val freeFlowMs = estimateFreeFlowSpeed(segment)
            (freeFlowMs / segment.expectedSpeedMs).coerceIn(0.8, 3.0)
        } else null
    }

    override fun isAvailable(): Boolean = cachedSegments.isNotEmpty()

    override fun getTrafficDescription(location: Location): String? {
        val factor = getTrafficFactor(location) ?: return null
        return when {
            factor < 0.9 -> "üü¢ Tr√°fico fluido"
            factor < 1.1 -> "üü¢ Tr√°fico normal"
            factor < 1.3 -> "üü° Tr√°fico moderado"
            factor < 1.6 -> "üü† Tr√°fico intenso"
            else -> "üî¥ Tr√°fico muy intenso"
        }
    }

    // ‚îÄ‚îÄ Alimentar datos desde ruta OSRM ‚îÄ‚îÄ

    /**
     * Llama a OSRM con annotations=speed,duration,distance y cachea segmentos.
     * Debe llamarse cuando se calcula una nueva ruta.
     */
    suspend fun loadRouteTrafficData(origin: LatLng, dest: LatLng) {
        withContext(Dispatchers.IO) {
            try {
                val coordinates = String.format(
                    Locale.US, "%.6f,%.6f;%.6f,%.6f",
                    origin.longitude, origin.latitude,
                    dest.longitude, dest.latitude
                )

                val response = osrmService.getRoute(
                    coordinates = coordinates,
                    annotations = "speed,duration,distance"
                )

                if (response.code == "Ok" && response.routes.isNotEmpty()) {
                    val route = response.routes[0]
                    val segments = mutableListOf<SegmentSpeed>()

                    route.legs.forEach { leg ->
                        val annotation = leg.annotation ?: return@forEach
                        val speeds = annotation.speed ?: return@forEach
                        val distances = annotation.distance ?: emptyList()

                        // Extraer coordenadas de los steps para mapear segmentos
                        val stepLocations = leg.steps.map { step ->
                            step.maneuver.location // [lon, lat]
                        }

                        speeds.forEachIndexed { i, speedMs ->
                            val dist = distances.getOrNull(i) ?: 0.0
                            // Aproximar start/end desde steps
                            val locIdx = (i * stepLocations.size / speeds.size)
                                .coerceIn(0, stepLocations.lastIndex)
                            val nextLocIdx = ((i + 1) * stepLocations.size / speeds.size)
                                .coerceIn(0, stepLocations.lastIndex)

                            val startLoc = stepLocations.getOrNull(locIdx) ?: return@forEachIndexed
                            val endLoc = stepLocations.getOrNull(nextLocIdx) ?: startLoc

                            segments.add(
                                SegmentSpeed(
                                    startLat = startLoc[1], startLon = startLoc[0],
                                    endLat = endLoc[1], endLon = endLoc[0],
                                    expectedSpeedMs = speedMs,
                                    distanceM = dist
                                )
                            )
                        }
                    }

                    cachedSegments = segments
                    cacheTimestamp = System.currentTimeMillis()
                    gridCache.clear()
                    Log.i(TAG, "‚úÖ Loaded ${segments.size} traffic segments from OSRM")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error loading traffic data", e)
            }
        }
    }

    /**
     * Alimenta directamente con una respuesta OSRM ya obtenida (evita doble llamada).
     */
    fun updateFromResponse(response: OsrmResponse, routePoints: List<LatLng>) {
        val segments = mutableListOf<SegmentSpeed>()

        response.routes.firstOrNull()?.legs?.forEach { leg ->
            val annotation = leg.annotation ?: return@forEach
            val speeds = annotation.speed ?: return@forEach
            val distances = annotation.distance ?: emptyList()

            speeds.forEachIndexed { i, speedMs ->
                val dist = distances.getOrNull(i) ?: 0.0
                val pointIdx = (i * routePoints.size / speeds.size)
                    .coerceIn(0, routePoints.lastIndex)
                val nextPointIdx = ((i + 1) * routePoints.size / speeds.size)
                    .coerceIn(0, routePoints.lastIndex)

                val start = routePoints[pointIdx]
                val end = routePoints[nextPointIdx]

                segments.add(
                    SegmentSpeed(
                        startLat = start.latitude, startLon = start.longitude,
                        endLat = end.latitude, endLon = end.longitude,
                        expectedSpeedMs = speedMs,
                        distanceM = dist
                    )
                )
            }
        }

        cachedSegments = segments
        cacheTimestamp = System.currentTimeMillis()
        gridCache.clear()
        Log.i(TAG, "‚úÖ Updated ${segments.size} traffic segments from existing response")
    }

    // ‚îÄ‚îÄ L√≥gica interna ‚îÄ‚îÄ

    private fun findNearestSegment(location: Location): SegmentSpeed? {
        if (cachedSegments.isEmpty()) return null
        if (System.currentTimeMillis() - cacheTimestamp > CACHE_VALIDITY_MS) return null

        return cachedSegments.minByOrNull { seg ->
            val midLat = (seg.startLat + seg.endLat) / 2
            val midLon = (seg.startLon + seg.endLon) / 2
            val results = FloatArray(1)
            Location.distanceBetween(location.latitude, location.longitude, midLat, midLon, results)
            results[0].toDouble()
        }?.let { seg ->
            val midLat = (seg.startLat + seg.endLat) / 2
            val midLon = (seg.startLon + seg.endLon) / 2
            val results = FloatArray(1)
            Location.distanceBetween(location.latitude, location.longitude, midLat, midLon, results)
            if (results[0] < SEGMENT_MATCH_RADIUS_M) seg else null
        }
    }

    private fun calculateTrafficFactor(location: Location, segment: SegmentSpeed): Double {
        val expectedSpeedMs = segment.expectedSpeedMs
        if (expectedSpeedMs <= 0) return 1.0

        // Si tenemos velocidad GPS, comparar
        if (location.hasSpeed() && location.speed > 1.0f) {
            val actualSpeedMs = location.speed.toDouble()
            // factor = esperado / real ‚Üí >1 significa m√°s lento de lo esperado (tr√°fico)
            val factor = expectedSpeedMs / actualSpeedMs
            return factor.coerceIn(0.5, 3.0)
        }

        // Sin GPS speed ‚Üí usar perfil OSRM como indicador
        val freeFlowMs = estimateFreeFlowSpeed(segment)
        return if (freeFlowMs > expectedSpeedMs) {
            (freeFlowMs / expectedSpeedMs).coerceIn(1.0, 2.5)
        } else {
            1.0 // Velocidad OSRM >= free flow ‚Üí no hay congesti√≥n
        }
    }

    /**
     * Estima velocidad en flujo libre bas√°ndose en la velocidad OSRM del segmento.
     * OSRM ya usa perfiles de velocidad conservadores, as√≠ que usamos un factor.
     */
    private fun estimateFreeFlowSpeed(segment: SegmentSpeed): Double {
        val osrmSpeed = segment.expectedSpeedMs
        return when {
            osrmSpeed > 30.0 -> osrmSpeed * 1.1  // Autopista: OSRM ~= free flow
            osrmSpeed > 20.0 -> osrmSpeed * 1.15  // Autov√≠a
            osrmSpeed > 10.0 -> osrmSpeed * 1.2   // Carretera
            else -> osrmSpeed * 1.3                // Urbano
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/traffic/TrafficProvider.kt`

```kotlin
package com.georacing.georacing.domain.traffic

import android.location.Location

/**
 * FASE 3: Interfaz para proveedores de datos de tr√°fico en tiempo real.
 * 
 * Esta interfaz define el contrato para obtener informaci√≥n de tr√°fico
 * que se usar√° para ajustar el ETA durante la navegaci√≥n.
 * 
 * IMPLEMENTACIONES POSIBLES:
 * - Google Maps Traffic API (requiere API key de pago)
 * - TomTom Traffic API
 * - HERE Traffic API
 * - OpenStreetMap Traffic (limitado)
 * - Datos propios de sensores/GPS
 * 
 * FASE 3: Actualmente solo existe FakeTrafficProvider (placeholder).
 */
interface TrafficProvider {
    
    /**
     * Obtiene el factor de tr√°fico global para la ubicaci√≥n actual.
     * 
     * El factor indica qu√© tan lento/r√°pido est√° el tr√°fico:
     * - 1.0 = tr√°fico normal (sin cambios al ETA)
     * - 1.2 = tr√°fico moderado (+20% m√°s lento)
     * - 1.5 = tr√°fico intenso (+50% m√°s lento)
     * - 2.0 = tr√°fico muy intenso (el doble de tiempo)
     * - 0.8 = tr√°fico fluido (-20% m√°s r√°pido, poco com√∫n)
     * 
     * IMPORTANTE: Los valores extremos (<0.5 o >3.0) ser√°n limitados
     * autom√°ticamente por ETACalculator para evitar errores.
     * 
     * @param location Ubicaci√≥n actual del veh√≠culo
     * @return Factor de tr√°fico (1.0 = normal). Null si no hay datos disponibles.
     */
    fun getTrafficFactor(location: Location): Double?
    
    /**
     * Obtiene el factor de tr√°fico para un segmento espec√≠fico de ruta.
     * 
     * FASE 3: Este m√©todo es AVANZADO y permite factores diferentes
     * por segmento de ruta (m√°s preciso que factor global).
     * 
     * Ejemplo de uso:
     * - Segmento 1 (autopista): factor 1.0 (fluido)
     * - Segmento 2 (ciudad): factor 1.8 (atasco)
     * - Segmento 3 (salida): factor 1.2 (moderado)
     * 
     * IMPLEMENTACI√ìN FUTURA: Por ahora, FakeTrafficProvider devuelve null.
     * 
     * @param startLat Latitud inicio del segmento
     * @param startLon Longitud inicio del segmento
     * @param endLat Latitud fin del segmento
     * @param endLon Longitud fin del segmento
     * @return Factor de tr√°fico para ese segmento. Null si no soportado.
     */
    fun getTrafficFactorForSegment(
        startLat: Double,
        startLon: Double,
        endLat: Double,
        endLon: Double
    ): Double? = null  // Default: no soportado
    
    /**
     * Indica si el proveedor tiene datos de tr√°fico disponibles.
     * 
     * √ötil para mostrar advertencias al usuario si no hay datos.
     * 
     * @return true si hay datos disponibles, false si no
     */
    fun isAvailable(): Boolean
    
    /**
     * Obtiene descripci√≥n legible del estado del tr√°fico.
     * 
     * Ejemplos:
     * - "Tr√°fico fluido"
     * - "Tr√°fico moderado"
     * - "Tr√°fico intenso"
     * - "Datos no disponibles"
     * 
     * @param location Ubicaci√≥n para consultar
     * @return Descripci√≥n del tr√°fico o null si no disponible
     */
    fun getTrafficDescription(location: Location): String? {
        val factor = getTrafficFactor(location) ?: return null
        
        return when {
            factor < 0.9 -> "Tr√°fico fluido"
            factor < 1.1 -> "Tr√°fico normal"
            factor < 1.3 -> "Tr√°fico moderado"
            factor < 1.6 -> "Tr√°fico intenso"
            else -> "Tr√°fico muy intenso"
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/usecase/BroadcastEmergencyUseCase.kt`

```kotlin
package com.georacing.georacing.domain.usecase

import com.georacing.georacing.infrastructure.ble.StaffBeaconAdvertiser
import kotlinx.coroutines.flow.Flow

/**
 * Caso de Uso que permite a un perfil Staff emitir una alerta de emergencia usando
 * su dispositivo m√≥vil como "Baliza Humana" BLE.
 */
class BroadcastEmergencyUseCase(
    private val staffBeaconAdvertiser: StaffBeaconAdvertiser
) {

    /**
     * Inicia la emisi√≥n de la baliza de emergencia con el estado proporcionado.
     * @param isEvacuation Si es true emite "EVACUATE", sino "DANGER".
     * @return Flow con el estado de la emisi√≥n (true = √©xito, false = error/apagado)
     */
    operator fun invoke(isEvacuation: Boolean): Flow<Boolean> {
        val payload = if (isEvacuation) "STATE: EVACUATE" else "STATE: DANGER"
        return staffBeaconAdvertiser.startAdvertising(payload)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/usecase/CalculateEcoMetricsUseCase.kt`

```kotlin
package com.georacing.georacing.domain.usecase

import com.georacing.georacing.domain.model.EcoMetrics
import com.georacing.georacing.infrastructure.health.HealthConnectManager

/**
 * Caso de uso que aplica las reglas de negocio de Sostenibilidad.
 * Transforma datos nativos pasivos (Health Connect) en el valor Gamificado ("CO2 Ahorrado")
 * sin usar sensores GPS en background.
 */
class CalculateEcoMetricsUseCase(
    private val healthConnectManager: HealthConnectManager
) {

    // Asumimos un coche promedio emite 120 gramos de CO2 por kil√≥metro en tr√°fico denso
    private val gramsOfCo2PerKm = 120.0

    /**
     * Genera las m√©tricas de eco consultando silenciosamente a HealthConnect.
     */
    suspend operator fun invoke(): EcoMetrics {
        val steps = healthConnectManager.getTodaySteps()
        val distanceMeters = healthConnectManager.getTodayDistanceMeters()
        
        // Si no hay permisos o no hay cuenta de distancia, podemos hacer una estimaci√≥n 
        // fallback (ej: 0.70m por paso) para que la UI nunca est√© vac√≠a.
        val effectiveDistanceMeters = if (distanceMeters == 0.0 && steps > 0) {
            steps * 0.76 // zancada promedio de un adulto en metros
        } else {
            distanceMeters
        }

        val distanceKm = effectiveDistanceMeters / 1000.0
        val co2Saved = distanceKm * gramsOfCo2PerKm

        return EcoMetrics(
            stepsWalkedToday = steps,
            distanceWalkedMeters = effectiveDistanceMeters,
            co2SavedGrams = co2Saved
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/usecases/CheckArrivalUseCase.kt`

```kotlin
package com.georacing.georacing.domain.usecases

import android.location.Location
import com.georacing.georacing.domain.models.NavigationState
import com.georacing.georacing.utils.DistanceCalculator
import org.maplibre.android.geometry.LatLng

/**
 * Use Case: Detectar cuando el usuario ha llegado al destino.
 * 
 * Criterios de llegada:
 * 1. Distancia directa al destino < 30 metros
 * 2. Velocidad < 5 km/h (pr√°cticamente detenido)
 * 3. Distancia restante de ruta < 50 metros
 */
object CheckArrivalUseCase {
    
    private const val ARRIVAL_DISTANCE_THRESHOLD = 30.0  // metros
    private const val ARRIVAL_SPEED_THRESHOLD = 1.4f      // m/s (~5 km/h)
    private const val ARRIVAL_ROUTE_DISTANCE_THRESHOLD = 50.0  // metros
    
    /**
     * Verifica si el usuario ha llegado al destino.
     * 
     * @param currentLocation Ubicaci√≥n GPS actual
     * @param currentState Estado de navegaci√≥n actual
     * @return NavigationState.Arrived si lleg√≥, null si a√∫n no
     */
    fun execute(
        currentLocation: Location,
        currentState: NavigationState.Active
    ): NavigationState.Arrived? {
        
        // Obtener destino
        val destination = currentState.route.points.lastOrNull() ?: return null
        
        // 1. Distancia directa al destino
        val directDistance = DistanceCalculator.calculateDirectDistance(
            from = currentLocation,
            to = destination
        )
        
        // 2. Velocidad actual
        val speedMps = currentLocation.speed  // m/s
        
        // 3. Distancia restante de ruta
        val routeDistance = currentState.remainingDistance
        
        android.util.Log.d(
            "CheckArrival",
            "Distance: ${directDistance}m, Speed: ${speedMps * 3.6f}km/h, Route: ${routeDistance}m"
        )
        
        // Criterio principal: distancia directa
        val arrivedByDistance = directDistance < ARRIVAL_DISTANCE_THRESHOLD
        
        // Criterio secundario: distancia de ruta (por si la directa no es precisa)
        val arrivedByRoute = routeDistance < ARRIVAL_ROUTE_DISTANCE_THRESHOLD
        
        if (arrivedByDistance || arrivedByRoute) {
            android.util.Log.i(
                "CheckArrival",
                "üéØ ARRIVED at ${currentState.destinationName}"
            )
            
            return NavigationState.Arrived(
                destinationName = currentState.destinationName
            )
        }
        
        return null  // A√∫n no ha llegado
    }
    
    /**
     * Variante que solo considera distancia directa (m√°s simple).
     * √ötil para destinos en plazas/parkings amplios.
     */
    fun executeSimple(
        currentLocation: Location,
        destination: LatLng
    ): Boolean {
        val distance = DistanceCalculator.calculateDirectDistance(
            from = currentLocation,
            to = destination
        )
        
        return distance < ARRIVAL_DISTANCE_THRESHOLD
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/usecases/ProfileGenerator.kt`

```kotlin
package com.georacing.georacing.domain.usecases

import com.georacing.georacing.domain.model.DashboardLayout
import com.georacing.georacing.domain.model.Interest
import com.georacing.georacing.domain.model.OnboardingAnswers
import com.georacing.georacing.domain.model.TransportMethod
import com.georacing.georacing.domain.model.UserType
import com.georacing.georacing.domain.model.WidgetType

class ProfileGenerator {

    fun generateDefaultLayout(answers: OnboardingAnswers): DashboardLayout {
        val widgets = mutableListOf<WidgetType>()

        // Core widgets
        widgets.add(WidgetType.METEOROLOGY)
        widgets.add(WidgetType.STATUS_CARD)

        // Interest logic - Tech
        if (answers.interests.contains(Interest.TECH)) {
            widgets.add(WidgetType.AR_ACCESS)
        }

        // Logic based on Transport
        if (answers.transportMethod == TransportMethod.CAR) {
            widgets.add(WidgetType.PARKING_INFO)
        }

        // Logic based on User Type
        when (answers.userType) {
            UserType.FAMILY -> {
                widgets.add(WidgetType.FIND_RESTROOMS)
                widgets.add(WidgetType.FOOD_OFFERS)
            }
            UserType.STAFF -> {
                widgets.add(WidgetType.STAFF_ACTIONS)
            }
            UserType.VIP -> {
                widgets.add(WidgetType.ACTIONS_GRID) // Priority actions for VIP
                if (!widgets.contains(WidgetType.FOOD_OFFERS)) {
                    widgets.add(WidgetType.FOOD_OFFERS)
                }
            }
            else -> { // FAN
                 widgets.add(WidgetType.ACTIONS_GRID)
            }
        }
        
        // Secondary interest logic
        if (answers.interests.contains(Interest.TECH) && !widgets.contains(WidgetType.ECO_METER)) {
             widgets.add(WidgetType.ECO_METER)
        }
        
        if (answers.interests.contains(Interest.FOOD) && !widgets.contains(WidgetType.FOOD_OFFERS)) {
            widgets.add(WidgetType.FOOD_OFFERS)
        }

        // Add news feed at the end usually
        widgets.add(WidgetType.NEWS_FEED)

        return DashboardLayout(widgets.distinct())
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/usecases/RecalculateRouteUseCase.kt`

```kotlin
package com.georacing.georacing.domain.usecases

import android.location.Location
import com.georacing.georacing.car.RouteRepository
import com.georacing.georacing.domain.models.NavigationState
import org.maplibre.android.geometry.LatLng

/**
 * Use Case: Recalcular ruta cuando el usuario se desv√≠a.
 * 
 * Se ejecuta cuando:
 * - OffRouteDetector confirma que estamos fuera de ruta
 * - Han pasado 30+ segundos desde el √∫ltimo c√°lculo (actualizaci√≥n por tr√°fico)
 */
object RecalculateRouteUseCase {
    
    private val routeRepository = RouteRepository()
    
    /**
     * Recalcula la ruta desde la posici√≥n actual al destino original.
     * 
     * @param currentLocation Posici√≥n GPS actual
     * @param currentState Estado de navegaci√≥n actual
     * @return Nuevo estado con ruta actualizada, o null si falla el recalculo
     */
    suspend fun execute(
        currentLocation: Location,
        currentState: NavigationState.Active
    ): NavigationState.Active? {
        // Obtener destino de la ruta actual
        val destination = currentState.route.points.lastOrNull() ?: return null
        
        android.util.Log.i(
            "RecalculateRoute",
            "Recalculando ruta desde (${currentLocation.latitude}, ${currentLocation.longitude}) a destino"
        )
        
        // Llamar al repositorio para obtener nueva ruta
        val newRoute = routeRepository.getRoute(
            origin = LatLng(currentLocation.latitude, currentLocation.longitude),
            dest = destination,
            avoidTraffic = true
        )
        
        if (newRoute == null) {
            android.util.Log.e("RecalculateRoute", "Failed to get new route")
            return null
        }
        
        android.util.Log.i(
            "RecalculateRoute",
            "Nueva ruta: ${newRoute.distance}m, ${newRoute.duration}s, ${newRoute.steps.size} steps"
        )
        
        // Resetear OffRouteDetector (ya no estamos fuera de ruta con la nueva)
        com.georacing.georacing.utils.OffRouteDetector.reset()
        
        // Resetear TTSManager para que anuncie las nuevas instrucciones
        com.georacing.georacing.utils.TTSManager.reset()
        
        // Crear nuevo estado con la ruta recalculada
        return NavigationState.Active(
            route = newRoute,
            destinationName = currentState.destinationName,
            currentStepIndex = 0,  // Volver al primer paso
            currentStep = newRoute.steps.firstOrNull() 
                ?: currentState.currentStep,  // Fallback si no hay steps
            distanceToNextManeuver = newRoute.steps.firstOrNull()?.distance ?: 0.0,
            remainingDistance = newRoute.distance,
            estimatedTimeRemaining = newRoute.duration,
            isOffRoute = false,  // Ya no estamos fuera de ruta
            closestPointIndex = 0,  // Reset
            distanceToRoute = 0.0
        )
    }
    
    /**
     * Versi√≥n simplificada que solo recalcula si han pasado X segundos.
     * √ötil para actualizaciones peri√≥dicas por tr√°fico.
     */
    suspend fun executeIfNeeded(
        currentLocation: Location,
        currentState: NavigationState.Active,
        lastRecalculationTime: Long,
        minIntervalMs: Long = 30_000L  // 30 segundos por defecto
    ): NavigationState.Active? {
        val now = System.currentTimeMillis()
        val timeSinceLastRecalc = now - lastRecalculationTime
        
        if (timeSinceLastRecalc < minIntervalMs) {
            return null  // A√∫n no toca recalcular
        }
        
        return execute(currentLocation, currentState)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/domain/usecases/UpdateLocationUseCase.kt`

```kotlin
package com.georacing.georacing.domain.usecases

import android.location.Location
import com.georacing.georacing.car.RouteResult
import com.georacing.georacing.domain.models.NavigationState
import com.georacing.georacing.utils.*

/**
 * Use Case: Actualizar estado de navegaci√≥n con nueva ubicaci√≥n GPS.
 * 
 * Este es el use case m√°s importante, se ejecuta cada vez que
 * llega un update del GPS (t√≠picamente cada 1 segundo).
 * 
 * Responsabilidades:
 * 1. Hacer snap de la posici√≥n a la ruta
 * 2. Calcular distancia restante
 * 3. Calcular ETA proporcional
 * 4. Detectar paso actual
 * 5. Detectar si est√° fuera de ruta
 * 6. Actualizar NavigationState.Active
 */
object UpdateLocationUseCase {
    
    /**
     * FASE 3: Factor de tr√°fico para ajustar ETA.
     * 
     * Valor por defecto: 1.0 (sin ajuste de tr√°fico)
     * - 1.0 = sin tr√°fico
     * - 1.2 = tr√°fico moderado (+20%)
     * - 1.5 = tr√°fico intenso (+50%)
     * 
     * TODO FASE 3: Reemplazar con TrafficProvider real
     */
    private var trafficFactor: Double = 1.0
    
    /**
     * Establece el factor de tr√°fico global.
     * FASE 3: Este m√©todo ser√° llamado por NavigationManager cuando haya datos de tr√°fico.
     * 
     * @param factor Factor de tr√°fico (1.0 = sin cambios, >1.0 = m√°s lento)
     */
    fun setTrafficFactor(factor: Double) {
        trafficFactor = factor.coerceIn(0.5, 3.0)
    }
    
    /**
     * Ejecuta el update de ubicaci√≥n.
     * 
     * @param newLocation Nueva posici√≥n GPS
     * @param currentState Estado actual de navegaci√≥n
     * @return Nuevo estado actualizado (o el mismo si no hay cambios)
     */
    fun execute(
        newLocation: Location,
        currentState: NavigationState
    ): NavigationState {
        // Solo procesar si estamos en navegaci√≥n activa
        if (currentState !is NavigationState.Active) {
            return currentState
        }
        
        val route = currentState.route
        
        // 1. SNAP TO ROUTE
        val snapResult = if (currentState.closestPointIndex > 0) {
            // Optimizaci√≥n: buscar solo cerca del √∫ltimo punto conocido
            RouteSnapper.snapToRouteOptimized(
                currentLocation = newLocation,
                routePoints = route.points,
                lastKnownIndex = currentState.closestPointIndex,
                searchRadius = 50
            )
        } else {
            // Primera vez: buscar en toda la ruta
            RouteSnapper.snapToRoute(
                currentLocation = newLocation,
                routePoints = route.points
            )
        }
        
        // 2. CALCULAR DISTANCIA RESTANTE
        val remainingDistance = DistanceCalculator.calculateRemainingDistance(
            snapResult = snapResult,
            routePoints = route.points
        )
        
        // 3. CALCULAR ETA (PROPORCIONAL CON FACTOR DE TR√ÅFICO - FASE 3)
        val estimatedTimeRemaining = ETACalculator.calculateRemainingTimeWithTraffic(
            remainingDistance = remainingDistance,
            totalDistance = route.distance,
            totalDuration = route.duration,
            trafficFactor = trafficFactor  // FASE 3: Actualmente 1.0 (placeholder)
        )
        
        // 4. DETECTAR PASO ACTUAL
        val stepInfo = StepDetector.findCurrentStep(
            snapResult = snapResult,
            route = route
        )
        
        // 5. CHECK OFF-ROUTE
        val isOffRoute = OffRouteDetector.checkOffRoute(
            location = newLocation,
            snapResult = snapResult
        )
        
        // 6. CONSTRUIR NUEVO ESTADO
        return currentState.copy(
            currentStepIndex = stepInfo.index,
            currentStep = stepInfo.step,
            distanceToNextManeuver = stepInfo.distanceToManeuver,
            remainingDistance = remainingDistance,
            estimatedTimeRemaining = estimatedTimeRemaining,
            isOffRoute = isOffRoute,
            closestPointIndex = snapResult.closestIndex,
            distanceToRoute = snapResult.distanceToRoute
        )
    }
    
    /**
     * Helper para determinar si debemos avanzar al siguiente paso.
     * Se llama despu√©s de execute() para detectar cambios de paso.
     */
    fun shouldAdvanceToNextStep(state: NavigationState.Active): Boolean {
        // Si estamos a menos de 20m de la maniobra, consideramos que ya la ejecutamos
        return state.distanceToNextManeuver < 20.0 &&
                state.currentStepIndex < state.route.steps.size - 1
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/feature/navigation/routing/algorithm/PedestrianPathfinder.kt`

```kotlin
package com.georacing.georacing.feature.navigation.routing.algorithm

import com.georacing.georacing.feature.navigation.routing.models.CircuitEdge
import com.georacing.georacing.feature.navigation.routing.models.CircuitNode
import com.georacing.georacing.feature.navigation.routing.models.RoutePreference
import java.util.PriorityQueue
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.sqrt

/**
 * Motor de enrutamiento A* (A-Star) modificado para "Seguridad Industrial".
 * Permite calcular la ruta m√°s corta (cl√°sica) o la ruta m√°s fresca (t√©rmica)
 * bas√°ndose en variables ambientales offline.
 */
class PedestrianPathfinder(
    private val nodes: Map<String, CircuitNode>,
    private val edges: List<CircuitEdge>
) {
    // Mapa de adyacencia: NodeId -> Lista de Aristas que salen de √©l
    private val graph: Map<String, List<CircuitEdge>> = edges.groupBy { it.source }

    /**
     * Calcula el "Peso T√©rmico" de un tramo.
     * Si la temperatura es extrema y el usuario pide sombra, penalizamos 
     * exponencialmente los tramos de asfalto y sin protecci√≥n solar.
     */
    fun calculateEdgeCost(
        edge: CircuitEdge,
        preference: RoutePreference,
        currentTemperature: Float
    ): Float {
        val baseDistance = edge.distanceMeters

        if (preference == RoutePreference.FASTEST) {
            return baseDistance // Comportamiento Dijkstra cl√°sico puro
        }

        // Si es COOLEST, aplicamos la Regla de Negocio
        if (currentTemperature > 28.0f) {
            // Factor base: si hay 0% sombra (shadeFactor=0), la penalizaci√≥n t√©rmica es m√°xima.
            // Si shadeFactor=1 (100% sombra), la penalizaci√≥n t√©rmica es cero.
            val sunExposurePenalty = 1.0f - edge.shadeFactor
            
            // Incrementamos x3 o x5 seg√∫n la exposici√≥n y tipo de suelo
            // (10 metros al sol pueden "sentirse" como 50 metros para el algoritmo)
            val thermalMultiplier = 1.0f + (sunExposurePenalty * 4.0f) * edge.surfaceType.thermalMultiplier
            
            return baseDistance * thermalMultiplier
        }

        // Si la temperatura es agradable, la preferencia t√©rmica es casi igual a la de distancia
        return baseDistance
    }

    /**
     * Heur√≠stica para A* (Distancia en l√≠nea recta - Haversine).
     */
    private fun heuristic(nodeId1: String, nodeId2: String): Float {
        val n1 = nodes[nodeId1] ?: return Float.MAX_VALUE
        val n2 = nodes[nodeId2] ?: return Float.MAX_VALUE
        return calculateHaversineDistance(n1.latitude, n1.longitude, n2.latitude, n2.longitude)
    }

    /**
     * Ejecuta el Algoritmo A*.
     * @return Una lista en orden de los ID de las aristas que forman la ruta √≥ptima.
     * Retorna lista vac√≠a si no hay ruta.
     */
    fun findRoute(
        startId: String,
        targetId: String,
        preference: RoutePreference,
        currentTemperature: Float
    ): List<CircuitEdge> {
        if (!nodes.containsKey(startId) || !nodes.containsKey(targetId)) return emptyList()

        // Costes G: Coste real acumulado desde el inicio hasta un nodo
        val gScores = mutableMapOf<String, Float>().withDefault { Float.MAX_VALUE }
        gScores[startId] = 0f

        // Registro del camino (qui√©n visit√≥ a qui√©n a trav√©s de qu√© arista)
        val cameFrom = mutableMapOf<String, CircuitEdge>()

        // Cola de prioridad basada en el F-Score (G-Score + Heur√≠stica)
        val openSet = PriorityQueue<Pair<String, Float>>(compareBy { it.second })
        openSet.add(Pair(startId, heuristic(startId, targetId)))

        // Para evitar revisitar nodos de forma ineficiente
        val closedSet = mutableSetOf<String>()

        while (openSet.isNotEmpty()) {
            val (currentId, _) = openSet.poll()

            // ¬°Meta encontrada! Reconstruir el camino desde atr√°s
            if (currentId == targetId) {
                return reconstructPath(cameFrom, currentId)
            }

            if (!closedSet.add(currentId)) continue

            val neighbors = graph[currentId] ?: emptyList()
            for (edge in neighbors) {
                val neighborId = edge.destination
                if (closedSet.contains(neighborId)) continue

                val tentativeGScore = gScores.getValue(currentId) + 
                                      calculateEdgeCost(edge, preference, currentTemperature)

                if (tentativeGScore < gScores.getValue(neighborId)) {
                    cameFrom[neighborId] = edge
                    gScores[neighborId] = tentativeGScore
                    
                    val fScore = tentativeGScore + heuristic(neighborId, targetId)
                    openSet.add(Pair(neighborId, fScore))
                }
            }
        }
        return emptyList() // No se encontr√≥ camino
    }

    private fun reconstructPath(cameFrom: Map<String, CircuitEdge>, currentId: String): List<CircuitEdge> {
        val path = mutableListOf<CircuitEdge>()
        var curr = currentId
        while (cameFrom.containsKey(curr)) {
            val edge = cameFrom[curr]!!
            path.add(edge)
            curr = edge.source
        }
        path.reverse()
        return path
    }

    // F√≥rmula Haversine para distancia en metros
    private fun calculateHaversineDistance(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Float {
        val R = 6371e3 // Radio de la tierra en metros
        val phi1 = Math.toRadians(lat1)
        val phi2 = Math.toRadians(lat2)
        val deltaPhi = Math.toRadians(lat2 - lat1)
        val deltaLambda = Math.toRadians(lon2 - lon1)

        val a = sin(deltaPhi / 2) * sin(deltaPhi / 2) +
                cos(phi1) * cos(phi2) *
                sin(deltaLambda / 2) * sin(deltaLambda / 2)
        val c = 2 * atan2(sqrt(a), sqrt(1 - a))

        return (R * c).toFloat()
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/feature/navigation/routing/domain/FindPedestrianRouteUseCase.kt`

```kotlin
package com.georacing.georacing.feature.navigation.routing.domain

import com.georacing.georacing.feature.navigation.routing.algorithm.PedestrianPathfinder
import com.georacing.georacing.feature.navigation.routing.models.CircuitEdge
import com.georacing.georacing.feature.navigation.routing.models.RoutePreference
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * Caso de Uso que encapsula y expone la solicitud de ruta desde el ViewModel.
 * Recopila la temperatura, la preferencia e inyecta esto al Pathfinder.
 */
class FindPedestrianRouteUseCase(
    private val pathfinder: PedestrianPathfinder
    // Injectar√≠amos aqu√≠ un WeatherRepository offline (BLE o cach√©)
) {
    /**
     * Calcula de forma as√≠ncrona la mejor ruta seg√∫n las variables t√©rmicas.
     * En un entorno real `currentTemperature` vendr√≠a del repo del clima.
     */
    suspend operator fun invoke(
        startNodeId: String,
        targetNodeId: String,
        preference: RoutePreference,
        currentTemperature: Float // Simulamos 32.0C en horas puntas de Julio
    ): List<CircuitEdge> = withContext(Dispatchers.Default) {
        
        pathfinder.findRoute(
            startId = startNodeId,
            targetId = targetNodeId,
            preference = preference,
            currentTemperature = currentTemperature
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/feature/navigation/routing/models/CircuitGraph.kt`

```kotlin
package com.georacing.georacing.feature.navigation.routing.models

/**
 * Nodo del grafo que representa un punto en el Circuito (intersecciones).
 */
data class CircuitNode(
    val id: String,
    val latitude: Double,
    val longitude: Double
)

/**
 * Arista del grafo (un camino entre dos Nodos).
 */
data class CircuitEdge(
    val id: String,
    val source: String,       // ID del nodo origen
    val destination: String,  // ID del nodo destino
    val distanceMeters: Float, // Coste base (Kruskal/Dijkstra cl√°sico)
    // --- Variables T√©rmicas/Industriales ---
    val surfaceType: SurfaceType = SurfaceType.ASPHALT,
    /**
     * Nivel de protecci√≥n solar (0.0 = pleno sol ardiente, 1.0 = toldo/interior refrigerado).
     */
    val shadeFactor: Float = 0.0f 
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/feature/navigation/routing/models/RoutePreference.kt`

```kotlin
package com.georacing.georacing.feature.navigation.routing.models

/**
 * Las posibles preferencias que un peat√≥n puede seleccionar en su ruta.
 */
enum class RoutePreference {
    /** 
     * Minimiza la distancia sin importar el sol (Comportamiento cl√°sico). 
     */
    FASTEST,
    
    /** 
     * Minimiza la exposici√≥n solar aplicando grandes penalizaciones a 
     * tramos descubiertos cuando hace calor, priorizando rutas m√°s largas 
     * pero por la sombra de las tribunas/√°rboles.
     */
    COOLEST
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/feature/navigation/routing/models/SurfaceType.kt`

```kotlin
package com.georacing.georacing.feature.navigation.routing.models

/**
 * Tipos de superficie por las que puede caminar un usuario.
 * Afecta directamente la retenci√≥n t√©rmica (y el cansancio).
 */
enum class SurfaceType(val thermalMultiplier: Float) {
    ASPHALT(1.5f),   // El asfalto irradia calor (m√°s penalizaci√≥n)
    CONCRETE(1.2f),  // Hormig√≥n, algo mejor que el asfalto oscuro
    GRAVEL(1.0f),    // Grava/Tierra compactada (neutro)
    GRASS(0.8f)      // C√©sped/Tierra natural (agradable t√©rmicamente)
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/features/ar/AREnhancedOverlay.kt`

```kotlin
package com.georacing.georacing.features.ar

import android.graphics.Paint
import android.graphics.RectF
import android.hardware.SensorManager
import android.location.Location
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.unit.dp
import com.georacing.georacing.car.PoiModel
import com.georacing.georacing.car.PoiType
import kotlin.math.abs
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin

/**
 * Overlay AR mejorado con:
 *
 * 1. Indicador de calibraci√≥n de br√∫jula (barra de precisi√≥n)
 * 2. Marcadores POI por categor√≠a con colores e iconos
 * 3. Escala de tama√±o seg√∫n distancia (m√°s cerca = m√°s grande)
 * 4. Flecha de navegaci√≥n al siguiente waypoint
 * 5. Br√∫jula mini en esquina superior
 * 6. Etiquetas con info de distancia y zona
 */
object AREnhancedOverlay {

    // ‚îÄ‚îÄ Colores por tipo de POI ‚îÄ‚îÄ
    private val poiColors = mapOf<PoiType, Color>(
        PoiType.PARKING to Color(0xFF9C27B0),
        PoiType.GATE to Color(0xFF4CAF50),
        PoiType.FANZONE to Color(0xFFFF9800),
        PoiType.SERVICE to Color(0xFF2196F3),
        PoiType.MEDICAL to Color(0xFFF44336),
        PoiType.OTHER to Color(0xFF00BCD4)
    )

    private val poiEmojis = mapOf<PoiType, String>(
        PoiType.PARKING to "üÖøÔ∏è",
        PoiType.GATE to "üö™",
        PoiType.FANZONE to "üéâ",
        PoiType.SERVICE to "üîß",
        PoiType.MEDICAL to "üè•",
        PoiType.OTHER to "üìç"
    )

    // ‚îÄ‚îÄ Par√°metros ‚îÄ‚îÄ
    private const val FOV_HORIZONTAL = 60.0
    private const val FOV_VERTICAL = 45.0
    private const val MAX_DISTANCE = 500f
    private const val MIN_MARKER_SIZE = 40f
    private const val MAX_MARKER_SIZE = 100f

    // ‚îÄ‚îÄ Renderizado principal ‚îÄ‚îÄ

    @Composable
    fun EnhancedOverlay(
        pois: List<PoiModel>,
        userLocation: Location,
        azimuth: Float,
        pitch: Float,
        compassAccuracy: Int, // SensorManager.SENSOR_STATUS_*
        navigationTarget: PoiModel? = null // POI destino para flecha
    ) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            val w = size.width
            val h = size.height

            // 1. Crosshair mejorado
            drawEnhancedCrosshair(w, h)

            // 2. POI markers
            var visibleCount = 0
            pois.forEach { poi ->
                if (visibleCount >= 15) return@forEach

                val result = calculateScreenPosition(userLocation, poi, azimuth, pitch)
                if (result.isVisible && result.distance < MAX_DISTANCE) {
                    visibleCount++
                    drawPoiMarker(
                        poi = poi,
                        x = result.x * w,
                        y = result.y * h,
                        distance = result.distance,
                        w = w, h = h
                    )
                }
            }

            // 3. Flecha de navegaci√≥n al destino
            if (navigationTarget != null) {
                drawNavigationArrow(userLocation, navigationTarget, azimuth, w, h)
            }

            // 4. Mini br√∫jula
            drawMiniCompass(azimuth, w)

            // 5. Indicador de calibraci√≥n
            drawCalibrationIndicator(compassAccuracy, w, h)

            // 6. Info bar inferior
            drawInfoBar(visibleCount, pois.size, w, h)
        }
    }

    // ‚îÄ‚îÄ Dibujar POI marker mejorado ‚îÄ‚îÄ

    private fun DrawScope.drawPoiMarker(
        poi: PoiModel,
        x: Float, y: Float,
        distance: Float,
        w: Float, h: Float
    ) {
        val color = poiColors[poi.type] ?: Color.Green
        val emoji = poiEmojis[poi.type] ?: "üìç"

        // Escala inversamente proporcional a la distancia
        val scale = ((1f - (distance / MAX_DISTANCE)) * 0.7f + 0.3f).coerceIn(0.3f, 1f)
        val markerSize = MIN_MARKER_SIZE + (MAX_MARKER_SIZE - MIN_MARKER_SIZE) * scale

        // L√≠nea vertical desde la base
        drawLine(
            color = color,
            start = Offset(x, y),
            end = Offset(x, y - markerSize * 0.6f),
            strokeWidth = (2f * scale).dp.toPx()
        )

        // C√≠rculo marcador
        drawCircle(
            color = color,
            radius = (markerSize * 0.25f).dp.toPx() / 3,
            center = Offset(x, y - markerSize * 0.6f)
        )

        // Borde del c√≠rculo
        drawCircle(
            color = Color.White,
            radius = (markerSize * 0.25f).dp.toPx() / 3,
            center = Offset(x, y - markerSize * 0.6f),
            style = androidx.compose.ui.graphics.drawscope.Stroke(width = 1.5.dp.toPx())
        )

        // Texto: nombre + distancia
        val textPaint = Paint().apply {
            this.color = android.graphics.Color.WHITE
            textSize = (12f * scale + 8f)
            textAlign = Paint.Align.CENTER
            isFakeBoldText = true
            setShadowLayer(4f, 0f, 2f, android.graphics.Color.BLACK)
        }

        val distText = when {
            distance < 100 -> "${distance.toInt()}m"
            else -> "${"%.1f".format(distance / 1000)}km"
        }
        val labelText = "${poi.name} ‚Ä¢ $distText"

        // Fondo del label
        val textWidth = textPaint.measureText(labelText)
        val bgPaint = Paint().apply {
            this.color = android.graphics.Color.argb(180, 0, 0, 0)
            style = Paint.Style.FILL
        }

        val labelY = y - markerSize * 0.8f
        val rect = RectF(
            x - textWidth / 2 - 12, labelY - 28,
            x + textWidth / 2 + 12, labelY + 8
        )
        drawContext.canvas.nativeCanvas.drawRoundRect(rect, 8f, 8f, bgPaint)

        // Barra de color superior
        val colorBarPaint = Paint().apply {
            this.color = color.toArgb()
            style = Paint.Style.FILL
        }
        drawContext.canvas.nativeCanvas.drawRoundRect(
            RectF(rect.left, rect.top, rect.right, rect.top + 4),
            8f, 8f, colorBarPaint
        )

        // Texto
        drawContext.canvas.nativeCanvas.drawText(labelText, x, labelY, textPaint)
    }

    // ‚îÄ‚îÄ Crosshair mejorado ‚îÄ‚îÄ

    private fun DrawScope.drawEnhancedCrosshair(w: Float, h: Float) {
        val cx = w / 2
        val cy = h / 2
        val lineLen = 25.dp.toPx()
        val gap = 5.dp.toPx()
        val color = Color.Green.copy(alpha = 0.6f)

        // 4 l√≠neas con gap central
        drawLine(color, Offset(cx - lineLen - gap, cy), Offset(cx - gap, cy), 1.5.dp.toPx())
        drawLine(color, Offset(cx + gap, cy), Offset(cx + lineLen + gap, cy), 1.5.dp.toPx())
        drawLine(color, Offset(cx, cy - lineLen - gap), Offset(cx, cy - gap), 1.5.dp.toPx())
        drawLine(color, Offset(cx, cy + gap), Offset(cx, cy + lineLen + gap), 1.5.dp.toPx())

        // Punto central
        drawCircle(color, 2.dp.toPx(), Offset(cx, cy))
    }

    // ‚îÄ‚îÄ Flecha de navegaci√≥n ‚îÄ‚îÄ

    private fun DrawScope.drawNavigationArrow(
        userLocation: Location,
        target: PoiModel,
        azimuth: Float,
        w: Float, h: Float
    ) {
        val targetLoc = Location("").apply {
            latitude = target.latitude
            longitude = target.longitude
        }

        val bearing = userLocation.bearingTo(targetLoc)
        val distance = userLocation.distanceTo(targetLoc)

        val normalizedBearing = (bearing + 360) % 360
        var delta = normalizedBearing - azimuth
        if (delta > 180) delta -= 360
        if (delta < -180) delta += 360

        // Si el target no est√° en FOV, mostrar flecha en el borde
        if (abs(delta) > FOV_HORIZONTAL / 2) {
            val arrowX = if (delta > 0) w - 60.dp.toPx() else 60.dp.toPx()
            val arrowY = h / 2

            // Tri√°ngulo flecha
            val arrowSize = 20.dp.toPx()
            val path = androidx.compose.ui.graphics.Path().apply {
                if (delta > 0) {
                    moveTo(arrowX + arrowSize, arrowY)
                    lineTo(arrowX - arrowSize / 2, arrowY - arrowSize)
                    lineTo(arrowX - arrowSize / 2, arrowY + arrowSize)
                } else {
                    moveTo(arrowX - arrowSize, arrowY)
                    lineTo(arrowX + arrowSize / 2, arrowY - arrowSize)
                    lineTo(arrowX + arrowSize / 2, arrowY + arrowSize)
                }
                close()
            }
            drawPath(path, Color(0xFF00D9FF))

            // Texto distancia
            val arrowPaint = Paint().apply {
                color = android.graphics.Color.WHITE
                textSize = 32f
                textAlign = if (delta > 0) Paint.Align.RIGHT else Paint.Align.LEFT
                setShadowLayer(4f, 0f, 0f, android.graphics.Color.BLACK)
            }
            val distStr = if (distance < 100) "${distance.toInt()}m" else "${"%.0f".format(distance)}m"
            drawContext.canvas.nativeCanvas.drawText(
                "‚Üí ${target.name} $distStr",
                if (delta > 0) arrowX - 10 else arrowX + 10,
                arrowY + arrowSize + 30,
                arrowPaint
            )
        }
    }

    // ‚îÄ‚îÄ Mini br√∫jula ‚îÄ‚îÄ

    private fun DrawScope.drawMiniCompass(azimuth: Float, w: Float) {
        val cx = w - 50.dp.toPx()
        val cy = 60.dp.toPx()
        val radius = 25.dp.toPx()

        // Fondo circular
        drawCircle(Color.Black.copy(alpha = 0.5f), radius, Offset(cx, cy))
        drawCircle(
            Color.Green.copy(alpha = 0.3f), radius, Offset(cx, cy),
            style = androidx.compose.ui.graphics.drawscope.Stroke(1.5.dp.toPx())
        )

        // Aguja norte
        val northAngle = Math.toRadians((-azimuth).toDouble())
        val needleLen = radius * 0.7f
        val nx = cx + (sin(northAngle) * needleLen).toFloat()
        val ny = cy - (cos(northAngle) * needleLen).toFloat()

        drawLine(Color.Red, Offset(cx, cy), Offset(nx, ny), 2.dp.toPx())

        // Aguja sur (m√°s corta)
        val sx = cx - (sin(northAngle) * needleLen * 0.5).toFloat()
        val sy = cy + (cos(northAngle) * needleLen * 0.5).toFloat()
        drawLine(Color.White.copy(alpha = 0.5f), Offset(cx, cy), Offset(sx, sy), 1.dp.toPx())

        // Etiqueta N
        val nPaint = Paint().apply {
            color = android.graphics.Color.RED
            textSize = 22f
            textAlign = Paint.Align.CENTER
            isFakeBoldText = true
        }
        drawContext.canvas.nativeCanvas.drawText("N", nx, ny - 8, nPaint)

        // Grados
        val degPaint = Paint().apply {
            color = android.graphics.Color.GREEN
            textSize = 20f
            textAlign = Paint.Align.CENTER
        }
        drawContext.canvas.nativeCanvas.drawText("${azimuth.toInt()}¬∞", cx, cy + radius + 20, degPaint)
    }

    // ‚îÄ‚îÄ Indicador de calibraci√≥n ‚îÄ‚îÄ

    private fun DrawScope.drawCalibrationIndicator(accuracy: Int, w: Float, h: Float) {
        val label = when (accuracy) {
            SensorManager.SENSOR_STATUS_ACCURACY_HIGH -> "Calibraci√≥n: Alta"
            SensorManager.SENSOR_STATUS_ACCURACY_MEDIUM -> "Calibraci√≥n: Media"
            SensorManager.SENSOR_STATUS_ACCURACY_LOW -> "‚ö†Ô∏è Calibraci√≥n: Baja"
            SensorManager.SENSOR_STATUS_UNRELIABLE -> "‚ùå Calibraci√≥n: No fiable"
            else -> "Calibrando..."
        }
        val color = when (accuracy) {
            SensorManager.SENSOR_STATUS_ACCURACY_HIGH -> Color(0xFF4CAF50)
            SensorManager.SENSOR_STATUS_ACCURACY_MEDIUM -> Color(0xFFFF9800)
            SensorManager.SENSOR_STATUS_ACCURACY_LOW -> Color(0xFFFF5722)
            else -> Color(0xFFF44336)
        }

        // Barra en la parte superior
        val barWidth = w * when (accuracy) {
            SensorManager.SENSOR_STATUS_ACCURACY_HIGH -> 1f
            SensorManager.SENSOR_STATUS_ACCURACY_MEDIUM -> 0.65f
            SensorManager.SENSOR_STATUS_ACCURACY_LOW -> 0.35f
            else -> 0.15f
        }
        drawRect(color=color.copy(alpha = 0.8f), topLeft=Offset(0f, 0f), size=androidx.compose.ui.geometry.Size(barWidth, 4.dp.toPx()))

        // Texto
        if (accuracy < SensorManager.SENSOR_STATUS_ACCURACY_MEDIUM) {
            val paint = Paint().apply {
                this.color = color.toArgb()
                textSize = 28f
                textAlign = Paint.Align.LEFT
                setShadowLayer(3f, 0f, 0f, android.graphics.Color.BLACK)
            }
            drawContext.canvas.nativeCanvas.drawText(label, 16f, 30f, paint)

            if (accuracy <= SensorManager.SENSOR_STATUS_ACCURACY_LOW) {
                val hintPaint = Paint().apply {
                    this.color = android.graphics.Color.WHITE
                    textSize = 22f
                    textAlign = Paint.Align.LEFT
                    setShadowLayer(3f, 0f, 0f, android.graphics.Color.BLACK)
                }
                drawContext.canvas.nativeCanvas.drawText(
                    "Mueve el m√≥vil en forma de 8 para calibrar",
                    16f, 56f, hintPaint
                )
            }
        }
    }

    // ‚îÄ‚îÄ Info bar inferior ‚îÄ‚îÄ

    private fun DrawScope.drawInfoBar(visible: Int, total: Int, w: Float, h: Float) {
        val bgPaint = Paint().apply {
            color = android.graphics.Color.argb(120, 0, 0, 0)
            style = Paint.Style.FILL
        }
        drawContext.canvas.nativeCanvas.drawRect(0f, h - 40.dp.toPx(), w, h, bgPaint)

        val textPaint = Paint().apply {
            color = android.graphics.Color.GREEN
            textSize = 24f
            textAlign = Paint.Align.LEFT
        }
        drawContext.canvas.nativeCanvas.drawText(
            "AR POIs: $visible/$total visibles ‚Ä¢ FOV ${FOV_HORIZONTAL.toInt()}¬∞",
            16f, h - 15.dp.toPx(), textPaint
        )
    }

    // ‚îÄ‚îÄ C√°lculo de posici√≥n ‚îÄ‚îÄ

    private data class PosResult(
        val x: Float, val y: Float,
        val isVisible: Boolean, val distance: Float
    )

    private fun calculateScreenPosition(
        userLocation: Location,
        poi: PoiModel,
        azimuth: Float,
        pitch: Float
    ): PosResult {
        val poiLoc = Location("POI").apply {
            latitude = poi.latitude; longitude = poi.longitude
        }
        val distance = userLocation.distanceTo(poiLoc)
        if (distance > MAX_DISTANCE) return PosResult(0f, 0f, false, distance)

        val bearing = userLocation.bearingTo(poiLoc)
        val normalizedBearing = (bearing + 360) % 360
        var delta = normalizedBearing - azimuth
        if (delta > 180) delta -= 360
        if (delta < -180) delta += 360

        if (abs(delta) > FOV_HORIZONTAL / 2) {
            return PosResult(0f, 0f, false, distance)
        }

        val x = (0.5f + (delta / FOV_HORIZONTAL)).toFloat()
        val y = (0.5f + (pitch / FOV_VERTICAL)).toFloat().coerceIn(0.1f, 0.9f)

        return PosResult(x, y, true, distance)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/features/ar/QRCodePositioningManager.kt`

```kotlin
package com.georacing.georacing.features.ar

import android.content.Context
import android.util.Log
import android.widget.Toast
import androidx.camera.core.ImageProxy
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.barcode.common.Barcode
import com.google.mlkit.vision.common.InputImage
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

object QRCodePositioningManager {
    private const val TAG = "QRCodePositioning"
    private const val QR_PREFIX = "GEO:" // Payload format: GEO:lat,lon,id

    @androidx.annotation.OptIn(androidx.camera.core.ExperimentalGetImage::class)
    fun processImage(
        imageProxy: ImageProxy,
        context: Context,
        onLocationRecalibrated: (Double, Double, String) -> Unit
    ) {
        val mediaImage = imageProxy.image
        if (mediaImage != null) {
            val image = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)
            val scanner = BarcodeScanning.getClient()

            scanner.process(image)
                .addOnSuccessListener { barcodes ->
                    for (barcode in barcodes) {
                        handleBarcode(barcode, context, onLocationRecalibrated)
                    }
                }
                .addOnFailureListener {
                    Log.e(TAG, "QR Scan failed", it)
                }
                .addOnCompleteListener {
                    // Must close imageProxy to allow next frame
                    imageProxy.close()
                }
        } else {
            imageProxy.close()
        }
    }

    private fun handleBarcode(
        barcode: Barcode,
        context: Context,
        onLocationRecalibrated: (Double, Double, String) -> Unit
    ) {
        val rawValue = barcode.rawValue ?: return

        if (rawValue.startsWith(QR_PREFIX)) {
            // Parse Payload: GEO:41.56,2.26,GATE_1
            try {
                val content = rawValue.removePrefix(QR_PREFIX)
                val parts = content.split(",")
                if (parts.size >= 2) {
                    val lat = parts[0].toDouble()
                    val lon = parts[1].toDouble()
                    val id = if (parts.size > 2) parts[2] else "FIX_POINT"

                    Log.i(TAG, "QR Positioning Match: $lat, $lon ($id)")

                    // In a real app, you would inject this into LocationRepository
                    onLocationRecalibrated(lat, lon, id)

                    CoroutineScope(Dispatchers.Main).launch {
                        Toast.makeText(context, "üìç Ubicaci√≥n Recalibrada: $id", Toast.LENGTH_LONG).show()
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Invalid GEO QR format", e)
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/infrastructure/ble/BleCommandService.kt`

```kotlin
package com.georacing.georacing.infrastructure.ble

import android.Manifest
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothManager
import android.bluetooth.le.AdvertiseCallback
import android.bluetooth.le.AdvertiseData
import android.bluetooth.le.AdvertiseSettings
import android.bluetooth.le.BluetoothLeAdvertiser
import android.content.Context
import android.content.pm.PackageManager
import android.os.Handler
import android.os.Looper
import android.os.ParcelUuid
import android.util.Log
import androidx.core.app.ActivityCompat
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.util.UUID

class BleCommandService(private val context: Context) {

    private val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
    private val adapter: BluetoothAdapter? = bluetoothManager.adapter
    private var advertiser: BluetoothLeAdvertiser? = null

    private val _isAdvertising = MutableStateFlow(false)
    val isAdvertising = _isAdvertising.asStateFlow()

    private val handler = Handler(Looper.getMainLooper())
    private val stopRunnable = Runnable { stopAdvertising() }

    companion object {
        private const val TAG = "BleCommandService"
        private const val MANUFACTURER_ID = 0x1234 // Example ID for GeoRacing Beacons
        
        // Commands
        const val CMD_NORMAL = 0x00
        const val CMD_EVACUATE = 0x01
        const val CMD_DANGER = 0x02
        
        private const val TIMEOUT_MS = 30_000L // 30 seconds safety timeout
    }

    fun startAdvertising(commandId: Int) {
        if (adapter == null || !adapter.isEnabled) {
            Log.e(TAG, "Bluetooth not enabled")
            return
        }

        advertiser = adapter.bluetoothLeAdvertiser
        if (advertiser == null) {
            Log.e(TAG, "BLE Advertising not supported on this device")
            return
        }

        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.BLUETOOTH_ADVERTISE) != PackageManager.PERMISSION_GRANTED) {
            Log.e(TAG, "Missing BLUETOOTH_ADVERTISE permission")
            return
        }

        // Stop any previous session
        stopAdvertising()

        val settings = AdvertiseSettings.Builder()
            .setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY) // High priority
            .setTxPowerLevel(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH)
            .setConnectable(false)
            .build()

        // Payload: [0xFF, commandId] 
        // 0xFF often used as a custom preamble or just data
        val payload = byteArrayOf(0xFF.toByte(), commandId.toByte())

        val data = AdvertiseData.Builder()
            .setIncludeDeviceName(false)
            .addManufacturerData(MANUFACTURER_ID, payload)
            .build()

        advertiser?.startAdvertising(settings, data, advertiseCallback)
        
        // Auto-stop safety timer
        handler.postDelayed(stopRunnable, TIMEOUT_MS)
    }

    fun stopAdvertising() {
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.BLUETOOTH_ADVERTISE) == PackageManager.PERMISSION_GRANTED) {
            advertiser?.stopAdvertising(advertiseCallback)
        }
        _isAdvertising.value = false
        handler.removeCallbacks(stopRunnable)
        Log.d(TAG, "Advertising stopped")
    }

    private val advertiseCallback = object : AdvertiseCallback() {
        override fun onStartSuccess(settingsInEffect: AdvertiseSettings?) {
            Log.i(TAG, "BLE Broadcasting started successfully. Command active.")
            _isAdvertising.value = true
        }

        override fun onStartFailure(errorCode: Int) {
            Log.e(TAG, "BLE Broadcasting failed: error $errorCode")
            _isAdvertising.value = false
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/infrastructure/ble/StaffBeaconAdvertiser.kt`

```kotlin
package com.georacing.georacing.infrastructure.ble

import android.annotation.SuppressLint
import android.bluetooth.BluetoothManager
import android.bluetooth.le.AdvertiseCallback
import android.bluetooth.le.AdvertiseData
import android.bluetooth.le.AdvertiseSettings
import android.bluetooth.le.BluetoothLeAdvertiser
import android.content.Context
import android.os.ParcelUuid
import android.util.Log
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import java.util.UUID

/**
 * Emisor BLE nativo para la "Infraestructura Din√°mica" (Staff Beacon).
 * Permite convertir el m√≥vil del guardia de seguridad en una baliza emisora
 * en caso de emergencia, a m√°xima potencia y baja latencia.
 */
class StaffBeaconAdvertiser(private val context: Context) {

    private val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
    private val bluetoothAdapter = bluetoothManager.adapter
    private val advertiser: BluetoothLeAdvertiser?
        get() = bluetoothAdapter?.bluetoothLeAdvertiser

    companion object {
        // UUID de servicio espec√≠fico para identificar balizas humanas de GeoRacing (formato Hex est√°ndar)
        val GEORACING_EMERGENCY_UUID: UUID = UUID.fromString("c3084c18-0000-1000-8000-00805f9b34fb")
    }

    /**
     * Inicia la emisi√≥n BLE con el payload indicado y devuelve un Flow
     * para monitorizar el estado (true = emitiendo, false = error o detenido).
     */
    @SuppressLint("MissingPermission") // Asumimos permisos validados por la UI/UseCase
    fun startAdvertising(payload: String): Flow<Boolean> = callbackFlow {
        if (advertiser == null || bluetoothAdapter?.isEnabled == false) {
            trySend(false)
            close()
            return@callbackFlow
        }

        val settings = AdvertiseSettings.Builder()
            .setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY)
            .setTxPowerLevel(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH)
            .setConnectable(false)
            .build()

        val pUuid = ParcelUuid(GEORACING_EMERGENCY_UUID)
        val data = AdvertiseData.Builder()
            .addServiceUuid(pUuid)
            .addServiceData(pUuid, payload.toByteArray(Charsets.UTF_8))
            .setIncludeDeviceName(false)
            .build()

        val callback = object : AdvertiseCallback() {
            override fun onStartSuccess(settingsInEffect: AdvertiseSettings?) {
                super.onStartSuccess(settingsInEffect)
                Log.d("StaffBeacon", "BLE Advertising Started Successfully - Payload: $payload")
                trySend(true)
            }

            override fun onStartFailure(errorCode: Int) {
                super.onStartFailure(errorCode)
                Log.e("StaffBeacon", "BLE Advertising Failed with code: $errorCode")
                trySend(false)
            }
        }

        advertiser?.startAdvertising(settings, data, callback)

        awaitClose {
            Log.d("StaffBeacon", "BLE Advertising Stopped")
            advertiser?.stopAdvertising(callback)
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/infrastructure/car/CarConnectionManager.kt`

```kotlin
package com.georacing.georacing.infrastructure.car

import android.Manifest
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Color
import android.os.Build
import androidx.car.app.connection.CarConnection
import androidx.core.app.NotificationCompat
import androidx.core.content.ContextCompat
import com.georacing.georacing.MainActivity
import com.georacing.georacing.R
import com.georacing.georacing.data.parking.ParkingLocation
import com.georacing.georacing.data.parking.ParkingRepository
import com.georacing.georacing.data.repository.CircuitLocationsRepository
import com.georacing.georacing.debug.ScenarioSimulator
import com.georacing.georacing.services.NotificationFactory
import com.google.android.gms.location.LocationServices
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await

/**
 * Manages seamless handover between Android Auto and pedestrian mode.
 * 
 * When car disconnects:
 * 1. Saves current location as "Car Position"
 * 2. Shows high-priority notification
 * 3. Triggers navigation to assigned gate
 */
class CarConnectionManager(private val context: Context) {

    companion object {
        const val CHANNEL_ID_HANDOVER = "car_handover_channel"
        const val NOTIFICATION_ID_HANDOVER = 5001
        
        // Assigned gate for navigation (can be set from user preferences)
        var assignedGate: String = "Gate 3"
    }
    
    private val parkingRepository = ParkingRepository(context)
    private val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
    private val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    
    private var previousConnectionType = CarConnection.CONNECTION_TYPE_NOT_CONNECTED
    
    // Observable state for handover events
    private val _handoverTriggered = MutableStateFlow(false)
    val handoverTriggered: StateFlow<Boolean> = _handoverTriggered.asStateFlow()
    
    private val _savedParkingLocation = MutableStateFlow<ParkingLocation?>(null)
    val savedParkingLocation: StateFlow<ParkingLocation?> = _savedParkingLocation.asStateFlow()
    
    init {
        createHandoverChannel()
        startObserving()
    }
    
    private fun createHandoverChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = android.app.NotificationChannel(
                CHANNEL_ID_HANDOVER,
                "Car Handover",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Alerts when parking is saved"
                enableVibration(true)
                enableLights(true)
                lightColor = Color.BLUE
            }
            notificationManager.createNotificationChannel(channel)
        }
    }
    
    private fun startObserving() {
        CarConnection(context).type.observeForever { connectionType ->
            android.util.Log.d("CarConnectionManager", "Connection type changed: $previousConnectionType -> $connectionType")
            
            // Detect disconnect: was connected, now not connected
            if (previousConnectionType == CarConnection.CONNECTION_TYPE_NATIVE && 
                connectionType == CarConnection.CONNECTION_TYPE_NOT_CONNECTED) {
                
                android.util.Log.i("CarConnectionManager", "üöó Car disconnected! Triggering handover...")
                triggerHandover()
            }
            
            previousConnectionType = connectionType
        }
    }
    
    /**
     * Triggers the seamless handover sequence.
     * Can be called manually for simulation/demo purposes.
     */
    fun triggerHandover() {
        CoroutineScope(Dispatchers.Main).launch {
            try {
                // 1. Save current location as car position
                val location = getCurrentLocation()
                if (location != null) {
                    val parkingLocation = ParkingLocation(
                        latitude = location.latitude,
                        longitude = location.longitude,
                        timestamp = System.currentTimeMillis(),
                        photoUri = null
                    )
                    
                    parkingRepository.saveParkingLocation(parkingLocation)
                    _savedParkingLocation.value = parkingLocation
                    
                    android.util.Log.i("CarConnectionManager", "‚úÖ Parking saved: (${location.latitude}, ${location.longitude})")
                }
                
                // 2. Show high-priority notification
                showHandoverNotification()
                
                // 3. Signal that handover was triggered (for UI to react)
                _handoverTriggered.value = true
                
                android.util.Log.i("CarConnectionManager", "‚úÖ Handover triggered successfully")
                
            } catch (e: Exception) {
                android.util.Log.e("CarConnectionManager", "‚ùå Error during handover: ${e.message}", e)
            }
        }
    }
    
    private suspend fun getCurrentLocation(): android.location.Location? {
        return try {
            if (ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) 
                == PackageManager.PERMISSION_GRANTED) {
                fusedLocationClient.lastLocation.await()
            } else {
                android.util.Log.w("CarConnectionManager", "Location permission not granted")
                null
            }
        } catch (e: Exception) {
            android.util.Log.e("CarConnectionManager", "Error getting location: ${e.message}")
            null
        }
    }
    
    private fun showHandoverNotification() {
        val gates = CircuitLocationsRepository.getGates()
        val targetGate = gates.find { it.name.contains("3") || it.name.contains("Principal") } ?: gates.firstOrNull()
        
        // Intent to open app and navigate to gate
        val intent = Intent(context, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
            putExtra("navigate_to_gate", true)
            putExtra("gate_lat", targetGate?.lat ?: 0.0)
            putExtra("gate_lon", targetGate?.lon ?: 0.0)
            putExtra("gate_name", targetGate?.name ?: "Puerta")
        }
        
        val pendingIntent = PendingIntent.getActivity(
            context,
            0,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        val notification = NotificationCompat.Builder(context, CHANNEL_ID_HANDOVER)
            .setSmallIcon(R.mipmap.ic_launcher_round)
            .setContentTitle("üÖøÔ∏è Coche guardado")
            .setContentText("Toca para ir a ${targetGate?.name ?: "tu Puerta"}")
            .setStyle(NotificationCompat.BigTextStyle()
                .bigText("Tu posici√≥n de aparcamiento ha sido guardada autom√°ticamente. Toca para iniciar navegaci√≥n peatonal hacia ${targetGate?.name ?: "tu puerta asignada"}."))
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setCategory(NotificationCompat.CATEGORY_NAVIGATION)
            .setColorized(true)
            .setColor(Color.parseColor("#1976D2")) // Material Blue
            .setVibrate(longArrayOf(0, 250, 100, 250))
            .build()
        
        notificationManager.notify(NOTIFICATION_ID_HANDOVER, notification)
    }
    
    /**
     * Clears the handover state after navigation has started
     */
    fun clearHandoverState() {
        _handoverTriggered.value = false
    }
    
    /**
     * Gets the target gate coordinates for walking navigation
     */
    fun getTargetGateCoordinates(): Pair<Double, Double>? {
        val gates = CircuitLocationsRepository.getGates()
        val targetGate = gates.find { it.name.contains("3") || it.name.contains("Principal") } ?: gates.firstOrNull()
        return targetGate?.let { Pair(it.lat, it.lon) }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/infrastructure/car/CarTransitionManager.kt`

```kotlin
package com.georacing.georacing.infrastructure.car

import android.content.Context
import android.util.Log
import androidx.car.app.connection.CarConnection
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.LiveData
import androidx.lifecycle.Observer
import com.georacing.georacing.debug.ScenarioSimulator
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch

enum class CarConnectionState {
    CONNECTED,
    DISCONNECTED,
    UNKNOWN
}

class CarTransitionManager(private val context: Context) : DefaultLifecycleObserver {

    private val _carConnectionState = MutableStateFlow(CarConnectionState.UNKNOWN)
    val carConnectionState: StateFlow<CarConnectionState> = _carConnectionState.asStateFlow()

    private val _realConnectionState = MutableStateFlow(CarConnectionState.UNKNOWN)

    private var carConnection: LiveData<Int>? = null

    // Callback for the critical transition event
    var onParkingTransitionDetected: (() -> Unit)? = null

    private val scope = CoroutineScope(Dispatchers.Main)
    private var monitoringJob: Job? = null

    private val connectionObserver = Observer<Int> { connectionState ->
        val newState = when (connectionState) {
            CarConnection.CONNECTION_TYPE_PROJECTION -> CarConnectionState.CONNECTED
            CarConnection.CONNECTION_TYPE_NOT_CONNECTED -> CarConnectionState.DISCONNECTED
            CarConnection.CONNECTION_TYPE_NATIVE -> CarConnectionState.CONNECTED // Assuming native is also connected
            else -> CarConnectionState.UNKNOWN
        }
        _realConnectionState.value = newState
    }

    fun startMonitoring(lifecycleOwner: LifecycleOwner) {
        lifecycleOwner.lifecycle.addObserver(this)
        try {
            carConnection = CarConnection(context).type
            carConnection?.observe(lifecycleOwner, connectionObserver)
        } catch (e: Exception) {
            Log.e("CarTransitionManager", "Error initializing CarConnection", e)
        }
    }

    override fun onStart(owner: LifecycleOwner) {
        super.onStart(owner)
        monitoringJob?.cancel()
        monitoringJob = scope.launch {
            combine(
                _realConnectionState,
                ScenarioSimulator.forcedCarConnection
            ) { real, forced ->
                if (forced != null) {
                    if (forced) CarConnectionState.CONNECTED else CarConnectionState.DISCONNECTED
                } else {
                    real
                }
            }.collect { newState ->
                val oldState = _carConnectionState.value
                if (oldState != newState) {
                    _carConnectionState.value = newState
                    Log.d("CarTransitionManager", "Car Config Changed: $oldState -> $newState")

                    // CRITICAL LOGIC: Transition from CONNECTED -> DISCONNECTED
                    if (oldState == CarConnectionState.CONNECTED && newState == CarConnectionState.DISCONNECTED) {
                        Log.i("CarTransitionManager", "Parking Transition Detected!")
                        onParkingTransitionDetected?.invoke()
                    }
                }
            }
        }
    }

    override fun onStop(owner: LifecycleOwner) {
        monitoringJob?.cancel()
        super.onStop(owner)
    }

    override fun onDestroy(owner: LifecycleOwner) {
        carConnection?.removeObserver(connectionObserver)
        super.onDestroy(owner)
    }

    companion object {
        @Volatile
        private var INSTANCE: CarTransitionManager? = null

        fun getInstance(context: Context): CarTransitionManager {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: CarTransitionManager(context.applicationContext).also { INSTANCE = it }
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/infrastructure/health/HealthConnectManager.kt`

```kotlin
package com.georacing.georacing.infrastructure.health

import android.content.Context
import android.os.Build
import androidx.activity.result.contract.ActivityResultContract
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.PermissionController
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.DistanceRecord
import androidx.health.connect.client.records.StepsRecord
import androidx.health.connect.client.request.AggregateRequest
import androidx.health.connect.client.time.TimeRangeFilter
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.Instant
import java.time.temporal.ChronoUnit

/**
 * Gestor de la API de Health Connect (Infraestructura).
 * Se encarga de solicitar permisos y leer agregados diarios (0 coste de bater√≠a).
 */
class HealthConnectManager(
    private val context: Context
) {
    // Inicializaci√≥n perezosa del cliente
    private val healthConnectClient by lazy { HealthConnectClient.getOrCreate(context) }

    // Los permisos m√≠nimos para la Fase 3: Pasos y Distancia de s√≥lo lectura
    val requiredPermissions = setOf(
        HealthPermission.getReadPermission(StepsRecord::class),
        HealthPermission.getReadPermission(DistanceRecord::class)
    )

    /**
     * Comprueba si la aplicaci√≥n Health Connect est√° disponible y soportada.
     */
    fun isAvailable(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
            true // En Android 14+ est√° integrada en el framework
        } else {
            HealthConnectClient.getSdkStatus(context) == HealthConnectClient.SDK_AVAILABLE
        }
    }

    /**
     * Comprueba si tenemos todos los permisos concedidos.
     */
    suspend fun hasAllPermissions(): Boolean {
        if (!isAvailable()) return false
        val granted = healthConnectClient.permissionController.getGrantedPermissions()
        return granted.containsAll(requiredPermissions)
    }

    /**
     * Genera el contrato para solicitar permisos desde un Activity/Compose.
     */
    fun requestPermissionsActivityContract(): ActivityResultContract<Set<String>, Set<String>> {
        return PermissionController.createRequestPermissionResultContract()
    }

    /**
     * Lee los pasos totales agregados en el d√≠a de hoy (desde la medianoche).
     */
    suspend fun getTodaySteps(): Long = withContext(Dispatchers.IO) {
        if (!hasAllPermissions()) return@withContext 0L

        val now = Instant.now()
        val startOfDay = now.truncatedTo(ChronoUnit.DAYS)

        val request = AggregateRequest(
            metrics = setOf(StepsRecord.COUNT_TOTAL),
            timeRangeFilter = TimeRangeFilter.between(startOfDay, now)
        )

        try {
            val response = healthConnectClient.aggregate(request)
            response[StepsRecord.COUNT_TOTAL] ?: 0L
        } catch (e: Exception) {
            e.printStackTrace()
            0L
        }
    }

    /**
     * Lee la distancia total recorrida hoy (en metros).
     */
    suspend fun getTodayDistanceMeters(): Double = withContext(Dispatchers.IO) {
        if (!hasAllPermissions()) return@withContext 0.0

        val now = Instant.now()
        val startOfDay = now.truncatedTo(ChronoUnit.DAYS)

        val request = AggregateRequest(
            metrics = setOf(DistanceRecord.DISTANCE_TOTAL),
            timeRangeFilter = TimeRangeFilter.between(startOfDay, now)
        )

        try {
            val response = healthConnectClient.aggregate(request)
            response[DistanceRecord.DISTANCE_TOTAL]?.inMeters ?: 0.0
        } catch (e: Exception) {
            e.printStackTrace()
            0.0
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/infrastructure/security/MedicalWallpaperGenerator.kt`

```kotlin
package com.georacing.georacing.infrastructure.security

import android.app.WallpaperManager
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.Typeface
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * Genera un fondo de pantalla t√°ctico en caso de emergencia m√©dica.
 * Graba los datos vitales a bajo nivel (Canvas) y fuerza el bloqueo de pantalla del SO
 * para que los m√©dicos/polic√≠a vean la informaci√≥n aunque el terminal est√© bloqueado.
 */
class MedicalWallpaperGenerator(
    private val context: Context
) {

    /**
     * Dibuja un nuevo Bitmap con la info m√©dica y lo aplica en el Lock Screen.
     */
    suspend fun applyEmergencyWallpaper(
        bloodType: String,
        emergencyContact: String,
        ticketId: String
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            val metrics = context.resources.displayMetrics
            val width = metrics.widthPixels
            val height = metrics.heightPixels

            // Configuraci√≥n del Bitmap para minimizar uso de RAM. (RGB_565 es suficiente pero ARGB_8888 asegura texto n√≠tido)
            val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
            val canvas = Canvas(bitmap)

            // Fondo negro puro (ahorro extremo OLED)
            canvas.drawColor(Color.BLACK)

            val paintText = Paint(Paint.ANTI_ALIAS_FLAG).apply {
                color = Color.WHITE
                textSize = 60f
                typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)
                textAlign = Paint.Align.CENTER
            }

            val paintWarning = Paint(Paint.ANTI_ALIAS_FLAG).apply {
                color = Color.RED
                textSize = 80f
                typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)
                textAlign = Paint.Align.CENTER
            }

            // Dise√±o y Pintado de la UI est√°tica en Canvas
            val centerX = width / 2f
            var startY = height * 0.2f

            canvas.drawText("‚ö†Ô∏è MEDICAL EMERGENCY ‚ö†Ô∏è", centerX, startY, paintWarning)
            
            startY += 200f
            paintText.textSize = 50f
            canvas.drawText("Blood Type:", centerX, startY, paintText)
            startY += 80f
            canvas.drawText(bloodType, centerX, startY, paintWarning) // Resaltado en rojo
            
            startY += 200f
            canvas.drawText("ICE (In Case of Emergency):", centerX, startY, paintText)
            startY += 80f
            paintText.textSize = 70f
            canvas.drawText(emergencyContact, centerX, startY, paintText)

            startY += 200f
            paintText.textSize = 40f
            canvas.drawText("Fan Ticket ID / Insurance:", centerX, startY, paintText)
            startY += 60f
            canvas.drawText(ticketId, centerX, startY, paintText)

            // Aplicar Wallpaper exclusivamente a la pantalla de bloqueo (FLAG_LOCK)
            val wallpaperManager = WallpaperManager.getInstance(context)
            
            // Requerir√° permiso SET_WALLPAPER en el Manifest
            wallpaperManager.setBitmap(bitmap, null, false, WallpaperManager.FLAG_LOCK)

            bitmap.recycle() // Liberar memoria nativa
            true
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/infrastructure/telemetry/BlackBoxLogger.kt`

```kotlin
package com.georacing.georacing.infrastructure.telemetry

import com.georacing.georacing.data.local.dao.TelemetryDao
import com.georacing.georacing.data.local.entities.TelemetryEntity
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

/**
 * La Caja Negra Operativa.
 * Escucha eventos cr√≠ticos en la aplicaci√≥n y los persiste offline en Room.
 */
class BlackBoxLogger(
    private val telemetryDao: TelemetryDao
) {
    private val scope = CoroutineScope(Dispatchers.IO)

    /**
     * Registra un evento en la "Caja Negra".
     * @param eventType Tipo de evento (ej: "NETWORK_DROP", "BLE_TIMEOUT").
     * @param metadata Informaci√≥n adicional del evento (JSON o texto plano).
     */
    fun logEvent(eventType: String, metadata: String) {
        scope.launch {
            val entity = TelemetryEntity(
                timestamp = System.currentTimeMillis(),
                eventType = eventType,
                metadata = metadata
            )
            telemetryDao.insertLog(entity)
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/infrastructure/telemetry/TelemetrySyncWorker.kt`

```kotlin
package com.georacing.georacing.infrastructure.telemetry

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.georacing.georacing.data.local.GeoRacingDatabase

/**
 * Worker responsable de subir los logs de la caja negra
 * cuando las condiciones de red son ideales (ej. Wi-Fi).
 */
class TelemetrySyncWorker(
    appContext: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(appContext, workerParams) {

    override suspend fun doWork(): Result {
        val database = GeoRacingDatabase.getInstance(applicationContext)
        val telemetryDao = database.telemetryDao()

        return try {
            val logs = telemetryDao.getAllLogs()

            if (logs.isNotEmpty()) {
                Log.d("TelemetrySyncWorker", "Attempting to sync ${logs.size} BlackBox events to QNAP NAS...")
                
                // Simulaci√≥n de subida de payloads binarios/JSON al NAS QNAP TS-464.
                // callQnapApi(logs)
                
                // Si la sincronizaci√≥n es exitosa, limpiamos localmente para ahorrar espacio.
                telemetryDao.clearLogs()
                Log.d("TelemetrySyncWorker", "Sync successful. Local database cleared.")
            } else {
                Log.d("TelemetrySyncWorker", "No Telemetry events to sync.")
            }

            Result.success()
        } catch (e: Exception) {
            Log.e("TelemetrySyncWorker", "Sync failed: ${e.message}", e)
            Result.retry() // Si la red cae a la mitad, reintentar√° luego
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/navigation/NavigationEngine.kt`

```kotlin
package com.georacing.georacing.navigation

import android.location.Location
import android.util.Log
import com.georacing.georacing.car.RouteRepository
import com.georacing.georacing.car.RouteResult
import com.georacing.georacing.car.Step as OsrmStep
import com.georacing.georacing.domain.usecases.CheckArrivalUseCase
import com.georacing.georacing.utils.*
import org.maplibre.android.geometry.LatLng
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * Motor de navegaci√≥n compartido entre Android Auto y la app m√≥vil.
 * 
 * Este componente encapsula toda la l√≥gica de navegaci√≥n:
 * - Gesti√≥n de rutas (c√°lculo, rec√°lculo)
 * - Snap a ruta
 * - C√°lculo de distancia y ETA
 * - Detecci√≥n de off-route
 * - Detecci√≥n de llegada
 * - Detecci√≥n de pasos/maniobras
 * 
 * Es usado tanto por GeoRacingNavigationScreen (Android Auto) como por
 * CircuitNavigationScreen (app m√≥vil) para garantizar comportamiento consistente.
 */
class NavigationEngine {
    
    private val TAG = "NavigationEngine"
    
    private val routeRepository = RouteRepository()
    
    // Estado de navegaci√≥n
    private val _navigationState = MutableStateFlow<NavigationState>(NavigationState.Idle)
    val navigationState: StateFlow<NavigationState> = _navigationState.asStateFlow()
    
    // √öltima posici√≥n conocida para snap adaptativo
    private var lastSnapResult: SnapResult? = null
    
    // Control de rec√°lculo de ruta
    private var lastRouteCalculationTime = 0L
    private val MIN_RECALCULATION_INTERVAL_MS = 30_000L // 30 segundos
    
    /**
     * Inicia la navegaci√≥n hacia un destino.
     * 
     * @param destination Coordenadas del destino
     * @param destinationName Nombre del destino para mostrar al usuario
     * @param currentLocation Ubicaci√≥n actual del usuario (opcional, si ya est√° disponible)
     */
    suspend fun startNavigation(
        destination: LatLng,
        destinationName: String,
        currentLocation: Location? = null
    ): Boolean {
        Log.i(TAG, "üöÄ Iniciando navegaci√≥n a $destinationName")
        
        _navigationState.value = NavigationState.Loading(destinationName)
        
        // Si no tenemos ubicaci√≥n actual, esperar a que llegue la primera actualizaci√≥n
        if (currentLocation == null) {
            Log.d(TAG, "Esperando primera ubicaci√≥n GPS para calcular ruta...")
            _navigationState.value = NavigationState.WaitingForLocation(destination, destinationName)
            return true
        }
        
        // Calcular ruta inicial
        val route = routeRepository.getRoute(
            origin = LatLng(currentLocation.latitude, currentLocation.longitude),
            dest = destination
        )
        
        if (route == null) {
            Log.e(TAG, "‚ùå Error al calcular ruta inicial")
            _navigationState.value = NavigationState.Error("No se pudo calcular la ruta. Verifica tu conexi√≥n.")
            return false
        }
        
        Log.i(TAG, "‚úÖ Ruta calculada: ${route.distance}m, ${route.duration}s, ${route.steps.size} pasos")
        
        // Inicializar estado activo
        _navigationState.value = NavigationState.Active(
            route = route,
            destinationName = destinationName,
            destination = destination,
            currentStepIndex = 0,
            currentStep = route.steps.firstOrNull(),
            distanceToNextManeuver = route.steps.firstOrNull()?.distance ?: 0.0,
            remainingDistance = route.distance,
            estimatedTimeRemaining = route.duration,
            isOffRoute = false,
            closestPointIndex = 0,
            distanceToRoute = 0.0
        )
        
        lastRouteCalculationTime = System.currentTimeMillis()
        
        // Resetear detectores
        OffRouteDetector.reset()
        TTSManager.reset()
        
        return true
    }
    
    /**
     * Actualiza el estado de navegaci√≥n con una nueva ubicaci√≥n GPS.
     * 
     * Esta es la funci√≥n principal que se llama cada vez que llega una nueva se√±al GPS.
     * Realiza todo el procesamiento necesario:
     * - Snap a ruta
     * - Actualizaci√≥n de distancia y ETA
     * - Detecci√≥n de off-route y rec√°lculo autom√°tico
     * - Detecci√≥n de llegada
     * - Actualizaci√≥n de paso/maniobra actual
     */
    suspend fun updateLocation(location: Location) {
        val currentState = _navigationState.value
        
        // Si estamos esperando ubicaci√≥n para calcular ruta inicial
        if (currentState is NavigationState.WaitingForLocation) {
            startNavigation(currentState.destination, currentState.destinationName, location)
            return
        }
        
        // Solo procesar si estamos en navegaci√≥n activa
        if (currentState !is NavigationState.Active) {
            return
        }
        
        val route = currentState.route
        if (route.points.isEmpty()) {
            Log.w(TAG, "Ruta sin puntos, ignorando actualizaci√≥n")
            return
        }
        
        // 1. SNAP TO ROUTE (adaptativo para mejor precisi√≥n)
        val snapResult = RouteSnapper.snapToRouteAdaptive(
            currentLocation = location,
            routePoints = route.points,
            lastIndex = lastSnapResult?.closestIndex ?: 0,
            firstRadius = 30,
            secondRadius = 100,
            distanceThresholdMeters = 80.0
        )
        
        lastSnapResult = snapResult
        
        Log.d(TAG, "üìç Snap: index=${snapResult.closestIndex}, distToRoute=${snapResult.distanceToRoute.toInt()}m")
        
        // 2. CALCULAR DISTANCIA RESTANTE
        val remainingDistance = DistanceCalculator.calculateRemainingDistance(
            snapResult = snapResult,
            routePoints = route.points
        )
        
        // 3. CALCULAR ETA ESTABLE (proporcional a ruta original)
        val estimatedTimeRemaining = ETACalculator.calculateRemainingTime(
            remainingDistance = remainingDistance,
            totalDistance = route.distance,
            totalDuration = route.duration
        )
        
        // 4. DETECTAR PASO/MANIOBRA ACTUAL
        val stepInfo = StepDetector.findCurrentStep(
            snapResult = snapResult,
            route = route
        )
        
        Log.d(TAG, "üìä Dist: ${(remainingDistance / 1000.0).format(1)} km, ETA: ${formatETA(estimatedTimeRemaining)}, Paso: ${stepInfo.index + 1}/${route.steps.size}")
        
        // 5. DETECCI√ìN OFF-ROUTE
        val isOffRoute = OffRouteDetector.checkOffRoute(
            location = location,
            snapResult = snapResult
        )
        
        if (isOffRoute) {
            Log.w(TAG, "‚ö†Ô∏è Usuario fuera de ruta, recalculando...")
            handleOffRoute(location, currentState)
            return
        }
        
        // 6. DETECCI√ìN DE LLEGADA
        val arrived = CheckArrivalUseCase.executeSimple(
            currentLocation = location,
            destination = currentState.destination
        )
        
        if (arrived) {
            Log.i(TAG, "üéØ LLEGADA a ${currentState.destinationName}")
            _navigationState.value = NavigationState.Arrived(currentState.destinationName)
            return
        }
        
        // 7. ACTUALIZAR ESTADO
        _navigationState.value = currentState.copy(
            currentStepIndex = stepInfo.index,
            currentStep = stepInfo.step,
            distanceToNextManeuver = stepInfo.distanceToManeuver,
            remainingDistance = remainingDistance,
            estimatedTimeRemaining = estimatedTimeRemaining,
            isOffRoute = false,
            closestPointIndex = snapResult.closestIndex,
            distanceToRoute = snapResult.distanceToRoute
        )
    }
    
    /**
     * Maneja la situaci√≥n cuando el usuario se sale de la ruta.
     * Recalcula autom√°ticamente desde la posici√≥n actual.
     */
    private suspend fun handleOffRoute(location: Location, currentState: NavigationState.Active) {
        Log.i(TAG, "üîÑ Recalculando ruta desde posici√≥n actual...")
        
        val newRoute = routeRepository.getRoute(
            origin = LatLng(location.latitude, location.longitude),
            dest = currentState.destination
        )
        
        if (newRoute == null) {
            Log.e(TAG, "‚ùå Error al recalcular ruta")
            // Mantener ruta anterior pero marcar como off-route
            _navigationState.value = currentState.copy(isOffRoute = true)
            return
        }
        
        Log.i(TAG, "‚úÖ Nueva ruta calculada: ${newRoute.distance}m, ${newRoute.duration}s")
        
        // Actualizar estado con nueva ruta
        _navigationState.value = NavigationState.Active(
            route = newRoute,
            destinationName = currentState.destinationName,
            destination = currentState.destination,
            currentStepIndex = 0,
            currentStep = newRoute.steps.firstOrNull(),
            distanceToNextManeuver = newRoute.steps.firstOrNull()?.distance ?: 0.0,
            remainingDistance = newRoute.distance,
            estimatedTimeRemaining = newRoute.duration,
            isOffRoute = false,
            closestPointIndex = 0,
            distanceToRoute = 0.0
        )
        
        lastRouteCalculationTime = System.currentTimeMillis()
        
        // Resetear detectores
        OffRouteDetector.reset()
        TTSManager.reset()
    }
    
    /**
     * Recalcula la ruta peri√≥dicamente para actualizar datos de tr√°fico.
     * Solo se ejecuta si ha pasado el intervalo m√≠nimo desde el √∫ltimo c√°lculo.
     */
    suspend fun recalculateRouteIfNeeded(location: Location): Boolean {
        val currentState = _navigationState.value
        if (currentState !is NavigationState.Active) {
            return false
        }
        
        val now = System.currentTimeMillis()
        if (now - lastRouteCalculationTime < MIN_RECALCULATION_INTERVAL_MS) {
            return false // Muy pronto para recalcular
        }
        
        Log.d(TAG, "üîÑ Recalculando ruta por actualizaci√≥n de tr√°fico...")
        
        val newRoute = routeRepository.getRoute(
            origin = LatLng(location.latitude, location.longitude),
            dest = currentState.destination,
            avoidTraffic = true
        )
        
        if (newRoute != null) {
            _navigationState.value = currentState.copy(
                route = newRoute,
                remainingDistance = newRoute.distance,
                estimatedTimeRemaining = newRoute.duration
            )
            lastRouteCalculationTime = now
            Log.i(TAG, "‚úÖ Ruta actualizada con datos de tr√°fico")
            return true
        }
        
        return false
    }
    
    /**
     * Detiene la navegaci√≥n y resetea el estado.
     */
    fun stopNavigation() {
        Log.i(TAG, "üõë Navegaci√≥n detenida")
        _navigationState.value = NavigationState.Idle
        lastSnapResult = null
        OffRouteDetector.reset()
        TTSManager.reset()
    }
    
    /**
     * Formatea el tiempo en segundos a un string legible.
     */
    private fun formatETA(seconds: Double): String {
        val mins = (seconds / 60).toInt()
        return if (mins < 60) {
            "$mins min"
        } else {
            val hours = mins / 60
            val remainingMins = mins % 60
            "${hours}h ${remainingMins}min"
        }
    }
    
    /**
     * Extensi√≥n para formatear Double con decimales.
     */
    private fun Double.format(decimals: Int): String {
        return "%.${decimals}f".format(this)
    }
}

/**
 * Estados posibles de la navegaci√≥n.
 */
sealed class NavigationState {
    /** No hay navegaci√≥n activa */
    object Idle : NavigationState()
    
    /** Cargando ruta inicial */
    data class Loading(val destinationName: String) : NavigationState()
    
    /** Esperando primera ubicaci√≥n GPS para calcular ruta */
    data class WaitingForLocation(
        val destination: LatLng,
        val destinationName: String
    ) : NavigationState()
    
    /** Navegaci√≥n activa */
    data class Active(
        val route: RouteResult,
        val destinationName: String,
        val destination: LatLng,
        val currentStepIndex: Int,
        val currentStep: OsrmStep?,
        val distanceToNextManeuver: Double,
        val remainingDistance: Double,
        val estimatedTimeRemaining: Double,
        val isOffRoute: Boolean,
        val closestPointIndex: Int,
        val distanceToRoute: Double
    ) : NavigationState()
    
    /** Llegada al destino */
    data class Arrived(val destinationName: String) : NavigationState()
    
    /** Error en navegaci√≥n */
    data class Error(val message: String) : NavigationState()
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/services/BatteryMonitor.kt`

```kotlin
package com.georacing.georacing.services

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.BatteryManager
import android.util.Log
import com.georacing.georacing.domain.model.AppPowerState
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * Monitor de bater√≠a para implementar Load Shedding.
 * 
 * Observa el nivel de bater√≠a del dispositivo y emite estados
 * que determinan qu√© funcionalidades deben estar activas.
 * 
 * Uso:
 * ```
 * val monitor = BatteryMonitor(context)
 * monitor.startMonitoring()
 * 
 * // En Compose:
 * val powerState by monitor.powerState.collectAsState()
 * when (powerState) {
 *     AppPowerState.CRITICAL -> // Solo emergencia
 *     AppPowerState.POWER_SAVE -> // Funciones reducidas
 *     AppPowerState.NORMAL -> // Todo activo
 * }
 * ```
 */
class BatteryMonitor(private val context: Context) {

    companion object {
        private const val TAG = "BatteryMonitor"
        
        // Umbrales de bater√≠a
        const val THRESHOLD_POWER_SAVE = 30  // Activa modo ahorro
        const val THRESHOLD_CRITICAL = 15    // Solo emergencia
    }

    private val _batteryLevel = MutableStateFlow(100)
    val batteryLevel: StateFlow<Int> = _batteryLevel.asStateFlow()

    private val _isCharging = MutableStateFlow(false)
    val isCharging: StateFlow<Boolean> = _isCharging.asStateFlow()

    private val _powerState = MutableStateFlow(AppPowerState.NORMAL)
    val powerState: StateFlow<AppPowerState> = _powerState.asStateFlow()

    private var isMonitoring = false

    private val batteryReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            intent?.let { processIntent(it) }
        }
    }

    /**
     * Inicia la monitorizaci√≥n de la bater√≠a.
     * Llama a esto en onCreate de MainActivity o en el NavHost.
     */
    fun startMonitoring() {
        if (isMonitoring) return
        
        val filter = IntentFilter(Intent.ACTION_BATTERY_CHANGED)
        val intent = context.registerReceiver(batteryReceiver, filter)
        
        // Procesar estado inicial
        intent?.let { processIntent(it) }
        
        isMonitoring = true
        Log.d(TAG, "Battery monitoring started")
    }

    /**
     * Detiene la monitorizaci√≥n.
     * Llama a esto en onDestroy o cuando ya no sea necesario.
     */
    fun stopMonitoring() {
        if (!isMonitoring) return
        
        try {
            context.unregisterReceiver(batteryReceiver)
        } catch (e: Exception) {
            Log.w(TAG, "Receiver already unregistered")
        }
        
        isMonitoring = false
        Log.d(TAG, "Battery monitoring stopped")
    }

    private fun processIntent(intent: Intent) {
        val level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)
        val scale = intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)
        val status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1)

        val percentage = if (level >= 0 && scale > 0) {
            (level * 100 / scale)
        } else {
            100
        }

        val charging = status == BatteryManager.BATTERY_STATUS_CHARGING ||
                       status == BatteryManager.BATTERY_STATUS_FULL

        _batteryLevel.value = percentage
        _isCharging.value = charging

        // Calcular nuevo estado de energ√≠a
        val newState = calculatePowerState(percentage, charging)
        
        if (_powerState.value != newState) {
            Log.i(TAG, "Power state changed: ${_powerState.value} -> $newState (battery: $percentage%, charging: $charging)")
            _powerState.value = newState
        }
    }

    private fun calculatePowerState(percentage: Int, charging: Boolean): AppPowerState {
        // Si est√° cargando, siempre modo normal
        if (charging) return AppPowerState.NORMAL

        return when {
            percentage < THRESHOLD_CRITICAL -> AppPowerState.CRITICAL
            percentage < THRESHOLD_POWER_SAVE -> AppPowerState.POWER_SAVE
            else -> AppPowerState.NORMAL
        }
    }

    /**
     * Fuerza una lectura inmediata del estado de bater√≠a.
     * √ötil para verificaci√≥n en tests.
     */
    fun forceUpdate() {
        val intent = context.registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED))
        intent?.let { processIntent(it) }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/services/LiveNotificationManager.kt`

```kotlin
package com.georacing.georacing.services

import android.Manifest
import android.annotation.SuppressLint
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.util.Log
import android.widget.RemoteViews
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import com.georacing.georacing.MainActivity
import com.georacing.georacing.R
import com.georacing.georacing.domain.model.CircuitMode

/**
 * Manages "Live Activities" style notifications for Android 15 & Samsung One UI.
 */
class LiveNotificationManager(private val context: Context) {

    private val notificationManager = NotificationManagerCompat.from(context)

    fun createChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "Live Activity",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Shows live race status and navigation"
                setShowBadge(true)
            }
            notificationManager.createNotificationChannel(channel)
        }
    }

    @SuppressLint("MissingPermission")
    fun buildNotification(mode: CircuitMode, message: String): Notification {
        // Intent to open App
        val intent = Intent(context, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }
        val pendingIntent = PendingIntent.getActivity(
            context, 0, intent,
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
        )

        // Categorize for System Priority (Samsung Capsule / Dynamic Island)
        val category = when (mode) {
            CircuitMode.EVACUATION, CircuitMode.RED_FLAG -> Notification.CATEGORY_ALARM // High priority, breaks DND
            else -> Notification.CATEGORY_NAVIGATION // Standard persistent status
        }

        val builder = NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.mipmap.ic_launcher_round) // Replace with a solid white icon ideally
            .setContentTitle(getTitleForMode(mode))
            .setContentText(message)
            .setPriority(NotificationCompat.PRIORITY_MAX)
            .setCategory(category)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
            .setOngoing(true)
            .setOnlyAlertOnce(true)
            .setAutoCancel(false)
            .setContentIntent(pendingIntent)
            .setStyle(NotificationCompat.DecoratedCustomViewStyle())
            .setColor(getColorForMode(mode))
            .setColorized(true) // üü¢ Critical for Samsung "NowBar" look
            .setUsesChronometer(true) // ‚è±Ô∏è Triggers "time elapsed" style


        // Add Action Button
        val mapIntent = Intent(context, MainActivity::class.java).apply {
            action = "OPEN_MAP" // Handle this in MainActivity
        }
        val mapPendingIntent = PendingIntent.getActivity(
            context, 1, mapIntent, PendingIntent.FLAG_IMMUTABLE
        )
        builder.addAction(android.R.drawable.ic_menu_mapmode, "Ver Mapa", mapPendingIntent)

        return builder.build()
    }

    @SuppressLint("MissingPermission")
    fun updateNotification(notificationId: Int, mode: CircuitMode, message: String) {
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED) {
             val notification = buildNotification(mode, message)
             notificationManager.notify(notificationId, notification)
        }
    }

    private fun getTitleForMode(mode: CircuitMode): String {
        return when (mode) {
            CircuitMode.NORMAL -> "üü¢ Carrera en Curso"
            CircuitMode.GREEN_FLAG -> "üü¢ BANDERA VERDE"
            CircuitMode.YELLOW_FLAG -> "üü° BANDERA AMARILLA"
            CircuitMode.VSC -> "üü° SAFETY CAR VIRTUAL"
            CircuitMode.SAFETY_CAR -> "üü° Safety Car (SC)"
            CircuitMode.RED_FLAG -> "üî¥ BANDERA ROJA"
            CircuitMode.EVACUATION -> "üÜò EVACUACI√ìN"
            CircuitMode.UNKNOWN -> "GeoRacing"
        }
    }

    private fun getColorForMode(mode: CircuitMode): Int {
        return when (mode) {
            CircuitMode.NORMAL, CircuitMode.GREEN_FLAG -> android.graphics.Color.GREEN
            CircuitMode.YELLOW_FLAG, CircuitMode.VSC, CircuitMode.SAFETY_CAR -> android.graphics.Color.YELLOW
            CircuitMode.RED_FLAG, CircuitMode.EVACUATION -> android.graphics.Color.RED
            else -> android.graphics.Color.GRAY
        }
    }

    companion object {
        const val CHANNEL_ID = "live_activity_channel"
        const val NOTIFICATION_ID = 1001
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/services/LiveSessionService.kt`

```kotlin
package com.georacing.georacing.services

import android.app.NotificationManager
import android.content.Intent
import android.os.IBinder
import android.util.Log
import androidx.lifecycle.LifecycleService
import androidx.lifecycle.lifecycleScope
import com.georacing.georacing.domain.model.LiveSessionState
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch

/**
 * Live Session Service - The Engine for real-time notifications.
 * 
 * Design:
 * - Extends LifecycleService for coroutine-aware lifecycle.
 * - Uses StateFlow for reactive state management.
 * - Calls startForeground() immediately in onCreate() (<5s rule).
 * - Updates notification on every state change.
 */
class LiveSessionService : LifecycleService() {

    companion object {
        private const val TAG = "LiveSessionService"
        
        // External access to update state (Singleton pattern for simplicity)
        // In production, use a shared repository or event bus.
        private val _sessionState = MutableStateFlow<LiveSessionState>(LiveSessionState.Idle)
        val sessionState: StateFlow<LiveSessionState> = _sessionState.asStateFlow()
        
        fun updateState(newState: LiveSessionState) {
            _sessionState.value = newState
            Log.d(TAG, "State updated: $newState")
        }
    }

    private lateinit var notificationFactory: NotificationFactory

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "Service onCreate")
        
        // Initialize NotificationFactory (manual DI)
        notificationFactory = NotificationFactory(this)
        
        // CRITICAL: Start foreground immediately to avoid ANR (<5 seconds rule)
        val initialNotification = notificationFactory.build(LiveSessionState.Idle)
        startForeground(NotificationFactory.NOTIFICATION_ID, initialNotification)
        
        // Observe state changes and update notification
        observeStateChanges()
    }

    private fun observeStateChanges() {
        lifecycleScope.launch {
            sessionState.collectLatest { state ->
                Log.d(TAG, "State observed: $state")
                val notification = notificationFactory.build(state)
                val manager = getSystemService(NotificationManager::class.java)
                manager.notify(NotificationFactory.NOTIFICATION_ID, notification)
            }
        }
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        super.onStartCommand(intent, flags, startId)
        Log.d(TAG, "Service onStartCommand")
        return START_STICKY
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "Service onDestroy")
        // Reset state to Idle when service is killed
        _sessionState.value = LiveSessionState.Idle
    }

    override fun onBind(intent: Intent): IBinder? {
        super.onBind(intent)
        return null
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/services/LiveStatusNotificationBuilder.kt`

```kotlin
package com.georacing.georacing.services

import android.content.Context
import android.widget.RemoteViews
import com.georacing.georacing.R

/**
 * Builds the RemoteViews for the Live Activity Notification.
 * Switched to XML RemoteViews for maximum stability and compatibility.
 */
object LiveStatusNotificationBuilder {

    fun createRemoteViews(context: Context, status: String, distance: String, time: String): RemoteViews {
        val remoteViews = RemoteViews(context.packageName, R.layout.notification_live_status)
        
        remoteViews.setTextViewText(R.id.tvStatus, status)
        remoteViews.setTextViewText(R.id.tvDistance, distance)
        remoteViews.setTextViewText(R.id.tvTime, time)
        
        // Dynamic Progress (Simulated based on text)
        // In real app, pass progress int
        remoteViews.setProgressBar(R.id.progressBar, 100, 75, false)

        return remoteViews
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/services/NetworkMonitor.kt`

```kotlin
package com.georacing.georacing.services

import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import android.util.Log
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * Monitor de conectividad de red.
 * 
 * Detecta autom√°ticamente cuando el dispositivo pierde conexi√≥n a internet
 * y emite estados que permiten activar el fallback a BLE.
 * 
 * Uso:
 * ```
 * val monitor = NetworkMonitor(context)
 * monitor.startMonitoring()
 * 
 * // En Compose:
 * val isOnline by monitor.isOnline.collectAsState()
 * if (!isOnline) {
 *     // Mostrar indicador offline + confiar en BLE
 * }
 * ```
 */
class NetworkMonitor(private val context: Context) {

    companion object {
        private const val TAG = "NetworkMonitor"
    }

    private val connectivityManager = 
        context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

    private val _isOnline = MutableStateFlow(true)
    val isOnline: StateFlow<Boolean> = _isOnline.asStateFlow()

    private val _connectionType = MutableStateFlow(ConnectionType.UNKNOWN)
    val connectionType: StateFlow<ConnectionType> = _connectionType.asStateFlow()

    private val _lastOnlineTime = MutableStateFlow(System.currentTimeMillis())
    val lastOnlineTime: StateFlow<Long> = _lastOnlineTime.asStateFlow()

    private var isMonitoring = false

    private val networkCallback = object : ConnectivityManager.NetworkCallback() {
        override fun onAvailable(network: Network) {
            Log.d(TAG, "Network available")
            _isOnline.value = true
            _lastOnlineTime.value = System.currentTimeMillis()
            updateConnectionType()
        }

        override fun onLost(network: Network) {
            Log.w(TAG, "Network lost - Switching to offline/BLE mode")
            _isOnline.value = false
            _connectionType.value = ConnectionType.NONE
        }

        override fun onCapabilitiesChanged(network: Network, capabilities: NetworkCapabilities) {
            updateConnectionType(capabilities)
        }
    }

    /**
     * Inicia la monitorizaci√≥n de red.
     */
    fun startMonitoring() {
        if (isMonitoring) return

        // Verificar estado inicial
        updateCurrentState()

        // Registrar callback para cambios futuros
        val request = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()

        try {
            connectivityManager.registerNetworkCallback(request, networkCallback)
            isMonitoring = true
            Log.d(TAG, "Network monitoring started. Online: ${_isOnline.value}")
        } catch (e: Exception) {
            Log.e(TAG, "Error starting network monitor", e)
        }
    }

    /**
     * Detiene la monitorizaci√≥n.
     */
    fun stopMonitoring() {
        if (!isMonitoring) return

        try {
            connectivityManager.unregisterNetworkCallback(networkCallback)
            isMonitoring = false
            Log.d(TAG, "Network monitoring stopped")
        } catch (e: Exception) {
            Log.w(TAG, "Error stopping network monitor", e)
        }
    }

    private fun updateCurrentState() {
        val activeNetwork = connectivityManager.activeNetwork
        val capabilities = connectivityManager.getNetworkCapabilities(activeNetwork)

        _isOnline.value = capabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) == true
        
        if (_isOnline.value) {
            _lastOnlineTime.value = System.currentTimeMillis()
        }
        
        updateConnectionType(capabilities)
    }

    private fun updateConnectionType(capabilities: NetworkCapabilities? = null) {
        val caps = capabilities ?: connectivityManager.getNetworkCapabilities(
            connectivityManager.activeNetwork
        )

        _connectionType.value = when {
            caps == null -> ConnectionType.NONE
            caps.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) -> ConnectionType.WIFI
            caps.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) -> ConnectionType.CELLULAR
            caps.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) -> ConnectionType.ETHERNET
            else -> ConnectionType.OTHER
        }
    }

    /**
     * Verifica si hay conexi√≥n en este momento (s√≠ncrono).
     */
    fun isCurrentlyOnline(): Boolean {
        val capabilities = connectivityManager.getNetworkCapabilities(
            connectivityManager.activeNetwork
        )
        return capabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) == true
    }

    /**
     * Tiempo en segundos desde que se perdi√≥ la conexi√≥n.
     * Retorna 0 si est√° online.
     */
    fun secondsOffline(): Long {
        return if (_isOnline.value) {
            0
        } else {
            (System.currentTimeMillis() - _lastOnlineTime.value) / 1000
        }
    }
}

enum class ConnectionType {
    WIFI,
    CELLULAR,
    ETHERNET,
    OTHER,
    NONE,
    UNKNOWN
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/services/NotificationFactory.kt`

```kotlin
package com.georacing.georacing.services

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.graphics.Color
import android.os.Build
import android.widget.RemoteViews
import androidx.core.app.NotificationCompat
import com.georacing.georacing.MainActivity
import com.georacing.georacing.R
import com.georacing.georacing.domain.model.EmergencyType
import com.georacing.georacing.domain.model.LiveSessionState

/**
 * Factory for creating "Live Activity" style notifications.
 * 
 * Samsung NowBar Hack:
 * - CATEGORY_NAVIGATION: Triggers the green status bar pill.
 * - CATEGORY_ALARM: For emergencies, bypasses DND.
 * - setColorized(true): Forces color background on Samsung.
 */
class NotificationFactory(private val context: Context) {

    companion object {
        const val CHANNEL_ID_NAVIGATION = "live_navigation_channel"
        const val CHANNEL_ID_EMERGENCY = "live_emergency_channel"
        const val NOTIFICATION_ID = 3001
    }

    init {
        createChannels()
    }

    private fun createChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val manager = context.getSystemService(NotificationManager::class.java)

            // Navigation Channel (Medium Priority, Silent Updates)
            val navChannel = NotificationChannel(
                CHANNEL_ID_NAVIGATION,
                "Live Navigation",
                NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "Real-time navigation updates"
                setShowBadge(false)
                setSound(null, null)
            }

            // Emergency Channel (Max Priority, Bypass DND)
            val emergencyChannel = NotificationChannel(
                CHANNEL_ID_EMERGENCY,
                "Emergency Alerts",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Critical safety alerts"
                enableVibration(true)
                setBypassDnd(true)
            }

            manager.createNotificationChannels(listOf(navChannel, emergencyChannel))
        }
    }

    /**
     * Builds a notification based on the current session state.
     */
    fun build(state: LiveSessionState): Notification {
        return when (state) {
            is LiveSessionState.Idle -> buildIdleNotification()
            is LiveSessionState.Navigation -> buildNavigationNotification(state)
            is LiveSessionState.Emergency -> buildEmergencyNotification(state)
        }
    }

    private fun buildIdleNotification(): Notification {
        return NotificationCompat.Builder(context, CHANNEL_ID_NAVIGATION)
            .setSmallIcon(R.mipmap.ic_launcher_round)
            .setContentTitle("GeoRacing")
            .setContentText("Sesi√≥n activa")
            .setOngoing(true)
            .setOnlyAlertOnce(true)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .build()
    }

    private fun buildNavigationNotification(state: LiveSessionState.Navigation): Notification {
        val remoteViews = createNavigationRemoteViews(state)
        val contentIntent = createMainActivityIntent()

        return NotificationCompat.Builder(context, CHANNEL_ID_NAVIGATION)
            .setSmallIcon(R.mipmap.ic_launcher_round)
            .setCustomContentView(remoteViews)
            .setCustomBigContentView(remoteViews)
            .setStyle(NotificationCompat.DecoratedCustomViewStyle())
            .setContentIntent(contentIntent)
            
            // ========== SAMSUNG NOWBAR HACK ==========
            .setCategory(Notification.CATEGORY_NAVIGATION) // üü¢ Green Pill
            .setColorized(true)
            .setColor(Color.BLACK) // OLED Friendly
            
            // ========== ENERGY EFFICIENCY ==========
            .setOngoing(true)
            .setOnlyAlertOnce(true) // Silent updates
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
            .build()
    }

    private fun buildEmergencyNotification(state: LiveSessionState.Emergency): Notification {
        val remoteViews = createEmergencyRemoteViews(state)
        val contentIntent = createMainActivityIntent()

        val title = when (state.type) {
            EmergencyType.EVACUATION -> "üÜò EVACUACI√ìN"
            EmergencyType.RED_FLAG -> "üî¥ BANDERA ROJA"
            EmergencyType.MEDICAL -> "üè• EMERGENCIA M√âDICA"
            EmergencyType.SECURITY -> "üîí ALERTA SEGURIDAD"
        }

        return NotificationCompat.Builder(context, CHANNEL_ID_EMERGENCY)
            .setSmallIcon(android.R.drawable.ic_dialog_alert)
            .setContentTitle(title)
            .setContentText(state.message.ifEmpty { "Siga las instrucciones: ${state.exitRoute}" })
            .setCustomContentView(remoteViews)
            .setCustomBigContentView(remoteViews)
            .setStyle(NotificationCompat.DecoratedCustomViewStyle())
            .setContentIntent(contentIntent)
            
            // ========== SAMSUNG EMERGENCY MODE ==========
            .setCategory(Notification.CATEGORY_ALARM) // üî¥ Bypasses DND
            .setColorized(true)
            .setColor(Color.RED) // High Alert Color
            
            // ========== MAX PRIORITY ==========
            .setOngoing(true)
            .setOnlyAlertOnce(false) // Allow re-alerting
            .setPriority(NotificationCompat.PRIORITY_MAX)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
            .build()
    }

    private fun createNavigationRemoteViews(state: LiveSessionState.Navigation): RemoteViews {
        val remoteViews = RemoteViews(context.packageName, R.layout.notification_live_status)
        remoteViews.setTextViewText(R.id.tvStatus, state.instruction)
        remoteViews.setTextViewText(R.id.tvDistance, "${state.distanceMeters} m")
        remoteViews.setTextViewText(R.id.tvTime, "${state.distanceMeters / 80} min") // ~80m/min walk
        remoteViews.setProgressBar(R.id.progressBar, 100, state.progress, false)
        return remoteViews
    }

    private fun createEmergencyRemoteViews(state: LiveSessionState.Emergency): RemoteViews {
        val remoteViews = RemoteViews(context.packageName, R.layout.notification_live_status)
        remoteViews.setTextViewText(R.id.tvStatus, "‚ö†Ô∏è ${state.type.name}")
        remoteViews.setTextViewText(R.id.tvDistance, state.exitRoute)
        remoteViews.setTextViewText(R.id.tvTime, "AHORA")
        remoteViews.setProgressBar(R.id.progressBar, 100, 100, false)
        return remoteViews
    }

    private fun createMainActivityIntent(): PendingIntent {
        val intent = Intent(context, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }
        return PendingIntent.getActivity(
            context, 0, intent,
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/services/StatePollingService.kt`

```kotlin
package com.georacing.georacing.services

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.Service
import android.content.Context
import android.content.Intent
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.core.app.NotificationCompat
import com.georacing.georacing.data.remote.RetrofitClient
import com.georacing.georacing.ui.evacuation.EvacuationActivity
import kotlinx.coroutines.*

class StatePollingService : Service() {
    private val job = SupervisorJob()
    private val scope = CoroutineScope(Dispatchers.IO + job)
    private var lastKnownMode: String? = null
    private var isEvacuationActive = false
    
    // Hybrid Components
    private lateinit var beaconScanner: com.georacing.georacing.data.ble.BeaconScanner
    private lateinit var beaconAdvertiser: com.georacing.georacing.data.ble.BeaconAdvertiser
    private lateinit var repository: com.georacing.georacing.data.repository.HybridCircuitStateRepository

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Ensure polling/collecting is active if restarted
        if (!job.isActive) startMonitoring()
        return START_STICKY
    }

    override fun onCreate() {
        super.onCreate()
        createNotificationChannels()
        // Promote to Foreground Service immediately to alert user we are monitoring
        startForeground(999, createMonitoringNotification())
        
        // Initialize Hybrid Repo
        beaconScanner = com.georacing.georacing.data.ble.BeaconScanner(this)
        beaconAdvertiser = com.georacing.georacing.data.ble.BeaconAdvertiser(this)
        repository = com.georacing.georacing.data.repository.HybridCircuitStateRepository(
             com.georacing.georacing.data.repository.NetworkCircuitStateRepository(),
             beaconScanner
        )
        
        // Start BLE Scan (Service Lifecycle)
        beaconScanner.startScanning()

        startMonitoring()
    }

    private fun startMonitoring() {
        // Parallel Job: Order Status Polling (Every 30s) + BLE Advertising Keep-Alive
        scope.launch {
            val auth = com.google.firebase.auth.FirebaseAuth.getInstance()
            val api = com.georacing.georacing.data.firestorelike.FirestoreLikeClient.api
            val orderPrefs = applicationContext.getSharedPreferences("geo_racing_orders", Context.MODE_PRIVATE)
            val appPrefs = applicationContext.getSharedPreferences("georacing_prefs", Context.MODE_PRIVATE)
            
            while (isActive) {
                try {
                    val user = auth.currentUser
                    if (user != null) {
                         // BLE Location Sharing Logic
                         val activeGroupId = appPrefs.getString("active_group_id", null)
                         val isSharing = if (activeGroupId != null) appPrefs.getBoolean("is_sharing_$activeGroupId", false) else false
                         
                         if (isSharing && androidx.core.content.ContextCompat.checkSelfPermission(this@StatePollingService, android.Manifest.permission.ACCESS_FINE_LOCATION) == android.content.pm.PackageManager.PERMISSION_GRANTED) {
                              val fused = com.google.android.gms.location.LocationServices.getFusedLocationProviderClient(this@StatePollingService)
                              fused.lastLocation.addOnSuccessListener { loc ->
                                  beaconAdvertiser.startAdvertising(user.uid, loc?.latitude, loc?.longitude)
                              }.addOnFailureListener {
                                  beaconAdvertiser.startAdvertising(user.uid)
                              }
                         } else {
                              beaconAdvertiser.startAdvertising(user.uid)
                         }

                         val result = api.get(
                            com.georacing.georacing.data.firestorelike.FirestoreLikeApi.GetRequest(
                                table = "orders",
                                where = mapOf("user_uid" to user.uid, "status" to "READY")
                            )
                        )
                        
                        result.forEach { orderData ->
                             val orderId = orderData["order_id"] as? String ?: return@forEach
                             val wasNotified = orderPrefs.getBoolean("notified_$orderId", false)
            
                             if (!wasNotified) {
                                 showOrderNotification()
                                 orderPrefs.edit().putBoolean("notified_$orderId", true).apply()
                             }
                        }
                    }
                } catch (e: Exception) {
                    Log.e("StatePolling", "Order Poll / Adv Error", e)
                }
                delay(30000) // Check every 30 seconds
            }
        }

        scope.launch {
            // Ensure scanner is running (retries if permissions were missing initially)
            beaconScanner.startScanning()

            // Use Hybrid Flow which combines BLE + API Polling
            repository.getCircuitState().collect { state ->
                 try {
                    Log.d("StatePolling", "State Update: Mode=${state.mode}, Msg=${state.message}") // DEBUG LOG
                    
                    // Convert Domain Mode to String because legacy logic uses Strings
                    val modeString = when(state.mode) {
                        com.georacing.georacing.domain.model.CircuitMode.EVACUATION -> "EVACUATION"
                        else -> state.mode.name
                    }
                    
                    // Hybrid Logic: If MODE is RED_FLAG (Mapped from Evacuation or Red Flag), trigger alert?
                    // Original logic checked string "EVACUATION".
                    // The DTO says: "EVACUATION" -> CircuitMode.RED_FLAG.
                    // So if we receive RED_FLAG, it implies Evacuation or Red Flag.
                    // Let's check if the generic RED_FLAG should trigger EvacuationActivity.
                    // Probably SAFETY_CAR = Safety, RED_FLAG = Stop/Evac?
                    // I will check specific logic.
                    // BUT: The user prompt says "EVACUATION" is a distinct mode in their mental model.
                    // My BleParser maps 3 -> RED_FLAG.
                    // I should probably map 3 -> EVACUATION if I updated the Enum, but I didn't update the Enum.
                    // I will check if I should update CircuitMode Enum. 
                    // To be safe and compatible with legacy string logic:
                    
                    val isEvacuation = (state.mode == com.georacing.georacing.domain.model.CircuitMode.EVACUATION) 
                                       || (state.message?.contains("EVACUATION", ignoreCase = true) == true)
                    
                    if (isEvacuation) {
                        if (!isEvacuationActive) {
                            Log.d("StatePolling", "üö® ACTIVATING EVACUATION (Mode: ${state.mode})")
                            
                            // Activate once
                            showEvacuationNotification()
                            isEvacuationActive = true
                        }
                    } else {
                        // EXIT Logic
                        if (isEvacuationActive) {
                            Log.d("StatePolling", "‚úÖ EXITING EVACUATION")
                            val intent = Intent("com.georacing.georacing.EXIT_EVACUATION")
                            intent.setPackage(packageName)
                            sendBroadcast(intent)
                            
                            // Cancel notification
                            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                            notificationManager.cancel(1)
                            
                            isEvacuationActive = false
                        }
                    }
                    lastKnownMode = state.mode.name

                } catch (e: Exception) {
                    Log.e("StatePolling", "Error processing state", e)
                }
            }
        }

        // DEBUG: Observe Scanner and Advertiser Info
        scope.launch {
             kotlinx.coroutines.flow.combine(
                 beaconScanner.debugInfo,
                 beaconAdvertiser.advertisingState
             ) { scan, adv ->
                 "Scan: ${scan.take(20)}.. | Adv: $adv"
             }.collect { info ->
                 updateMonitoringNotification(info)
             }
        }
    }



    private fun showOrderNotification() {
         val context = this
         val channelId = "order_updates"
         val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
 
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
             val channel = NotificationChannel(channelId, "Order Updates", NotificationManager.IMPORTANCE_HIGH)
             manager.createNotificationChannel(channel)
         }
 
         val resultIntent = Intent(context, com.georacing.georacing.MainActivity::class.java).apply {
             flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
             putExtra("navigate_to", "my_orders")
         }
         val pendingIntent = android.app.PendingIntent.getActivity(
             context, 0, resultIntent, 
             android.app.PendingIntent.FLAG_UPDATE_CURRENT or android.app.PendingIntent.FLAG_IMMUTABLE
         )
 
         val notification = NotificationCompat.Builder(context, channelId)
             .setContentTitle("¬°Tu pedido est√° listo!")
             .setContentText("Pasa por la barra para recoger tu comida.")
             .setSmallIcon(android.R.drawable.ic_dialog_info)
             .setContentIntent(pendingIntent)
             .setAutoCancel(true)
             .setPriority(NotificationCompat.PRIORITY_HIGH)
             .build()
 
         manager.notify(1001, notification)
    }

    private fun showEvacuationNotification() {
        // Notification only - Activity is handled in the loop for aggression
        
        // Prepare Full Screen Intent (for lock screen priority)
        val fullScreenIntent = Intent(this, EvacuationActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }
        val fullScreenPendingIntent = android.app.PendingIntent.getActivity(
            this, 
            0, 
            fullScreenIntent, 
            android.app.PendingIntent.FLAG_UPDATE_CURRENT or android.app.PendingIntent.FLAG_IMMUTABLE
        )

        val notification = NotificationCompat.Builder(this, "EMERGENCY_CHANNEL_V2")
            .setContentTitle("‚ö†Ô∏è ORDEN DE EVACUACI√ìN")
            .setContentText("Emergencia detectada. Siga las instrucciones inmediatamente.")
            .setSmallIcon(android.R.drawable.ic_dialog_alert)
            .setPriority(NotificationCompat.PRIORITY_MAX)
            .setCategory(NotificationCompat.CATEGORY_ALARM)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
            .setFullScreenIntent(fullScreenPendingIntent, true) 
            .setAutoCancel(true)
            .build()
        
        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        notificationManager.notify(1, notification)
        
        // Explicitly launch activity to ensure window opens even if screen is on
        try {
            startActivity(fullScreenIntent)
        } catch (e: Exception) {
            Log.e("StatePolling", "Direct launch failed", e)
        }
    }

    private fun createMonitoringNotification(): android.app.Notification {
        return NotificationCompat.Builder(this, "MONITORING_CHANNEL")
            .setContentTitle("GeoRacing Security")
            .setContentText("Iniciando esc√°ner...")
            .setSmallIcon(android.R.drawable.ic_menu_compass)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setOnlyAlertOnce(true)
            .build()
    }

    private fun updateMonitoringNotification(text: String) {
        val notification = NotificationCompat.Builder(this, "MONITORING_CHANNEL")
            .setContentTitle("GeoRacing BLE Debug")
            .setContentText(text)
            .setSmallIcon(android.R.drawable.ic_menu_compass)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setOnlyAlertOnce(true)
            .build()
        
        val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        manager.notify(999, notification)
    }

    private fun createNotificationChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val manager = getSystemService(NotificationManager::class.java)
            
            // 1. Critical Alert Channel (V2 to force update)
            val emergencyChannel = NotificationChannel(
                "EMERGENCY_CHANNEL_V2",
                "Emergency Alerts",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Critical alerts for evacuation"
                enableVibration(true)
                lockscreenVisibility = android.app.Notification.VISIBILITY_PUBLIC
                setBypassDnd(true) // Attempt to bypass Do Not Disturb
            }
            
            // 2. Background Service Channel
            val monitoringChannel = NotificationChannel(
                "MONITORING_CHANNEL",
                "Service Monitoring",
                NotificationManager.IMPORTANCE_LOW
            )

            manager.createNotificationChannels(listOf(emergencyChannel, monitoringChannel))
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
        try {
            beaconScanner.stopScanning()
            beaconAdvertiser.stopAdvertising()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/services/VoiceCommandManager.kt`

```kotlin
package com.georacing.georacing.services

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.speech.RecognitionListener
import android.speech.RecognizerIntent
import android.speech.SpeechRecognizer
import android.util.Log
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * Servicio de comandos de voz para la navegaci√≥n GeoRacing.
 *
 * Soporta comandos en espa√±ol:
 * - "Buscar [lugar]" ‚Üí Busca un POI o destino
 * - "Ir a [destino]" ‚Üí Navega al destino
 * - "Evitar autopistas" ‚Üí Recalcula sin autopistas
 * - "Evitar peajes" ‚Üí Recalcula sin peajes
 * - "Gasolinera" ‚Üí Busca gasolinera cercana
 * - "Parking" ‚Üí Busca parking cercano
 * - "Parar navegaci√≥n" ‚Üí Detiene la navegaci√≥n
 * - "Silencio" ‚Üí Mutea las indicaciones de voz
 * - "Repetir" ‚Üí Repite la √∫ltima instrucci√≥n
 * - "¬øCu√°nto falta?" ‚Üí Anuncia ETA y distancia restante
 */
class VoiceCommandManager(private val context: Context) {

    companion object {
        private const val TAG = "VoiceCommandManager"
    }

    // ‚îÄ‚îÄ Estado ‚îÄ‚îÄ

    private val _isListening = MutableStateFlow(false)
    val isListening: StateFlow<Boolean> = _isListening.asStateFlow()

    private val _lastCommand = MutableStateFlow<VoiceCommand?>(null)
    val lastCommand: StateFlow<VoiceCommand?> = _lastCommand.asStateFlow()

    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()

    private var speechRecognizer: SpeechRecognizer? = null
    private var callback: VoiceCommandCallback? = null

    // ‚îÄ‚îÄ Modelos ‚îÄ‚îÄ

    sealed class VoiceCommand {
        data class Search(val query: String) : VoiceCommand()
        data class NavigateTo(val destination: String) : VoiceCommand()
        data object AvoidHighways : VoiceCommand()
        data object AvoidTolls : VoiceCommand()
        data object FindGasStation : VoiceCommand()
        data object FindParking : VoiceCommand()
        data object StopNavigation : VoiceCommand()
        data object Mute : VoiceCommand()
        data object Unmute : VoiceCommand()
        data object RepeatInstruction : VoiceCommand()
        data object QueryETA : VoiceCommand()
        data object FindRestaurant : VoiceCommand()
        data object FindWC : VoiceCommand()
        data object FindMedical : VoiceCommand()
        data class Unknown(val rawText: String) : VoiceCommand()
    }

    interface VoiceCommandCallback {
        fun onCommand(command: VoiceCommand)
        fun onError(message: String)
    }

    // ‚îÄ‚îÄ API p√∫blica ‚îÄ‚îÄ

    fun isAvailable(): Boolean {
        return SpeechRecognizer.isRecognitionAvailable(context)
    }

    fun setCallback(cb: VoiceCommandCallback) {
        callback = cb
    }

    fun startListening() {
        if (!isAvailable()) {
            Log.w(TAG, "Speech recognition not available")
            _error.value = "Reconocimiento de voz no disponible"
            return
        }

        try {
            speechRecognizer?.destroy()
            speechRecognizer = SpeechRecognizer.createSpeechRecognizer(context)
            speechRecognizer?.setRecognitionListener(recognitionListener)

            val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
                putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
                putExtra(RecognizerIntent.EXTRA_LANGUAGE, "es-ES")
                putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 3)
                putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS, true)
                putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_MINIMUM_LENGTH_MILLIS, 1500L)
            }

            speechRecognizer?.startListening(intent)
            _isListening.value = true
            _error.value = null
            Log.d(TAG, "üé§ Listening started")
        } catch (e: Exception) {
            Log.e(TAG, "Error starting speech recognition", e)
            _error.value = "Error al iniciar reconocimiento: ${e.message}"
            _isListening.value = false
        }
    }

    fun stopListening() {
        speechRecognizer?.stopListening()
        _isListening.value = false
        Log.d(TAG, "üé§ Listening stopped")
    }

    fun destroy() {
        speechRecognizer?.destroy()
        speechRecognizer = null
        _isListening.value = false
    }

    // ‚îÄ‚îÄ Parseo de comandos ‚îÄ‚îÄ

    private fun parseCommand(text: String): VoiceCommand {
        val lower = text.lowercase().trim()
        Log.d(TAG, "üé§ Parsing: '$lower'")

        return when {
            // Navegaci√≥n
            lower.startsWith("ir a ") -> VoiceCommand.NavigateTo(lower.removePrefix("ir a ").trim())
            lower.startsWith("navegar a ") -> VoiceCommand.NavigateTo(lower.removePrefix("navegar a ").trim())
            lower.startsWith("ll√©vame a ") -> VoiceCommand.NavigateTo(lower.removePrefix("ll√©vame a ").trim())

            // B√∫squeda
            lower.startsWith("buscar ") -> VoiceCommand.Search(lower.removePrefix("buscar ").trim())
            lower.startsWith("busca ") -> VoiceCommand.Search(lower.removePrefix("busca ").trim())
            lower.startsWith("d√≥nde est√° ") -> VoiceCommand.Search(lower.removePrefix("d√≥nde est√° ").trim())
            lower.startsWith("donde est√° ") -> VoiceCommand.Search(lower.removePrefix("donde est√° ").trim())

            // Evitar
            lower.contains("evitar autopista") || lower.contains("sin autopista") -> VoiceCommand.AvoidHighways
            lower.contains("evitar peaje") || lower.contains("sin peaje") -> VoiceCommand.AvoidTolls

            // POIs r√°pidos
            lower.contains("gasolinera") || lower.contains("gasolina") || lower.contains("combustible") -> VoiceCommand.FindGasStation
            lower.contains("parking") || lower.contains("aparcar") || lower.contains("aparcamiento") -> VoiceCommand.FindParking
            lower.contains("restaurante") || lower.contains("comida") || lower.contains("comer") -> VoiceCommand.FindRestaurant
            lower.contains("ba√±o") || lower.contains("aseo") || lower.contains("lavabo") -> VoiceCommand.FindWC
            lower.contains("m√©dico") || lower.contains("hospital") || lower.contains("urgencia") -> VoiceCommand.FindMedical

            // Control
            lower.contains("parar navegaci√≥n") || lower.contains("detener navegaci√≥n") || lower.contains("cancelar ruta") -> VoiceCommand.StopNavigation
            lower.contains("silencio") || lower.contains("mute") || lower.contains("calla") -> VoiceCommand.Mute
            lower.contains("activar voz") || lower.contains("unmute") || lower.contains("habla") -> VoiceCommand.Unmute
            lower.contains("repetir") || lower.contains("repite") || lower.contains("otra vez") -> VoiceCommand.RepeatInstruction
            lower.contains("cu√°nto falta") || lower.contains("cuanto falta") || lower.contains("tiempo") && lower.contains("llegar") -> VoiceCommand.QueryETA

            // No reconocido
            else -> VoiceCommand.Unknown(text)
        }
    }

    // ‚îÄ‚îÄ Recognition Listener ‚îÄ‚îÄ

    private val recognitionListener = object : RecognitionListener {
        override fun onReadyForSpeech(params: Bundle?) {
            Log.d(TAG, "üé§ Ready for speech")
        }

        override fun onBeginningOfSpeech() {
            Log.d(TAG, "üé§ Speech started")
        }

        override fun onRmsChanged(rmsdB: Float) {}

        override fun onBufferReceived(buffer: ByteArray?) {}

        override fun onEndOfSpeech() {
            _isListening.value = false
            Log.d(TAG, "üé§ Speech ended")
        }

        override fun onError(error: Int) {
            _isListening.value = false
            val errorMsg = when (error) {
                SpeechRecognizer.ERROR_AUDIO -> "Error de audio"
                SpeechRecognizer.ERROR_CLIENT -> "Error del cliente"
                SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS -> "Sin permisos de micr√≥fono"
                SpeechRecognizer.ERROR_NETWORK -> "Error de red"
                SpeechRecognizer.ERROR_NETWORK_TIMEOUT -> "Timeout de red"
                SpeechRecognizer.ERROR_NO_MATCH -> "No se reconoci√≥ el comando"
                SpeechRecognizer.ERROR_RECOGNIZER_BUSY -> "Reconocedor ocupado"
                SpeechRecognizer.ERROR_SERVER -> "Error del servidor"
                SpeechRecognizer.ERROR_SPEECH_TIMEOUT -> "No se detect√≥ voz"
                else -> "Error desconocido ($error)"
            }
            Log.w(TAG, "üé§ Error: $errorMsg")
            _error.value = errorMsg
            callback?.onError(errorMsg)
        }

        override fun onResults(results: Bundle?) {
            _isListening.value = false
            val matches = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
            if (!matches.isNullOrEmpty()) {
                val bestMatch = matches[0]
                Log.d(TAG, "üé§ Result: '$bestMatch'")
                val command = parseCommand(bestMatch)
                _lastCommand.value = command
                callback?.onCommand(command)
            }
        }

        override fun onPartialResults(partialResults: Bundle?) {
            val partial = partialResults?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
            if (!partial.isNullOrEmpty()) {
                Log.v(TAG, "üé§ Partial: '${partial[0]}'")
            }
        }

        override fun onEvent(eventType: Int, params: Bundle?) {}
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/AppMonitorManager.kt`

```kotlin
package com.georacing.georacing.ui

import android.util.Log
import com.georacing.georacing.data.ble.BeaconScanner
import com.georacing.georacing.domain.model.AppPowerState
import com.georacing.georacing.services.BatteryMonitor
import com.georacing.georacing.services.NetworkMonitor
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch

/**
 * AppMonitorManager centralizes background monitoring logic that was
 * previously embedded in GeoRacingNavHost LaunchedEffect blocks.
 *
 * This class should be initialized once at the Application or Activity level
 * and held as a singleton in the AppContainer.
 *
 * Responsibilities:
 * - BLE beacon scanning start
 * - Battery monitoring + critical state callback
 * - Network monitoring + offline/online logging
 */
class AppMonitorManager(
    private val beaconScanner: BeaconScanner,
    private val batteryMonitor: BatteryMonitor,
    private val networkMonitor: NetworkMonitor
) {
    companion object {
        private const val TAG = "AppMonitorManager"
    }

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)
    private var isStarted = false

    // ‚îÄ‚îÄ Exposed state flows (UI can collect these) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    /** Current power state (NORMAL, POWER_SAVE, CRITICAL). */
    val powerState: StateFlow<AppPowerState> get() = batteryMonitor.powerState

    /** Current battery level (0-100). */
    val batteryLevel: StateFlow<Int> get() = batteryMonitor.batteryLevel

    /** Whether the device currently has network connectivity. */
    val isOnline: StateFlow<Boolean> get() = networkMonitor.isOnline

    /** Current connection type (WIFI, CELLULAR, etc.). */
    val connectionType: StateFlow<com.georacing.georacing.services.ConnectionType>
        get() = networkMonitor.connectionType

    // ‚îÄ‚îÄ Callback for critical battery (navigation is UI-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    /**
     * Called when battery state transitions to CRITICAL.
     * The NavHost should set this to trigger emergency navigation.
     */
    var onCriticalBattery: ((batteryLevel: Int) -> Unit)? = null

    // ‚îÄ‚îÄ Lifecycle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    /**
     * Starts all monitors. Safe to call multiple times (idempotent).
     * Should be called from Activity.onCreate or Application.onCreate.
     */
    fun startAll() {
        if (isStarted) return
        isStarted = true

        // 1. BLE Beacon Scanning
        if (!beaconScanner.isScanningValue) {
            beaconScanner.startScanning()
            Log.d(TAG, "BLE beacon scanning started")
        }

        // 2. Battery Monitoring + Kill Switch
        batteryMonitor.startMonitoring()
        Log.d(TAG, "Battery monitoring started")

        scope.launch {
            batteryMonitor.powerState.collect { state ->
                if (state == AppPowerState.CRITICAL) {
                    val level = batteryMonitor.batteryLevel.value
                    Log.w(TAG, "üÜò CRITICAL BATTERY ($level%) - invoking onCriticalBattery callback")
                    onCriticalBattery?.invoke(level)
                }
            }
        }

        // 3. Network Monitoring + Logging
        networkMonitor.startMonitoring()
        Log.d(TAG, "Network monitoring started")

        networkMonitor.isOnline
            .onEach { online ->
                if (!online) {
                    Log.w(TAG, "üì° OFFLINE - Relying on BLE beacons (physical + staff phones)")
                } else {
                    Log.d(TAG, "üåê ONLINE - Network: ${networkMonitor.connectionType.value}")
                }
            }
            .launchIn(scope)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/CircuitStatusCard.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Flag
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.domain.model.CircuitMode
import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LocalBackdrop

@Composable
fun CircuitStatusCard(
    mode: CircuitMode,
    message: String?,
    temperature: String, // unused in card, moved to header
    modifier: Modifier = Modifier
) {
    // Colors & Text based on state
    val (statusColor, titleText, iconVector) = when (mode) {
        CircuitMode.NORMAL -> Triple(Color(0xFF22C55E), "PISTA LIBRE", Icons.Filled.Flag)
        CircuitMode.GREEN_FLAG -> Triple(Color(0xFF22C55E), "BANDERA VERDE", Icons.Filled.Flag)
        CircuitMode.YELLOW_FLAG -> Triple(Color(0xFFFFA726), "BANDERA AMARILLA", Icons.Filled.Flag)
        CircuitMode.VSC -> Triple(Color(0xFFFFA726), "VSC", Icons.Filled.Flag)
        CircuitMode.SAFETY_CAR -> Triple(Color(0xFFFFA726), "SAFETY CAR", Icons.Filled.Flag)
        CircuitMode.RED_FLAG -> Triple(Color(0xFFEF4444), "BANDERA ROJA", Icons.Filled.Flag)
        CircuitMode.EVACUATION -> Triple(Color(0xFFEF4444), "EVACUACI√ìN", Icons.Filled.Flag)
        CircuitMode.UNKNOWN -> Triple(Color(0xFF64748B), "DESCONECTADO", Icons.Filled.Flag)
    }

    val backdrop = LocalBackdrop.current

    LiquidCard(
        backdrop = backdrop,
        modifier = modifier
            .fillMaxWidth()
            .height(200.dp),
        cornerRadius = 28.dp,
        surfaceColor = Color(0xFF0E0E18).copy(alpha = 0.85f),
        tint = statusColor.copy(alpha = 0.12f)
    ) {
        // CONTENT
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(top = 24.dp, start = 24.dp, end = 24.dp, bottom = 0.dp)
        ) {
            
            // Top Row: Icon + Digital Text
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.Top
            ) {
                // Circle Icon
                Box(
                    modifier = Modifier
                        .size(64.dp)
                        .clip(CircleShape)
                        .background(
                            brush = Brush.linearGradient(
                                colors = listOf(
                                    statusColor.copy(alpha = 0.2f),
                                    Color(0xFF1E293B)
                                )
                            )
                        )
                        .border(1.dp, statusColor.copy(alpha = 0.3f), CircleShape),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        imageVector = iconVector,
                        contentDescription = null,
                        tint = Color.White,
                        modifier = Modifier.size(32.dp)
                    )
                }

                // Digital Info Block
                Column(
                    horizontalAlignment = Alignment.End
                ) {
                    Text(
                        text = "/ 2:9 / 006P", // Mock data mimicking image
                        style = MaterialTheme.typography.titleLarge.copy(
                            fontWeight = FontWeight.Bold,
                            fontFamily = androidx.compose.ui.text.font.FontFamily.Monospace,
                            letterSpacing = 1.sp
                        ),
                        color = Color.White.copy(alpha = 0.5f)
                    )
                    Spacer(modifier = Modifier.height(4.dp))
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                         Text(
                            text = "PM",
                            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold),
                            color = Color.White.copy(alpha = 0.3f)
                        )
                         Spacer(modifier = Modifier.width(8.dp))
                         Text(
                            text = "MAP - SENI",
                            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold),
                            color = Color.White.copy(alpha = 0.3f)
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(24.dp))

            // Main Status Text
            Text(
                text = titleText,
                style = MaterialTheme.typography.headlineLarge.copy(
                    fontWeight = FontWeight.Black,
                    fontSize = 32.sp
                ),
                color = Color.White
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Dashed Status Bar
            androidx.compose.foundation.Canvas(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(12.dp)
            ) {
                val dashWidth = 6.dp.toPx()
                val dashHeight = size.height
                val spacing = 4.dp.toPx()
                val skewOffset = 4.dp.toPx() // How much to slant

                var currentX = 0f
                while (currentX < size.width) {
                    val path = androidx.compose.ui.graphics.Path().apply {
                         // Skewed Rectangle (Parallelogram)
                         // Top-Left -> Top-Right -> Bottom-Right -> Bottom-Left
                        moveTo(currentX + skewOffset, 0f)
                        lineTo(currentX + dashWidth + skewOffset, 0f)
                        lineTo(currentX + dashWidth, dashHeight)
                        lineTo(currentX, dashHeight)
                        close()
                    }
                    drawPath(path, color = statusColor.copy(alpha = 0.8f))
                    currentX += dashWidth + spacing
                }
            }
        }
        
        // FOOTER STRIPES: Red/White Hazard Pattern at very bottom
        Box(
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .fillMaxWidth()
                .height(16.dp) // Stripe height
                .background(
                    brush = Brush.linearGradient(
                        colors = listOf(
                            Color(0xFFB00020), Color(0xFFB00020), // Red
                            Color.White, Color.White // White
                        ),
                        start = androidx.compose.ui.geometry.Offset.Zero,
                        end = androidx.compose.ui.geometry.Offset(40f, 40f), // Angle of stripes
                        tileMode = androidx.compose.ui.graphics.TileMode.Repeated
                    )
                )
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/Components.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.animation.animateColorAsState
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CutCornerShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Home
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Shape
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import com.georacing.georacing.ui.theme.liquidGlass
import com.georacing.georacing.ui.theme.GlassLevel
import com.georacing.georacing.ui.theme.TextPrimary
import com.georacing.georacing.ui.theme.glassSmall
import androidx.compose.ui.unit.sp
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.animation.core.spring
import androidx.compose.animation.core.Spring

@Composable
fun CockpitButton(
    text: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    icon: ImageVector? = null,
    enabled: Boolean = true,
    containerColor: Color = MaterialTheme.colorScheme.primary,
    contentColor: Color = MaterialTheme.colorScheme.onPrimary
) {
    Button(
        onClick = onClick,
        modifier = modifier.height(56.dp),
        enabled = enabled,
        shape = CutCornerShape(topStart = 14.dp, bottomEnd = 14.dp),
        colors = ButtonDefaults.buttonColors(
            containerColor = containerColor,
            contentColor = contentColor,
            disabledContainerColor = containerColor.copy(alpha = 0.4f)
        ),
        elevation = ButtonDefaults.buttonElevation(
            defaultElevation = 6.dp,
            pressedElevation = 1.dp
        )
    ) {
        Row(
            verticalAlignment = Alignment.CenterVertically,
            modifier = Modifier.padding(horizontal = 8.dp)
        ) {
            if (icon != null) {
                Icon(
                    imageVector = icon,
                    contentDescription = text,
                    modifier = Modifier.size(22.dp)
                )
                Spacer(modifier = Modifier.width(10.dp))
            }
            Text(
                text = text.uppercase(),
                style = MaterialTheme.typography.labelLarge
            )
        }
    }
}

@Composable
fun DashboardCard(
    modifier: Modifier = Modifier,
    title: String? = null,
    content: @Composable () -> Unit
) {
    Card(
        modifier = modifier,
        shape = RoundedCornerShape(16.dp),
        colors = CardDefaults.cardColors(
            containerColor = Color(0xFF14141C),
            contentColor = MaterialTheme.colorScheme.onSurface
        ),
        border = androidx.compose.foundation.BorderStroke(
            0.5.dp, 
            Color.White.copy(alpha = 0.08f)
        )
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            if (title != null) {
                Text(
                    text = title.uppercase(),
                    style = MaterialTheme.typography.labelSmall,
                    color = Color(0xFF64748B),
                    letterSpacing = 1.5.sp
                )
                Spacer(modifier = Modifier.height(10.dp))
            }
            content()
        }
    }
}

@Composable
fun RacingIcon(
    icon: ImageVector,
    modifier: Modifier = Modifier,
    tint: Color = MaterialTheme.colorScheme.primary
) {
    // In a real implementation, we might apply a skew transform here
    Icon(
        imageVector = icon,
        contentDescription = "Icono",
        modifier = modifier,
        tint = tint
    )
}

@Composable
fun Sidebar(
    isOpen: Boolean,
    onClose: () -> Unit,
    content: @Composable () -> Unit
) {
    val offsetX by animateDpAsState(
        targetValue = if (isOpen) 0.dp else (-320).dp,
        animationSpec = spring(
            dampingRatio = Spring.DampingRatioLowBouncy,
            stiffness = Spring.StiffnessLow
        ),
        label = "offsetX"
    )
    
    val alpha by animateFloatAsState(
        targetValue = if (isOpen) 1f else 0f,
        animationSpec = tween(durationMillis = 300),
        label = "alpha"
    )
    
    if (isOpen || offsetX > (-320).dp) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black.copy(alpha = 0.6f * alpha))
                .clickable(enabled = isOpen) { onClose() }
        ) {
            // Sidebar Container
            Box(
                modifier = Modifier
                    .fillMaxHeight()
                    .width(300.dp)
                    .offset(x = offsetX)
                    .clickable(enabled = false) {}
                    // Liquid Glass Background
                    .liquidGlass(
                        shape = RoundedCornerShape(topEnd = 32.dp, bottomEnd = 32.dp),
                        level = GlassLevel.L2
                    )
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(24.dp)
                ) {
                    // Header: Title + Close Button
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(bottom = 32.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            Box(
                                modifier = Modifier
                                    .size(8.dp)
                                    .background(
                                        MaterialTheme.colorScheme.primary,
                                        shape = CircleShape
                                    )
                            )
                            Spacer(modifier = Modifier.width(10.dp))
                            Text(
                                text = "MENU",
                                style = MaterialTheme.typography.headlineMedium.copy(
                                    fontWeight = FontWeight.Black,
                                    letterSpacing = 2.sp
                                ),
                                color = TextPrimary
                            )
                        }
                        
                        IconButton(
                            onClick = onClose,
                            modifier = Modifier
                                .size(40.dp)
                                .glassSmall(shape = CircleShape)
                        ) {
                            Icon(
                                Icons.Default.Close, 
                                contentDescription = "Cerrar",
                                tint = TextPrimary
                            )
                        }
                    }
                    
                    // Content Slot
                    Box(modifier = Modifier.weight(1f)) {
                        content()
                    }
                    
                    // Footer: Logout or Branding (Optional placeholder)
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(top = 16.dp)
                            .glassSmall(shape = RoundedCornerShape(12.dp))
                            .clickable { onClose() }
                            .padding(16.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = "CERRAR SESI√ìN",
                            style = MaterialTheme.typography.labelLarge,
                            color = Color(0xFFEF4444)
                        )
                    }
                    
                    Spacer(modifier = Modifier.height(32.dp)) // System bar spacing
                }
            }
        }
    }
}

@Composable
fun HomeIconButton(onClick: () -> Unit) {
    IconButton(onClick = onClick) {
        Icon(
            imageVector = Icons.Default.Home,
            contentDescription = "Volver al inicio",
            tint = MaterialTheme.colorScheme.primary
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/ConnectivityAwareScaffold.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.tween
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Warning
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.debug.ScenarioSimulator

@Composable
fun ConnectivityAwareScaffold(
    content: @Composable () -> Unit
) {
    val isNetworkDead by ScenarioSimulator.isNetworkDead.collectAsState()

    Box(modifier = Modifier.fillMaxSize()) {
        
        // Main Content (Always rendered, but covered when dead)
        content()

        // Dead State Overlay (Terminal Style)
        if (isNetworkDead) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(Color(0xFF0E0E18)) // Racing Dark Surface
                    .padding(32.dp),
                contentAlignment = Alignment.Center
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(24.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Warning,
                        contentDescription = "Critical Failure",
                        tint = Color(0xFFE8253A), // Racing Red
                        modifier = Modifier.size(80.dp)
                    )

                    Text(
                        text = "CRITICAL NETWORK FAILURE\nERROR 503",
                        color = Color(0xFF06B6D4),
                        fontSize = 20.sp,
                        fontFamily = FontFamily.Monospace,
                        fontWeight = FontWeight.Bold,
                        letterSpacing = 1.5.sp,
                        textAlign = androidx.compose.ui.text.style.TextAlign.Center
                    )

                    Text(
                        text = "ACTIVATING OFFLINE PROTOCOL...\nESTABLISHING MESH NODE...",
                        color = Color(0xFF06B6D4).copy(alpha = 0.8f),
                        fontSize = 14.sp,
                        fontFamily = FontFamily.Monospace,
                        letterSpacing = 1.5.sp,
                        textAlign = androidx.compose.ui.text.style.TextAlign.Center
                    )

                    Spacer(modifier = Modifier.height(32.dp))

                    // Static Vital Data
                    TerminalDataRow("Ubicaci√≥n segura:", "PUERTA 3")
                    TerminalDataRow("Ticket Status:", "CACHED (VALID)")
                    TerminalDataRow("Emergency Route:", "DOWNLOADED")

                    Spacer(modifier = Modifier.height(48.dp))

                    // Offline Action Button
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .border(2.dp, Color(0xFFF8FAFC), RoundedCornerShape(4.dp))
                            .clickable { /* Action for demo */ }
                            .padding(16.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = "VER TICKET OFFLINE",
                            color = Color(0xFFF8FAFC),
                            fontFamily = FontFamily.Monospace,
                            fontWeight = FontWeight.Bold,
                            letterSpacing = 1.5.sp
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun TerminalDataRow(label: String, value: String) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(
            text = label.uppercase(),
            color = Color(0xFF06B6D4).copy(alpha = 0.6f),
            fontFamily = FontFamily.Monospace,
            fontSize = 14.sp,
            letterSpacing = 1.5.sp
        )
        Text(
            text = value,
            color = Color(0xFF06B6D4),
            fontFamily = FontFamily.Monospace,
            fontWeight = FontWeight.Bold,
            fontSize = 14.sp
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/DashboardBottomBar.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import androidx.navigation.compose.currentBackStackEntryAsState
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.glass.GlassSupport
import com.georacing.georacing.ui.glass.LiquidBottomTabs
import com.georacing.georacing.ui.glass.LiquidBottomTab
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.glass.LiquidSurface

data class NavItem(
    val label: String,
    val icon: ImageVector,
    val route: String
)

@Composable
fun DashboardBottomBar(navController: NavController) {
    val navBackStackEntry by navController.currentBackStackEntryAsState()
    val currentRoute = navBackStackEntry?.destination?.route

    val items = listOf(
        NavItem("Inicio", Icons.Default.Home, Screen.Home.route),
        NavItem("Mapa", Icons.Default.Map, Screen.Map.route),
        NavItem("Alertas", Icons.Default.Notifications, Screen.Alerts.route),
        NavItem("Tienda", Icons.Default.ShoppingCart, Screen.Orders.route),
        NavItem("Ajustes", Icons.Default.Settings, Screen.Settings.route)
    )
    
    // Find current selected index
    val selectedIndex = items.indexOfFirst { it.route == currentRoute }.coerceAtLeast(0)

    if (GlassSupport.isEmulator) {
        // Fallback: simple bottom bar without any RuntimeShader/drawBackdrop usage
        FallbackBottomBar(
            items = items,
            selectedIndex = selectedIndex,
            currentRoute = currentRoute,
            navController = navController
        )
    } else {
        // Full Liquid Glass bottom bar (real device only)
        LiquidGlassBottomBar(
            items = items,
            selectedIndex = selectedIndex,
            currentRoute = currentRoute,
            navController = navController
        )
    }
}

@Composable
private fun LiquidGlassBottomBar(
    items: List<NavItem>,
    selectedIndex: Int,
    currentRoute: String?,
    navController: NavController
) {
    val backdrop = LocalBackdrop.current

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp)
            .padding(bottom = 4.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        LiquidBottomTabs(
            selectedTabIndex = { selectedIndex },
            onTabSelected = { index ->
                val targetRoute = items[index].route
                if (currentRoute != targetRoute) {
                    navController.navigate(targetRoute) {
                        popUpTo(Screen.Home.route) { saveState = false }
                        launchSingleTop = true
                        restoreState = false
                    }
                }
            },
            backdrop = backdrop,
            tabsCount = items.size,
            modifier = Modifier.fillMaxWidth()
        ) {
            items.forEachIndexed { index, item ->
                val isSelected = index == selectedIndex
                val color = if (isSelected) Color(0xFF00F0FF) else Color(0xFF8E8E93)
                
                LiquidBottomTab(
                    onClick = {
                        if (currentRoute != item.route) {
                            navController.navigate(item.route) {
                                popUpTo(Screen.Home.route) { saveState = true }
                                launchSingleTop = true
                                restoreState = true
                            }
                        }
                    }
                ) {
                    Icon(
                        imageVector = item.icon,
                        contentDescription = item.label,
                        tint = color,
                        modifier = Modifier.size(if (isSelected) 24.dp else 20.dp)
                    )
                    Spacer(modifier = Modifier.height(2.dp))
                    Text(
                        text = item.label.uppercase(),
                        style = MaterialTheme.typography.labelSmall.copy(
                            fontWeight = if (isSelected) FontWeight.ExtraBold else FontWeight.Medium,
                            fontSize = if (isSelected) 10.sp else 9.sp,
                            letterSpacing = 0.8.sp
                        ),
                        color = color
                    )
                }
            }
        }
    }
}

/**
 * Simple fallback bottom bar for emulators where RuntimeShader crashes.
 * Uses standard Compose drawing without any backdrop/shader effects.
 */
@Composable
private fun FallbackBottomBar(
    items: List<NavItem>,
    selectedIndex: Int,
    currentRoute: String?,
    navController: NavController
) {
    val backdrop = LocalBackdrop.current
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp)
            .padding(bottom = 4.dp)
    ) {
        LiquidSurface(
            backdrop = backdrop,
            modifier = Modifier
                .fillMaxWidth()
                .height(64.dp),
            cornerRadius = 32.dp,
            surfaceColor = com.georacing.georacing.ui.theme.AsphaltGrey.copy(alpha = 0.8f)
        ) {
            Row(
                modifier = Modifier.fillMaxSize().padding(horizontal = 4.dp),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
        items.forEachIndexed { index, item ->
            val isSelected = index == selectedIndex
            val color = if (isSelected) Color(0xFF00F0FF) else Color(0xFF8E8E93)

            Column(
                modifier = Modifier
                    .weight(1f)
                    .clickable {
                        if (currentRoute != item.route) {
                            navController.navigate(item.route) {
                                popUpTo(Screen.Home.route) { saveState = false }
                                launchSingleTop = true
                                restoreState = false
                            }
                        }
                    }
                    .padding(vertical = 6.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Icon(
                    imageVector = item.icon,
                    contentDescription = item.label,
                    tint = color,
                    modifier = Modifier.size(if (isSelected) 24.dp else 20.dp)
                )
                Spacer(modifier = Modifier.height(2.dp))
                Text(
                    text = item.label.uppercase(),
                    style = MaterialTheme.typography.labelSmall.copy(
                        fontWeight = if (isSelected) FontWeight.ExtraBold else FontWeight.Medium,
                        fontSize = if (isSelected) 10.sp else 9.sp,
                        letterSpacing = 0.8.sp
                    ),
                    color = color
                )
            }
        }
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/FeatureCard.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.animation.core.*
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.background
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.foundation.border
import androidx.compose.ui.graphics.BlendMode
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.util.lerp
import com.kyant.backdrop.Backdrop
import com.kyant.backdrop.drawBackdrop
import com.kyant.backdrop.effects.blur
import com.kyant.backdrop.effects.lens
import com.kyant.backdrop.effects.vibrancy
import com.kyant.backdrop.highlight.Highlight
import com.kyant.backdrop.shadow.Shadow
import com.georacing.georacing.ui.glass.GlassSupport
import com.georacing.georacing.ui.glass.drawBackdropSafe
import androidx.compose.foundation.shape.RoundedCornerShape
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.glass.utils.InteractiveHighlight
import kotlinx.coroutines.delay
import kotlin.math.tanh

/**
 * A Liquid Glass feature card for the dashboard grid.
 * Uses blur, lens distortion, and interactive highlight effects.
 */
@Composable
fun FeatureCard(
    title: String,
    description: String, // unused in new design
    icon: ImageVector,
    accentColor: Color,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    index: Int = 0
) {
    val backdrop = LocalBackdrop.current
    val animationScope = rememberCoroutineScope()
    
    val interactiveHighlight = remember(animationScope) {
        InteractiveHighlight(animationScope = animationScope)
    }
    
    // Entrance Animation
    var hasAnimated by remember { mutableStateOf(false) }
    val entranceScale by animateFloatAsState(
        targetValue = if (hasAnimated) 1f else 0.6f,
        animationSpec = spring(dampingRatio = 0.55f, stiffness = 500f),
        label = "entranceScale"
    )
    val entranceAlpha by animateFloatAsState(
        targetValue = if (hasAnimated) 1f else 0f,
        animationSpec = tween(500, easing = FastOutSlowInEasing),
        label = "entranceAlpha"
    )
    val entranceOffsetY by animateFloatAsState(
        targetValue = if (hasAnimated) 0f else 20f,
        animationSpec = spring(dampingRatio = 0.6f, stiffness = 400f),
        label = "entranceOffsetY"
    )

    LaunchedEffect(Unit) {
        delay(index * 60L) 
        hasAnimated = true
    }

    val shape = RoundedCornerShape(22.dp)

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = modifier
            .graphicsLayer {
                scaleX = entranceScale
                scaleY = entranceScale
                alpha = entranceAlpha
                translationY = entranceOffsetY
            }
            .clickable(onClick = onClick)
    ) {
        // Icon Container with Solid Glass effect (OLED optimized)
        Box(
            modifier = Modifier
                .size(70.dp)
                .clip(shape) // Clip before border
                .background(Color(0xFF14141C)) // Solid ultra-dark base
                .border(
                    width = 1.dp,
                    color = accentColor.copy(alpha = 0.4f),
                    shape = shape
                )
                // Maintain the interactive press scale logic
                .graphicsLayer {
                    val progress = interactiveHighlight.pressProgress
                    val animScale = lerp(1f, 1.05f, progress)
                    scaleX = animScale
                    scaleY = animScale

                    val maxOffset = size.minDimension * 0.15f
                    val offset = interactiveHighlight.offset
                    translationX = maxOffset * tanh(0.03f * offset.x / maxOffset)
                    translationY = maxOffset * tanh(0.03f * offset.y / maxOffset)
                    
                    // Add standard shadow for glow effect
                    shadowElevation = 8f
                    this.shape = shape // Use 'this.shape' or the outer 'shape'
                    ambientShadowColor = accentColor
                    spotShadowColor = accentColor
                }
                .then(interactiveHighlight.modifier)
                .then(interactiveHighlight.gestureModifier),
            contentAlignment = Alignment.Center
        ) {
            // Accent tint overlay to replace the old drawRect overlay
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(accentColor.copy(alpha = 0.1f))
            )
            
            Icon(
                imageVector = icon,
                contentDescription = title,
                tint = accentColor,
                modifier = Modifier.size(32.dp) // Slightly larger icon
            )
        }
        
        Spacer(modifier = Modifier.height(8.dp))
        
        // Title Label
        Text(
            text = title,
            style = MaterialTheme.typography.labelMedium.copy(
                fontWeight = FontWeight.ExtraBold,
                fontSize = 12.sp,
                letterSpacing = 0.5.sp
            ),
            color = Color.White,
            textAlign = TextAlign.Center,
            maxLines = 1,
            overflow = TextOverflow.Ellipsis
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/GamifiedSpeedometer.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.animation.core.*
import androidx.compose.animation.animateColorAsState
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

/**
 * Veloc√≠metro circular gamificado estilo Waze.
 * 
 * Caracter√≠sticas:
 * - C√≠rculo de 80.dp en esquina inferior izquierda
 * - Se pone rojo y pulsa al exceder el l√≠mite de velocidad
 * - Muestra velocidad actual en grande y bold
 * - Muestra l√≠mite en gris cuando no se excede
 * - Fondo semi-transparente para no obstruir el mapa
 */
@Composable
fun GamifiedSpeedometer(
    currentSpeed: Float,
    speedLimit: Int?,
    modifier: Modifier = Modifier
) {
    val isExceedingLimit = speedLimit != null && currentSpeed > speedLimit
    
    // Animaci√≥n de color
    val backgroundColor by animateColorAsState(
        targetValue = if (isExceedingLimit) {
            Color(0xFFE8253A) // Racing red vibrante
        } else {
            Color(0xFF14141C).copy(alpha = 0.85f) // Glass-like dark
        },
        animationSpec = tween(300),
        label = "background_color"
    )
    
    // Animaci√≥n del borde
    val borderColor by animateColorAsState(
        targetValue = if (isExceedingLimit) {
            Color(0xFFFF3352).copy(alpha = 0.6f)
        } else {
            Color.White.copy(alpha = 0.1f)
        },
        animationSpec = tween(300),
        label = "border_color"
    )
    
    // Pulso cuando excede el l√≠mite
    val infiniteTransition = rememberInfiniteTransition(label = "pulse")
    val pulseScale by infiniteTransition.animateFloat(
        initialValue = if (isExceedingLimit) 1f else 1f,
        targetValue = if (isExceedingLimit) 1.1f else 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(500, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "pulse_scale"
    )
    
    Box(
        modifier = modifier
            .size(80.dp)
            .scale(if (isExceedingLimit) pulseScale else 1f)
            .background(backgroundColor, CircleShape)
            .border(1.dp, borderColor, CircleShape),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // Velocidad actual (n√∫mero grande)
            Text(
                text = currentSpeed.toInt().toString(),
                color = Color.White,
                fontSize = 28.sp,
                fontWeight = FontWeight.Black,
                lineHeight = 28.sp,
                letterSpacing = (-1).sp
            )
            
            // "km/h" peque√±o
            Text(
                text = "km/h",
                color = Color.White.copy(alpha = 0.7f),
                fontSize = 10.sp,
                fontWeight = FontWeight.ExtraBold,
                letterSpacing = 1.sp
            )
            
            // Mostrar l√≠mite si existe
            speedLimit?.let { limit ->
                Text(
                    text = if (isExceedingLimit) "‚ö† $limit" else "$limit",
                    color = if (isExceedingLimit) {
                        Color.White
                    } else {
                        Color.LightGray.copy(alpha = 0.7f)
                    },
                    fontSize = 10.sp,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

/**
 * Versi√≥n alternativa con borde circular para mayor visibilidad.
 */
@Composable
fun GamifiedSpeedometerWithBorder(
    currentSpeed: Float,
    speedLimit: Int?,
    modifier: Modifier = Modifier
) {
    val isExceedingLimit = speedLimit != null && currentSpeed > speedLimit
    
    val borderColor by animateColorAsState(
        targetValue = if (isExceedingLimit) {
            Color(0xFFFFFFFF) // Borde blanco cuando excede
        } else {
            Color.Transparent
        },
        animationSpec = tween(300),
        label = "border_color"
    )
    
    Box(
        modifier = modifier
            .size(84.dp)
            .background(borderColor, CircleShape)
            .padding(2.dp)
    ) {
        GamifiedSpeedometer(
            currentSpeed = currentSpeed,
            speedLimit = speedLimit,
            modifier = Modifier.fillMaxSize()
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/GlassComponents.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CutCornerShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Shape
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.georacing.georacing.ui.theme.*

/**
 * Tarjeta base del sistema Liquid Glass.
 *
 * Se usa como contenedor principal para modulos de informacion.
 * Ahora con inner highlight y borde specular mejorado.
 *
 * @param modifier Modificador para layout (padding, size).
 * @param shape Forma del contenedor (Default: Rounded 24dp).
 * @param content Contenido composable (ColumnScope).
 */
@Composable
fun GlassCard(
    modifier: Modifier = Modifier,
    shape: Shape = RoundedCornerShape(Radius.xl), // Updated to use Token
    accentColor: Color? = null,
    content: @Composable ColumnScope.() -> Unit
) {
    Column(
        modifier = modifier
            .liquidGlass(
                shape = shape,
                accentGlow = accentColor
            )
            .padding(Layout.cardPadding),
        content = content
    )
}

/**
 * üèéÔ∏è Bot√≥n de acci√≥n principal Racing ‚Äî Dise√±o F1 Premium.
 * Corte angular agresivo con gradiente sutil.
 */
@Composable
fun RacingButton(
    text: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    icon: ImageVector? = null,
    enabled: Boolean = true,
    color: Color = RacingRed
) {
    val shape = CutCornerShape(topStart = 0.dp, bottomEnd = 18.dp, topEnd = 6.dp, bottomStart = 6.dp)

    Button(
        onClick = onClick,
        enabled = enabled,
        modifier = modifier.height(56.dp).fillMaxWidth(),
        shape = shape,
        colors = ButtonDefaults.buttonColors(
            containerColor = color,
            contentColor = Color.White,
            disabledContainerColor = color.copy(alpha = 0.4f)
        ),
        elevation = ButtonDefaults.buttonElevation(
            defaultElevation = 6.dp,
            pressedElevation = 1.dp,
            hoveredElevation = 10.dp
        )
    ) {
        Row(
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.Center
        ) {
            if (icon != null) {
                Icon(imageVector = icon, contentDescription = text, modifier = Modifier.size(20.dp))
                Spacer(modifier = Modifier.width(10.dp))
            }
            Text(
                text = text.uppercase(),
                style = MaterialTheme.typography.labelLarge
            )
        }
    }
}

/**
 * üèéÔ∏è P√≠ldora de estado ‚Äî LED style con glow.
 */
@Composable
fun StatusPill(
    text: String,
    color: Color,
    modifier: Modifier = Modifier,
    icon: ImageVector? = null
) {
    Row(
        modifier = modifier
            .glassSmall(color = color.copy(alpha = 0.25f))
            .border(
                width = 0.5.dp,
                color = color.copy(alpha = 0.4f),
                shape = RoundedCornerShape(50)
            )
            .padding(horizontal = 14.dp, vertical = 7.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        if (icon != null) {
            Icon(
                imageVector = icon,
                contentDescription = text,
                tint = color,
                modifier = Modifier.size(14.dp)
            )
            Spacer(modifier = Modifier.width(6.dp))
        }
        Text(
            text = text.uppercase(),
            style = MaterialTheme.typography.labelMedium,
            color = color
        )
    }
}

/**
 * üèéÔ∏è Fila de datos estilo HUD (Head Up Display) ‚Äî Data telemetry feel.
 * Label peque√±o arriba en color terciario, Valor grande abajo en blanco.
 */
@Composable
fun HUDRow(
    label: String,
    value: String,
    icon: ImageVector? = null,
    valueColor: Color = TextPrimary,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier.padding(vertical = 6.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        if (icon != null) {
            Box(
                modifier = Modifier
                    .size(28.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(MetalGrey.copy(alpha = 0.5f)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = icon,
                    contentDescription = label,
                    tint = TextSecondary,
                    modifier = Modifier.size(14.dp)
                )
            }
            Spacer(modifier = Modifier.width(10.dp))
        }
        Column {
            Text(
                text = label.uppercase(),
                style = MaterialTheme.typography.labelSmall,
                color = TextSecondary
            )
            Text(
                text = value,
                style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.ExtraBold),
                color = valueColor
            )
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/HazardAlertOverlay.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.debug.ScenarioSimulator
import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LocalBackdrop

/**
 * Overlay estilo Waze para mostrar alertas de incidentes en la ruta.
 * 
 * Caracter√≠sticas:
 * - Burbujas grandes con colores saturados (naranja/rojo)
 * - Iconos cartoonish grandes
 * - Animaci√≥n de entrada desde arriba
 * - Auto-dismiss despu√©s de 5 segundos
 * - Pulso sutil para llamar la atenci√≥n
 */
@Composable
fun HazardAlertOverlay(
    hazards: List<ScenarioSimulator.RoadHazard>,
    modifier: Modifier = Modifier
) {
    Box(modifier = modifier.fillMaxWidth()) {
        // Mostrar solo el hazard m√°s cercano/importante
        hazards.firstOrNull()?.let { hazard ->
            HazardBubble(
                hazard = hazard,
                modifier = Modifier
                    .align(Alignment.TopCenter)
                    .padding(top = 120.dp)
            )
        }
    }
}

@Composable
private fun HazardBubble(
    hazard: ScenarioSimulator.RoadHazard,
    modifier: Modifier = Modifier
) {
    var visible by remember { mutableStateOf(false) }
    
    // Auto-show on composition
    LaunchedEffect(hazard.id) {
        visible = true
        kotlinx.coroutines.delay(5000) // Show for 5 seconds
        visible = false
    }
    
    // Pulso sutil para llamar atenci√≥n
    val infiniteTransition = rememberInfiniteTransition(label = "pulse")
    val pulseScale by infiniteTransition.animateFloat(
        initialValue = 1f,
        targetValue = 1.05f,
        animationSpec = infiniteRepeatable(
            animation = tween(600, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "pulse_scale"
    )
    
    AnimatedVisibility(
        visible = visible,
        enter = slideInVertically(
            initialOffsetY = { -it },
            animationSpec = spring(
                dampingRatio = Spring.DampingRatioMediumBouncy,
                stiffness = Spring.StiffnessLow
            )
        ) + fadeIn(),
        exit = fadeOut(animationSpec = tween(300)),
        modifier = modifier
    ) {
        val backdrop = LocalBackdrop.current
        
        LiquidCard(
            backdrop = backdrop,
            modifier = Modifier
                .scale(pulseScale)
                .width(280.dp)
                .height(100.dp),
            cornerRadius = 20.dp,
            surfaceColor = getHazardColor(hazard.type).copy(alpha = 0.8f),
            tint = getHazardColor(hazard.type).copy(alpha = 0.3f),
            blurRadius = 12.dp
        ) {
            Row(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.spacedBy(16.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Icono cartoonish grande
                Icon(
                    imageVector = getHazardIcon(hazard.type),
                    contentDescription = null,
                    tint = Color(0xFFF8FAFC),
                    modifier = Modifier.size(48.dp)
                )
                
                // Texto del incidente
                Column(
                    modifier = Modifier.weight(1f),
                    verticalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    Text(
                        text = hazard.type.emoji + " " + hazard.type.label.uppercase(),
                        color = Color(0xFFF8FAFC),
                        fontSize = 18.sp,
                        fontWeight = FontWeight.ExtraBold,
                        letterSpacing = 1.5.sp
                    )
                    Text(
                        text = "EN LA RUTA",
                        color = Color(0xFFF8FAFC).copy(alpha = 0.9f),
                        fontSize = 14.sp,
                        fontWeight = FontWeight.Bold,
                        letterSpacing = 1.5.sp
                    )
                }
            }
        }
    }
}

/**
 * Retorna el color de fondo seg√∫n el tipo de incidente.
 * Colores saturados estilo Waze.
 */
private fun getHazardColor(type: ScenarioSimulator.HazardType): Color {
    return when (type) {
        ScenarioSimulator.HazardType.ACCIDENT -> Color(0xFFEF4444) // Racing Red
        ScenarioSimulator.HazardType.TRAFFIC -> Color(0xFFF97316)   // Neon Orange
        ScenarioSimulator.HazardType.CONSTRUCTION -> Color(0xFFFFA726) // Amber
        ScenarioSimulator.HazardType.POLICE -> Color(0xFF06B6D4) // Neon Cyan
    }
}

/**
 * Retorna el icono apropiado para cada tipo de incidente.
 */
private fun getHazardIcon(type: ScenarioSimulator.HazardType): ImageVector {
    return when (type) {
        ScenarioSimulator.HazardType.ACCIDENT -> Icons.Default.Warning
        ScenarioSimulator.HazardType.TRAFFIC -> Icons.Default.Traffic
        ScenarioSimulator.HazardType.CONSTRUCTION -> Icons.Default.Construction
        ScenarioSimulator.HazardType.POLICE -> Icons.Default.Security
    }
}

/**
 * Formatea la distancia en texto legible.
 */
private fun formatDistance(meters: Double): String {
    return when {
        meters < 100 -> "${meters.toInt()}m adelante"
        meters < 1000 -> "${(meters / 100).toInt() * 100}m adelante"
        else -> "${String.format("%.1f", meters / 1000)}km adelante"
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/OfflineIndicator.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.animateColorAsState
import androidx.compose.animation.core.*
import androidx.compose.animation.slideInVertically
import androidx.compose.animation.slideOutVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Bluetooth
import androidx.compose.material.icons.filled.CloudOff
import androidx.compose.material.icons.filled.Wifi
import androidx.compose.material.icons.filled.WifiOff
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LiquidPill
import com.georacing.georacing.ui.glass.LocalBackdrop

/**
 * Indicador de conectividad que aparece en la parte superior de la pantalla.
 * 
 * - Cuando est√° ONLINE: No muestra nada
 * - Cuando est√° OFFLINE: Muestra banner con icono BLE pulsando
 * 
 * Uso:
 * ```
 * Box {
 *     // Tu contenido
 *     OfflineIndicator(
 *         isOnline = isOnline,
 *         bleBeaconsDetected = detectedBeacons.size
 *     )
 * }
 * ```
 */
@Composable
fun OfflineIndicator(
    isOnline: Boolean,
    bleBeaconsDetected: Int = 0,
    modifier: Modifier = Modifier
) {
    // Animaci√≥n de pulso para icono BLE
    val infiniteTransition = rememberInfiniteTransition(label = "ble_pulse")
    val blePulse by infiniteTransition.animateFloat(
        initialValue = 0.8f,
        targetValue = 1.2f,
        animationSpec = infiniteRepeatable(
            animation = tween(1000, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "ble_pulse_alpha"
    )
    
    val backgroundColor by animateColorAsState(
        targetValue = if (isOnline) Color.Transparent else Color(0xFFE8253A),
        animationSpec = tween(500),
        label = "bg_color"
    )

    val backdrop = LocalBackdrop.current
    
    AnimatedVisibility(
        visible = !isOnline,
        enter = slideInVertically(initialOffsetY = { -it }),
        exit = slideOutVertically(targetOffsetY = { -it }),
        modifier = modifier.fillMaxWidth()
    ) {
        LiquidCard(
            backdrop = backdrop,
            modifier = Modifier.fillMaxWidth(),
            cornerRadius = 0.dp, // Full width panel
            surfaceColor = backgroundColor.copy(alpha = 0.8f),
            tint = backgroundColor.copy(alpha = 0.2f),
            blurRadius = 12.dp
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 4.dp),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.Center
            ) {
            // Icono offline
            Icon(
                imageVector = Icons.Default.WifiOff,
                contentDescription = "Sin conexi√≥n WiFi",
                tint = Color(0xFFF8FAFC),
                modifier = Modifier.size(20.dp)
            )
            
            Spacer(modifier = Modifier.width(8.dp))
            
            Text(
                text = "SIN CONEXI√ìN",
                color = Color(0xFFF8FAFC),
                fontWeight = FontWeight.Bold,
                fontSize = 14.sp,
                letterSpacing = 1.5.sp
            )
            
            Spacer(modifier = Modifier.width(16.dp))
            
            // Icono BLE pulsando
            Icon(
                imageVector = Icons.Default.Bluetooth,
                contentDescription = "Estado Bluetooth",
                tint = Color(0xFFF8FAFC).copy(alpha = blePulse.coerceIn(0f, 1f)),
                modifier = Modifier.size(20.dp)
            )
            
            Spacer(modifier = Modifier.width(4.dp))
            
            Text(
                text = if (bleBeaconsDetected > 0) 
                    "$bleBeaconsDetected BALIZAS" 
                else 
                    "BUSCANDO BALIZAS...",
                color = Color(0xFFF8FAFC).copy(alpha = 0.9f),
                letterSpacing = 1.5.sp
            )
        }
    }
    }
}

/**
 * Versi√≥n compacta del indicador para usar en TopAppBar.
 */
@Composable
fun OfflineChip(
    isOnline: Boolean,
    modifier: Modifier = Modifier
) {
    val backdrop = LocalBackdrop.current
    AnimatedVisibility(visible = !isOnline, modifier = modifier) {
        LiquidPill(
            backdrop = backdrop,
            surfaceColor = Color(0xFFE8253A).copy(alpha = 0.8f)
        ) {
            Row(verticalAlignment = Alignment.CenterVertically) {
            Icon(
                imageVector = Icons.Default.CloudOff,
                contentDescription = "Offline",
                tint = Color(0xFFF8FAFC),
                modifier = Modifier.size(14.dp)
            )
            Spacer(modifier = Modifier.width(4.dp))
            Text(
                text = "BLE",
                color = Color(0xFFF8FAFC),
                fontSize = 10.sp,
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.5.sp
            )
        }
    }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/ParkingComponents.kt`

```kotlin
package com.georacing.georacing.ui.components

import android.location.Location
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.georacing.georacing.data.parking.ParkingLocation
import com.georacing.georacing.ui.glass.LiquidDialog
import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LocalBackdrop
import kotlin.math.roundToInt

@Composable
fun ParkingConfirmationDialog(
    location: Location,
    onConfirm: () -> Unit,
    onDismiss: () -> Unit,
    onAddPhoto: () -> Unit // Placeholder for future
) {
    val backdrop = LocalBackdrop.current
    Dialog(onDismissRequest = onDismiss) {
        LiquidDialog(
            backdrop = backdrop,
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            cornerRadius = 32.dp,
            surfaceColor = Color(0xFF0E0E18).copy(alpha = 0.90f)
        ) {
            Column(
                modifier = Modifier
                    .padding(24.dp)
                    .fillMaxWidth(),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "üöó",
                    style = MaterialTheme.typography.displayMedium
                )
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = "Coche desconectado",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Text(
                    text = "¬øGuardar la ubicaci√≥n actual como parking?",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(top = 8.dp)
                )

                Spacer(modifier = Modifier.height(24.dp))

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceEvenly,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    TextButton(onClick = onDismiss) {
                        Text(
                            "Ignorar",
                            color = Color(0xFFE8253A),
                            fontWeight = FontWeight.Bold
                        )
                    }
                    Spacer(modifier = Modifier.width(12.dp))
                    Button(
                        onClick = onConfirm,
                        colors = ButtonDefaults.buttonColors(
                            containerColor = Color(0xFFE8253A)
                        ),
                        shape = androidx.compose.foundation.shape.RoundedCornerShape(16.dp),
                        modifier = Modifier.height(48.dp)
                    ) {
                        Text(
                            "Guardar Parking",
                            color = Color(0xFFF8FAFC),
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }
        }
    }
}

/**
 * Enhanced ParkingStatusCard with distance display.
 * 
 * @param parkingLocation Saved parking location
 * @param currentLocation User's current location (nullable)
 * @param onNavigate Callback when navigate button is clicked
 */
@Composable
fun ParkingStatusCard(
    parkingLocation: ParkingLocation,
    currentLocation: Location? = null,
    onNavigate: () -> Unit
) {
    // üõ°Ô∏è Don't show if coordinates are (0, 0) - invalid data
    if (parkingLocation.latitude == 0.0 && parkingLocation.longitude == 0.0) {
        return
    }
    
    // üìè Calculate distance using Location.distanceBetween()
    val distanceText = remember(parkingLocation, currentLocation) {
        if (currentLocation != null) {
            val results = FloatArray(1)
            Location.distanceBetween(
                currentLocation.latitude,
                currentLocation.longitude,
                parkingLocation.latitude,
                parkingLocation.longitude,
                results
            )
            formatDistance(results[0])
        } else {
            null
        }
    }
    
    val backdrop = LocalBackdrop.current
    
    LiquidCard(
        backdrop = backdrop,
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        cornerRadius = 24.dp,
        surfaceColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = "üìç",
                style = MaterialTheme.typography.headlineSmall
            )
            Spacer(modifier = Modifier.width(16.dp))
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = "TU COCHE EST√Å APARCADO",
                    style = MaterialTheme.typography.labelMedium,
                    color = MaterialTheme.colorScheme.primary
                )
                Text(
                    text = if (distanceText != null) "A $distanceText" else "Ubicaci√≥n guardada",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            Button(
                onClick = onNavigate,
                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.primary)
            ) {
                Text("Ir")
            }
        }
    }
}

/**
 * Formats distance in meters to human-readable string.
 */
private fun formatDistance(meters: Float): String {
    return when {
        meters < 1000 -> "${meters.roundToInt()}m"
        else -> "${"%.1f".format(meters / 1000)}km"
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/RaceStatusPill.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.domain.model.CircuitMode
import com.georacing.georacing.ui.glass.LiquidPill
import com.georacing.georacing.ui.glass.LocalBackdrop

/**
 * P√≠ldora flotante que muestra el estado actual de la pista.
 * 
 * Caracter√≠sticas:
 * - Dise√±o pill (RoundedCornerShape)
 * - Colores seg√∫n flag: Verde (Green), Rojo (Red), Amarillo (Yellow)
 * - Emoji de flag + texto bold
 * - Animaci√≥n de entrada desde arriba
 * - Elevation para efecto flotante
 */
@Composable
fun RaceStatusPill(
    circuitMode: CircuitMode,
    modifier: Modifier = Modifier
) {
    val pillColor = getPillColor(circuitMode)
    val flagEmoji = getFlagEmoji(circuitMode)
    val statusText = getStatusText(circuitMode)
    
    // Animaci√≥n de entrada
    var visible by remember { mutableStateOf(false) }
    
    LaunchedEffect(Unit) {
        visible = true
    }
    
    AnimatedVisibility(
        visible = visible,
        enter = slideInVertically(
            initialOffsetY = { -it },
            animationSpec = spring(
                dampingRatio = Spring.DampingRatioMediumBouncy,
                stiffness = Spring.StiffnessMedium
            )
        ) + fadeIn(),
        modifier = modifier
    ) {
        val backdrop = LocalBackdrop.current
        
        LiquidPill(
            backdrop = backdrop,
            modifier = Modifier
                .height(42.dp)
                .widthIn(min = 200.dp, max = 300.dp),
            surfaceColor = pillColor.copy(alpha = 0.8f),
            tint = pillColor.copy(alpha = 0.2f)
        ) {
            Row(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(horizontal = 20.dp, vertical = 8.dp),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Emoji de flag
                Text(
                    text = flagEmoji,
                    fontSize = 18.sp
                )
                
                // Texto del estado
                Text(
                    text = statusText,
                    color = Color(0xFFF8FAFC),
                    fontSize = 14.sp,
                    fontWeight = FontWeight.ExtraBold,
                    letterSpacing = 1.5.sp
                )
            }
        }
    }
}

/**
 * Variante compacta solo con emoji (para espacios reducidos)
 */
@Composable
fun CompactRaceStatusPill(
    circuitMode: CircuitMode,
    modifier: Modifier = Modifier
) {
    val pillColor = getPillColor(circuitMode)
    val flagEmoji = getFlagEmoji(circuitMode)
    
    val backdrop = LocalBackdrop.current
    
    LiquidPill(
        backdrop = backdrop,
        modifier = modifier.size(48.dp),
        surfaceColor = pillColor.copy(alpha = 0.8f),
        tint = pillColor.copy(alpha = 0.2f)
    ) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = flagEmoji,
                fontSize = 24.sp
            )
        }
    }
}

/**
 * Retorna el color de fondo seg√∫n el estado del circuito.
 */
private fun getPillColor(mode: CircuitMode): Color {
    return when (mode) {
        CircuitMode.GREEN_FLAG, CircuitMode.NORMAL -> Color(0xFF22C55E) // Racing Green
        CircuitMode.RED_FLAG -> Color(0xFFE8253A) // Racing Red
        CircuitMode.YELLOW_FLAG -> Color(0xFFFFA726) // Racing Yellow
        CircuitMode.SAFETY_CAR -> Color(0xFFF97316) // Neon Orange
        CircuitMode.VSC -> Color(0xFF06B6D4) // Neon Cyan
        CircuitMode.EVACUATION -> Color(0xFFEF4444) // Alert Red
        CircuitMode.UNKNOWN -> Color(0xFF64748B) // Slate
    }
}

/**
 * Retorna el emoji de flag correspondiente.
 */
private fun getFlagEmoji(mode: CircuitMode): String {
    return when (mode) {
        CircuitMode.GREEN_FLAG, CircuitMode.NORMAL -> "üü¢"
        CircuitMode.RED_FLAG -> "üî¥"
        CircuitMode.YELLOW_FLAG -> "üü°"
        CircuitMode.SAFETY_CAR -> "üöó"
        CircuitMode.VSC -> "üü£"
        CircuitMode.EVACUATION -> "üö®"
        CircuitMode.UNKNOWN -> "‚ö™"
    }
}

/**
 * Retorna el texto de estado.
 */
private fun getStatusText(mode: CircuitMode): String {
    return when (mode) {
        CircuitMode.GREEN_FLAG, CircuitMode.NORMAL -> "PISTA: GREEN FLAG"
        CircuitMode.RED_FLAG -> "PISTA: RED FLAG"
        CircuitMode.YELLOW_FLAG -> "PISTA: YELLOW FLAG"
        CircuitMode.SAFETY_CAR -> "SAFETY CAR"
        CircuitMode.VSC -> "VSC ACTIVO"
        CircuitMode.EVACUATION -> "EVACUACI√ìN"
        CircuitMode.UNKNOWN -> "ESTADO DESCONOCIDO"
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/RacingComponents.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.hapticfeedback.HapticFeedbackType
import androidx.compose.ui.platform.LocalHapticFeedback
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import com.georacing.georacing.ui.theme.*

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üèéÔ∏è  GeoRacing ‚Äî Industrial Grade Components (Phase 6)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Cero blur, cero transparencias, cero overdraw.
// Alto contraste. Botones enormes para interactuar en movimiento.

enum class RacingStyle {
    DEFAULT, 
    ACTIVE, 
    DANGER
}

/**
 * Contenedor base plano. Reemplaza a LiquidCard.
 * Fondo AsphaltDark, sin elevaci√≥n. Bordes duros.
 */
@Composable
fun RacingCard(
    modifier: Modifier = Modifier,
    style: RacingStyle = RacingStyle.DEFAULT,
    onClick: (() -> Unit)? = null,
    content: @Composable ColumnScope.() -> Unit
) {
    val haptic = LocalHapticFeedback.current
    val borderColor = when (style) {
        RacingStyle.DEFAULT -> AsphaltLight
        RacingStyle.ACTIVE -> KerbYellow
        RacingStyle.DANGER -> CatalunyaRed
    }

    Surface(
        color = AsphaltDark,
        shape = MaterialTheme.shapes.medium,
        shadowElevation = 0.dp, // 0 Overdraw GPU
        tonalElevation = 0.dp,
        border = BorderStroke(if (style != RacingStyle.DEFAULT) 2.dp else 1.dp, borderColor),
        modifier = modifier
            .fillMaxWidth()
            .then(
                if (onClick != null) {
                    Modifier.clickable {
                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)
                        onClick()
                    }
                } else Modifier
            )
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            content = content
        )
    }
}

/**
 * Bot√≥n masivo para el piloto/staff. Min height 56dp.
 */
@Composable
fun RacingButton(
    text: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    isPrimary: Boolean = true,
    enabled: Boolean = true
) {
    val haptic = LocalHapticFeedback.current

    val containerColor = if (isPrimary) CatalunyaRed else Color.Transparent
    val contentColor = KerbWhite
    val borderStroke = if (isPrimary) null else BorderStroke(2.dp, KerbWhite)

    Button(
        onClick = {
            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)
            onClick()
        },
        enabled = enabled,
        shape = MaterialTheme.shapes.small, // Sharp corners
        colors = ButtonDefaults.buttonColors(
            containerColor = containerColor,
            contentColor = contentColor,
            disabledContainerColor = AsphaltLight,
            disabledContentColor = MutedText
        ),
        border = borderStroke,
        modifier = modifier
            .fillMaxWidth()
            .defaultMinSize(minHeight = 56.dp) // Massivo para interactuar sin mirar
    ) {
        Text(
            text = text.uppercase(),
            style = MaterialTheme.typography.labelLarge,
            textAlign = TextAlign.Center
        )
    }
}

/**
 * Barra superior ultra-minimalista, fondo negro OLED nativo.
 */
@Composable
fun RacingTopBar(
    title: String,
    modifier: Modifier = Modifier,
    logoSlot: @Composable (() -> Unit)? = null,
    statusSlot: @Composable (() -> Unit)? = null
) {
    Surface(
        color = TarmacBlack,
        shadowElevation = 0.dp,
        modifier = modifier.fillMaxWidth()
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 12.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                if (logoSlot != null) {
                    logoSlot()
                    Spacer(modifier = Modifier.width(12.dp))
                }
                Text(
                    text = title.uppercase(),
                    style = MaterialTheme.typography.titleMedium,
                    color = KerbWhite
                )
            }
            if (statusSlot != null) {
                statusSlot()
            }
        }
    }
}

/**
 * Badge estilo telemetr√≠a, altamente visible.
 * Usar para tags como "LIVE", "OFFLINE", "DANGER".
 */
@Composable
fun TelemetryBadge(
    text: String,
    style: RacingStyle = RacingStyle.DEFAULT,
    modifier: Modifier = Modifier
) {
    val (bgColor, textColor) = when (style) {
        RacingStyle.DEFAULT -> AsphaltLight to KerbWhite
        RacingStyle.ACTIVE -> KerbYellow to TarmacBlack
        RacingStyle.DANGER -> CatalunyaRed to KerbWhite
    }

    Box(
        modifier = modifier
            .clip(RoundedCornerShape(50)) // P√≠ldora
            .background(bgColor)
            .padding(horizontal = 8.dp, vertical = 4.dp),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = text.uppercase(),
            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Black),
            color = textColor
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/RacingTopBar.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.ui.theme.*
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun RacingTopBar(
    onMenuClick: () -> Unit,
    onProfileClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val backdrop = LocalBackdrop.current
    
    LiquidTopBar(
        backdrop = backdrop,
        modifier = modifier,
        surfaceColor = Color(0xFF12121A).copy(alpha = 0.85f),
        navigationIcon = {
             IconButton(onClick = onMenuClick) {
                Icon(
                    Icons.Default.Menu,
                    contentDescription = stringResource(id = com.georacing.georacing.R.string.cd_menu),
                    tint = RacingRed,
                    modifier = Modifier.size(26.dp)
                )
             }
        },
        title = {
            Row(verticalAlignment = Alignment.CenterVertically) {
                // Accent dot
                Box(
                    modifier = Modifier
                        .size(8.dp)
                        .clip(CircleShape)
                        .background(RacingRed)
                )
                Spacer(modifier = Modifier.width(10.dp))
                Text(
                    text = "GEORACING",
                    style = MaterialTheme.typography.titleLarge.copy(
                        fontWeight = FontWeight.Black,
                        letterSpacing = 2.sp,
                        fontStyle = FontStyle.Italic
                    ),
                    color = Color.White
                )
            }
        },
        actions = {
            IconButton(onClick = onProfileClick) {
                 Box(
                    modifier = Modifier
                        .size(36.dp)
                        .clip(CircleShape)
                        .background(
                            brush = androidx.compose.ui.graphics.Brush.linearGradient(
                                colors = listOf(
                                    RacingRed.copy(alpha = 0.3f),
                                    Color(0xFF14141C).copy(alpha = 0.8f)
                                )
                            )
                        )
                        .border(1.dp, RacingRed.copy(alpha = 0.3f), CircleShape),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        Icons.Default.Person,
                        contentDescription = stringResource(id = com.georacing.georacing.R.string.cd_profile),
                        tint = Color.White,
                        modifier = Modifier.size(18.dp)
                    )
                }
            }
        }
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/ShimmerComponents.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp

/**
 * Shimmer / Skeleton loading components para GeoRacing.
 * Usados mientras se cargan datos de red o base de datos.
 */

private val ShimmerColorBase = Color(0xFF1E1E2A)
private val ShimmerColorHighlight = Color(0xFF2A2A3A)

@Composable
fun shimmerBrush(): Brush {
    val transition = rememberInfiniteTransition(label = "shimmer")
    val translateAnim by transition.animateFloat(
        initialValue = 0f, targetValue = 1000f,
        animationSpec = infiniteRepeatable(tween(1200, easing = LinearEasing)), label = "translate"
    )
    return Brush.linearGradient(
        colors = listOf(ShimmerColorBase, ShimmerColorHighlight, ShimmerColorBase),
        start = Offset(translateAnim - 200f, 0f),
        end = Offset(translateAnim + 200f, 0f)
    )
}

@Composable
fun ShimmerBox(
    modifier: Modifier = Modifier,
    width: Dp = Dp.Unspecified,
    height: Dp = 16.dp,
    shape: androidx.compose.ui.graphics.Shape = RoundedCornerShape(8.dp)
) {
    val brush = shimmerBrush()
    Box(
        modifier = modifier
            .then(if (width != Dp.Unspecified) Modifier.width(width) else Modifier.fillMaxWidth())
            .height(height)
            .clip(shape)
            .background(brush)
    )
}

/** Skeleton de una tarjeta t√≠pica del dashboard */
@Composable
fun SkeletonCard(modifier: Modifier = Modifier) {
    val brush = shimmerBrush()
    Column(
        modifier = modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(16.dp))
            .background(Color(0xFF14141C))
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        ShimmerBox(width = 120.dp, height = 12.dp)
        ShimmerBox(height = 20.dp)
        ShimmerBox(width = 200.dp, height = 14.dp)
    }
}

/** Skeleton para el grid de features del home */
@Composable
fun SkeletonGrid(modifier: Modifier = Modifier) {
    Column(modifier = modifier, verticalArrangement = Arrangement.spacedBy(16.dp)) {
        repeat(2) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                repeat(4) {
                    Column(horizontalAlignment = androidx.compose.ui.Alignment.CenterHorizontally) {
                        ShimmerBox(width = 64.dp, height = 64.dp, shape = RoundedCornerShape(18.dp))
                        Spacer(Modifier.height(6.dp))
                        ShimmerBox(width = 48.dp, height = 10.dp)
                    }
                }
            }
        }
    }
}

/** Skeleton de una fila de lista (POI, transport, etc.) */
@Composable
fun SkeletonListItem(modifier: Modifier = Modifier) {
    Row(
        modifier = modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(12.dp))
            .background(Color(0xFF14141C))
            .padding(14.dp),
        verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
    ) {
        ShimmerBox(width = 40.dp, height = 40.dp, shape = RoundedCornerShape(10.dp))
        Spacer(Modifier.width(12.dp))
        Column(Modifier.weight(1f), verticalArrangement = Arrangement.spacedBy(6.dp)) {
            ShimmerBox(width = 140.dp, height = 14.dp)
            ShimmerBox(width = 200.dp, height = 10.dp)
        }
    }
}

/** Skeleton de la pantalla home completa */
@Composable
fun SkeletonHomeScreen(modifier: Modifier = Modifier) {
    Column(
        modifier = modifier.fillMaxSize().padding(20.dp),
        verticalArrangement = Arrangement.spacedBy(24.dp)
    ) {
        // Greeting skeleton
        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
            Column(verticalArrangement = Arrangement.spacedBy(6.dp)) {
                ShimmerBox(width = 100.dp, height = 12.dp)
                ShimmerBox(width = 180.dp, height = 18.dp)
            }
            ShimmerBox(width = 70.dp, height = 32.dp, shape = RoundedCornerShape(16.dp))
        }

        // Status card skeleton
        SkeletonCard()

        // Grid skeleton
        SkeletonGrid()

        // News skeleton
        ShimmerBox(height = 120.dp, shape = RoundedCornerShape(24.dp))
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/SurvivalModeBanner.kt`

```kotlin
package com.georacing.georacing.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.ui.theme.LocalEnergyProfile
import com.georacing.georacing.domain.model.EnergyProfile
import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LocalBackdrop

@Composable
fun SurvivalModeBanner() {
    val energyProfile = LocalEnergyProfile.current

    if (energyProfile is EnergyProfile.Survival) {
        val backdrop = LocalBackdrop.current
        
        LiquidCard(
            backdrop = backdrop,
            modifier = Modifier.fillMaxWidth(),
            cornerRadius = 0.dp, // Full width banner
            surfaceColor = Color(0xFFE8253A).copy(alpha = 0.65f),
            blurRadius = 12.dp
        ) {
            Box(modifier = Modifier.padding(vertical = 8.dp, horizontal = 16.dp)) {
                Text(
                    text = "‚ö†Ô∏è MODO SUPERVIVENCIA: Funciones no cr√≠ticas desactivadas para asegurar tu retorno.",
                    color = Color(0xFFF8FAFC),
                    fontWeight = FontWeight.Bold,
                    fontSize = 14.sp,
                    textAlign = TextAlign.Center,
                    modifier = Modifier.align(Alignment.Center)
                )
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/ar/AROverlayView.kt`

```kotlin
package com.georacing.georacing.ui.components.ar

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Paint
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.domain.navigation.BearingCalculator

data class ARLabel(
    val id: String,
    val text: String,
    val lat: Double,
    val lon: Double
)

@Composable
fun AROverlayView(
    azimuth: Float,
    userLat: Double,
    userLon: Double,
    targets: List<ARLabel>
) {
    Canvas(modifier = Modifier.fillMaxSize()) {
        val width = size.width
        val height = size.height
        val fov = 60f // Camera FOV (approx)

        // Draw HUD Center Crosshair
        drawLine(
            color = Color(0xFF00FF00), // Neon Green
            start = Offset(width / 2 - 20, height / 2),
            end = Offset(width / 2 + 20, height / 2),
            strokeWidth = 2.dp.toPx()
        )
        drawLine(
            color = Color(0xFF00FF00),
            start = Offset(width / 2, height / 2 - 20),
            end = Offset(width / 2, height / 2 + 20),
            strokeWidth = 2.dp.toPx()
        )

        // Draw targets
        val paint = Paint().asFrameworkPaint().apply {
            textSize = 32f
            color = android.graphics.Color.WHITE
            textAlign = android.graphics.Paint.Align.CENTER
            isFakeBoldText = true
            setShadowLayer(4f, 0f, 0f, android.graphics.Color.BLACK)
        }

        val linePaint = Paint().asFrameworkPaint().apply {
            color = android.graphics.Color.GREEN
            strokeWidth = 2f
        }

        targets.forEach { target ->
            val bearing = BearingCalculator.calculateBearing(userLat, userLon, target.lat, target.lon)
            val screenPos = BearingCalculator.calculateScreenPosition(azimuth, bearing, fov)

            if (screenPos != null) {
                // screenPos is -1 (left) to 1 (right)
                // Map to 0 to width
                val x = (screenPos + 1) / 2 * width
                val y = height / 2

                // Draw Marker Line
                drawLine(
                    color = Color.Red,
                    start = Offset(x, y - 50),
                    end = Offset(x, y + 50),
                    strokeWidth = 4f
                )

                // Draw Text
                drawContext.canvas.nativeCanvas.drawText(
                    target.text,
                    x,
                    y - 60, // Above line
                    paint
                )

                drawContext.canvas.nativeCanvas.drawText(
                    "${bearing.toInt()}¬∞",
                    x,
                    y + 80, // Below line
                    paint
                )
            }
        }
    }
}

@Preview
@Composable
fun PreviewAROverlay() {
    AROverlayView(
        azimuth = 0f, // Looking North
        userLat = 0.0,
        userLon = 0.0,
        targets = listOf(
            ARLabel("1", "NORTH", 1.0, 0.0), // Should be center
            ARLabel("2", "EAST", 0.0, 1.0)   // Should be right (90 deg) -> Off screen if fov=60
        )
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/background/CarbonBackground.kt`

```kotlin
package com.georacing.georacing.ui.components.background

import androidx.compose.animation.core.LinearEasing
import androidx.compose.animation.core.RepeatMode
import androidx.compose.animation.core.animateFloat
import androidx.compose.animation.core.infiniteRepeatable
import androidx.compose.animation.core.rememberInfiniteTransition
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import kotlin.math.sin

/**
 * üèéÔ∏è Fondo racing premium con degradado multicapa,
 * l√≠neas de velocidad diagonales y glow sutil animado.
 */
@Composable
fun CarbonBackground(
    modifier: Modifier = Modifier
) {
    // Ambient glow pulse muy sutil
    val infiniteTransition = rememberInfiniteTransition(label = "bg_glow")
    val glowPhase by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(8000, easing = LinearEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "glow_phase"
    )

    Canvas(modifier = modifier.fillMaxSize()) {
        val width = size.width
        val height = size.height
        
        // ‚îÄ‚îÄ Capa 1: Degradado base profundo con tinte azulado ‚îÄ‚îÄ
        val gradientBrush = Brush.verticalGradient(
            colors = listOf(
                Color(0xFF06060C),   // Ultra negro azulado
                Color(0xFF0A0A12),   // Transici√≥n
                Color(0xFF0E0E18),   // Sutil azulado en bottom
                Color(0xFF080810)    // Cierre oscuro
            ),
            startY = 0f,
            endY = height
        )
        drawRect(brush = gradientBrush)
        
        // ‚îÄ‚îÄ Capa 2: Glow radial sutil en la zona superior (efecto pit light) ‚îÄ‚îÄ
        val glowAlpha = 0.04f + (glowPhase * 0.02f)
        val glowBrush = Brush.radialGradient(
            colors = listOf(
                Color(0xFFE8253A).copy(alpha = glowAlpha), // Racing Red sutil
                Color.Transparent
            ),
            center = Offset(width * 0.7f, height * 0.08f),
            radius = width * 0.6f
        )
        drawRect(brush = glowBrush)
        
        // ‚îÄ‚îÄ Capa 3: Glow cyan sutil zona inferior izquierda ‚îÄ‚îÄ
        val cyanGlowBrush = Brush.radialGradient(
            colors = listOf(
                Color(0xFF00E5FF).copy(alpha = 0.02f + glowPhase * 0.01f),
                Color.Transparent
            ),
            center = Offset(width * 0.15f, height * 0.85f),
            radius = width * 0.5f
        )
        drawRect(brush = cyanGlowBrush)
        
        // ‚îÄ‚îÄ Capa 4: L√≠neas de velocidad diagonales premium ‚îÄ‚îÄ
        val lineSpacing = 50f
        val lineCount = (width / lineSpacing).toInt() + 15
        
        for (i in 0..lineCount) {
            val x = i * lineSpacing - height * 0.35f
            // Variaci√≥n de opacidad por l√≠nea para efecto org√°nico
            val lineAlpha = if (i % 3 == 0) 0.025f else 0.015f
            drawLine(
                color = Color.White.copy(alpha = lineAlpha),
                start = Offset(x, 0f),
                end = Offset(x + height * 0.35f, height),
                strokeWidth = if (i % 5 == 0) 1.5f else 0.8f
            )
        }
        
        // ‚îÄ‚îÄ Capa 5: L√≠nea de acento horizontal sutil ‚îÄ‚îÄ
        val accentY = height * 0.35f
        drawLine(
            brush = Brush.horizontalGradient(
                colors = listOf(
                    Color.Transparent,
                    Color(0xFFE8253A).copy(alpha = 0.06f),
                    Color(0xFFE8253A).copy(alpha = 0.04f),
                    Color.Transparent
                )
            ),
            start = Offset(0f, accentY),
            end = Offset(width, accentY),
            strokeWidth = 1f
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/circuit/CircuitTrack.kt`

```kotlin
package com.georacing.georacing.ui.components.circuit

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.drawscope.Stroke

/**
 * Simplified Circuit de Barcelona-Catalunya track layout
 */
@Composable
fun CircuitTrack(
    modifier: Modifier = Modifier,
    trackColor: Color = Color(0xFFE8253A),
    congestionZones: List<Int> = emptyList() // Zone indices with congestion
) {
    Canvas(modifier = modifier.fillMaxSize()) {
        val width = size.width
        val height = size.height
        val centerX = width / 2
        val centerY = height / 2
        
        // Simplified track path (Barcelona Catalunya layout inspired)
        val trackPath = Path().apply {
            // Start/Finish straight
            moveTo(centerX - width * 0.3f, centerY + height * 0.25f)
            lineTo(centerX + width * 0.1f, centerY + height * 0.25f)
            
            // Turn 1 (Elf)
            cubicTo(
                centerX + width * 0.15f, centerY + height * 0.25f,
                centerX + width * 0.2f, centerY + height * 0.15f,
                centerX + width * 0.2f, centerY + height * 0.05f
            )
            
            // Turn 2 (Renault)
            cubicTo(
                centerX + width * 0.2f, centerY - height * 0.05f,
                centerX + width * 0.15f, centerY - height * 0.15f,
                centerX + width * 0.05f, centerY - height * 0.2f
            )
            
            // Turn 3 (Repsol)
            cubicTo(
                centerX - width * 0.05f, centerY - height * 0.25f,
                centerX - width * 0.15f, centerY - height * 0.25f,
                centerX - width * 0.25f, centerY - height * 0.2f
            )
            
            // Turns 4-5 (Seat-Wurth)
            cubicTo(
                centerX - width * 0.3f, centerY - height * 0.15f,
                centerX - width * 0.32f, centerY - height * 0.05f,
                centerX - width * 0.3f, centerY
            )
            
            // Turn 7 (Campsa)
            cubicTo(
                centerX - width * 0.28f, centerY + height * 0.05f,
                centerX - width * 0.25f, centerY + height * 0.1f,
                centerX - width * 0.2f, centerY + height * 0.12f
            )
            
            // Turns 9-10 (La Caixa-Banc Sabadell)
            lineTo(centerX - width * 0.1f, centerY + height * 0.12f)
            cubicTo(
                centerX - width * 0.05f, centerY + height * 0.12f,
                centerX, centerY + height * 0.15f,
                centerX, centerY + height * 0.2f
            )
            
            // Turn 12-13 (New chicane)
            cubicTo(
                centerX, centerY + height * 0.23f,
                centerX - width * 0.05f, centerY + height * 0.25f,
                centerX - width * 0.1f, centerY + height * 0.25f
            )
            
            // Back to start
            lineTo(centerX - width * 0.3f, centerY + height * 0.25f)
            close()
        }
        
        // Draw track outline
        drawPath(
            path = trackPath,
            color = Color(0xFF64748B),
            style = Stroke(
                width = 28f,
                cap = StrokeCap.Round,
                join = StrokeJoin.Round
            )
        )
        
        // Draw track surface
        drawPath(
            path = trackPath,
            color = Color(0xFF14141C),
            style = Stroke(
                width = 24f,
                cap = StrokeCap.Round,
                join = StrokeJoin.Round
            )
        )
        
        // Draw center line
        drawPath(
            path = trackPath,
            color = Color(0xFFF8FAFC).copy(alpha = 0.25f),
            style = Stroke(
                width = 2f,
                cap = StrokeCap.Round,
                join = StrokeJoin.Round
            )
        )
        
        // Draw start/finish line
        val startX = centerX - width * 0.3f
        val startY = centerY + height * 0.25f
        for (i in 0 until 8) {
            val segmentHeight = 20f
            val y = startY - segmentHeight * i
            val isWhite = i % 2 == 0
            drawLine(
                color = if (isWhite) Color(0xFFF8FAFC) else Color(0xFF080810),
                start = Offset(startX - 14f, y),
                end = Offset(startX - 14f, y - segmentHeight),
                strokeWidth = 4f,
                cap = StrokeCap.Butt
            )
        }
        
        // Draw track name markers
        drawCircle(
            color = trackColor,
            radius = 8f,
            center = Offset(centerX - width * 0.3f, centerY + height * 0.25f)
        )
        
        drawCircle(
            color = Color(0xFFF97316),
            radius = 6f,
            center = Offset(centerX + width * 0.15f, centerY + height * 0.25f)
        )
        
        drawCircle(
            color = Color(0xFF22C55E),
            radius = 6f,
            center = Offset(centerX + width * 0.2f, centerY)
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/contextual/ContextualCardWidget.kt`

```kotlin
package com.georacing.georacing.ui.components.contextual

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.domain.model.CircuitMode
import com.georacing.georacing.domain.model.CircuitState
import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.theme.*

/**
 * Context state enum - determines what the contextual card shows.
 * Priority: Emergency > Evacuation > RedFlag > SafetyCar > Offline > Route > Race > Status
 * Mirrors iOS: ContextState.swift
 */
enum class ContextState {
    EMERGENCY,
    EVACUATION,
    RED_FLAG,
    SAFETY_CAR,
    OFFLINE,
    ROUTE_GUIDANCE,
    RACE_LIVE,
    CIRCUIT_STATUS
}

/**
 * ContextualCardWidget ‚Äî Smart card that changes content based on circuit state.
 * Mirrors iOS: ContextualCardView.swift + ContextualCardViewModel.swift
 *
 * Priorities:
 * 1. Emergency/Evacuation ‚Üí Red pulsing card
 * 2. Red Flag ‚Üí Dark red card
 * 3. Safety Car ‚Üí Orange card
 * 4. Offline ‚Üí Grey card
 * 5. Route Guidance ‚Üí Blue card (if navigating)
 * 6. Race Live ‚Üí Circuit status card
 * 7. Default ‚Üí Green status card
 */
@Composable
fun ContextualCardWidget(
    circuitState: CircuitState?,
    isOnline: Boolean = true,
    isNavigating: Boolean = false,
    navigationInstruction: String? = null,
    navigationDistance: String? = null,
    modifier: Modifier = Modifier
) {
    val contextState = remember(circuitState, isOnline, isNavigating) {
        resolveContextState(circuitState, isOnline, isNavigating)
    }

    val backdrop = LocalBackdrop.current

    AnimatedContent(
        targetState = contextState,
        transitionSpec = {
            fadeIn(tween(400)) + slideInVertically(tween(400)) { -30 } togetherWith
                    fadeOut(tween(300)) + slideOutVertically(tween(300)) { 30 }
        },
        label = "contextual_card"
    ) { state ->
        when (state) {
            ContextState.EMERGENCY, ContextState.EVACUATION -> EmergencyWidget(
                circuitState = circuitState,
                modifier = modifier
            )
            ContextState.RED_FLAG -> FlagWidget(
                title = "BANDERA ROJA",
                subtitle = circuitState?.message ?: "Sesi√≥n detenida",
                icon = Icons.Default.Flag,
                backgroundColor = Color(0xFF8B0000),
                accentColor = RacingRed,
                modifier = modifier
            )
            ContextState.SAFETY_CAR -> FlagWidget(
                title = "SAFETY CAR",
                subtitle = circuitState?.message ?: "Precauci√≥n en pista",
                icon = Icons.Default.DirectionsCar,
                backgroundColor = Color(0xFF5C3D00),
                accentColor = StatusAmber,
                modifier = modifier
            )
            ContextState.OFFLINE -> OfflineWidget(modifier = modifier)
            ContextState.ROUTE_GUIDANCE -> RouteGuidanceWidget(
                instruction = navigationInstruction ?: "",
                distance = navigationDistance ?: "",
                modifier = modifier
            )
            ContextState.RACE_LIVE, ContextState.CIRCUIT_STATUS -> CircuitStatusWidget(
                circuitState = circuitState,
                modifier = modifier
            )
        }
    }
}

/**
 * Emergency card ‚Äî pulsing red, evacuation instructions
 */
@Composable
private fun EmergencyWidget(
    circuitState: CircuitState?,
    modifier: Modifier = Modifier
) {
    val pulseAnim = rememberInfiniteTransition(label = "emergency_pulse")
    val pulseAlpha by pulseAnim.animateFloat(
        initialValue = 0.6f,
        targetValue = 1f,
        animationSpec = infiniteRepeatable(
            tween(800, easing = FastOutSlowInEasing),
            RepeatMode.Reverse
        ),
        label = "pulse"
    )

    Box(
        modifier = modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(20.dp))
            .background(
                Brush.verticalGradient(
                    listOf(
                        RacingRed.copy(alpha = pulseAlpha * 0.9f),
                        Color(0xFF8B0000).copy(alpha = pulseAlpha * 0.7f)
                    )
                )
            )
            .padding(20.dp)
    ) {
        Column {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Icon(
                    Icons.Default.Warning,
                    contentDescription = null,
                    tint = Color.White,
                    modifier = Modifier.size(32.dp)
                )
                Spacer(Modifier.width(12.dp))
                Column {
                    Text(
                        "EMERGENCIA",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Black,
                        color = Color.White,
                        letterSpacing = 2.sp
                    )
                    Text(
                        "ORDEN DE EVACUACI√ìN",
                        style = MaterialTheme.typography.labelSmall,
                        color = Color.White.copy(alpha = 0.8f),
                        letterSpacing = 1.sp
                    )
                }
            }
            Spacer(Modifier.height(12.dp))
            Text(
                circuitState?.message ?: "Sigue las instrucciones del personal y dir√≠gete a la salida m√°s cercana.",
                style = MaterialTheme.typography.bodyMedium,
                color = Color.White.copy(alpha = 0.9f)
            )
        }
    }
}

/**
 * Flag widget ‚Äî Red flag or Safety Car
 */
@Composable
private fun FlagWidget(
    title: String,
    subtitle: String,
    icon: ImageVector,
    backgroundColor: Color,
    accentColor: Color,
    modifier: Modifier = Modifier
) {
    val backdrop = LocalBackdrop.current
    LiquidCard(
        backdrop = backdrop,
        modifier = modifier.fillMaxWidth(),
        cornerRadius = 20.dp,
        surfaceColor = backgroundColor.copy(alpha = 0.85f),
        tint = accentColor.copy(alpha = 0.15f)
    ) {
        Row(
            modifier = Modifier.padding(18.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Box(
                modifier = Modifier
                    .size(48.dp)
                    .clip(RoundedCornerShape(14.dp))
                    .background(accentColor.copy(alpha = 0.2f)),
                contentAlignment = Alignment.Center
            ) {
                Icon(icon, contentDescription = null, tint = accentColor, modifier = Modifier.size(28.dp))
            }
            Spacer(Modifier.width(14.dp))
            Column {
                Text(
                    title,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Black,
                    color = TextPrimary,
                    letterSpacing = 1.sp
                )
                Spacer(Modifier.height(2.dp))
                Text(
                    subtitle,
                    style = MaterialTheme.typography.bodySmall,
                    color = TextSecondary
                )
            }
        }
    }
}

/**
 * Offline widget ‚Äî no connection indicator
 */
@Composable
private fun OfflineWidget(modifier: Modifier = Modifier) {
    val backdrop = LocalBackdrop.current
    LiquidCard(
        backdrop = backdrop,
        modifier = modifier.fillMaxWidth(),
        cornerRadius = 20.dp,
        surfaceColor = AsphaltGrey.copy(alpha = 0.85f),
        tint = TextTertiary.copy(alpha = 0.1f)
    ) {
        Row(
            modifier = Modifier.padding(18.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                Icons.Default.WifiOff,
                contentDescription = null,
                tint = StatusAmber,
                modifier = Modifier.size(28.dp)
            )
            Spacer(Modifier.width(14.dp))
            Column {
                Text(
                    "SIN CONEXI√ìN",
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Black,
                    color = TextPrimary,
                    letterSpacing = 1.sp
                )
                Text(
                    "Usando datos en cach√©. Algunas funciones pueden estar limitadas.",
                    style = MaterialTheme.typography.bodySmall,
                    color = TextTertiary
                )
            }
        }
    }
}

/**
 * Route guidance widget ‚Äî turn-by-turn instruction
 */
@Composable
private fun RouteGuidanceWidget(
    instruction: String,
    distance: String,
    modifier: Modifier = Modifier
) {
    val backdrop = LocalBackdrop.current
    LiquidCard(
        backdrop = backdrop,
        modifier = modifier.fillMaxWidth(),
        cornerRadius = 20.dp,
        surfaceColor = Color(0xFF0A1628).copy(alpha = 0.85f),
        tint = ElectricBlue.copy(alpha = 0.15f)
    ) {
        Row(
            modifier = Modifier.padding(18.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Box(
                modifier = Modifier
                    .size(48.dp)
                    .clip(CircleShape)
                    .background(ElectricBlue.copy(alpha = 0.2f)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    Icons.Default.Navigation,
                    contentDescription = null,
                    tint = ElectricBlue,
                    modifier = Modifier.size(28.dp)
                )
            }
            Spacer(Modifier.width(14.dp))
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    instruction,
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold,
                    color = TextPrimary
                )
                Text(
                    distance,
                    style = MaterialTheme.typography.bodySmall,
                    color = NeonCyan
                )
            }
        }
    }
}

/**
 * Default circuit status widget ‚Äî green/normal state
 */
@Composable
private fun CircuitStatusWidget(
    circuitState: CircuitState?,
    modifier: Modifier = Modifier
) {
    val mode = circuitState?.mode ?: CircuitMode.NORMAL
    val statusColor = when (mode) {
        CircuitMode.NORMAL -> StatusGreen
        CircuitMode.SAFETY_CAR -> StatusAmber
        CircuitMode.RED_FLAG -> RacingRed
        CircuitMode.EVACUATION -> RacingRed
        else -> TextTertiary
    }
    val statusText = when (mode) {
        CircuitMode.NORMAL -> "BANDERA VERDE"
        CircuitMode.SAFETY_CAR -> "SAFETY CAR"
        CircuitMode.RED_FLAG -> "BANDERA ROJA"
        CircuitMode.EVACUATION -> "EVACUACI√ìN"
        else -> "DESCONOCIDO"
    }

    val backdrop = LocalBackdrop.current
    LiquidCard(
        backdrop = backdrop,
        modifier = modifier.fillMaxWidth(),
        cornerRadius = 20.dp,
        surfaceColor = CarbonBlack.copy(alpha = 0.85f),
        tint = statusColor.copy(alpha = 0.1f)
    ) {
        Row(
            modifier = Modifier.padding(18.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Box(
                modifier = Modifier
                    .size(12.dp)
                    .clip(CircleShape)
                    .background(statusColor)
                    .drawBehind {
                        drawCircle(statusColor.copy(alpha = 0.3f), radius = size.minDimension)
                    }
            )
            Spacer(Modifier.width(14.dp))
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    statusText,
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Black,
                    color = TextPrimary,
                    letterSpacing = 1.sp
                )
                if (!circuitState?.message.isNullOrBlank()) {
                    Text(
                        circuitState?.message ?: "",
                        style = MaterialTheme.typography.bodySmall,
                        color = TextSecondary
                    )
                }
                circuitState?.temperature?.let { temp ->
                    Text(
                        "üå°Ô∏è $temp",
                        style = MaterialTheme.typography.labelSmall,
                        color = TextTertiary
                    )
                }
            }
            Text(
                circuitState?.updatedAt ?: "",
                style = MaterialTheme.typography.labelSmall,
                color = TextTertiary
            )
        }
    }
}

/**
 * Resolves which context state should be shown based on current conditions.
 */
private fun resolveContextState(
    circuitState: CircuitState?,
    isOnline: Boolean,
    isNavigating: Boolean
): ContextState {
    val mode = circuitState?.mode

    // Priority 1: Emergency/Evacuation
    if (mode == CircuitMode.EVACUATION) return ContextState.EVACUATION

    // Priority 2: Red Flag
    if (mode == CircuitMode.RED_FLAG) return ContextState.RED_FLAG

    // Priority 3: Safety Car
    if (mode == CircuitMode.SAFETY_CAR) return ContextState.SAFETY_CAR

    // Priority 4: Offline
    if (!isOnline) return ContextState.OFFLINE

    // Priority 5: Route guidance
    if (isNavigating) return ContextState.ROUTE_GUIDANCE

    // Default: Circuit status
    return ContextState.CIRCUIT_STATUS
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/debug/DebugControlPanel.kt`

```kotlin
package com.georacing.georacing.ui.components.debug

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.debug.ScenarioSimulator
import com.georacing.georacing.domain.model.CircuitMode

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Color Palette
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
private val BgDark = Color(0xFF0A0A14)
private val BgCard = Color(0xFF12121E)
private val BgCardLight = Color(0xFF1A1A2E)
private val AccentCyan = Color(0xFF06B6D4)
private val AccentGreen = Color(0xFF22C55E)
private val AccentRed = Color(0xFFEF4444)
private val AccentOrange = Color(0xFFF97316)
private val AccentPurple = Color(0xFF8B5CF6)
private val AccentPink = Color(0xFFEC4899)
private val AccentGold = Color(0xFFEAB308)
private val AccentBlue = Color(0xFF3B82F6)
private val TextDim = Color(0xFF64748B)
private val TextLight = Color(0xFFE2E8F0)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Tab definitions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
private enum class DebugTab(val icon: ImageVector, val label: String, val color: Color) {
    PRESETS(Icons.Filled.AutoAwesome, "Presets", AccentPink),
    GAMIFICATION(Icons.Filled.EmojiEvents, "Logros", AccentGold),
    CIRCUIT(Icons.Filled.Flag, "Circuito", AccentRed),
    SOCIAL(Icons.Filled.People, "Social", AccentBlue),
    SYSTEM(Icons.Filled.Settings, "Sistema", AccentCyan)
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN PANEL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
@Composable
fun DebugControlPanel(
    onDismiss: () -> Unit
) {
    var selectedTab by remember { mutableStateOf(DebugTab.PRESETS) }
    var toastMessage by remember { mutableStateOf<String?>(null) }

    val showToast: (String) -> Unit = { msg -> toastMessage = msg }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(BgDark.copy(alpha = 0.92f))
            .clickable { onDismiss() }
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(top = 40.dp)
                .clickable(enabled = false) {}
        ) {
            // ‚îÄ‚îÄ Header ‚îÄ‚îÄ
            DebugHeader(onDismiss)

            // ‚îÄ‚îÄ Toast feedback ‚îÄ‚îÄ
            AnimatedVisibility(
                visible = toastMessage != null,
                enter = slideInVertically() + fadeIn(),
                exit = slideOutVertically() + fadeOut()
            ) {
                toastMessage?.let { msg ->
                    Card(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(horizontal = 16.dp, vertical = 4.dp),
                        colors = CardDefaults.cardColors(containerColor = AccentGreen.copy(alpha = 0.15f)),
                        shape = RoundedCornerShape(8.dp)
                    ) {
                        Text(
                            msg,
                            color = AccentGreen,
                            fontSize = 12.sp,
                            fontWeight = FontWeight.Medium,
                            modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp)
                        )
                    }
                    LaunchedEffect(msg) {
                        kotlinx.coroutines.delay(2000)
                        toastMessage = null
                    }
                }
            }

            // ‚îÄ‚îÄ Tab Bar ‚îÄ‚îÄ
            DebugTabBar(selectedTab) { selectedTab = it }

            // ‚îÄ‚îÄ Tab Content ‚îÄ‚îÄ
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(horizontal = 12.dp),
                contentPadding = PaddingValues(top = 8.dp, bottom = 32.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                when (selectedTab) {
                    DebugTab.PRESETS -> presetsTab(showToast)
                    DebugTab.GAMIFICATION -> gamificationTab(showToast)
                    DebugTab.CIRCUIT -> circuitTab(showToast)
                    DebugTab.SOCIAL -> socialTab(showToast)
                    DebugTab.SYSTEM -> systemTab(showToast)
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HEADER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
@Composable
private fun DebugHeader(onDismiss: () -> Unit) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Animated indicator
        val infiniteTransition = rememberInfiniteTransition(label = "pulse")
        val pulseAlpha by infiniteTransition.animateFloat(
            initialValue = 0.4f, targetValue = 1f,
            animationSpec = infiniteRepeatable(tween(1000), RepeatMode.Reverse),
            label = "pulse"
        )

        Box(
            modifier = Modifier
                .size(10.dp)
                .clip(CircleShape)
                .background(AccentGreen.copy(alpha = pulseAlpha))
        )

        Spacer(Modifier.width(10.dp))

        Column(modifier = Modifier.weight(1f)) {
            Text(
                "Debug Console",
                color = TextLight,
                fontSize = 18.sp,
                fontWeight = FontWeight.Bold,
                letterSpacing = 0.5.sp
            )
            Text(
                "Simula toda la app sin estar en el circuito",
                color = TextDim,
                fontSize = 11.sp
            )
        }

        // Simulation active indicator
        val isActive = ScenarioSimulator.isSimulationActive
        if (isActive) {
            Box(
                modifier = Modifier
                    .clip(RoundedCornerShape(4.dp))
                    .background(AccentOrange.copy(alpha = 0.2f))
                    .padding(horizontal = 6.dp, vertical = 2.dp)
            ) {
                Text("LIVE", color = AccentOrange, fontSize = 9.sp, fontWeight = FontWeight.Bold)
            }
            Spacer(Modifier.width(8.dp))
        }

        IconButton(onClick = onDismiss) {
            Icon(Icons.Filled.Close, "Cerrar", tint = TextDim)
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TAB BAR
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
@Composable
private fun DebugTabBar(selected: DebugTab, onSelect: (DebugTab) -> Unit) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 12.dp, vertical = 4.dp)
            .clip(RoundedCornerShape(12.dp))
            .background(BgCard),
        horizontalArrangement = Arrangement.SpaceEvenly
    ) {
        DebugTab.entries.forEach { tab ->
            val isSelected = tab == selected
            val bgColor by animateColorAsState(
                if (isSelected) tab.color.copy(alpha = 0.15f) else Color.Transparent,
                label = "tabBg"
            )
            val contentColor by animateColorAsState(
                if (isSelected) tab.color else TextDim,
                label = "tabContent"
            )

            Column(
                modifier = Modifier
                    .weight(1f)
                    .clickable { onSelect(tab) }
                    .background(bgColor)
                    .padding(vertical = 10.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Icon(tab.icon, tab.label, tint = contentColor, modifier = Modifier.size(20.dp))
                Spacer(Modifier.height(2.dp))
                Text(
                    tab.label, color = contentColor, fontSize = 9.sp,
                    fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal,
                    maxLines = 1
                )
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TAB: PRESETS ‚Äî Full scenario simulations
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
private fun androidx.compose.foundation.lazy.LazyListScope.presetsTab(toast: (String) -> Unit) {
    item {
        SectionTitle("Escenarios completos", "Un bot√≥n = experiencia simulada completa")
    }

    item {
        PresetCard(
            emoji = "üÜï", title = "Fan Nuevo",
            subtitle = "Primera visita al circuito. Reset total + primer logro y cromo.",
            gradient = listOf(Color(0xFF1E3A5F), Color(0xFF0F2030)),
            onClick = { ScenarioSimulator.simulateNewFan(); toast("‚úÖ Fan nuevo ‚Äî reset + primer logro") }
        )
    }
    item {
        PresetCard(
            emoji = "üèéÔ∏è", title = "Fan Activo ‚Äî D√≠a Completo",
            subtitle = "5 logros, 5 cromos, 12K pasos, exploraci√≥n b√°sica.",
            gradient = listOf(Color(0xFF1A3D2E), Color(0xFF0F2018)),
            onClick = { ScenarioSimulator.simulateActiveFanDay(); toast("‚úÖ D√≠a activo simulado") }
        )
    }
    item {
        PresetCard(
            emoji = "‚≠ê", title = "VIP Experience",
            subtitle = "Todo desbloqueado. Todos los logros + √©picos + 2000 XP.",
            gradient = listOf(Color(0xFF3D3010), Color(0xFF201A08)),
            onClick = { ScenarioSimulator.simulateVIPExperience(); toast("‚úÖ VIP ‚Äî todo desbloqueado") }
        )
    }
    item {
        PresetCard(
            emoji = "üö®", title = "Emergencia Total",
            subtitle = "Evacuaci√≥n BLE + Crowd surge + Logros safety desbloqueados.",
            gradient = listOf(Color(0xFF3D1010), Color(0xFF200808)),
            onClick = { ScenarioSimulator.simulateEmergencyScenario(); toast("‚úÖ Emergencia activada") }
        )
    }
    item {
        PresetCard(
            emoji = "üèÅ", title = "Race Day",
            subtitle = "Safety Car + hazards + crowd + pedidos + grupo con 3 miembros.",
            gradient = listOf(Color(0xFF2D1040), Color(0xFF180820)),
            onClick = {
                ScenarioSimulator.simulateCircuitMode(CircuitMode.SAFETY_CAR)
                ScenarioSimulator.addHazard(ScenarioSimulator.HazardType.TRAFFIC)
                ScenarioSimulator.triggerCrowdSurge()
                ScenarioSimulator.createOrdersAllStatuses()
                ScenarioSimulator.createFakeGroup()
                ScenarioSimulator.addFakeSteps(8000)
                ScenarioSimulator.spawnRacers(5)
                toast("‚úÖ Race Day simulado")
            }
        )
    }
    item {
        PresetCard(
            emoji = "üåßÔ∏è", title = "D√≠a Lluvioso",
            subtitle = "Lluvia, 14¬∞C, tr√°fico denso, bandera amarilla.",
            gradient = listOf(Color(0xFF10253D), Color(0xFF081520)),
            onClick = {
                ScenarioSimulator.simulateWeather(14f, "Lluvia")
                ScenarioSimulator.simulateCircuitMode(CircuitMode.YELLOW_FLAG)
                ScenarioSimulator.addHazard(ScenarioSimulator.HazardType.TRAFFIC)
                ScenarioSimulator.unlockCollectible("c20") // Bajo la lluvia
                toast("‚úÖ D√≠a lluvioso simulado")
            }
        )
    }

    item { Spacer(Modifier.height(4.dp)) }

    item {
        DangerButton(
            text = "üîÑ RESET COMPLETO (todo)",
            onClick = { ScenarioSimulator.resetEverything(); toast("‚úÖ Todo reseteado") }
        )
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TAB: GAMIFICATION ‚Äî Achievements + Collectibles + XP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
private fun androidx.compose.foundation.lazy.LazyListScope.gamificationTab(toast: (String) -> Unit) {
    // ‚îÄ‚îÄ Achievements section ‚îÄ‚îÄ
    item { SectionTitle("üèÜ Logros", "20 logros en 6 categor√≠as") }

    item {
        ActionRow(
            left = ActionItem("Desbloquear TODOS", AccentGreen) {
                ScenarioSimulator.unlockAllAchievements(); toast("‚úÖ 20 logros desbloqueados")
            },
            right = ActionItem("Resetear TODOS", AccentRed) {
                ScenarioSimulator.resetAllAchievements(); toast("‚úÖ Logros reseteados")
            }
        )
    }

    // Logros individuales agrupados
    item {
        var expanded by remember { mutableStateOf(false) }
        ExpandableSection("Logros individuales (20)", expanded) { expanded = !expanded }
        if (expanded) {
            Column(verticalArrangement = Arrangement.spacedBy(3.dp)) {
                achievementList.forEach { (category, items) ->
                    Text(category, color = TextDim, fontSize = 10.sp, fontWeight = FontWeight.Bold,
                        modifier = Modifier.padding(top = 6.dp, bottom = 2.dp))
                    items.forEach { (id, label, emoji) ->
                        MiniButton("$emoji $label") {
                            ScenarioSimulator.unlockAchievement(id); toast("‚úÖ $label")
                        }
                    }
                }
            }
        }
    }

    // ‚îÄ‚îÄ XP ‚îÄ‚îÄ
    item { SectionTitle("‚ö° Experiencia", "A√±ade XP para subir de nivel") }

    item {
        ActionRow(
            left = ActionItem("+500 XP", AccentPurple) {
                ScenarioSimulator.addBonusXP(500); toast("‚úÖ +500 XP")
            },
            right = ActionItem("+2000 XP", Color(0xFF6D28D9)) {
                ScenarioSimulator.addBonusXP(2000); toast("‚úÖ +2000 XP")
            }
        )
    }

    // ‚îÄ‚îÄ Collectibles section ‚îÄ‚îÄ
    item { SectionTitle("üé¥ Coleccionables", "24 cromos digitales (4 rarezas)") }

    item {
        ActionRow(
            left = ActionItem("Todos (24)", AccentGreen) {
                ScenarioSimulator.unlockAllCollectibles(); toast("‚úÖ 24 cromos desbloqueados")
            },
            right = ActionItem("Resetear", AccentRed) {
                ScenarioSimulator.resetAllCollectibles(); toast("‚úÖ Cromos reseteados")
            }
        )
    }

    item {
        ActionRow(
            left = ActionItem("üé≤ Random 5", AccentPurple) {
                ScenarioSimulator.unlockRandomCollectibles(5); toast("‚úÖ 5 aleatorios")
            },
            right = ActionItem("üé≤ Random 12", Color(0xFF7C3AED)) {
                ScenarioSimulator.unlockRandomCollectibles(12); toast("‚úÖ 12 aleatorios")
            }
        )
    }

    item {
        var expanded by remember { mutableStateOf(false) }
        ExpandableSection("Cromos individuales (24)", expanded) { expanded = !expanded }
        if (expanded) {
            Column(verticalArrangement = Arrangement.spacedBy(3.dp)) {
                // Generamos la lista de 24 cromos a partir de los datos en CollectiblesScreen
                // Como no tenemos acceso directo a la lista est√°tica aqu√≠ sin refactorizar,
                // usamos los IDs num√©ricos y un t√≠tulo gen√©rico (el usuario en debug ya sabe qu√© es)
                val collectibleNames = mapOf(
                    1 to "Fernando Alonso", 2 to "Lewis Hamilton", 3 to "Max Verstappen",
                    4 to "Marc M√°rquez", 5 to "Pecco Bagnaia", 6 to "Marchador",
                    7 to "Corredor", 25 to "Maratonista", 8 to "Primera Foto",
                    9 to "Fot√≥grafo", 10 to "Paparazzi", 11 to "Primer Pedido",
                    12 to "Gourmet", 13 to "Master Chef", 14 to "VIP Access",
                    15 to "Pit Lane", 16 to "Eco Warrior", 17 to "Planeta Verde",
                    18 to "Nocturno", 19 to "Madrugador", 20 to "Bajo la Lluvia",
                    21 to "Leyenda GeoRacing", 22 to "Fiel al Circuito", 23 to "El Primero",
                    24 to "Grupo Legendario"
                )
                
                collectibleNames.forEach { (num, name) ->
                    val id = "c${num.toString().padStart(2, '0')}"
                    MiniButton("üé¥ $id - $name") {
                        ScenarioSimulator.unlockCollectible(id)
                        toast("‚úÖ Desbloqueado: $name")
                    }
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TAB: CIRCUIT ‚Äî Flags, Weather, Traffic, Zones, Hazards
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
private fun androidx.compose.foundation.lazy.LazyListScope.circuitTab(toast: (String) -> Unit) {
    // ‚îÄ‚îÄ Circuit Flags ‚îÄ‚îÄ
    item { SectionTitle("üèÅ Banderas del Circuito", "Simula el estado de la carrera") }

    item {
        FlagGrid(toast)
    }

    // ‚îÄ‚îÄ Weather ‚îÄ‚îÄ
    item { SectionTitle("üå§Ô∏è Meteorolog√≠a", "Inyecta datos de clima") }

    item {
        ActionRow(
            left = ActionItem("‚òÄÔ∏è Sol 32¬∞C", AccentOrange) {
                ScenarioSimulator.simulateWeather(32f, "Soleado"); toast("‚úÖ Sol 32¬∞C")
            },
            right = ActionItem("üåßÔ∏è Lluvia 14¬∞C", AccentBlue) {
                ScenarioSimulator.simulateWeather(14f, "Lluvia"); toast("‚úÖ Lluvia 14¬∞C")
            }
        )
    }
    item {
        ActionRow(
            left = ActionItem("‚ùÑÔ∏è Fr√≠o 3¬∞C", Color(0xFF7DD3FC)) {
                ScenarioSimulator.simulateWeather(3f, "Fr√≠o"); toast("‚úÖ Fr√≠o 3¬∞C")
            },
            right = ActionItem("üîÑ Real", TextDim) {
                ScenarioSimulator.clearWeather(); toast("‚úÖ Clima real")
            }
        )
    }

    // ‚îÄ‚îÄ Crowd / Traffic ‚îÄ‚îÄ
    item { SectionTitle("üë• Multitudes y Tr√°fico", "Aglomeraci√≥n + hazards Waze") }

    item {
        ActionRow(
            left = ActionItem("Crowd 90%", AccentRed) {
                ScenarioSimulator.triggerCrowdSurge(); toast("‚úÖ Surge activado")
            },
            right = ActionItem("Clear Crowd", AccentGreen) {
                ScenarioSimulator.resetCrowd(); toast("‚úÖ Crowd limpio")
            }
        )
    }
    item {
        ActionRow(
            left = ActionItem("üèéÔ∏è Spawn 5 Racers", AccentCyan) {
                ScenarioSimulator.spawnRacers(5); toast("‚úÖ 5 racers spawned")
            },
            right = ActionItem("Clear Racers", TextDim) {
                ScenarioSimulator.clearRacers(); toast("‚úÖ Racers eliminados")
            }
        )
    }

    // ‚îÄ‚îÄ Hazards ‚îÄ‚îÄ
    item { SectionTitle("‚ö†Ô∏è Hazards (estilo Waze)", "Peligros en el mapa") }

    item {
        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(6.dp)) {
            ScenarioSimulator.HazardType.entries.forEach { hazard ->
                SmallChipButton(
                    text = "${hazard.emoji} ${hazard.label.take(10)}",
                    color = AccentOrange,
                    modifier = Modifier.weight(1f)
                ) {
                    ScenarioSimulator.addHazard(hazard); toast("‚úÖ ${hazard.label}")
                }
            }
        }
    }
    item {
        MiniButton("üóëÔ∏è Limpiar todos los hazards") {
            ScenarioSimulator.clearHazards(); toast("‚úÖ Hazards eliminados")
        }
    }

    // ‚îÄ‚îÄ Zone simulation ‚îÄ‚îÄ
    item { SectionTitle("üìç Zonas del Circuito", "Simula estar en una zona") }

    item {
        var expanded by remember { mutableStateOf(false) }
        ExpandableSection("8 zonas disponibles", expanded) { expanded = !expanded }
        if (expanded) {
            Column(verticalArrangement = Arrangement.spacedBy(3.dp)) {
                listOf(
                    "Tribuna Principal", "Paddock VIP", "Fan Zone",
                    "Curva 1-3", "Recta Principal", "Pit Lane",
                    "Parking Norte", "Hospitality"
                ).forEach { zone ->
                    MiniButton("üìç $zone") {
                        ScenarioSimulator.simulateZoneVisit(zone); toast("‚úÖ Zona: $zone")
                    }
                }
            }
        }
    }

    item {
        ActionRow(
            left = ActionItem("üó∫Ô∏è Todas las zonas", AccentCyan) {
                ScenarioSimulator.simulateAllZonesVisited(); toast("‚úÖ Todas visitadas")
            },
            right = ActionItem("üîÑ Reset zona", TextDim) {
                ScenarioSimulator.resetSimulatedZone(); toast("‚úÖ Zona reseteada")
            }
        )
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TAB: SOCIAL ‚Äî Orders, Groups, Alerts, Incidents
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
private fun androidx.compose.foundation.lazy.LazyListScope.socialTab(toast: (String) -> Unit) {
    // ‚îÄ‚îÄ Orders ‚îÄ‚îÄ
    item { SectionTitle("üõí Pedidos Click & Collect", "Crea pedidos falsos en todas las fases") }

    item {
        ActionRow(
            left = ActionItem("Pedido Pendiente", AccentOrange) {
                ScenarioSimulator.createFakeOrder("pending"); toast("‚úÖ Pedido pending")
            },
            right = ActionItem("Preparando", Color(0xFFD97706)) {
                ScenarioSimulator.createFakeOrder("preparing"); toast("‚úÖ Pedido preparing")
            }
        )
    }
    item {
        ActionRow(
            left = ActionItem("üîî Listo!", AccentGreen) {
                ScenarioSimulator.createFakeOrder("ready"); toast("‚úÖ Pedido listo!")
            },
            right = ActionItem("üì¶ Todos (4)", AccentBlue) {
                ScenarioSimulator.createOrdersAllStatuses(); toast("‚úÖ 4 pedidos creados")
            }
        )
    }

    // ‚îÄ‚îÄ Groups ‚îÄ‚îÄ
    item { SectionTitle("üë• Grupos", "Crea un grupo con miembros fake en el mapa") }

    item {
        GlowButton(
            text = "Crear grupo + 3 miembros GPS",
            color = AccentBlue,
            onClick = { ScenarioSimulator.createFakeGroup(); toast("‚úÖ Grupo con 3 miembros") }
        )
    }

    // ‚îÄ‚îÄ Alerts / News ‚îÄ‚îÄ
    item { SectionTitle("üì∞ Alertas / Noticias", "Publica alertas que se ven en la app") }

    item {
        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(6.dp)) {
            listOf(
                Triple("‚ö†Ô∏è Safety", "SAFETY", AccentRed),
                Triple("üå§Ô∏è Meteo", "WEATHER", AccentBlue),
                Triple("üöó Tr√°fico", "TRAFFIC", AccentOrange)
            ).forEach { (label, cat, color) ->
                SmallChipButton(label, color, Modifier.weight(1f)) {
                    ScenarioSimulator.createFakeAlert(cat); toast("‚úÖ Alerta $cat")
                }
            }
        }
    }
    item {
        ActionRow(
            left = ActionItem("üìÖ Horario", AccentPurple) {
                ScenarioSimulator.createFakeAlert("SCHEDULE_CHANGE"); toast("‚úÖ Alerta horario")
            },
            right = ActionItem("üì¢ General", TextDim) {
                ScenarioSimulator.createFakeAlert("GENERAL"); toast("‚úÖ Alerta general")
            }
        )
    }

    // ‚îÄ‚îÄ Incidents ‚îÄ‚îÄ
    item { SectionTitle("üö® Incidencias", "Simula reportes de incidentes") }

    item {
        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(6.dp)) {
            listOf(
                Triple("üè• M√©dica", "medical", AccentRed),
                Triple("üî• Fuego", "fire", AccentOrange),
                Triple("üë• Crowd", "crowd", AccentPurple)
            ).forEach { (label, type, color) ->
                SmallChipButton(label, color, Modifier.weight(1f)) {
                    ScenarioSimulator.createFakeIncident(type); toast("‚úÖ Incidente $type")
                }
            }
        }
    }

    // ‚îÄ‚îÄ Eco ‚îÄ‚îÄ
    item { SectionTitle("üå± Eco / Sostenibilidad", "CO‚ÇÇ ahorrado") }

    item {
        ActionRow(
            left = ActionItem("+1 kg CO‚ÇÇ", AccentGreen) {
                ScenarioSimulator.addCO2Saved(1f); toast("‚úÖ +1 kg CO‚ÇÇ")
            },
            right = ActionItem("+5 kg CO‚ÇÇ", Color(0xFF16A34A)) {
                ScenarioSimulator.addCO2Saved(5f); toast("‚úÖ +5 kg CO‚ÇÇ")
            }
        )
    }

    // ‚îÄ‚îÄ Parking ‚îÄ‚îÄ
    item { SectionTitle("üÖøÔ∏è Parking", "Guardar/borrar posici√≥n del coche") }

    item {
        ActionRow(
            left = ActionItem("üìç Guardar coche", AccentBlue) {
                ScenarioSimulator.saveCarLocation(); toast("‚úÖ Coche guardado")
            },
            right = ActionItem("üóëÔ∏è Borrar", AccentRed) {
                ScenarioSimulator.clearCarLocation(); toast("‚úÖ Coche borrado")
            }
        )
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TAB: SYSTEM ‚Äî Battery, Network, Car, Steps, Speed, BLE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
private fun androidx.compose.foundation.lazy.LazyListScope.systemTab(toast: (String) -> Unit) {
    // ‚îÄ‚îÄ Battery ‚îÄ‚îÄ
    item { SectionTitle("üîã Bater√≠a / Energ√≠a", "Fuerza nivel de bater√≠a") }

    item {
        ActionRow(
            left = ActionItem("Survival 20%", AccentOrange) {
                ScenarioSimulator.simulateSurvivalMode(); toast("‚úÖ Bater√≠a 20%")
            },
            right = ActionItem("üîÑ Real", TextDim) {
                ScenarioSimulator.resetAll(); toast("‚úÖ Bater√≠a real")
            }
        )
    }

    // ‚îÄ‚îÄ Network ‚îÄ‚îÄ
    item { SectionTitle("üì° Red / Conectividad", "Simula ca√≠da de red") }

    item {
        ActionRow(
            left = ActionItem("üíÄ Kill Network", Color(0xFF374151)) {
                ScenarioSimulator.killNetwork(); toast("‚úÖ Red muerta (503)")
            },
            right = ActionItem("üì° Restaurar", AccentCyan) {
                ScenarioSimulator.restoreNetwork(); toast("‚úÖ Red ok")
            }
        )
    }

    // ‚îÄ‚îÄ Car ‚îÄ‚îÄ
    item { SectionTitle("üöó Android Auto / Coche", "Simula conexi√≥n/desconexi√≥n") }

    item {
        ActionRow(
            left = ActionItem("Conectar", AccentCyan) {
                ScenarioSimulator.simulateCarConnect(); toast("‚úÖ Coche conectado")
            },
            right = ActionItem("Desconectar", TextDim) {
                ScenarioSimulator.simulateCarDisconnect(); toast("‚úÖ Coche desconectado")
            }
        )
    }

    // ‚îÄ‚îÄ Health ‚îÄ‚îÄ
    item { SectionTitle("üèÉ Salud / Pasos", "Inyecta pasos en Health Connect") }

    item {
        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(6.dp)) {
            listOf(
                Triple("+1K", 1000, AccentBlue),
                Triple("+5K", 5000, AccentCyan),
                Triple("+10K", 10000, AccentPurple),
                Triple("+25K", 25000, Color(0xFF6D28D9))
            ).forEach { (label, steps, color) ->
                SmallChipButton(label, color, Modifier.weight(1f)) {
                    ScenarioSimulator.addFakeSteps(steps); toast("‚úÖ +$steps pasos")
                }
            }
        }
    }

    // ‚îÄ‚îÄ Speed ‚îÄ‚îÄ
    item { SectionTitle("‚ö° Velocidad GPS", "Simula velocidad de desplazamiento") }

    item {
        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(6.dp)) {
            listOf(
                Triple("5 km/h", 5f, AccentGreen),
                Triple("30 km/h", 30f, AccentBlue),
                Triple("80 km/h", 80f, AccentOrange),
                Triple("200 km/h", 200f, AccentRed)
            ).forEach { (label, speed, color) ->
                SmallChipButton(label, color, Modifier.weight(1f)) {
                    ScenarioSimulator.setSimulatedSpeed(speed); toast("‚úÖ $label")
                }
            }
        }
    }

    // ‚îÄ‚îÄ Transport mode ‚îÄ‚îÄ
    item { SectionTitle("üö∂ Modo Transporte", "Fuerza detecci√≥n de transporte") }

    item {
        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(6.dp)) {
            listOf(
                Triple("üö∂ Andando", "walking", AccentGreen),
                Triple("üöó Coche", "driving", AccentBlue),
                Triple("üöÜ Tren", "transit", AccentPurple),
                Triple("üîÑ Auto", null, TextDim)
            ).forEach { (label, mode, color) ->
                SmallChipButton(label, color, Modifier.weight(1f)) {
                    ScenarioSimulator.setTransportMode(mode); toast("‚úÖ $label")
                }
            }
        }
    }

    // ‚îÄ‚îÄ Smart Ticket ‚îÄ‚îÄ
    item { SectionTitle("üé´ Smart Ticket", "Proximidad a puertas de acceso") }

    item {
        ActionRow(
            left = ActionItem("üìç En puerta", AccentGold) {
                ScenarioSimulator.arriveAtGate(); toast("‚úÖ En puerta de acceso")
            },
            right = ActionItem("üîÑ Reset", TextDim) {
                ScenarioSimulator.resetGate(); toast("‚úÖ Puerta reseteada")
            }
        )
    }

    // ‚îÄ‚îÄ Master Reset ‚îÄ‚îÄ
    item { Spacer(Modifier.height(8.dp)) }

    item {
        DangerButton("üí£ RESET ABSOLUTO ‚Äî Todo a cero") {
            ScenarioSimulator.resetEverything(); toast("‚úÖ Reset absoluto completado")
        }
    }
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UI COMPONENTS ‚Äî Premium Design System
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun SectionTitle(title: String, subtitle: String) {
    Column(modifier = Modifier.padding(top = 8.dp, bottom = 2.dp)) {
        Text(title, color = TextLight, fontSize = 14.sp, fontWeight = FontWeight.Bold)
        Text(subtitle, color = TextDim, fontSize = 10.sp)
    }
}

@Composable
private fun PresetCard(
    emoji: String,
    title: String,
    subtitle: String,
    gradient: List<Color>,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick),
        shape = RoundedCornerShape(14.dp),
        colors = CardDefaults.cardColors(containerColor = Color.Transparent)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .background(Brush.horizontalGradient(gradient))
                .border(1.dp, Color.White.copy(alpha = 0.06f), RoundedCornerShape(14.dp))
                .padding(14.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(emoji, fontSize = 28.sp)
            Spacer(Modifier.width(12.dp))
            Column(modifier = Modifier.weight(1f)) {
                Text(title, color = TextLight, fontSize = 14.sp, fontWeight = FontWeight.Bold)
                Text(subtitle, color = TextDim, fontSize = 11.sp, lineHeight = 14.sp)
            }
            Icon(Icons.Filled.PlayArrow, null, tint = TextDim.copy(alpha = 0.5f), modifier = Modifier.size(20.dp))
        }
    }
}

data class ActionItem(val label: String, val color: Color, val onClick: () -> Unit)

@Composable
private fun ActionRow(left: ActionItem, right: ActionItem) {
    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(6.dp)) {
        ActionButton(left.label, left.color, Modifier.weight(1f), left.onClick)
        ActionButton(right.label, right.color, Modifier.weight(1f), right.onClick)
    }
}

@Composable
private fun ActionButton(text: String, color: Color, modifier: Modifier = Modifier, onClick: () -> Unit) {
    Button(
        onClick = onClick,
        modifier = modifier.height(42.dp),
        shape = RoundedCornerShape(10.dp),
        colors = ButtonDefaults.buttonColors(
            containerColor = color.copy(alpha = 0.15f),
            contentColor = color
        ),
        contentPadding = PaddingValues(horizontal = 8.dp)
    ) {
        Text(text, fontSize = 11.sp, fontWeight = FontWeight.SemiBold, maxLines = 1, overflow = TextOverflow.Ellipsis)
    }
}

@Composable
private fun SmallChipButton(text: String, color: Color, modifier: Modifier = Modifier, onClick: () -> Unit) {
    OutlinedButton(
        onClick = onClick,
        modifier = modifier.height(36.dp),
        shape = RoundedCornerShape(8.dp),
        colors = ButtonDefaults.outlinedButtonColors(contentColor = color),
        border = ButtonDefaults.outlinedButtonBorder(enabled = true),
        contentPadding = PaddingValues(horizontal = 4.dp)
    ) {
        Text(text, fontSize = 9.sp, maxLines = 1, overflow = TextOverflow.Ellipsis)
    }
}

@Composable
private fun GlowButton(text: String, color: Color, onClick: () -> Unit) {
    Button(
        onClick = onClick,
        modifier = Modifier.fillMaxWidth().height(48.dp),
        shape = RoundedCornerShape(12.dp),
        colors = ButtonDefaults.buttonColors(
            containerColor = color.copy(alpha = 0.2f),
            contentColor = color
        )
    ) {
        Text(text, fontWeight = FontWeight.Bold, fontSize = 13.sp)
    }
}

@Composable
private fun MiniButton(text: String, onClick: () -> Unit) {
    TextButton(
        onClick = onClick,
        modifier = Modifier.fillMaxWidth().height(34.dp),
        shape = RoundedCornerShape(6.dp),
        contentPadding = PaddingValues(horizontal = 8.dp)
    ) {
        Text(text, color = TextLight.copy(alpha = 0.7f), fontSize = 11.sp, modifier = Modifier.fillMaxWidth())
    }
}

@Composable
private fun DangerButton(text: String, onClick: () -> Unit) {
    Button(
        onClick = onClick,
        modifier = Modifier.fillMaxWidth().height(48.dp),
        shape = RoundedCornerShape(12.dp),
        colors = ButtonDefaults.buttonColors(
            containerColor = AccentRed.copy(alpha = 0.15f),
            contentColor = AccentRed
        ),
        border = ButtonDefaults.outlinedButtonBorder(enabled = true)
    ) {
        Text(text, fontWeight = FontWeight.Bold, fontSize = 12.sp)
    }
}

@Composable
private fun ExpandableSection(title: String, expanded: Boolean, onClick: () -> Unit) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(8.dp))
            .background(BgCardLight)
            .clickable(onClick = onClick)
            .padding(horizontal = 12.dp, vertical = 10.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(title, color = TextLight, fontSize = 12.sp, modifier = Modifier.weight(1f))
        Icon(
            if (expanded) Icons.Filled.ExpandLess else Icons.Filled.ExpandMore,
            null, tint = TextDim, modifier = Modifier.size(18.dp)
        )
    }
}

@Composable
private fun FlagGrid(toast: (String) -> Unit) {
    val flags = listOf(
        Triple("üü¢ Green", CircuitMode.GREEN_FLAG, Color(0xFF22C55E)),
        Triple("üü° Yellow", CircuitMode.YELLOW_FLAG, Color(0xFFEAB308)),
        Triple("üî¥ Red", CircuitMode.RED_FLAG, Color(0xFFEF4444)),
        Triple("üèéÔ∏è Safety Car", CircuitMode.SAFETY_CAR, Color(0xFFF97316)),
        Triple("üíª VSC", CircuitMode.VSC, Color(0xFF8B5CF6)),
        Triple("üö® Evacuaci√≥n", CircuitMode.EVACUATION, Color(0xFFDC2626))
    )

    Column(verticalArrangement = Arrangement.spacedBy(4.dp)) {
        flags.chunked(3).forEach { row ->
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                row.forEach { (label, mode, color) ->
                    SmallChipButton(label, color, Modifier.weight(1f)) {
                        ScenarioSimulator.simulateCircuitMode(mode); toast("‚úÖ $label")
                    }
                }
            }
        }
        MiniButton("üîÑ Quitar bandera (dato real)") {
            ScenarioSimulator.clearCircuitMode(); toast("‚úÖ Bandera quitada")
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DATA: Achievement list for individual unlock
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
private val achievementList = listOf(
    "üó∫Ô∏è Explorer" to listOf(
        Triple("exp_first_visit", "Primera Visita", "üèÅ"),
        Triple("exp_all_zones", "Explorador Total", "üó∫Ô∏è"),
        Triple("exp_5km", "Maratoniano", "üèÉ"),
        Triple("exp_paddock", "Acceso VIP", "‚≠ê")
    ),
    "üë• Social" to listOf(
        Triple("soc_first_group", "En Equipo", "üë•"),
        Triple("soc_5_friends", "Escuder√≠a Completa", "üèéÔ∏è"),
        Triple("soc_share_qr", "Conexi√≥n R√°pida", "üì±"),
        Triple("soc_moment_shared", "Fot√≥grafo", "üì∏")
    ),
    "‚ö° Speed" to listOf(
        Triple("spd_first_nav", "GPS Activado", "üõ∞Ô∏è"),
        Triple("spd_arrive_fast", "Pole Position", "‚è±Ô∏è"),
        Triple("spd_find_car", "Memoria de Elefante", "üöó")
    ),
    "üé™ Fan" to listOf(
        Triple("fan_first_order", "Primera Compra", "üõí"),
        Triple("fan_merch", "Coleccionista", "üëï"),
        Triple("fan_weather_check", "Meteor√≥logo", "üå§Ô∏è"),
        Triple("fan_telemetry", "Ingeniero de Datos", "üìä")
    ),
    "üå± Eco" to listOf(
        Triple("eco_transport", "Movilidad Verde", "üöÜ"),
        Triple("eco_fountain", "Hidrataci√≥n Sostenible", "üíß")
    ),
    "üõ°Ô∏è Safety" to listOf(
        Triple("saf_report", "Ciudadano Responsable", "üõ°Ô∏è"),
        Triple("saf_emergency", "Preparado", "üè•"),
        Triple("saf_medical", "Prevenci√≥n", "üÜò")
    )
)

// ‚îÄ‚îÄ Public DebugButton (used by SettingsScreen) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@Composable
fun DebugButton(
    text: String,
    color: Color,
    onClick: () -> Unit
) {
    Button(
        onClick = onClick,
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 24.dp, vertical = 8.dp)
            .height(52.dp),
        colors = ButtonDefaults.buttonColors(containerColor = color),
        shape = RoundedCornerShape(14.dp),
        border = androidx.compose.foundation.BorderStroke(
            1.dp,
            Brush.horizontalGradient(listOf(Color(0xFFFF2D55), Color(0xFFBF5AF2)))
        )
    ) {
        Text(
            text = text,
            color = Color.White,
            fontWeight = FontWeight.Bold,
            fontSize = 14.sp
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/kpi/KpiCard.kt`

```kotlin
package com.georacing.georacing.ui.components.kpi

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@Composable
fun KpiCard(
    title: String,
    value: String,
    modifier: Modifier = Modifier,
    accent: Color = MaterialTheme.colorScheme.primary
) {
    Surface(
        modifier = modifier
            .clip(RoundedCornerShape(12.dp))
            .background(Color(0xFF14141C)),
        color = Color(0xFF14141C),
        tonalElevation = 0.dp
    ) {
        Column(modifier = Modifier.padding(12.dp)) {
            Text(title.uppercase(), style = MaterialTheme.typography.labelSmall, color = accent)
            Text(value, style = MaterialTheme.typography.headlineSmall.copy(fontWeight = FontWeight.Bold), color = Color(0xFFF8FAFC))
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/map/CrowdHeatmapOverlay.kt`

```kotlin
package com.georacing.georacing.ui.components.map

import androidx.compose.animation.core.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.*
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.Stroke
import com.georacing.georacing.data.repository.HeatPoint
import kotlinx.coroutines.delay

@Composable
fun CrowdHeatmapOverlay(
    heatPoints: List<HeatPoint>,
    cameraPositionLatitude: Double, // To project Points to Screen (Simplified for Demo)
    cameraPositionLongitude: Double,
    zoomLevel: Float
) {
    // Pulse Animation for High Intensity
    val infiniteTransition = rememberInfiniteTransition(label = "HeatmapPulse")
    val pulseAlpha by infiniteTransition.animateFloat(
        initialValue = 0.3f,
        targetValue = 0.6f,
        animationSpec = infiniteRepeatable(
            animation = tween(1000, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "PulseAlpha"
    )

    Canvas(modifier = Modifier.fillMaxSize()) {
        heatPoints.forEach { point: HeatPoint ->
            // --- SIMPLIFIED PROJECTION FOR DEMO ---
            // In a real app we'd use map projection.
            // Here we assume the map is roughly centered on the circuit and place points relatively.
            // This is a "Visual Hack" for the demo to ensure points appear on screen.
            
            // Map Center (Circuit Approx Center)
            val centerLat = 41.57
            val centerLon = 2.26
            
            // Scale diff based on zoom (rough approximation)
            val scaleFactor = 100000f // Arbitrary scale for lat/lon diff to pixels
            
            val dx = (point.lon - centerLon) * scaleFactor
            val dy = (centerLat - point.lat) * scaleFactor // Latitude inverted y-axis
            
            val screenX = size.width / 2 + dx.toFloat()
            val screenY = size.height / 2 + dy.toFloat()
            
            // Color Logic
            val isCritical = point.intensity > 0.8f
            val baseColor = if (isCritical) Color.Red else Color.Green
            val alpha = if (isCritical) pulseAlpha else 0.2f
            
            // Draw Heat Circle
            drawCircle(
                color = baseColor.copy(alpha = alpha),
                radius = point.radius * (if (isCritical) 1.5f else 1.0f),
                center = Offset(screenX, screenY)
            )
            
            // Draw Core
            drawCircle(
                color = baseColor.copy(alpha = 1f),
                radius = 10f,
                center = Offset(screenX, screenY)
            )
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/menu/SideMenuContent.kt`

```kotlin
package com.georacing.georacing.ui.components.menu

import androidx.compose.animation.*
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.spring
import androidx.compose.animation.core.Spring
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.domain.features.FeatureCategory
import com.georacing.georacing.domain.features.FeatureRegistry
import com.georacing.georacing.domain.features.FeatureStatus
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.*

/**
 * SideMenuContent ‚Äî iOS parity for SideMenuView.swift
 *
 * Shows:
 * - Quick navigation links (tabs)
 * - FeatureRegistry categories with expandable sections
 * - Completion counters per category
 */
@Composable
fun SideMenuContent(
    navController: NavController,
    onClose: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
    ) {
        // ‚îÄ‚îÄ Logo + Title ‚îÄ‚îÄ
        Row(verticalAlignment = Alignment.CenterVertically) {
            Icon(Icons.Default.Flag, null, tint = TextPrimary, modifier = Modifier.size(36.dp))
            Spacer(Modifier.width(12.dp))
            Column {
                Text(
                    "GeoRacing",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Black,
                    color = TextPrimary,
                    letterSpacing = 1.sp
                )
                Text(
                    "Driver Menu",
                    style = MaterialTheme.typography.labelSmall,
                    color = TextTertiary
                )
            }
        }

        Spacer(Modifier.height(20.dp))
        HorizontalDivider(color = MetalGrey.copy(alpha = 0.3f))
        Spacer(Modifier.height(16.dp))

        // ‚îÄ‚îÄ Quick Nav (tabs) ‚îÄ‚îÄ
        val quickLinks = listOf(
            Triple("Inicio", Icons.Default.Home, Screen.Home.route),
            Triple("Mapa", Icons.Default.Map, Screen.Map.route),
            Triple("Alertas", Icons.Default.Notifications, Screen.Alerts.route),
            Triple("Tienda", Icons.Default.ShoppingCart, Screen.Orders.route),
            Triple("Ajustes", Icons.Default.Settings, Screen.Settings.route)
        )

        quickLinks.forEach { (text, icon, route) ->
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clip(RoundedCornerShape(10.dp))
                    .clickable {
                        onClose()
                        navController.navigate(route) {
                            popUpTo(Screen.Home.route)
                            launchSingleTop = true
                        }
                    }
                    .padding(horizontal = 8.dp, vertical = 12.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(icon, null, tint = MetalGrey, modifier = Modifier.size(22.dp))
                Spacer(Modifier.width(16.dp))
                Text(
                    text,
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.SemiBold,
                    color = TextPrimary
                )
            }
        }

        Spacer(Modifier.height(12.dp))
        HorizontalDivider(color = MetalGrey.copy(alpha = 0.3f))
        Spacer(Modifier.height(12.dp))

        // ‚îÄ‚îÄ Feature Categories ‚îÄ‚îÄ
        Text(
            "FUNCIONES GEORACING",
            style = MaterialTheme.typography.labelSmall,
            color = TextTertiary,
            letterSpacing = 2.sp,
            fontWeight = FontWeight.Bold,
            modifier = Modifier.padding(start = 8.dp)
        )

        Spacer(Modifier.height(8.dp))

        FeatureCategory.entries.forEach { category ->
            val features = FeatureRegistry.features(category)
            if (features.isNotEmpty()) {
                FeatureCategorySection(
                    category = category,
                    onFeatureSelected = { feature ->
                        onClose()
                        feature.route?.let { route ->
                            navController.navigate(route) {
                                popUpTo(Screen.Home.route)
                                launchSingleTop = true
                            }
                        }
                    }
                )
            }
        }

        Spacer(Modifier.height(16.dp))

        // ‚îÄ‚îÄ Version ‚îÄ‚îÄ
        Text(
            "v1.0.0 (Parity Build)",
            style = MaterialTheme.typography.labelSmall,
            color = TextTertiary,
            modifier = Modifier.padding(start = 8.dp)
        )

        Spacer(Modifier.height(16.dp))
    }
}

@Composable
private fun FeatureCategorySection(
    category: FeatureCategory,
    onFeatureSelected: (com.georacing.georacing.domain.features.Feature) -> Unit
) {
    var isExpanded by remember { mutableStateOf(false) }
    val chevronRotation by animateFloatAsState(
        targetValue = if (isExpanded) 90f else 0f,
        animationSpec = spring(stiffness = Spring.StiffnessMedium),
        label = "chevron"
    )

    val features = FeatureRegistry.features(category)
    val completedCount = FeatureRegistry.completedCount(category)
    val totalCount = FeatureRegistry.totalCount(category)

    Column(modifier = Modifier.padding(horizontal = 4.dp)) {
        // ‚îÄ‚îÄ Category Header ‚îÄ‚îÄ
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clip(RoundedCornerShape(8.dp))
                .clickable { isExpanded = !isExpanded }
                .padding(horizontal = 8.dp, vertical = 10.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                category.icon,
                contentDescription = null,
                tint = category.color,
                modifier = Modifier.size(20.dp)
            )
            Spacer(Modifier.width(12.dp))
            Text(
                category.displayName,
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.Bold,
                color = TextPrimary,
                modifier = Modifier.weight(1f)
            )
            // Completion counter
            Text(
                "$completedCount/$totalCount",
                style = MaterialTheme.typography.labelSmall,
                color = TextTertiary
            )
            Spacer(Modifier.width(8.dp))
            Icon(
                Icons.Default.ChevronRight,
                null,
                tint = TextTertiary,
                modifier = Modifier
                    .size(16.dp)
                    .graphicsLayer { rotationZ = chevronRotation }
            )
        }

        // ‚îÄ‚îÄ Expandable Features ‚îÄ‚îÄ
        AnimatedVisibility(
            visible = isExpanded,
            enter = fadeIn() + expandVertically(),
            exit = fadeOut() + shrinkVertically()
        ) {
            Column(modifier = Modifier.padding(start = 20.dp)) {
                features.forEach { feature ->
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clip(RoundedCornerShape(8.dp))
                            .clickable(enabled = feature.route != null) {
                                onFeatureSelected(feature)
                            }
                            .padding(horizontal = 8.dp, vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            feature.icon,
                            null,
                            tint = if (feature.route != null) TextSecondary else TextTertiary,
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(Modifier.width(12.dp))
                        Text(
                            feature.title,
                            style = MaterialTheme.typography.bodySmall,
                            color = if (feature.route != null) TextPrimary else TextTertiary,
                            modifier = Modifier.weight(1f)
                        )
                        // Status dot (only if not complete)
                        if (feature.status != FeatureStatus.COMPLETE) {
                            Box(
                                modifier = Modifier
                                    .size(6.dp)
                                    .clip(CircleShape)
                                    .background(feature.status.color)
                            )
                        }
                    }
                }
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/racecontrol/LiveFlagOverlay.kt`

```kotlin
package com.georacing.georacing.ui.components.racecontrol

import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.domain.model.CircuitMode
import com.georacing.georacing.domain.model.CircuitState
import com.georacing.georacing.ui.theme.*
import com.georacing.georacing.ui.glass.LiquidSurface
import com.georacing.georacing.ui.glass.LocalBackdrop

@Composable
fun LiveFlagOverlay(
    state: CircuitState,
    modifier: Modifier = Modifier
) {
    val infiniteTransition = rememberInfiniteTransition(label = "flag_pulse")

    // Animations
    val heavyPulseAlpha by infiniteTransition.animateFloat(
        initialValue = 0.3f,
        targetValue = 0.8f,
        animationSpec = infiniteRepeatable(
            animation = tween(500, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "heavy_pulse"
    )

    val softBlinkAlpha by infiniteTransition.animateFloat(
        initialValue = 0.6f,
        targetValue = 1.0f,
        animationSpec = infiniteRepeatable(
            animation = tween(800, easing = LinearEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "soft_blink"
    )

    // Main Container
    Box(
        modifier = modifier
            .fillMaxSize()
            .then(
                // Full Screen Red Warning Border for Red Flag / Evacuation
                if (state.mode == CircuitMode.RED_FLAG || state.mode == CircuitMode.EVACUATION) {
                    Modifier.border(
                        width = 8.dp,
                        color = CircuitStop.copy(alpha = heavyPulseAlpha)
                    )
                } else {
                    Modifier
                }
            )
            .padding(top = 40.dp) // Avoid status bar slightly
    ) {
        when (state.mode) {
            CircuitMode.RED_FLAG, CircuitMode.EVACUATION -> {
                RaceControlBanner(
                    color = CircuitStop,
                    title = "SESSION STOPPED",
                    subtitle = state.message?.uppercase() ?: "RETURN TO PITS",
                    alpha = 1f, // Always visible
                    modifier = Modifier.align(Alignment.TopCenter)
                )
            }
            CircuitMode.SAFETY_CAR, CircuitMode.VSC -> {
                RaceControlBanner(
                    color = StatusAmber,
                    title = if (state.mode == CircuitMode.VSC) "VIRTUAL SAFETY CAR" else "SAFETY CAR",
                    subtitle = "REDUCE SPEED",
                    alpha = 1f, // Solid
                    modifier = Modifier.align(Alignment.TopCenter)
                )
            }
            CircuitMode.YELLOW_FLAG -> {
                RaceControlBanner(
                    color = StatusAmber,
                    title = "YELLOW FLAG",
                    subtitle = "SECTOR 2 - HAZARD", // Hardcoded per requirement or use state.message
                    alpha = softBlinkAlpha,
                    modifier = Modifier.align(Alignment.TopCenter)
                )
            }
            CircuitMode.GREEN_FLAG -> {
                // Subtle Green Line
                Box(
                    modifier = Modifier
                        .align(Alignment.TopCenter)
                        .fillMaxWidth(0.3f)
                        .height(4.dp)
                        .background(
                            Brush.horizontalGradient(
                                listOf(Color.Transparent, CircuitGreen, Color.Transparent)
                            )
                        )
                )
            }
            CircuitMode.NORMAL -> {
                // Invisible
            }
            else -> {}
        }
    }
}

@Composable
private fun RaceControlBanner(
    color: Color,
    title: String,
    subtitle: String,
    alpha: Float,
    modifier: Modifier = Modifier
) {
    val backdrop = LocalBackdrop.current
    LiquidSurface(
        backdrop = backdrop,
        modifier = modifier.fillMaxWidth(),
        surfaceColor = color.copy(alpha = 0.7f * alpha)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 20.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
        Text(
            text = title,
            color = Color(0xFFF8FAFC),
            style = androidx.compose.material3.MaterialTheme.typography.titleLarge.copy(
                fontWeight = FontWeight.Black,
                letterSpacing = 2.sp
            ),
            modifier = Modifier.alpha(alpha)
        )
        if (subtitle.isNotEmpty()) {
            Text(
                text = subtitle,
                color = Color(0xFFF8FAFC).copy(alpha = 0.9f),
                style = androidx.compose.material3.MaterialTheme.typography.labelMedium.copy(
                    fontWeight = FontWeight.Bold,
                    letterSpacing = 1.5.sp
                )
            )
        }
    }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/racecontrol/RaceControlWidget.kt`

```kotlin
package com.georacing.georacing.ui.components.racecontrol

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.domain.model.CircuitMode
import com.georacing.georacing.domain.model.CircuitState
import com.georacing.georacing.domain.model.DriverInfo
import com.georacing.georacing.domain.model.RaceSessionInfo
import com.georacing.georacing.ui.theme.*

@Composable
fun RaceControlWidget(
    state: CircuitState,
    modifier: Modifier = Modifier
) {
    // Defines header color based on flag status
    val statusColor = when (state.mode) {
        CircuitMode.NORMAL, CircuitMode.GREEN_FLAG -> CircuitGreen
        CircuitMode.YELLOW_FLAG, CircuitMode.SAFETY_CAR, CircuitMode.VSC -> StatusAmber
        CircuitMode.RED_FLAG, CircuitMode.EVACUATION -> CircuitStop
        else -> NeutralGrey
    }

    val statusText = when (state.mode) {
        CircuitMode.NORMAL, CircuitMode.GREEN_FLAG -> "TRACK CLEAR"
        CircuitMode.YELLOW_FLAG -> "YELLOW SECTOR"
        CircuitMode.SAFETY_CAR -> "SAFETY CAR"
        CircuitMode.VSC -> "VIRTUAL SC"
        CircuitMode.RED_FLAG -> "SESSION STOPPED"
        CircuitMode.EVACUATION -> "EVACUATE"
        else -> "OFFLINE"
    }

    // Use session info from state or fallback to "Simulated" demo data if null
    val session = state.sessionInfo ?: RaceSessionInfo(
        sessionTime = "00:45:12",
        currentLap = 24,
        totalLaps = 66,
        topDrivers = listOf(
            DriverInfo(1, "VERSTAPPEN", "RBR", "Leader"),
            DriverInfo(2, "NORRIS", "MCL", "+2.4s"),
            DriverInfo(3, "ALONSO", "AMR", "+8.1s")
        )
    )

    Card(
        modifier = modifier.fillMaxWidth(),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(containerColor = AsphaltGrey)
    ) {
        Column {
            // Header
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .background(statusColor)
                    .padding(horizontal = 12.dp, vertical = 8.dp),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = "RACE CONTROL",
                    style = MaterialTheme.typography.labelSmall.copy(
                        fontWeight = FontWeight.Bold,
                        letterSpacing = 1.5.sp
                    ),
                    color = Color(0xFF080810)
                )
                Text(
                    text = statusText,
                    style = MaterialTheme.typography.labelSmall.copy(
                        fontWeight = FontWeight.Black,
                        letterSpacing = 1.5.sp
                    ),
                    color = Color(0xFF080810)
                )
            }

            // Body
            Column(modifier = Modifier.padding(12.dp)) {
                // Time & Lap Row
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Column {
                        Text(
                            text = "SESSION TIME",
                            style = MaterialTheme.typography.labelSmall.copy(
                                letterSpacing = 1.5.sp
                            ),
                            color = NeutralGrey
                        )
                        Text(
                            text = session.sessionTime,
                            style = MaterialTheme.typography.titleLarge.copy(
                                fontFamily = FontFamily.Monospace,
                                fontWeight = FontWeight.Bold
                            ),
                            color = TextPrimary
                        )
                    }
                    Column(horizontalAlignment = Alignment.End) {
                        Text(
                            text = "LAP",
                            style = MaterialTheme.typography.labelSmall.copy(
                                letterSpacing = 1.5.sp
                            ),
                            color = NeutralGrey
                        )
                        Text(
                            text = "${session.currentLap}/${session.totalLaps}",
                            style = MaterialTheme.typography.titleLarge.copy(
                                fontFamily = FontFamily.Monospace,
                                fontWeight = FontWeight.Bold
                            ),
                            color = TextPrimary
                        )
                    }
                }

                HorizontalDivider(
                    modifier = Modifier.padding(vertical = 12.dp),
                    color = OutlineLight
                )

                // Top 3 Drivers
                session.topDrivers.forEach { driver ->
                    DriverRow(driver)
                    Spacer(modifier = Modifier.height(6.dp))
                }
            }
        }
    }
}

@Composable
private fun DriverRow(driver: DriverInfo) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Position Box
        Box(
            modifier = Modifier
                .size(24.dp)
                .background(
                    color = if (driver.position == 1) RacingRed else MetalGrey,
                    shape = RoundedCornerShape(4.dp)
                ),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = driver.position.toString(),
                style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold),
                color = Color(0xFFF8FAFC)
            )
        }
        
        Spacer(modifier = Modifier.width(12.dp))
        
        // Name & Team
        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = driver.name,
                style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Bold),
                color = TextPrimary
            )
        }
        
        // Gap
        Text(
            text = driver.gap,
            style = MaterialTheme.typography.bodyMedium.copy(fontFamily = FontFamily.Monospace),
            color = if(driver.position == 1) StatusGreen else TextSecondary
        )
        
        Spacer(modifier = Modifier.width(8.dp))
        
        // Tire (Circle)
        Box(
            modifier = Modifier
                .size(16.dp)
                .background(Color(0xFFF8FAFC), androidx.compose.foundation.shape.CircleShape)
                .border(1.dp, Color(0xFF080810), androidx.compose.foundation.shape.CircleShape),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = driver.tireCompound,
                style = MaterialTheme.typography.labelSmall.copy(fontSize = 10.sp, fontWeight = FontWeight.Black),
                color = Color(0xFF080810)
            )
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/state/StatusBadge.kt`

```kotlin
package com.georacing.georacing.ui.components.state

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

enum class StatusLevel { OK, WARN, CRIT }

@Composable
fun StatusBadge(level: StatusLevel, label: String, modifier: Modifier = Modifier) {
    val color = when (level) {
        StatusLevel.OK -> Color(0xFF22C55E)
        StatusLevel.WARN -> Color(0xFFF97316)
        StatusLevel.CRIT -> Color(0xFFE8253A)
    }
    Box(
        modifier = modifier
            .background(color.copy(alpha = 0.15f), RoundedCornerShape(50))
            .padding(horizontal = 12.dp, vertical = 6.dp)
    ) {
        Text(label, color = color, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.Bold))
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/table/SimpleTable.kt`

```kotlin
package com.georacing.georacing.ui.components.table

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@Composable
fun SimpleTable(headers: List<String>, rows: List<List<String>>, modifier: Modifier = Modifier) {
    Column(modifier = modifier) {
        Row(modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp)) {
            headers.forEach { h ->
                Text(
                    h.uppercase(),
                    modifier = Modifier.weight(1f).padding(horizontal = 4.dp),
                    style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold)
                )
            }
        }
        HorizontalDivider()
        rows.forEach { row ->
            Row(modifier = Modifier.fillMaxWidth().padding(vertical = 6.dp)) {
                row.forEach { cell ->
                    Text(
                        cell,
                        modifier = Modifier.weight(1f).padding(horizontal = 4.dp),
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            }
            HorizontalDivider()
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/ticket/SmartTicketCard.kt`

```kotlin
package com.georacing.georacing.ui.components.ticket

import androidx.compose.animation.animateContentSize
import androidx.compose.animation.core.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.QrCode
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.scale
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.debug.ScenarioSimulator

@Composable
fun SmartTicketCard(
    modifier: Modifier = Modifier
) {
    val isAtGate by ScenarioSimulator.isAtGate.collectAsState()
    
    // Animation for expansion
    val transition = updateTransition(targetState = isAtGate, label = "TicketExpansion")
    
    val cardHeight by transition.animateDp(label = "Height") { state ->
        if (state) 500.dp else 100.dp 
    }
    
    // Ripple Effect Animation
    val infiniteTransition = rememberInfiniteTransition(label = "Ripple")
    val rippleScale by infiniteTransition.animateFloat(
        initialValue = 1f,
        targetValue = 2f,
        animationSpec = infiniteRepeatable(
            animation = tween(2000),
            repeatMode = RepeatMode.Restart
        ),
        label = "RippleScale"
    )
    val rippleAlpha by infiniteTransition.animateFloat(
        initialValue = 0.5f,
        targetValue = 0f,
        animationSpec = infiniteRepeatable(
            animation = tween(2000),
            repeatMode = RepeatMode.Restart
        ),
        label = "RippleAlpha"
    )

    // Brightness/Glow effect state
    val brightnessAlpha = if (isAtGate) 0.3f else 0f

    // Haptic Feedback
    val haptic = androidx.compose.ui.platform.LocalHapticFeedback.current
    LaunchedEffect(isAtGate) {
        if (isAtGate) {
            haptic.performHapticFeedback(androidx.compose.ui.hapticfeedback.HapticFeedbackType.LongPress)
        }
    }

    val backdrop = LocalBackdrop.current

    LiquidCard(
        backdrop = backdrop,
        modifier = modifier
            .fillMaxWidth()
            .height(cardHeight)
            .animateContentSize()
            .graphicsLayer {
                // Subtle scale up when active
                scaleX = if (isAtGate) 1.02f else 1f
                scaleY = if (isAtGate) 1.02f else 1f
            },
        cornerRadius = 20.dp,
        blurRadius = if (isAtGate) 16.dp else 12.dp,
        surfaceColor = Color(0xFF14141C).copy(alpha = if (isAtGate) 0.85f else 0.6f)
    ) {
        Box(modifier = Modifier.fillMaxSize()) {
            
            // Ripple Background (Only when At Gate)
            if (isAtGate) {
                Box(
                    modifier = Modifier
                        .align(Alignment.Center)
                        .size(200.dp)
                        .scale(rippleScale)
                        .alpha(rippleAlpha)
                        .background(Color(0xFFE8253A), shape = RoundedCornerShape(100)) // Racing Red Ripple
                )
            }

            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(20.dp),
                verticalArrangement = if (isAtGate) Arrangement.SpaceEvenly else Arrangement.Center,
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                
                // Header Info
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Column {
                        Text(
                            text = "ACCESS PASS",
                            style = MaterialTheme.typography.labelMedium.copy(
                                letterSpacing = 1.5.sp
                            ),
                            color = Color(0xFF64748B)
                        )
                        Text(
                            text = "Gate 3 - Tribuna Principal",
                            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold),
                            color = Color(0xFFF8FAFC)
                        )
                    }
                    if (!isAtGate) {
                        Icon(
                            imageVector = Icons.Default.QrCode,
                            contentDescription = "QR",
                            tint = Color(0xFFF8FAFC),
                            modifier = Modifier.size(32.dp)
                        )
                    } else {
                         // Close Button
                         IconButton(onClick = { ScenarioSimulator.resetGate() }) {
                             Icon(
                                 imageVector = Icons.Default.Close,
                                 contentDescription = "Close Ticket",
                                 tint = Color(0xFFF8FAFC)
                             )
                         }
                    }
                }

                // Expanded Content (QR Code)
                if (isAtGate) {
                    Spacer(modifier = Modifier.height(20.dp))
                    
                    // "Official" QR Placeholder
                    Box(
                        modifier = Modifier
                            .size(250.dp)
                            .clip(RoundedCornerShape(16.dp))
                            .background(Color(0xFFF8FAFC))
                            .border(4.dp, Brush.linearGradient(listOf(Color(0xFFE8253A), Color(0xFF06B6D4))), RoundedCornerShape(16.dp)),
                        contentAlignment = Alignment.Center
                    ) {
                        // Simulated QR Pattern
                        Canvas(modifier = Modifier.fillMaxSize().padding(10.dp)) {
                            val cellSize = size.width / 10
                            for (i in 0 until 10) {
                                for (j in 0 until 10) {
                                    if ((i + j) % 2 == 0 || (i * j) % 3 == 0) {
                                        drawRect(
                                            color = Color(0xFF080810),
             
                                            topLeft = Offset(i * cellSize, j * cellSize),
                                            size = androidx.compose.ui.geometry.Size(cellSize, cellSize)
                                        )
                                    }
                                }
                            }
                            // Corner markers
                            drawRect(Color(0xFF080810), Offset(0f, 0f), androidx.compose.ui.geometry.Size(cellSize * 3, cellSize * 3))
                            drawRect(Color(0xFFF8FAFC), Offset(cellSize * 0.5f, cellSize * 0.5f), androidx.compose.ui.geometry.Size(cellSize * 2, cellSize * 2))
                            drawRect(Color(0xFF080810), Offset(cellSize * 1f, cellSize * 1f), androidx.compose.ui.geometry.Size(cellSize * 1, cellSize * 1))
                            
                            drawRect(Color(0xFF080810), Offset(size.width - cellSize * 3, 0f), androidx.compose.ui.geometry.Size(cellSize * 3, cellSize * 3))
                             drawRect(Color(0xFFF8FAFC), Offset(size.width - cellSize * 2.5f, cellSize * 0.5f), androidx.compose.ui.geometry.Size(cellSize * 2, cellSize * 2))
                             drawRect(Color(0xFF080810), Offset(size.width - cellSize * 2f, cellSize * 1f), androidx.compose.ui.geometry.Size(cellSize * 1, cellSize * 1))
                             
                             drawRect(Color(0xFF080810), Offset(0f, size.height - cellSize * 3), androidx.compose.ui.geometry.Size(cellSize * 3, cellSize * 3))
                             drawRect(Color(0xFFF8FAFC), Offset(cellSize * 0.5f, size.height - cellSize * 2.5f), androidx.compose.ui.geometry.Size(cellSize * 2, cellSize * 2))
                             drawRect(Color(0xFF080810), Offset(cellSize * 1f, size.height - cellSize * 2f), androidx.compose.ui.geometry.Size(cellSize * 1, cellSize * 1))
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    Text(
                        text = "SCANNING...",
                        style = MaterialTheme.typography.bodyMedium.copy(
                            letterSpacing = 1.5.sp
                        ),
                        color = Color(0xFF06B6D4),
                        fontWeight = FontWeight.Bold,
                        modifier = Modifier.alpha(if (rippleAlpha > 0.5f) 1f else 0.5f)
                    )
                }
            }
            
            // Brightness Overlay
            if (isAtGate) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .background(Color(0xFFF8FAFC).copy(alpha = 0.1f + (rippleAlpha * 0.1f))) // Pulsing brightness
                )
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/components/toast/ToastManager.kt`

```kotlin
package com.georacing.georacing.ui.components.toast

import androidx.compose.animation.*
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.Error
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.Warning
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow

enum class ToastType {
    SUCCESS,
    ERROR,
    WARNING,
    INFO
}

data class ToastData(
    val message: String,
    val type: ToastType,
    val duration: Long = 3000L
)

class ToastManager {
    private val _currentToast = MutableStateFlow<ToastData?>(null)
    val currentToast: StateFlow<ToastData?> = _currentToast
    
    fun showToast(message: String, type: ToastType = ToastType.INFO, duration: Long = 3000L) {
        _currentToast.value = ToastData(message, type, duration)
    }
    
    fun hideToast() {
        _currentToast.value = null
    }
}

@Composable
fun ToastHost(toastManager: ToastManager) {
    val currentToast by toastManager.currentToast.collectAsState()
    
    LaunchedEffect(currentToast) {
        currentToast?.let { toast ->
            delay(toast.duration)
            toastManager.hideToast()
        }
    }
    
    Box(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        contentAlignment = Alignment.TopCenter
    ) {
        AnimatedVisibility(
            visible = currentToast != null,
            enter = slideInVertically(
                initialOffsetY = { -it },
                animationSpec = tween(300)
            ) + fadeIn(animationSpec = tween(300)),
            exit = slideOutVertically(
                targetOffsetY = { -it },
                animationSpec = tween(300)
            ) + fadeOut(animationSpec = tween(300))
        ) {
            currentToast?.let { toast ->
                ToastCard(toast)
            }
        }
    }
}

@Composable
fun ToastCard(toast: ToastData) {
    val (bgColor, borderColor, icon) = when (toast.type) {
        ToastType.SUCCESS -> Triple(
            Color(0xFF0A2A1A),
            Color(0xFF22C55E),
            Icons.Default.CheckCircle
        )
        ToastType.ERROR -> Triple(
            Color(0xFF2A0A0A),
            Color(0xFFEF4444),
            Icons.Default.Error
        )
        ToastType.WARNING -> Triple(
            Color(0xFF2A1A05),
            Color(0xFFFFA726),
            Icons.Default.Warning
        )
        ToastType.INFO -> Triple(
            Color(0xFF0A1A2A),
            Color(0xFF06B6D4),
            Icons.Default.Info
        )
    }
    
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(
            containerColor = Color(0xFF14141C)
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 12.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .border(2.dp, borderColor, RoundedCornerShape(12.dp))
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Icon(
                imageVector = icon,
                contentDescription = null,
                tint = borderColor,
                modifier = Modifier.size(24.dp)
            )
            
            Text(
                text = toast.message,
                style = androidx.compose.material3.MaterialTheme.typography.bodyLarge,
                color = Color(0xFFF8FAFC),
                fontWeight = FontWeight.SemiBold,
                modifier = Modifier.weight(1f)
            )
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/evacuation/EvacuationActivity.kt`

```kotlin
package com.georacing.georacing.ui.evacuation

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.ui.theme.GeoRacingTheme
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Warning
import androidx.compose.material.icons.filled.ArrowUpward
import androidx.compose.ui.draw.clip
import androidx.compose.runtime.remember
import androidx.compose.foundation.verticalScroll
import androidx.compose.foundation.rememberScrollState

// MapLibre Imports
import org.maplibre.android.maps.MapView
import org.maplibre.android.maps.Style
import org.maplibre.android.geometry.LatLng
import org.maplibre.android.camera.CameraPosition
import org.maplibre.android.annotations.MarkerOptions
import org.maplibre.android.MapLibre

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter

class EvacuationActivity : ComponentActivity() {
    
    private val exitReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            if (intent?.action == "com.georacing.georacing.EXIT_EVACUATION") {
                val mainIntent = Intent(context, com.georacing.georacing.MainActivity::class.java).apply {
                   flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                }
                startActivity(mainIntent)
                finish()
            }
        }
    }
    
    private val bleMessageReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            if (intent?.action == "com.georacing.georacing.BLE_EVACUATION_MESSAGE") {
                val message = intent.getStringExtra("message") ?: return
                val zone = intent.getStringExtra("zone") ?: ""
                val timestamp = intent.getLongExtra("timestamp", System.currentTimeMillis())
                _bleMessages.value = _bleMessages.value + BleEvacuationMessage(message, zone, timestamp)
            }
        }
    }
    
    private val _bleMessages = androidx.compose.runtime.mutableStateOf<List<BleEvacuationMessage>>(emptyList())

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        val filter = IntentFilter("com.georacing.georacing.EXIT_EVACUATION")
        val bleFilter = IntentFilter("com.georacing.georacing.BLE_EVACUATION_MESSAGE")
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
            registerReceiver(exitReceiver, filter, Context.RECEIVER_NOT_EXPORTED)
            registerReceiver(bleMessageReceiver, bleFilter, Context.RECEIVER_NOT_EXPORTED)
        } else {
            registerReceiver(exitReceiver, filter)
            registerReceiver(bleMessageReceiver, bleFilter)
        }

        setContent {
            GeoRacingTheme {
                EvacuationScreen(bleMessages = _bleMessages.value)
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        unregisterReceiver(exitReceiver)
        try { unregisterReceiver(bleMessageReceiver) } catch (_: Exception) {}
    }
}

data class BleEvacuationMessage(
    val message: String,
    val zone: String,
    val timestamp: Long
)

@Composable
fun EvacuationScreen(bleMessages: List<BleEvacuationMessage> = emptyList()) {
    val infiniteTransition = rememberInfiniteTransition()
    val alpha by infiniteTransition.animateFloat(
        initialValue = 0.5f,
        targetValue = 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(500, easing = LinearEasing),
            repeatMode = RepeatMode.Reverse
        )
    )

    val scrollState = rememberScrollState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(Color(0xFF5D1010)) // Dark Red Background
            .padding(24.dp)
            .verticalScroll(scrollState),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // Top Bar Area
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .padding(top = 16.dp),
            contentAlignment = Alignment.CenterEnd
        ) {
            androidx.compose.material3.Icon(
                imageVector = Icons.Filled.Home,
                 contentDescription = "Home",
                 tint = Color.White.copy(alpha = 0.7f),
                 modifier = Modifier.size(32.dp)
             )
        }

        Spacer(modifier = Modifier.height(16.dp))

        // Warning Icon
        androidx.compose.material3.Icon(
            imageVector = Icons.Filled.Warning, 
            contentDescription = "Warning",
            tint = Color(0xFFE0E0E0), // Off-white
            modifier = Modifier.size(80.dp) // Slightly smaller to fit content
        )

        Spacer(modifier = Modifier.height(16.dp))

        // Titles
        Text(
            text = "EMERGENCIA",
            color = Color.White,
            fontSize = 36.sp,
            fontWeight = FontWeight.Black,
            textAlign = TextAlign.Center,
            letterSpacing = 2.sp
        )
        
        Text(
            text = "EVACUACI√ìN ACTIVADA",
            color = Color.White.copy(alpha = alpha),
            fontSize = 20.sp,
            fontWeight = FontWeight.Bold,
            textAlign = TextAlign.Center,
            letterSpacing = 1.sp,
            modifier = Modifier.padding(top = 4.dp)
        )

        Spacer(modifier = Modifier.height(32.dp))

        // Instructions Card (Restored)
        androidx.compose.material3.Card(
            colors = androidx.compose.material3.CardDefaults.cardColors(
                containerColor = Color(0xFF3E0A0A)
            ),
            shape = androidx.compose.foundation.shape.RoundedCornerShape(16.dp),
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .padding(24.dp)
                    .fillMaxWidth(),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "INSTRUCCIONES\nINMEDIATAS",
                    color = Color.White,
                    fontSize = 20.sp,
                    fontWeight = FontWeight.Bold,
                    textAlign = TextAlign.Center,
                    lineHeight = 24.sp
                )

                Spacer(modifier = Modifier.height(24.dp))

                InstructionItem(number = "1", text = "Mantenga la calma y no corra")
                Spacer(modifier = Modifier.height(16.dp))
                InstructionItem(number = "2", text = "Siga las indicaciones del personal")
                Spacer(modifier = Modifier.height(16.dp))
                InstructionItem(number = "3", text = "Dir√≠jase a la salida m√°s cercana")
                Spacer(modifier = Modifier.height(16.dp))
                InstructionItem(number = "4", text = "No regrese por objetos personales")
            }
        }
        
        Spacer(modifier = Modifier.height(40.dp))
        
        // Arrow & Exit Text
        androidx.compose.material3.Icon(
            imageVector = Icons.Filled.ArrowUpward,
            contentDescription = "Arrow Up",
            tint = Color.White,
            modifier = Modifier.size(48.dp)
        )
        
        Text(
            text = "SALIDAS DE EMERGENCIA",
            color = Color.White,
            fontSize = 22.sp,
            fontWeight = FontWeight.Black,
            modifier = Modifier.padding(top = 16.dp, bottom = 24.dp)
        )

        // Map Container
        Box(
             modifier = Modifier
                .fillMaxWidth()
                .height(250.dp)
                .background(Color.White, shape = androidx.compose.foundation.shape.RoundedCornerShape(16.dp))
                .background(Color.Black, shape = androidx.compose.foundation.shape.RoundedCornerShape(16.dp))
                .padding(2.dp)
        ) {
             EvacuationMap(
                 modifier = Modifier
                     .fillMaxSize()
                     .clip(androidx.compose.foundation.shape.RoundedCornerShape(14.dp))
             )
        }
        
        // ‚îÄ‚îÄ Mensajes BLE en tiempo real ‚îÄ‚îÄ
        if (bleMessages.isNotEmpty()) {
            Spacer(modifier = Modifier.height(24.dp))
            
            Text(
                text = "üì° MENSAJES DEL CIRCUITO",
                color = Color.White,
                fontSize = 16.sp,
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.sp
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            bleMessages.takeLast(5).reversed().forEach { msg ->
                androidx.compose.material3.Card(
                    colors = androidx.compose.material3.CardDefaults.cardColors(
                        containerColor = Color(0xFF3E0A0A)
                    ),
                    shape = androidx.compose.foundation.shape.RoundedCornerShape(8.dp),
                    modifier = Modifier.fillMaxWidth().padding(vertical = 2.dp)
                ) {
                    Row(
                        modifier = Modifier.padding(12.dp).fillMaxWidth(),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text("‚ö†Ô∏è", fontSize = 20.sp)
                        androidx.compose.foundation.layout.Spacer(modifier = Modifier.width(8.dp))
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = msg.message,
                                color = Color.White,
                                fontSize = 14.sp,
                                fontWeight = FontWeight.SemiBold
                            )
                            if (msg.zone.isNotEmpty()) {
                                Text(
                                    text = "Zona: ${msg.zone}",
                                    color = Color.White.copy(alpha = 0.7f),
                                    fontSize = 11.sp
                                )
                            }
                        }
                    }
                }
            }
        }
        
        Spacer(modifier = Modifier.height(32.dp))
        
        // Return Button
        val context = androidx.compose.ui.platform.LocalContext.current
        androidx.compose.material3.Button(
            onClick = { 
                 // Return to Main/Home
                 val intent = android.content.Intent(context, com.georacing.georacing.MainActivity::class.java).apply {
                     flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK or android.content.Intent.FLAG_ACTIVITY_CLEAR_TASK
                 }
                 context.startActivity(intent)
            },
            colors = androidx.compose.material3.ButtonDefaults.buttonColors(containerColor = Color.Black),
            shape = androidx.compose.foundation.shape.RoundedCornerShape(12.dp),
            border = androidx.compose.foundation.BorderStroke(1.dp, Color.White),
            modifier = Modifier
                .fillMaxWidth()
                .height(56.dp)
        ) {
            Text(text = "VOLVER", fontSize = 18.sp, fontWeight = FontWeight.Bold, color = Color.White)
        }
        
        Spacer(modifier = Modifier.height(32.dp))
    }
}

@Composable
fun InstructionItem(number: String, text: String) {
    Row(
        verticalAlignment = Alignment.CenterVertically,
        modifier = Modifier.fillMaxWidth()
    ) {
        // Circle Number
        Box(
            contentAlignment = Alignment.Center,
            modifier = Modifier
                .size(32.dp)
                .background(Color.White, shape = androidx.compose.foundation.shape.CircleShape)
        ) {
            Text(
                text = number,
                color = Color(0xFF5D1010), // Dark Red Text
                fontWeight = FontWeight.Bold,
                fontSize = 16.sp
            )
        }
        
        Spacer(modifier = Modifier.width(16.dp))
        
        Text(
            text = text,
            color = Color.White,
            fontSize = 16.sp,
            fontWeight = FontWeight.SemiBold,
            textAlign = TextAlign.Start
        )
    }
}



@androidx.compose.ui.tooling.preview.Preview(showBackground = true)
@Composable
fun EvacuationScreenPreview() {
    GeoRacingTheme {
        EvacuationScreen()
    }
}

@Composable
fun EvacuationMap(modifier: Modifier = Modifier) {
    val context = androidx.compose.ui.platform.LocalContext.current
    if (androidx.compose.ui.platform.LocalInspectionMode.current) {
         Box(
            modifier = modifier
                .background(Color.Gray)
                .padding(16.dp),
            contentAlignment = Alignment.Center
         ) {
             Text("Map Preview", color = Color.White)
         }
         return
    }

    val lifecycleOwner = androidx.lifecycle.compose.LocalLifecycleOwner.current
    
    // Initialize MapLibre instance
    remember { MapLibre.getInstance(context) }
    
    val mapView = remember {
        MapView(context).apply {
            onCreate(null)
        }
    }
    
    // Manage Lifecycle
    androidx.compose.runtime.DisposableEffect(lifecycleOwner) {
        val observer = androidx.lifecycle.LifecycleEventObserver { _, event ->
            when (event) {
                androidx.lifecycle.Lifecycle.Event.ON_START -> mapView.onStart()
                androidx.lifecycle.Lifecycle.Event.ON_RESUME -> mapView.onResume()
                androidx.lifecycle.Lifecycle.Event.ON_PAUSE -> mapView.onPause()
                androidx.lifecycle.Lifecycle.Event.ON_STOP -> mapView.onStop()
                androidx.lifecycle.Lifecycle.Event.ON_DESTROY -> mapView.onDestroy()
                else -> {}
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }
    }
    
    androidx.compose.ui.viewinterop.AndroidView(
        factory = { _: Context -> mapView },
        modifier = modifier,
        update = { mv: MapView ->
            mv.getMapAsync { map ->
                // Dark Style for Emergency
                map.uiSettings.isAttributionEnabled = false
                map.uiSettings.isLogoEnabled = false
                map.uiSettings.isTiltGesturesEnabled = false
                
                // Set Style
                map.setStyle("https://demotiles.maplibre.org/style.json") { style ->
                    // 1. Add Emergency Exits
                    // ... (Simplification: Just showing map for now)
                }

                // Initial Position: Circuit de Barcelona-Catalunya
                val circuitPos = LatLng(41.569308, 2.257692) // Grandstand
                
                map.cameraPosition = CameraPosition.Builder()
                    .target(circuitPos)
                    .zoom(16.0)
                    .build()
                
                // Add Marker for Safe Zone (Green)
                map.addMarker(MarkerOptions()
                    .position(LatLng(41.5710, 2.2600))
                    .title("PUNTO SEGURO")
                    .snippet("Dir√≠jase aqu√≠"))
            }
        }
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/GlassComponents.kt`

```kotlin
package com.georacing.georacing.ui.glass

import android.os.Build
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.BoxScope
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip

import androidx.compose.ui.graphics.Shape
import androidx.compose.ui.graphics.drawscope.ContentDrawScope
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp


import dev.chrisbanes.haze.hazeChild

/**
 * Core Glass Surface that applies the capture/blur/lens effect.
 */
@Composable
fun GlassSurface(
    modifier: Modifier = Modifier,
    config: GlassConfig = LocalGlassConfig.current,
    surfaceTint: androidx.compose.ui.graphics.Color? = null,
    alpha: Float? = null, // Override alpha
    shape: Shape = RoundedCornerShape(16.dp),
    content: @Composable BoxScope.() -> Unit
) {
    // Liquid Glass Implementation
    // Priority: Haze Library (Glassmorphism) > Native Fallback (Translucency)
    
    val hazeState = LocalHazeState.current
    val effectiveTint = surfaceTint ?: config.surfaceTint
    val effectiveAlpha = alpha ?: config.surfaceTintAlpha
    
    // Determine background color/alpha based on quality
    val fallbackBackgroundColor = when (config.quality) {
        GlassQuality.Low -> effectiveTint.copy(alpha = 0.95f) 
        GlassQuality.Medium -> effectiveTint.copy(alpha = 0.85f)
        GlassQuality.High -> effectiveTint.copy(alpha = 0.60f) 
    }

    if (config.enabled && 
        config.quality != GlassQuality.Low && 
        hazeState != null) {
        
        // Haze Implementation
        Box(
            modifier = modifier
                .clip(shape)
                .hazeChild(
                    state = hazeState, 
                    style = dev.chrisbanes.haze.HazeStyle(
                        backgroundColor = effectiveTint.copy(alpha = effectiveAlpha),
                        blurRadius = config.blurRadius,
                        noiseFactor = config.noiseFactor,
                        tints = emptyList() // Explicitly select the constructor with 'tints' (1.1.0+)
                    )
                )
                // Optional: Add a subtle border or overlay if needed by design, but haze does the heavy lifting
        ) {
            content()
        }
        
    } else {
        // Native Fallback (Low Power or Haze Unavailable)
        Box(
            modifier = modifier
                .background(fallbackBackgroundColor, shape)
                .clip(shape)
        ) {
            content()
        }
    }
}

/**
 * Pre-configured Glass Bottom Bar
 */
@Composable
fun GlassBottomBar(
    modifier: Modifier = Modifier,
    config: GlassConfig = GlassConfig(),
    height: Dp = 80.dp,
    content: @Composable BoxScope.() -> Unit
) {
    GlassSurface(
        modifier = modifier
            .fillMaxWidth()
            .height(height),
        config = config,
        shape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp), // Typical BottomBar shape
        content = content
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/GlassConfig.kt`

```kotlin
package com.georacing.georacing.ui.glass

import androidx.compose.runtime.Immutable
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp

@Immutable
data class GlassConfig(
    val enabled: Boolean = true,
    val quality: GlassQuality = GlassQuality.Medium,
    val surfaceTint: androidx.compose.ui.graphics.Color = androidx.compose.ui.graphics.Color.Black,
    
    // Aesthetic Tuning
    val blurRadius: Dp = 32.dp, // Premium heavy blur
    val saturation: Float = 1.3f, // Extra vibrancy for UI elements behind glass
    val noiseFactor: Float = 0.05f, // Subtle grain for realism
    
    // Readability
    val surfaceTintAlpha: Float = 0.5f, // Tint on top of glass
    val borderAlpha: Float = 0.25f
)

@Immutable
enum class GlassQuality {
    High,   // Lens + Blur + Vibrancy (Android 13+)
    Medium, // Blur + Vibrancy (Android 12+)
    Low     // Fallback (Transparency/Scrim only)
}


val LocalGlassConfig = androidx.compose.runtime.staticCompositionLocalOf { GlassConfig() }
val LocalGlassConfigState = androidx.compose.runtime.staticCompositionLocalOf<androidx.compose.runtime.MutableState<GlassConfig>> { error("No Glass Config State provided") }
val LocalHazeState = androidx.compose.runtime.staticCompositionLocalOf<dev.chrisbanes.haze.HazeState?> { null }

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/GlassSupport.kt`

```kotlin
package com.georacing.georacing.ui.glass

import android.os.Build
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.GraphicsLayerScope
import androidx.compose.ui.graphics.Shape
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.unit.dp
import com.kyant.backdrop.Backdrop
import com.kyant.backdrop.BackdropEffectScope
import com.kyant.backdrop.drawBackdrop
import com.kyant.backdrop.highlight.Highlight
import com.kyant.backdrop.shadow.InnerShadow
import com.kyant.backdrop.shadow.Shadow


object GlassSupport {
    
    /**
     * Detects if running on an emulator where GPU shaders may crash.
     * Checks multiple indicators to reliably detect emulators.
     */
    val isEmulator: Boolean by lazy {
        (Build.FINGERPRINT.startsWith("google/sdk_gphone")
                || Build.FINGERPRINT.startsWith("generic")
                || Build.FINGERPRINT.contains("emulator")
                || Build.MODEL.contains("Emulator")
                || Build.MODEL.contains("Android SDK built for x86")
                || Build.MODEL.contains("sdk_gphone")
                || Build.MANUFACTURER.contains("Genymotion")
                || Build.BRAND.startsWith("generic")
                || Build.DEVICE.startsWith("generic")
                || Build.PRODUCT.contains("sdk")
                || Build.PRODUCT.contains("emulator")
                || Build.HARDWARE.contains("goldfish")
                || Build.HARDWARE.contains("ranchu"))
    }

    /**
     * True if the device can safely run RuntimeShader-based effects (lens, vibrancy).
     * Requires API 33+ AND a real device (emulators crash on complex shaders).
     */
    val supportsLens: Boolean
        get() = Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU && !isEmulator

    /**
     * True if the device can safely run blur effects via RenderEffect.
     * Requires API 31+ AND a real device.
     */
    val supportsBlur: Boolean
        get() = Build.VERSION.SDK_INT >= Build.VERSION_CODES.S && !isEmulator
    
    /**
     * True if the device can run vibrancy (saturation shader).
     * Same requirements as lens.
     */
    val supportsVibrancy: Boolean
        get() = Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU && !isEmulator
}

/**
 * Safe version of drawBackdrop that falls back to simple clip+background on emulators.
 * On real devices, uses the full kyant backdrop pipeline.
 * On emulators, uses clip+background to avoid SIGSEGV from RuntimeShader.
 */
fun Modifier.drawBackdropSafe(
    backdrop: Backdrop,
    shape: () -> Shape,
    effects: BackdropEffectScope.() -> Unit = {},
    highlight: (() -> Highlight?)? = null,
    shadow: (() -> Shadow?)? = null,
    innerShadow: (() -> InnerShadow?)? = null,
    layerBlock: (GraphicsLayerScope.() -> Unit)? = null,
    onDrawSurface: (DrawScope.() -> Unit)? = null,
    fallbackColor: Color = Color(0xFF1C1C1E).copy(alpha = 0.6f)
): Modifier {
    return if (!GlassSupport.isEmulator) {
        this.drawBackdrop(
            backdrop = backdrop,
            shape = shape,
            effects = effects,
            highlight = highlight,
            shadow = shadow,
            innerShadow = innerShadow,
            layerBlock = layerBlock,
            onDrawSurface = onDrawSurface
        )
    } else {
        // Emulator fallback: simple clip + background, no shaders
        val s = shape()
        this
            .then(if (layerBlock != null) Modifier.graphicsLayer(layerBlock) else Modifier)
            .shadow(4.dp, s, clip = false, ambientColor = Color.Black.copy(alpha = 0.2f))
            .background(fallbackColor, s)
            .border(1.dp, Color.White.copy(alpha = 0.1f), s)
            .clip(s)
    }
}

/**
 * Builds the appropriate backdrop effects based on quality and device support.
 */


```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/LiquidBottomTab.kt`

```kotlin
package com.georacing.georacing.ui.glass

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ColumnScope
import androidx.compose.foundation.layout.RowScope
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.runtime.Composable
import androidx.compose.runtime.staticCompositionLocalOf
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.unit.dp
import com.kyant.shapes.Capsule

internal val LocalLiquidBottomTabScale =
    staticCompositionLocalOf { { 1f } }

@Composable
fun RowScope.LiquidBottomTab(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    val scale = LocalLiquidBottomTabScale.current
    Column(
        modifier
            .clip(Capsule)
            .clickable(
                interactionSource = null,
                indication = null,
                role = Role.Tab,
                onClick = onClick
            )
            .fillMaxHeight()
            .weight(1f)
            .graphicsLayer {
                val scale = scale()
                scaleX = scale
                scaleY = scale
            },
        verticalArrangement = Arrangement.spacedBy(2f.dp, Alignment.CenterVertically),
        horizontalAlignment = Alignment.CenterHorizontally,
        content = content
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/LiquidBottomTabs.kt`

```kotlin
package com.georacing.georacing.ui.glass

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.EaseOut
import androidx.compose.animation.core.spring
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.BoxWithConstraints
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.RowScope
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.runtime.snapshotFlow
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.ColorFilter
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.semantics.clearAndSetSemantics
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.compose.ui.util.fastCoerceIn
import androidx.compose.ui.util.fastRoundToInt
import androidx.compose.ui.util.lerp
import com.kyant.backdrop.Backdrop
import com.kyant.backdrop.backdrops.layerBackdrop
import com.kyant.backdrop.backdrops.rememberCombinedBackdrop
import com.kyant.backdrop.backdrops.rememberLayerBackdrop
import com.kyant.backdrop.drawBackdrop
import com.kyant.backdrop.effects.blur
import com.kyant.backdrop.effects.lens
import com.kyant.backdrop.effects.vibrancy
import com.kyant.backdrop.highlight.Highlight
import com.kyant.backdrop.shadow.InnerShadow
import com.kyant.backdrop.shadow.Shadow
import com.kyant.shapes.Capsule
import com.georacing.georacing.ui.glass.utils.DampedDragAnimation
import com.georacing.georacing.ui.glass.utils.InteractiveHighlight
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.drop
import kotlinx.coroutines.launch
import kotlin.math.abs
import kotlin.math.sign

@Composable
fun LiquidBottomTabs(
    selectedTabIndex: () -> Int,
    onTabSelected: (index: Int) -> Unit,
    backdrop: Backdrop,
    tabsCount: Int,
    modifier: Modifier = Modifier,
    content: @Composable RowScope.() -> Unit
) {
    val isLightTheme = !isSystemInDarkTheme()
    val accentColor = Color(0xFF00F0FF) // NeonCyan
    val containerColor = Color(0xFF0F1015).copy(0.6f) // AsphaltGrey


    val tabsBackdrop = rememberLayerBackdrop()


    BoxWithConstraints(
        modifier,
        contentAlignment = Alignment.CenterStart
    ) {
        val density = LocalDensity.current
        val tabWidth = with(density) {
            (constraints.maxWidth.toFloat() - 8f.dp.toPx()) / tabsCount
        }

        val offsetAnimation = remember { Animatable(0f) }
        val panelOffset by remember(density) {
            derivedStateOf {
                val fraction = (offsetAnimation.value / constraints.maxWidth).fastCoerceIn(-1f, 1f)
                with(density) {
                    4f.dp.toPx() * fraction.sign * EaseOut.transform(abs(fraction))
                }
            }
        }

        val isLtr = LocalLayoutDirection.current == LayoutDirection.Ltr
        val animationScope = rememberCoroutineScope()
        var currentIndex by remember {
            mutableIntStateOf(selectedTabIndex())
        }
        val dampedDragAnimation = remember(animationScope) {
            DampedDragAnimation(
                animationScope = animationScope,
                initialValue = selectedTabIndex().toFloat(),
                valueRange = 0f..(tabsCount - 1).toFloat(),
                visibilityThreshold = 0.001f,
                initialScale = 1f,
                pressedScale = 78f / 56f,
                onDragStarted = {},
                onDragStopped = {
                    val targetIndex = targetValue.fastRoundToInt().fastCoerceIn(0, tabsCount - 1)
                    currentIndex = targetIndex
                    animateToValue(targetIndex.toFloat())
                    animationScope.launch {
                        offsetAnimation.animateTo(
                            0f,
                            spring(1f, 300f, 0.5f)
                        )
                    }
                },
                onDrag = { _, dragAmount ->
                    updateValue(
                        (targetValue + dragAmount.x / tabWidth * if (isLtr) 1f else -1f)
                            .fastCoerceIn(0f, (tabsCount - 1).toFloat())
                    )
                    animationScope.launch {
                        offsetAnimation.snapTo(offsetAnimation.value + dragAmount.x)
                    }
                }
            )
        }
        LaunchedEffect(selectedTabIndex) {
            snapshotFlow { selectedTabIndex() }
                .collectLatest { index ->
                    currentIndex = index
                }
        }
        LaunchedEffect(dampedDragAnimation) {
            snapshotFlow { currentIndex }
                .drop(1)
                .collectLatest { index ->
                    dampedDragAnimation.animateToValue(index.toFloat())
                    onTabSelected(index)
                }
        }

        val interactiveHighlight = remember(animationScope) {
            InteractiveHighlight(
                animationScope = animationScope,
                position = { size, offset ->
                    Offset(
                        if (isLtr) (dampedDragAnimation.value + 0.5f) * tabWidth + panelOffset
                        else size.width - (dampedDragAnimation.value + 0.5f) * tabWidth + panelOffset,
                        size.height / 2f
                    )
                }
            )
        }

        Row(
            Modifier
                .graphicsLayer {
                    translationX = panelOffset
                }
                .drawBackdrop(
                    backdrop = backdrop,
                    shape = { Capsule },
                    effects = {
                        if (GlassSupport.supportsVibrancy) vibrancy()
                        if (GlassSupport.supportsBlur) blur(8f.dp.toPx())
                        if (GlassSupport.supportsLens) lens(24f.dp.toPx(), 24f.dp.toPx())
                    },
                    layerBlock = {
                        val progress = dampedDragAnimation.pressProgress
                        val scale = lerp(1f, 1f + 16f.dp.toPx() / size.width, progress)
                        scaleX = scale
                        scaleY = scale
                    },
                    onDrawSurface = { drawRect(containerColor) }
                )
                .then(interactiveHighlight.modifier)
                .height(64f.dp)
                .fillMaxWidth()
                .padding(4f.dp),
            verticalAlignment = Alignment.CenterVertically,
            content = content
        )

        CompositionLocalProvider(
            LocalLiquidBottomTabScale provides {
                lerp(1f, 1.2f, dampedDragAnimation.pressProgress)
            }
        ) {
            Row(
                Modifier
                    .clearAndSetSemantics {}
                    .alpha(0f)
                    .layerBackdrop(tabsBackdrop)
                    .graphicsLayer {
                        translationX = panelOffset
                    }
                    .drawBackdrop(
                        backdrop = backdrop,
                        shape = { Capsule },
                        effects = {
                            val progress = dampedDragAnimation.pressProgress
                            if (GlassSupport.supportsVibrancy) vibrancy()
                            if (GlassSupport.supportsBlur) blur(8f.dp.toPx())
                            if (GlassSupport.supportsLens) lens(
                                24f.dp.toPx() * progress,
                                24f.dp.toPx() * progress
                            )
                        },
                        highlight = {
                            val progress = dampedDragAnimation.pressProgress
                            Highlight.Default.copy(alpha = progress)
                        },
                        onDrawSurface = { drawRect(containerColor) }
                    )
                    .then(interactiveHighlight.modifier)
                    .height(56f.dp)
                    .fillMaxWidth()
                    .padding(horizontal = 4f.dp)
                    .graphicsLayer(colorFilter = ColorFilter.tint(accentColor)),
                verticalAlignment = Alignment.CenterVertically,
                content = content
            )
        }

        Box(
            Modifier
                .padding(horizontal = 4f.dp)
                .graphicsLayer {
                    translationX =
                        if (isLtr) dampedDragAnimation.value * tabWidth + panelOffset
                        else size.width - (dampedDragAnimation.value + 1f) * tabWidth + panelOffset
                }
                .then(interactiveHighlight.gestureModifier)
                .then(dampedDragAnimation.modifier)
                .drawBackdrop(
                    backdrop = rememberCombinedBackdrop(backdrop, tabsBackdrop),
                    shape = { Capsule },
                    effects = {
                        if (GlassSupport.supportsLens) {
                            val progress = dampedDragAnimation.pressProgress
                            lens(
                                10f.dp.toPx() * progress,
                                14f.dp.toPx() * progress,
                                chromaticAberration = true
                            )
                        }
                    },
                    highlight = {
                        val progress = dampedDragAnimation.pressProgress
                        Highlight.Default.copy(alpha = progress)
                    },
                    shadow = {
                        val progress = dampedDragAnimation.pressProgress
                        Shadow(alpha = progress)
                    },
                    innerShadow = {
                        val progress = dampedDragAnimation.pressProgress
                        InnerShadow(
                            radius = 8f.dp * progress,
                            alpha = progress
                        )
                    },
                    layerBlock = {
                        scaleX = dampedDragAnimation.scaleX
                        scaleY = dampedDragAnimation.scaleY
                        val velocity = dampedDragAnimation.velocity / 10f
                        scaleX /= 1f - (velocity * 0.75f).fastCoerceIn(-0.2f, 0.2f)
                        scaleY *= 1f - (velocity * 0.25f).fastCoerceIn(-0.2f, 0.2f)
                    },
                    onDrawSurface = {
                        val progress = dampedDragAnimation.pressProgress
                        drawRect(
                            if (isLightTheme) Color.Black.copy(0.1f)
                            else Color.White.copy(0.1f),
                            alpha = 1f - progress
                        )
                        drawRect(Color.Black.copy(alpha = 0.03f * progress))
                    }
                )
                .height(56f.dp)
                .fillMaxWidth(1f / tabsCount)
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/LiquidButton.kt`

```kotlin
package com.georacing.georacing.ui.glass

import androidx.compose.foundation.LocalIndication
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.RowScope
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.BlendMode
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.isSpecified
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.unit.dp
import androidx.compose.ui.util.fastCoerceAtMost
import androidx.compose.ui.util.lerp
import com.kyant.backdrop.Backdrop
import com.kyant.backdrop.drawBackdrop
import com.kyant.backdrop.effects.blur
import com.kyant.backdrop.effects.lens
import com.kyant.backdrop.effects.vibrancy
import com.kyant.shapes.Capsule
import com.georacing.georacing.ui.glass.drawBackdropSafe
import com.georacing.georacing.ui.glass.utils.InteractiveHighlight
import kotlin.math.abs
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.tanh

@Composable
fun LiquidButton(
    onClick: () -> Unit,
    backdrop: Backdrop,
    modifier: Modifier = Modifier,
    isInteractive: Boolean = true,
    tint: Color = Color.Unspecified,
    surfaceColor: Color = Color.Unspecified,
    content: @Composable RowScope.() -> Unit
) {
    val animationScope = rememberCoroutineScope()

    val interactiveHighlight = remember(animationScope) {
        InteractiveHighlight(
            animationScope = animationScope
        )
    }

    Row(
        modifier
            .drawBackdropSafe(
                backdrop = backdrop,
                shape = { Capsule },
                effects = {
                    if (GlassSupport.supportsVibrancy) vibrancy()
                    if (GlassSupport.supportsBlur) blur(2f.dp.toPx())
                    if (GlassSupport.supportsLens) lens(12f.dp.toPx(), 24f.dp.toPx())
                },
                fallbackColor = if (surfaceColor.isSpecified) surfaceColor else Color(0xFF1C1C1E).copy(alpha = 0.6f),
                layerBlock = if (isInteractive) {
                    {
                        val width = size.width
                        val height = size.height

                        val progress = interactiveHighlight.pressProgress
                        val scale = lerp(1f, 1f + 4f.dp.toPx() / size.height, progress)

                        val maxOffset = size.minDimension
                        val initialDerivative = 0.05f
                        val offset = interactiveHighlight.offset
                        translationX = maxOffset * tanh(initialDerivative * offset.x / maxOffset)
                        translationY = maxOffset * tanh(initialDerivative * offset.y / maxOffset)

                        val maxDragScale = 4f.dp.toPx() / size.height
                        val offsetAngle = atan2(offset.y, offset.x)
                        scaleX =
                            scale +
                                    maxDragScale * abs(cos(offsetAngle) * offset.x / size.maxDimension) *
                                    (width / height).fastCoerceAtMost(1f)
                        scaleY =
                            scale +
                                    maxDragScale * abs(sin(offsetAngle) * offset.y / size.maxDimension) *
                                    (height / width).fastCoerceAtMost(1f)
                    }
                } else {
                    null
                },
                onDrawSurface = {
                    if (tint.isSpecified) {
                        drawRect(tint, blendMode = BlendMode.Hue)
                        drawRect(tint.copy(alpha = 0.75f))
                    }
                    if (surfaceColor.isSpecified) {
                        drawRect(surfaceColor)
                    }
                }
            )
            .clickable(
                interactionSource = null,
                indication = if (isInteractive) null else LocalIndication.current,
                role = Role.Button,
                onClick = onClick
            )
            .then(
                if (isInteractive) {
                    Modifier
                        .then(interactiveHighlight.modifier)
                        .then(interactiveHighlight.gestureModifier)
                } else {
                    Modifier
                }
            )
            .height(48f.dp)
            .padding(horizontal = 16f.dp),
        horizontalArrangement = Arrangement.spacedBy(8f.dp, Alignment.CenterHorizontally),
        verticalAlignment = Alignment.CenterVertically,
        content = content
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/LiquidCard.kt`

```kotlin
package com.georacing.georacing.ui.glass

import androidx.compose.foundation.LocalIndication
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.BoxScope
import androidx.compose.foundation.layout.padding
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.BlendMode
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Shape
import androidx.compose.ui.graphics.isSpecified
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.compose.ui.util.lerp
import com.kyant.backdrop.Backdrop
import com.kyant.backdrop.drawBackdrop
import com.kyant.backdrop.effects.blur
import com.kyant.backdrop.effects.lens
import com.kyant.backdrop.effects.vibrancy
import com.kyant.backdrop.highlight.Highlight
import com.kyant.backdrop.shadow.Shadow
import com.georacing.georacing.ui.glass.drawBackdropSafe
import androidx.compose.foundation.shape.RoundedCornerShape
import com.georacing.georacing.ui.glass.utils.InteractiveHighlight
import kotlin.math.abs
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.tanh

/**
 * A glass card container with blur, lens distortion, and optional press effects.
 * Use this as a replacement for GlassCard, Box with rounded corners, etc.
 */
@Composable
fun LiquidCard(
    backdrop: Backdrop,
    modifier: Modifier = Modifier,
    onClick: (() -> Unit)? = null,
    isInteractive: Boolean = onClick != null,
    cornerRadius: Dp = 24.dp,
    blurRadius: Dp = 8.dp,
    tint: Color = Color.Unspecified,
    surfaceColor: Color = Color(0xFF1C1C1E).copy(alpha = 0.6f),
    content: @Composable BoxScope.() -> Unit
) {
    val animationScope = rememberCoroutineScope()
    val interactiveHighlight = remember(animationScope) {
        InteractiveHighlight(animationScope = animationScope)
    }

    val shape = RoundedCornerShape(cornerRadius)

    Box(
        modifier
            .drawBackdropSafe(
                backdrop = backdrop,
                shape = { shape },
                effects = {
                    if (GlassSupport.supportsVibrancy) vibrancy()
                    if (GlassSupport.supportsBlur) blur(blurRadius.toPx())
                    if (GlassSupport.supportsLens) lens(6f.dp.toPx(), 12f.dp.toPx())
                },
                highlight = {
                    Highlight.Ambient.copy(
                        alpha = 0.3f
                    )
                },
                shadow = {
                    Shadow(
                        radius = 8.dp,
                        color = Color.Black.copy(alpha = 0.15f)
                    )
                },
                fallbackColor = surfaceColor,
                layerBlock = if (isInteractive) {
                    {
                        val progress = interactiveHighlight.pressProgress
                        val scale = lerp(1f, 1.02f, progress)
                        scaleX = scale
                        scaleY = scale

                        val maxOffset = size.minDimension * 0.1f
                        val offset = interactiveHighlight.offset
                        translationX = maxOffset * tanh(0.02f * offset.x / maxOffset)
                        translationY = maxOffset * tanh(0.02f * offset.y / maxOffset)
                    }
                } else null,
                onDrawSurface = {
                    if (surfaceColor.isSpecified) {
                        drawRect(surfaceColor)
                    }
                    if (tint.isSpecified) {
                        drawRect(tint, blendMode = BlendMode.Overlay)
                    }
                }
            )
            .then(
                if (onClick != null) {
                    Modifier.clickable(
                        interactionSource = remember { MutableInteractionSource() },
                        indication = if (isInteractive) null else LocalIndication.current,
                        onClick = onClick
                    )
                } else Modifier
            )
            .then(
                if (isInteractive && onClick != null) {
                    Modifier
                        .then(interactiveHighlight.modifier)
                        .then(interactiveHighlight.gestureModifier)
                } else Modifier
            )
            .padding(16.dp),
        content = content
    )
}

/**
 * Non-interactive version of LiquidCard (no press effects, just glass appearance)
 */
@Composable
fun LiquidSurface(
    backdrop: Backdrop,
    modifier: Modifier = Modifier,
    cornerRadius: Dp = 24.dp,
    blurRadius: Dp = 8.dp,
    surfaceColor: Color = Color(0xFF1C1C1E).copy(alpha = 0.5f),
    content: @Composable BoxScope.() -> Unit
) {
    LiquidCard(
        backdrop = backdrop,
        modifier = modifier,
        onClick = null,
        isInteractive = false,
        cornerRadius = cornerRadius,
        blurRadius = blurRadius,
        surfaceColor = surfaceColor,
        content = content
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/LiquidDialog.kt`

```kotlin
package com.georacing.georacing.ui.glass

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.BoxScope
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.blur
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import com.kyant.backdrop.Backdrop
import com.kyant.backdrop.drawBackdrop
import com.kyant.backdrop.effects.blur
import com.kyant.backdrop.effects.lens
import com.kyant.backdrop.effects.vibrancy
import com.kyant.backdrop.highlight.Highlight
import com.kyant.backdrop.shadow.InnerShadow
import com.kyant.backdrop.shadow.Shadow
import com.georacing.georacing.ui.glass.drawBackdropSafe
import androidx.compose.foundation.shape.RoundedCornerShape

/**
 * A glass dialog/modal overlay with strong blur and lens effects.
 * Use for confirmation dialogs, alerts, and modals.
 */
@Composable
fun LiquidDialog(
    backdrop: Backdrop,
    modifier: Modifier = Modifier,
    cornerRadius: Dp = 32.dp,
    surfaceColor: Color = Color(0xFF1C1C1E).copy(alpha = 0.8f),
    content: @Composable BoxScope.() -> Unit
) {
    val shape = RoundedCornerShape(cornerRadius)

    Box(
        modifier
            .drawBackdropSafe(
                backdrop = backdrop,
                shape = { shape },
                effects = {
                    if (GlassSupport.supportsVibrancy) vibrancy()
                    if (GlassSupport.supportsBlur) blur(16f.dp.toPx())
                    if (GlassSupport.supportsLens) lens(8f.dp.toPx(), 16f.dp.toPx())
                },
                highlight = {
                    Highlight.Ambient.copy(
                        alpha = 0.4f,
                        width = Highlight.Ambient.width * 1.5f
                    )
                },
                shadow = {
                    Shadow(
                        radius = 24.dp,
                        color = Color.Black.copy(alpha = 0.3f)
                    )
                },
                innerShadow = {
                    InnerShadow(
                        radius = 2.dp,
                        alpha = 0.2f
                    )
                },
                onDrawSurface = {
                    drawRect(surfaceColor)
                },
                fallbackColor = surfaceColor
            )
            .padding(24.dp),
        contentAlignment = Alignment.Center,
        content = content
    )
}

/**
 * Glass pill for status indicators, badges, etc.
 */
@Composable
fun LiquidPill(
    backdrop: Backdrop,
    modifier: Modifier = Modifier,
    surfaceColor: Color = Color(0xFF1C1C1E).copy(alpha = 0.6f),
    tint: Color = Color.Unspecified,
    content: @Composable BoxScope.() -> Unit
) {
    Box(
        modifier
            .drawBackdropSafe(
                backdrop = backdrop,
                shape = { com.kyant.shapes.Capsule },
                effects = {
                    if (GlassSupport.supportsVibrancy) vibrancy()
                    if (GlassSupport.supportsBlur) blur(4f.dp.toPx())
                },
                highlight = {
                    Highlight.Ambient.copy(alpha = 0.25f)
                },
                onDrawSurface = {
                    drawRect(surfaceColor)
                    if (tint != Color.Unspecified) {
                        drawRect(tint.copy(alpha = 0.3f))
                    }
                },
                fallbackColor = surfaceColor
            )
            .padding(horizontal = 12.dp, vertical = 6.dp),
        contentAlignment = Alignment.Center,
        content = content
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/LiquidListItem.kt`

```kotlin
package com.georacing.georacing.ui.glass

import androidx.compose.foundation.LocalIndication
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.RowScope
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.util.lerp
import com.kyant.backdrop.Backdrop
import com.kyant.backdrop.drawBackdrop
import com.kyant.backdrop.effects.blur
import com.kyant.backdrop.effects.vibrancy
import com.georacing.georacing.ui.glass.drawBackdropSafe
import androidx.compose.foundation.shape.RoundedCornerShape
import com.georacing.georacing.ui.glass.utils.InteractiveHighlight
import kotlin.math.tanh

/**
 * A glass list item row with blur effects and press animations.
 * Use as a replacement for settings rows, POI items, alert items, etc.
 */
@Composable
fun LiquidListItem(
    onClick: () -> Unit,
    backdrop: Backdrop,
    modifier: Modifier = Modifier,
    surfaceColor: Color = Color(0xFF1C1C1E).copy(alpha = 0.4f),
    leadingContent: @Composable (() -> Unit)? = null,
    trailingContent: @Composable (() -> Unit)? = null,
    content: @Composable RowScope.() -> Unit
) {
    val animationScope = rememberCoroutineScope()
    val interactiveHighlight = remember(animationScope) {
        InteractiveHighlight(animationScope = animationScope)
    }

    val shape = RoundedCornerShape(16.dp)

    Row(
        modifier
            .fillMaxWidth()
            .drawBackdropSafe(
                backdrop = backdrop,
                shape = { shape },
                effects = {
                    if (GlassSupport.supportsVibrancy) vibrancy()
                    if (GlassSupport.supportsBlur) blur(4f.dp.toPx())
                },
                fallbackColor = surfaceColor,
                layerBlock = {
                    val progress = interactiveHighlight.pressProgress
                    val scale = lerp(1f, 1.01f, progress)
                    scaleX = scale
                    scaleY = scale

                    val maxOffset = size.minDimension * 0.05f
                    val offset = interactiveHighlight.offset
                    translationX = maxOffset * tanh(0.02f * offset.x / maxOffset)
                    translationY = maxOffset * tanh(0.02f * offset.y / maxOffset)
                },
                onDrawSurface = {
                    drawRect(surfaceColor)
                }
            )
            .clickable(
                interactionSource = remember { MutableInteractionSource() },
                indication = null,
                onClick = onClick
            )
            .then(interactiveHighlight.modifier)
            .then(interactiveHighlight.gestureModifier)
            .height(60.dp)
            .padding(horizontal = 16.dp),
        horizontalArrangement = Arrangement.spacedBy(12.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Leading content (icon)
        if (leadingContent != null) {
            leadingContent()
        }
        
        // Main content
        Row(
            modifier = Modifier.weight(1f),
            horizontalArrangement = Arrangement.Start,
            verticalAlignment = Alignment.CenterVertically,
            content = content
        )
        
        // Trailing content (switch, arrow, etc.)
        if (trailingContent != null) {
            trailingContent()
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/LiquidSlider.kt`

```kotlin
package com.georacing.georacing.ui.glass

import androidx.compose.foundation.background
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.BoxWithConstraints
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.runtime.snapshotFlow
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.scale
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.layout
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.compose.ui.util.fastCoerceIn
import androidx.compose.ui.util.fastRoundToInt
import androidx.compose.ui.util.lerp
import com.kyant.backdrop.Backdrop
import com.kyant.backdrop.backdrops.layerBackdrop
import com.kyant.backdrop.backdrops.rememberBackdrop
import com.kyant.backdrop.backdrops.rememberCombinedBackdrop
import com.kyant.backdrop.backdrops.rememberLayerBackdrop
import com.kyant.backdrop.drawBackdrop
import com.kyant.backdrop.effects.blur
import com.kyant.backdrop.effects.lens
import com.kyant.backdrop.highlight.Highlight
import com.kyant.backdrop.shadow.InnerShadow
import com.kyant.backdrop.shadow.Shadow
import com.kyant.shapes.Capsule
import com.georacing.georacing.ui.glass.utils.DampedDragAnimation
import kotlinx.coroutines.flow.collectLatest

@Composable
fun LiquidSlider(
    value: () -> Float,
    onValueChange: (Float) -> Unit,
    valueRange: ClosedFloatingPointRange<Float>,
    visibilityThreshold: Float,
    backdrop: Backdrop,
    modifier: Modifier = Modifier
) {
    val isLightTheme = !isSystemInDarkTheme()
    val accentColor =
        if (isLightTheme) Color(0xFF0088FF)
        else Color(0xFF0091FF)
    val trackColor =
        if (isLightTheme) Color(0xFF787878).copy(0.2f)
        else Color(0xFF787880).copy(0.36f)

    val trackBackdrop = rememberLayerBackdrop()

    BoxWithConstraints(
        modifier.fillMaxWidth(),
        contentAlignment = Alignment.CenterStart
    ) {
        val trackWidth = constraints.maxWidth

        val isLtr = LocalLayoutDirection.current == LayoutDirection.Ltr
        val animationScope = rememberCoroutineScope()
        var didDrag by remember { mutableStateOf(false) }
        val dampedDragAnimation = remember(animationScope) {
            DampedDragAnimation(
                animationScope = animationScope,
                initialValue = value(),
                valueRange = valueRange,
                visibilityThreshold = visibilityThreshold,
                initialScale = 1f,
                pressedScale = 1.5f,
                onDragStarted = {},
                onDragStopped = {
                    if (didDrag) {
                        onValueChange(targetValue)
                    }
                },
                onDrag = { _, dragAmount ->
                    if (!didDrag) {
                        didDrag = dragAmount.x != 0f
                    }
                    val delta = (valueRange.endInclusive - valueRange.start) * (dragAmount.x / trackWidth)
                    onValueChange(
                        if (isLtr) (targetValue + delta).coerceIn(valueRange)
                        else (targetValue - delta).coerceIn(valueRange)
                    )
                }
            )
        }
        LaunchedEffect(dampedDragAnimation) {
            snapshotFlow { value() }
                .collectLatest { value ->
                    if (dampedDragAnimation.targetValue != value) {
                        dampedDragAnimation.updateValue(value)
                    }
                }
        }

        Box(Modifier.then(
            if (!GlassSupport.isEmulator) Modifier.layerBackdrop(trackBackdrop)
            else Modifier
        )) {
            Box(
                Modifier
                    .clip(Capsule)
                    .background(trackColor)
                    .pointerInput(animationScope) {
                        detectTapGestures { position ->
                            val delta = (valueRange.endInclusive - valueRange.start) * (position.x / trackWidth)
                            val targetValue =
                                (if (isLtr) valueRange.start + delta
                                else valueRange.endInclusive - delta)
                                    .coerceIn(valueRange)
                            dampedDragAnimation.animateToValue(targetValue)
                            onValueChange(targetValue)
                        }
                    }
                    .height(6f.dp)
                    .fillMaxWidth()
            )

            Box(
                Modifier
                    .clip(Capsule)
                    .background(accentColor)
                    .height(6f.dp)
                    .layout { measurable, constraints ->
                        val placeable = measurable.measure(constraints)
                        val width = (constraints.maxWidth * dampedDragAnimation.progress).fastRoundToInt()
                        layout(width, placeable.height) {
                            placeable.place(0, 0)
                        }
                    }
            )
        }

        Box(
            Modifier
                .graphicsLayer {
                    translationX =
                        (-size.width / 2f + trackWidth * dampedDragAnimation.progress)
                            .fastCoerceIn(-size.width / 4f, trackWidth - size.width * 3f / 4f) * if (isLtr) 1f else -1f
                }
                .then(dampedDragAnimation.modifier)
                .then(
                    if (!GlassSupport.isEmulator) {
                        Modifier.drawBackdrop(
                    backdrop = rememberCombinedBackdrop(
                        backdrop,
                        rememberBackdrop(trackBackdrop) { drawBackdrop ->
                            val progress = dampedDragAnimation.pressProgress
                            val scaleX = lerp(2f / 3f, 1f, progress)
                            val scaleY = lerp(0f, 1f, progress)
                            scale(scaleX, scaleY) {
                                drawBackdrop()
                            }
                        }
                    ),
                    shape = { Capsule },
                    effects = {
                        val progress = dampedDragAnimation.pressProgress
                        if (GlassSupport.supportsBlur) blur(8f.dp.toPx() * (1f - progress))
                        if (GlassSupport.supportsLens) lens(
                            10f.dp.toPx() * progress,
                            14f.dp.toPx() * progress,
                            chromaticAberration = true
                        )
                    },
                    highlight = {
                        val progress = dampedDragAnimation.pressProgress
                        Highlight.Ambient.copy(
                            width = Highlight.Ambient.width / 1.5f,
                            blurRadius = Highlight.Ambient.blurRadius / 1.5f,
                            alpha = progress
                        )
                    },
                    shadow = {
                        Shadow(
                            radius = 4f.dp,
                            color = Color.Black.copy(alpha = 0.05f)
                        )
                    },
                    innerShadow = {
                        val progress = dampedDragAnimation.pressProgress
                        InnerShadow(
                            radius = 4f.dp * progress,
                            alpha = progress
                        )
                    },
                    layerBlock = {
                        scaleX = dampedDragAnimation.scaleX
                        scaleY = dampedDragAnimation.scaleY
                        val velocity = dampedDragAnimation.velocity / 10f
                        scaleX /= 1f - (velocity * 0.75f).fastCoerceIn(-0.2f, 0.2f)
                        scaleY *= 1f - (velocity * 0.25f).fastCoerceIn(-0.2f, 0.2f)
                    },
                    onDrawSurface = {
                        val progress = dampedDragAnimation.pressProgress
                        drawRect(Color.White.copy(alpha = 1f - progress))
                    }
                )
                    } else {
                        Modifier
                            .clip(Capsule)
                            .background(Color.White)
                    }
                )
                .size(40f.dp, 24f.dp)
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/LiquidToggle.kt`

```kotlin
package com.georacing.georacing.ui.glass

import androidx.compose.foundation.background
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.size
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.runtime.snapshotFlow
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.scale
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.lerp
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.semantics.role
import androidx.compose.ui.semantics.semantics
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.compose.ui.util.fastCoerceIn
import androidx.compose.ui.util.lerp
import com.kyant.backdrop.Backdrop
import com.kyant.backdrop.backdrops.layerBackdrop
import com.kyant.backdrop.backdrops.rememberBackdrop
import com.kyant.backdrop.backdrops.rememberCombinedBackdrop
import com.kyant.backdrop.backdrops.rememberLayerBackdrop
import com.kyant.backdrop.drawBackdrop
import com.kyant.backdrop.effects.blur
import com.kyant.backdrop.effects.lens
import com.kyant.backdrop.highlight.Highlight
import com.kyant.backdrop.shadow.InnerShadow
import com.kyant.backdrop.shadow.Shadow
import com.kyant.shapes.Capsule
import com.georacing.georacing.ui.glass.utils.DampedDragAnimation
import kotlinx.coroutines.flow.collectLatest

@Composable
fun LiquidToggle(
    selected: () -> Boolean,
    onSelect: (Boolean) -> Unit,
    backdrop: Backdrop,
    modifier: Modifier = Modifier
) {
    val isLightTheme = !isSystemInDarkTheme()
    val accentColor =
        if (isLightTheme) Color(0xFF34C759)
        else Color(0xFF30D158)
    val trackColor =
        if (isLightTheme) Color(0xFF787878).copy(0.2f)
        else Color(0xFF787880).copy(0.36f)

    val density = LocalDensity.current
    val isLtr = LocalLayoutDirection.current == LayoutDirection.Ltr
    val dragWidth = with(density) { 20f.dp.toPx() }
    val animationScope = rememberCoroutineScope()
    var didDrag by remember { mutableStateOf(false) }
    var fraction by remember { mutableFloatStateOf(if (selected()) 1f else 0f) }
    val dampedDragAnimation = remember(animationScope) {
        DampedDragAnimation(
            animationScope = animationScope,
            initialValue = fraction,
            valueRange = 0f..1f,
            visibilityThreshold = 0.001f,
            initialScale = 1f,
            pressedScale = 1.5f,
            onDragStarted = {},
            onDragStopped = {
                if (didDrag) {
                    fraction = if (targetValue >= 0.5f) 1f else 0f
                    onSelect(fraction == 1f)
                    didDrag = false
                } else {
                    fraction = if (selected()) 0f else 1f
                    onSelect(fraction == 1f)
                }
            },
            onDrag = { _, dragAmount ->
                if (!didDrag) {
                    didDrag = dragAmount.x != 0f
                }
                val delta = dragAmount.x / dragWidth
                fraction =
                    if (isLtr) (fraction + delta).fastCoerceIn(0f, 1f)
                    else (fraction - delta).fastCoerceIn(0f, 1f)
            }
        )
    }
    LaunchedEffect(dampedDragAnimation) {
        snapshotFlow { fraction }
            .collectLatest { fraction ->
                dampedDragAnimation.updateValue(fraction)
            }
    }
    LaunchedEffect(selected) {
        snapshotFlow { selected() }
            .collectLatest { isSelected ->
                val target = if (isSelected) 1f else 0f
                if (target != fraction) {
                    fraction = target
                    dampedDragAnimation.animateToValue(target)
                }
            }
    }

    val trackBackdrop = rememberLayerBackdrop()

    Box(
        modifier,
        contentAlignment = Alignment.CenterStart
    ) {
        Box(
            Modifier
                .then(
                    if (!GlassSupport.isEmulator) Modifier.layerBackdrop(trackBackdrop)
                    else Modifier
                )
                .clip(Capsule)
                .drawBehind {
                    val fraction = dampedDragAnimation.value
                    drawRect(lerp(trackColor, accentColor, fraction))
                }
                .size(64f.dp, 28f.dp)
        )

        Box(
            Modifier
                .graphicsLayer {
                    val fraction = dampedDragAnimation.value
                    val padding = 2f.dp.toPx()
                    translationX =
                        if (isLtr) lerp(padding, padding + dragWidth, fraction)
                        else lerp(-padding, -(padding + dragWidth), fraction)
                }
                .semantics {
                    role = Role.Switch
                }
                .then(dampedDragAnimation.modifier)
                .then(
                    if (!GlassSupport.isEmulator) {
                        Modifier.drawBackdrop(
                    backdrop = rememberCombinedBackdrop(
                        backdrop,
                        rememberBackdrop(trackBackdrop) { drawBackdrop ->
                            val progress = dampedDragAnimation.pressProgress
                            val scaleX = lerp(2f / 3f, 0.75f, progress)
                            val scaleY = lerp(0f, 0.75f, progress)
                            scale(scaleX, scaleY) {
                                drawBackdrop()
                            }
                        }
                    ),
                    shape = { Capsule },
                    effects = {
                        val progress = dampedDragAnimation.pressProgress
                        if (GlassSupport.supportsBlur) blur(8f.dp.toPx() * (1f - progress))
                        if (GlassSupport.supportsLens) lens(
                            5f.dp.toPx() * progress,
                            10f.dp.toPx() * progress,
                            chromaticAberration = true
                        )
                    },
                    highlight = {
                        val progress = dampedDragAnimation.pressProgress
                        Highlight.Ambient.copy(
                            width = Highlight.Ambient.width / 1.5f,
                            blurRadius = Highlight.Ambient.blurRadius / 1.5f,
                            alpha = progress
                        )
                    },
                    shadow = {
                        Shadow(
                            radius = 4f.dp,
                            color = Color.Black.copy(alpha = 0.05f)
                        )
                    },
                    innerShadow = {
                        val progress = dampedDragAnimation.pressProgress
                        InnerShadow(
                            radius = 4f.dp * progress,
                            alpha = progress
                        )
                    },
                    layerBlock = {
                        scaleX = dampedDragAnimation.scaleX
                        scaleY = dampedDragAnimation.scaleY
                        val velocity = dampedDragAnimation.velocity / 50f
                        scaleX /= 1f - (velocity * 0.75f).fastCoerceIn(-0.2f, 0.2f)
                        scaleY *= 1f - (velocity * 0.25f).fastCoerceIn(-0.2f, 0.2f)
                    },
                    onDrawSurface = {
                        val progress = dampedDragAnimation.pressProgress
                        drawRect(Color.White.copy(alpha = 1f - progress))
                    }
                )
                    } else {
                        Modifier
                            .clip(Capsule)
                            .background(Color.White)
                    }
                )
                .size(40f.dp, 24f.dp)
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/LiquidTopBar.kt`

```kotlin
package com.georacing.georacing.ui.glass

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.RowScope
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.kyant.backdrop.Backdrop
import com.kyant.backdrop.drawBackdrop
import com.kyant.backdrop.effects.blur
import com.kyant.backdrop.effects.vibrancy
import com.kyant.backdrop.highlight.Highlight
import com.kyant.backdrop.shadow.Shadow
import com.kyant.shapes.Capsule
import com.georacing.georacing.ui.glass.drawBackdropSafe

/**
 * A floating glass top bar with blur and vibrancy effects.
 * Use as a replacement for TopAppBar in screens.
 */
@Composable
fun LiquidTopBar(
    backdrop: Backdrop,
    modifier: Modifier = Modifier,
    surfaceColor: Color = Color(0xFF1C1C1E).copy(alpha = 0.7f),
    navigationIcon: @Composable (() -> Unit)? = null,
    title: @Composable () -> Unit = {},
    actions: @Composable RowScope.() -> Unit = {}
) {
    Row(
        modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp)
            .drawBackdropSafe(
                backdrop = backdrop,
                shape = { Capsule },
                effects = {
                    if (GlassSupport.supportsVibrancy) vibrancy()
                    if (GlassSupport.supportsBlur) blur(12f.dp.toPx())
                },
                highlight = {
                    Highlight.Ambient.copy(
                        alpha = 0.2f,
                        width = Highlight.Ambient.width / 2f
                    )
                },
                shadow = {
                    Shadow(
                        radius = 12.dp,
                        color = Color.Black.copy(alpha = 0.2f)
                    )
                },
                onDrawSurface = {
                    drawRect(surfaceColor)
                },
                fallbackColor = surfaceColor
            )
            .height(56.dp)
            .padding(horizontal = 8.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Navigation icon
        if (navigationIcon != null) {
            navigationIcon()
        }
        
        // Title (center weight)
        Row(
            modifier = Modifier.weight(1f),
            horizontalArrangement = Arrangement.Center,
            verticalAlignment = Alignment.CenterVertically
        ) {
            title()
        }
        
        // Actions
        Row(
            horizontalArrangement = Arrangement.End,
            verticalAlignment = Alignment.CenterVertically,
            content = actions
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/LocalBackdrop.kt`

```kotlin
package com.georacing.georacing.ui.glass

import androidx.compose.runtime.staticCompositionLocalOf
import androidx.compose.ui.graphics.GraphicsLayerScope
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.layout.LayoutCoordinates
import androidx.compose.ui.unit.Density
import com.kyant.backdrop.Backdrop

/**
 * Empty backdrop stub for default CompositionLocal value.
 * Actual backdrop should be provided via rememberLayerBackdrop() in MainActivity.
 */
private object StubBackdrop : Backdrop {
    override val isCoordinatesDependent: Boolean = false
    
    override fun DrawScope.drawBackdrop(
        density: Density,
        coordinates: LayoutCoordinates?,
        layerBlock: (GraphicsLayerScope.() -> Unit)?
    ) {
        // No-op: stub implementation for default
    }
}

/**
 * CompositionLocal for providing the Backdrop across the app.
 * The Backdrop is used for Liquid Glass effects in navigation bars, toggles, etc.
 */
val LocalBackdrop = staticCompositionLocalOf<Backdrop> { StubBackdrop }

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/utils/DampedDragAnimation.kt`

```kotlin
package com.georacing.georacing.ui.glass.utils

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.spring
import androidx.compose.foundation.MutatorMutex
import androidx.compose.runtime.snapshotFlow
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.input.pointer.util.VelocityTracker
import androidx.compose.ui.unit.IntSize
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.android.awaitFrame
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlin.math.abs

class DampedDragAnimation(
    private val animationScope: CoroutineScope,
    val initialValue: Float,
    val valueRange: ClosedRange<Float>,
    val visibilityThreshold: Float,
    val initialScale: Float,
    val pressedScale: Float,
    val onDragStarted: DampedDragAnimation.(position: Offset) -> Unit,
    val onDragStopped: DampedDragAnimation.() -> Unit,
    val onDrag: DampedDragAnimation.(size: IntSize, dragAmount: Offset) -> Unit,
) {

    private val valueAnimationSpec =
        spring(1f, 1000f, visibilityThreshold)
    private val velocityAnimationSpec =
        spring(0.5f, 300f, visibilityThreshold * 10f)
    private val pressProgressAnimationSpec =
        spring(1f, 1000f, 0.001f)
    private val scaleXAnimationSpec =
        spring(0.6f, 250f, 0.001f)
    private val scaleYAnimationSpec =
        spring(0.7f, 250f, 0.001f)

    private val valueAnimation =
        Animatable(initialValue, visibilityThreshold)
    private val velocityAnimation =
        Animatable(0f, 5f)
    private val pressProgressAnimation =
        Animatable(0f, 0.001f)
    private val scaleXAnimation =
        Animatable(initialScale, 0.001f)
    private val scaleYAnimation =
        Animatable(initialScale, 0.001f)

    private val mutatorMutex = MutatorMutex()

    private val velocityTracker = VelocityTracker()

    val value: Float get() = valueAnimation.value
    val progress: Float get() = (value - valueRange.start) / (valueRange.endInclusive - valueRange.start)
    val targetValue: Float get() = valueAnimation.targetValue
    val pressProgress: Float get() = pressProgressAnimation.value
    val scaleX: Float get() = scaleXAnimation.value
    val scaleY: Float get() = scaleYAnimation.value
    val velocity: Float get() = velocityAnimation.value

    val modifier: Modifier = Modifier.pointerInput(Unit) {
        inspectDragGestures(
            onDragStart = { down ->
                onDragStarted(down.position)
                press()
            },
            onDragEnd = {
                onDragStopped()
                release()
            },
            onDragCancel = {
                onDragStopped()
                release()
            }
        ) { change, dragAmount ->
            onDrag(size, dragAmount)
        }
    }

    fun press() {
        velocityTracker.resetTracking()
        animationScope.launch {
            launch { pressProgressAnimation.animateTo(1f, pressProgressAnimationSpec) }
            launch { scaleXAnimation.animateTo(pressedScale, scaleXAnimationSpec) }
            launch { scaleYAnimation.animateTo(pressedScale, scaleYAnimationSpec) }
        }
    }

    fun release() {
        animationScope.launch {
            awaitFrame()
            if (value != targetValue) {
                val threshold = (valueRange.endInclusive - valueRange.start) * 0.025f
                snapshotFlow { valueAnimation.value }
                    .filter { abs(it - valueAnimation.targetValue) < threshold }
                    .first()
            }
            launch { pressProgressAnimation.animateTo(0f, pressProgressAnimationSpec) }
            launch { scaleXAnimation.animateTo(initialScale, scaleXAnimationSpec) }
            launch { scaleYAnimation.animateTo(initialScale, scaleYAnimationSpec) }
        }
    }

    fun updateValue(value: Float) {
        val targetValue = value.coerceIn(valueRange)
        animationScope.launch {
            launch { valueAnimation.animateTo(targetValue, valueAnimationSpec) { updateVelocity() } }
        }
    }

    fun animateToValue(value: Float) {
        animationScope.launch {
            mutatorMutex.mutate {
                press()
                val targetValue = value.coerceIn(valueRange)
                launch { valueAnimation.animateTo(targetValue, valueAnimationSpec) }
                if (velocity != 0f) {
                    launch { velocityAnimation.animateTo(0f, velocityAnimationSpec) }
                }
                release()
            }
        }
    }

    private fun updateVelocity() {
        velocityTracker.addPosition(
            System.currentTimeMillis(),
            Offset(value, 0f)
        )
        val targetVelocity = velocityTracker.calculateVelocity().x / (valueRange.endInclusive - valueRange.start)
        animationScope.launch { velocityAnimation.animateTo(targetVelocity, velocityAnimationSpec) }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/utils/DragGestureInspector.kt`

```kotlin
package com.georacing.georacing.ui.glass.utils

import androidx.compose.foundation.gestures.awaitEachGesture
import androidx.compose.foundation.gestures.awaitFirstDown
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.input.pointer.AwaitPointerEventScope
import androidx.compose.ui.input.pointer.PointerEventPass
import androidx.compose.ui.input.pointer.PointerId
import androidx.compose.ui.input.pointer.PointerInputChange
import androidx.compose.ui.input.pointer.PointerInputScope
import androidx.compose.ui.input.pointer.changedToUpIgnoreConsumed
import androidx.compose.ui.input.pointer.positionChange
import androidx.compose.ui.util.fastFirstOrNull

suspend fun PointerInputScope.inspectDragGestures(
    onDragStart: (down: PointerInputChange) -> Unit = {},
    onDragEnd: (change: PointerInputChange) -> Unit = {},
    onDragCancel: () -> Unit = {},
    onDrag: (change: PointerInputChange, dragAmount: Offset) -> Unit
) {
    awaitEachGesture {
        val initialDown = awaitFirstDown(false, PointerEventPass.Initial)

        val down = awaitFirstDown(false)
        val drag = initialDown

        onDragStart(down)
        onDrag(drag, Offset.Zero)
        val upEvent =
            drag(
                pointerId = drag.id,
                onDrag = { onDrag(it, it.positionChange()) }
            )
        if (upEvent == null) {
            onDragCancel()
        } else {
            onDragEnd(upEvent)
        }
    }
}

private suspend inline fun AwaitPointerEventScope.drag(
    pointerId: PointerId,
    onDrag: (PointerInputChange) -> Unit
): PointerInputChange? {
    val isPointerUp = currentEvent.changes.fastFirstOrNull { it.id == pointerId }?.pressed != true
    if (isPointerUp) {
        return null
    }
    var pointer = pointerId
    while (true) {
        val change = awaitDragOrUp(pointer) ?: return null
        if (change.isConsumed) {
            return null
        }
        if (change.changedToUpIgnoreConsumed()) {
            return change
        }
        onDrag(change)
        pointer = change.id
    }
}

private suspend inline fun AwaitPointerEventScope.awaitDragOrUp(
    pointerId: PointerId
): PointerInputChange? {
    var pointer = pointerId
    while (true) {
        val event = awaitPointerEvent()
        val dragEvent = event.changes.fastFirstOrNull { it.id == pointer } ?: return null
        if (dragEvent.changedToUpIgnoreConsumed()) {
            val otherDown = event.changes.fastFirstOrNull { it.pressed }
            if (otherDown == null) {
                return dragEvent
            } else {
                pointer = otherDown.id
            }
        } else {
            val hasDragged = dragEvent.previousPosition != dragEvent.position
            if (hasDragged) {
                return dragEvent
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/glass/utils/InteractiveHighlight.kt`

```kotlin
package com.georacing.georacing.ui.glass.utils

import android.graphics.RuntimeShader
import android.os.Build
import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.VectorConverter
import androidx.compose.animation.core.VisibilityThreshold
import androidx.compose.animation.core.spring
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.drawWithContent
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.BlendMode
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.ShaderBrush
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.util.fastCoerceIn
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.launch

class InteractiveHighlight(
    val animationScope: CoroutineScope,
    val position: (size: Size, offset: Offset) -> Offset = { _, offset -> offset }
) {

    private val pressProgressAnimationSpec =
        spring(0.5f, 300f, 0.001f)
    private val positionAnimationSpec =
        spring(0.5f, 300f, Offset.VisibilityThreshold)

    private val pressProgressAnimation =
        Animatable(0f, 0.001f)
    private val positionAnimation =
        Animatable(Offset.Zero, Offset.VectorConverter, Offset.VisibilityThreshold)

    private var startPosition = Offset.Zero
    val pressProgress: Float get() = pressProgressAnimation.value
    val offset: Offset get() = positionAnimation.value - startPosition

    private val shader =
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU && !com.georacing.georacing.ui.glass.GlassSupport.isEmulator) {
            RuntimeShader(
                """
uniform float2 size;
layout(color) uniform half4 color;
uniform float radius;
uniform float2 position;

half4 main(float2 coord) {
    float dist = distance(coord, position);
    float intensity = smoothstep(radius, radius * 0.5, dist);
    return color * intensity;
}"""
            )
        } else {
            null
        }

    val modifier: Modifier =
        Modifier.drawWithContent {
            val progress = pressProgressAnimation.value
            if (progress > 0f) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU && shader != null && !com.georacing.georacing.ui.glass.GlassSupport.isEmulator) {
                    drawRect(
                        Color.White.copy(0.08f * progress),
                        blendMode = BlendMode.Plus
                    )
                    shader.apply {
                        val position = position(size, positionAnimation.value)
                        setFloatUniform("size", size.width, size.height)
                        setColorUniform("color", Color.White.copy(0.15f * progress).toArgb())
                        setFloatUniform("radius", size.minDimension * 1.5f)
                        setFloatUniform(
                            "position",
                            position.x.fastCoerceIn(0f, size.width),
                            position.y.fastCoerceIn(0f, size.height)
                        )
                    }
                    drawRect(
                        ShaderBrush(shader),
                        blendMode = BlendMode.Plus
                    )
                } else {
                    drawRect(
                        Color.White.copy(0.25f * progress),
                        blendMode = BlendMode.Plus
                    )
                }
            }

            drawContent()
        }

    val gestureModifier: Modifier =
        Modifier.pointerInput(animationScope) {
            inspectDragGestures(
                onDragStart = { down ->
                    startPosition = down.position
                    animationScope.launch {
                        launch { pressProgressAnimation.animateTo(1f, pressProgressAnimationSpec) }
                        launch { positionAnimation.snapTo(startPosition) }
                    }
                },
                onDragEnd = {
                    animationScope.launch {
                        launch { pressProgressAnimation.animateTo(0f, pressProgressAnimationSpec) }
                        launch { positionAnimation.animateTo(startPosition, positionAnimationSpec) }
                    }
                },
                onDragCancel = {
                    animationScope.launch {
                        launch { pressProgressAnimation.animateTo(0f, pressProgressAnimationSpec) }
                        launch { positionAnimation.animateTo(startPosition, positionAnimationSpec) }
                    }
                }
            ) { change, _ ->
                animationScope.launch { positionAnimation.snapTo(change.position) }
            }
        }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/navigation/GeoRacingNavHost.kt`

```kotlin
package com.georacing.georacing.ui.navigation

import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.navArgument
import com.georacing.georacing.data.local.UserPreferencesDataStore
import com.georacing.georacing.ui.screens.home.HomeScreen
import com.georacing.georacing.ui.screens.incidents.IncidentReportScreen
import com.georacing.georacing.ui.screens.map.MapScreen
import com.georacing.georacing.ui.screens.onboarding.OnboardingScreen
import com.georacing.georacing.ui.screens.poi.PoiListScreen
import com.georacing.georacing.ui.screens.seat.SeatSetupScreen
import com.georacing.georacing.ui.screens.settings.SettingsScreen
import com.georacing.georacing.ui.screens.group.GroupScreen
import com.georacing.georacing.ui.screens.orders.OrdersScreen
import com.georacing.georacing.ui.screens.moments.MomentsScreen
import com.georacing.georacing.ui.screens.alerts.AlertsScreen
import com.georacing.georacing.ui.screens.parking.ParkingScreen
import com.georacing.georacing.ui.screens.transport.TransportScreen
import com.georacing.georacing.ui.screens.clima.ClimaSmartScreen
import com.georacing.georacing.ui.screens.eco.EcoMeterScreen
import com.georacing.georacing.ui.screens.fan.FanImmersiveScreen
import com.georacing.georacing.ui.screens.navigation.CircuitDestinationSelector
import com.georacing.georacing.ui.screens.navigation.CircuitNavigationScreen
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import com.georacing.georacing.ui.screens.group.GroupMapViewModel
import com.georacing.georacing.data.repository.NetworkGroupRepository


@Composable
fun GeoRacingNavHost(
    navController: NavHostController,
    startDestination: String,
    userPreferences: UserPreferencesDataStore,
    appContainer: com.georacing.georacing.di.AppContainer, // üÜï Inject Container
    modifier: Modifier = Modifier
) {
    val context = androidx.compose.ui.platform.LocalContext.current
    
    // Dependencies from Container
    val beaconScanner = appContainer.beaconScanner
    val circuitStateRepository = appContainer.circuitStateRepository
    val poiRepository = appContainer.poiRepository
    // ... others as needed

    // =========================================================================
    // üéõÔ∏è AppMonitorManager: Centralized background monitoring
    // BLE scanning, battery monitoring, network monitoring
    // =========================================================================
    val appMonitorManager = appContainer.appMonitorManager
    
    // Start all monitors (idempotent ‚Äî safe to call on recomposition)
    androidx.compose.runtime.LaunchedEffect(Unit) {
        appMonitorManager.startAll()
    }
    
    // üÜò KILL SWITCH: Navigate to Emergency when battery critical
    androidx.compose.runtime.LaunchedEffect(Unit) {
        appMonitorManager.onCriticalBattery = { level ->
            navController.navigate(Screen.Emergency.route) {
                popUpTo(0) { inclusive = true }
            }
            android.util.Log.w("KillSwitch", "üÜò CRITICAL BATTERY ($level%) - Forced to EmergencyScreen")
        }
    }
    
    // Observe state from the centralized manager (for passing to composables)
    val powerState by appMonitorManager.powerState.collectAsState()
    val batteryLevel by appMonitorManager.batteryLevel.collectAsState()
    val isOnline by appMonitorManager.isOnline.collectAsState()
    val connectionType by appMonitorManager.connectionType.collectAsState()
    
    // Hoisted ViewModel for Group Sharing Persistence
    val groupMapViewModel: GroupMapViewModel = viewModel(
        factory = viewModelFactory {
            initializer {
                GroupMapViewModel(NetworkGroupRepository())
            }
        }
    )
    
    // Beacons repository from DI container (offline-first with caching)
    val beaconsRepository = appContainer.beaconsRepository
    val incidentsRepository = appContainer.incidentsRepository


    NavHost(
        navController = navController,
        startDestination = startDestination,
        modifier = modifier
    ) {
        composable(Screen.Splash.route) {
            com.georacing.georacing.ui.screens.splash.SplashScreen(navController = navController)
        }
        composable(Screen.Login.route) {
            com.georacing.georacing.ui.screens.login.LoginScreen(navController = navController)
        }
        composable(Screen.Onboarding.route) {
            OnboardingScreen(
                navController = navController,
                userPreferences = userPreferences
            )
        }
        composable(Screen.Home.route) {
            HomeScreen(
                navController = navController,
                circuitStateRepository = circuitStateRepository,
                beaconScanner = beaconScanner,
                isOnline = isOnline,
                bleBeaconsCount = beaconScanner.detectedBeacons.collectAsState().value.size,
                userPreferences = userPreferences,
                appContainer = appContainer // üÜï Pass Container
            )
        }
        composable(Screen.EditDashboard.route) {
            com.georacing.georacing.ui.screens.home.EditDashboardScreen(
                navController = navController,
                userPreferences = userPreferences
            )
        }
        composable(Screen.SeatSetup.route) {
            SeatSetupScreen(
                navController = navController,
                userPreferences = userPreferences
            )
        }
        composable(Screen.Map.route) {
            MapScreen(
                navController = navController,
                beaconsRepository = beaconsRepository,
                userPreferences = userPreferences
            )
        }
        composable(Screen.PoiList.route) {
            PoiListScreen(
                navController = navController,
                poiRepository = poiRepository
            )
        }
        composable(Screen.IncidentReport.route) {
            IncidentReportScreen(
                navController = navController,
                incidentsRepository = incidentsRepository
            )
        }
        composable(Screen.Settings.route) {
            SettingsScreen(
                navController = navController,
                userPreferences = userPreferences
            )
        }
        composable(Screen.Group.route) {
            GroupScreen(
                navController = navController,
                userPreferences = userPreferences,
                viewModel = groupMapViewModel
            )
        }
        composable(Screen.GroupMap.route) {
            com.georacing.georacing.ui.screens.group.GroupMapScreen(
                navController = navController,
                viewModel = groupMapViewModel
            )
        }
        composable(
            route = Screen.ShareQR.route,
            arguments = listOf(navArgument("groupId") { type = NavType.StringType })
        ) { backStackEntry ->
            val groupId = backStackEntry.arguments?.getString("groupId") ?: "default_group"
            com.georacing.georacing.ui.screens.share.ShareQRScreen(
                navController = navController,
                groupId = groupId
            )
        }
        composable(Screen.QRScanner.route) {
            com.georacing.georacing.ui.screens.share.QRScannerScreen(navController = navController)
        }
        composable(Screen.Orders.route) {
            com.georacing.georacing.ui.screens.orders.OrdersScreen(navController = navController)
        }
        composable(Screen.MyOrders.route) {
            com.georacing.georacing.ui.screens.orders.MyOrdersScreen(navController = navController)
        }
        composable(
            route = "order_confirmation/{orderId}",
            arguments = listOf(navArgument("orderId") { type = NavType.StringType })
        ) { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            com.georacing.georacing.ui.screens.orders.OrderConfirmationScreen(
                navController = navController,
                orderId = orderId
            )
        }
        composable(
            route = Screen.OrderStatus.route,
            arguments = listOf(navArgument("orderId") { type = NavType.StringType })
        ) { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            com.georacing.georacing.ui.orders.OrderStatusScreen(
                orderId = orderId,
                onBack = { navController.popBackStack() } 
            )
        }
        composable(Screen.Moments.route) {
            MomentsScreen(navController = navController)
        }
        composable(Screen.Alerts.route) {
            AlertsScreen(navController = navController)
        }
        composable(Screen.Parking.route) {
            ParkingScreen(
                navController = navController,
                parkingRepository = appContainer.parkingRepository
            )
        }
        composable(Screen.Transport.route) {
            TransportScreen(navController = navController)
        }
        composable(Screen.ClimaSmart.route) {
            ClimaSmartScreen(navController = navController)
        }
        composable(Screen.EcoMeter.route) {
            EcoMeterScreen(navController = navController)
        }
        composable(Screen.FanImmersive.route) {
            FanImmersiveScreen(navController = navController)
        }
        composable(Screen.Emergency.route) {
            com.georacing.georacing.ui.screens.emergency.EmergencyScreen(navController = navController)
        }
        
        // Navegaci√≥n al circuito
        composable(Screen.CircuitDestinations.route) {
            CircuitDestinationSelector(navController = navController)
        }
        composable(
            route = Screen.CircuitNavigation.route,
            arguments = listOf(navArgument("poiId") { type = NavType.StringType })
        ) { backStackEntry ->
            val poiId = backStackEntry.arguments?.getString("poiId")
            CircuitNavigationScreen(
                navController = navController,
                poiId = poiId
            )
        }
        composable(Screen.Roadmap.route) {
            com.georacing.georacing.ui.screens.roadmap.RoadmapScreen()
        }
        
        // üÜò Survival Features
        composable(Screen.MedicalLockScreen.route) {
            com.georacing.georacing.ui.screens.medical.MedicalLockScreenScreen(
                navController = navController
            )
        }
        composable(Screen.StaffMode.route) {
            com.georacing.georacing.ui.screens.staff.StaffModeScreen(
                navController = navController
            )
        }
        
        // New Features
        composable(Screen.AR.route) {
            com.georacing.georacing.ui.screens.ar.ARNavigationScreen(
                appContainer = appContainer,
                onBack = { navController.popBackStack() }
            )
        }
        composable(Screen.Search.route) {
            com.georacing.georacing.ui.screens.search.SearchScreen(navController = navController)
        }
        composable(Screen.Achievements.route) {
            com.georacing.georacing.ui.screens.achievements.AchievementsScreen(
                navController = navController,
                gamificationRepository = appContainer.gamificationRepository
            )
        }
        
        // üÜï New Features (Phase 3)
        composable(Screen.ClickCollect.route) {
            com.georacing.georacing.ui.screens.orders.ClickCollectScreen(
                onNavigateBack = { navController.popBackStack() },
                onNavigateToOrders = { standId -> 
                    navController.navigate(Screen.Orders.route)
                },
                onNavigateToMyOrders = { navController.navigate(Screen.MyOrders.route) }
            )
        }
        composable(Screen.Wrapped.route) {
            com.georacing.georacing.ui.screens.share.WrappedScreen(
                onNavigateBack = { navController.popBackStack() },
                healthConnectManager = appContainer.healthConnectManager,
                gamificationRepository = appContainer.gamificationRepository
            )
        }
        composable(Screen.Collectibles.route) {
            com.georacing.georacing.ui.screens.achievements.CollectiblesScreen(
                onNavigateBack = { navController.popBackStack() }
            )
        }
        composable(Screen.ProximityChat.route) {
            com.georacing.georacing.ui.screens.share.ProximityChatScreen(
                proximityChatManager = appContainer.proximityChatManager,
                onNavigateBack = { navController.popBackStack() }
            )
        }
        composable(Screen.RouteTraffic.route) {
            com.georacing.georacing.ui.screens.traffic.RouteTrafficScreen(
                navController = navController
            )
        }
        composable(Screen.FanZone.route) {
            com.georacing.georacing.ui.screens.fan.FanZoneScreen(
                navController = navController
            )
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/navigation/Screen.kt`

```kotlin
package com.georacing.georacing.ui.navigation

sealed class Screen(val route: String) {
    object Splash : Screen("splash")
    object Login : Screen("login")
    object Onboarding : Screen("onboarding")
    object Home : Screen("home")
    object SeatSetup : Screen("seat_setup")
    object Map : Screen("map")
    object PoiList : Screen("poi_list")
    object IncidentReport : Screen("incident_report")
    object Settings : Screen("settings")
    object Group : Screen("group")
    object GroupMap : Screen("group_map")
    object ShareQR : Screen("share_qr/{groupId}") {
        fun createRoute(groupId: String) = "share_qr/$groupId"
    }
    object QRScanner : Screen("qr_scanner")
    object Orders : Screen("orders")
    object OrderStatus : Screen("order_status/{orderId}") {
        fun createRoute(orderId: String) = "order_status/$orderId"
    }
    object Moments : Screen("moments")
    object Alerts : Screen("alerts")
    object Parking : Screen("parking")
    object Transport : Screen("transport")
    object ClimaSmart : Screen("clima_smart")
    object EcoMeter : Screen("eco_meter")
    object FanImmersive : Screen("fan_immersive")
    object Emergency : Screen("emergency")
    
    // Navegaci√≥n al circuito
    object CircuitDestinations : Screen("circuit_destinations")
    object CircuitNavigation : Screen("circuit_navigation/{poiId}") {
        fun createRoute(poiId: String) = "circuit_navigation/$poiId"
    }
    object MyOrders : Screen("my_orders")
    object Roadmap : Screen("roadmap")
    
    // üÜò Survival Features
    object MedicalLockScreen : Screen("medical_lockscreen")
    object StaffMode : Screen("staff_mode")
    
    // Config
    object EditDashboard : Screen("edit_dashboard")
    
    // New Features
    object AR : Screen("ar")
    object Search : Screen("search")
    object Achievements : Screen("achievements")
    
    // üÜï New Features (Phase 3)
    object ClickCollect : Screen("click_collect")
    object Wrapped : Screen("wrapped")
    object Collectibles : Screen("collectibles")
    object ProximityChat : Screen("proximity_chat")
    object RouteTraffic : Screen("route_traffic")
    object FanZone : Screen("fan_zone") // iOS parity: FanZoneView
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/orders/CartViewModel.kt`

```kotlin
package com.georacing.georacing.ui.orders

import android.app.Application
import android.widget.Toast
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.data.orders.OrdersRepositoryImpl
import com.georacing.georacing.data.products.ProductsRepositoryImpl
import com.georacing.georacing.domain.orders.OrderLine
import com.georacing.georacing.domain.products.Product
import com.google.android.gms.wallet.PaymentsClient
import com.google.android.gms.wallet.Wallet
import com.google.android.gms.wallet.WalletConstants
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import org.json.JSONArray
import org.json.JSONObject
import retrofit2.HttpException

data class CartItem(
    val product: Product,
    var quantity: Int
)

class CartViewModel(application: Application) : AndroidViewModel(application) {

    private val productsRepository = ProductsRepositoryImpl()
    private val ordersRepository = OrdersRepositoryImpl()

    private val _products = MutableStateFlow<List<Product>>(emptyList())
    val products: StateFlow<List<Product>> = _products.asStateFlow()

    private val _cartItems = MutableStateFlow<List<CartItem>>(emptyList())
    val cartItems: StateFlow<List<CartItem>> = _cartItems.asStateFlow()

    private val _uiState = MutableStateFlow<CartUiState>(CartUiState.Idle)
    val uiState: StateFlow<CartUiState> = _uiState.asStateFlow()

    private lateinit var paymentsClient: PaymentsClient

    init {
        initializeGooglePay()
        loadProducts()
    }

    private fun initializeGooglePay() {
        val walletOptions = Wallet.WalletOptions.Builder()
            .setEnvironment(WalletConstants.ENVIRONMENT_TEST)
            .build()
        paymentsClient = Wallet.getPaymentsClient(getApplication(), walletOptions)
    }

    fun loadProducts() {
        viewModelScope.launch {
            _uiState.value = CartUiState.Loading
            try {
                val list = productsRepository.getAllProducts()
                _products.value = list
                _uiState.value = CartUiState.Idle
            } catch (e: Exception) {
                // Check for 500 error (Missing Table) either via HttpException or message text
                val is500 = (e is HttpException && e.code() == 500) || 
                            e.message?.contains("500") == true ||
                            e.message?.contains("Internal Server Error") == true

                if (is500) {
                    try {
                        seedDatabase()
                        val list = productsRepository.getAllProducts()
                        _products.value = list
                        _uiState.value = CartUiState.Idle
                    } catch (retryEx: Exception) {
                         _uiState.value = CartUiState.Error("Error seeding/loading: ${retryEx.message}")
                    }
                } else {
                    _uiState.value = CartUiState.Error("Error loading products: ${e.message}")
                }
            }
        }
    }

    private suspend fun seedDatabase() {
        val demoProducts = listOf(
            Product("1", "Bocadillo Jam√≥n", "Delicioso bocadillo de jam√≥n serrano", 6.50, 100, "Comida", null, "ü•™", true),
            Product("2", "Cerveza Estrella", "Cerveza fr√≠a 33cl", 5.00, 100, "Bebidas", null, "üç∫", true),
            Product("3", "Hot Dog", "Perrito caliente con salsas", 5.50, 100, "Comida", null, "üå≠", true),
            Product("4", "Agua 500ml", "Agua mineral natural", 2.50, 100, "Bebidas", null, "üíß", true),
            Product("5", "Nachos con Queso", "Nachos crujientes con salsa de queso", 7.00, 100, "Comida", null, "üßÄ", true),
            Product("6", "Coca-Cola", "Refresco de cola 33cl", 3.50, 100, "Bebidas", null, "ü•§", true),
            Product("7", "Gorra Oficial F1", "Gorra del equipo oficial", 35.00, 50, "Merchandising", null, "üß¢", true),
            Product("8", "Camiseta Equipo", "Camiseta t√©cnica oficial", 45.00, 50, "Merchandising", null, "üëï", true)
        )
        demoProducts.forEach { productsRepository.upsertProduct(it) }
    }

    fun addToCart(product: Product) {
        val currentCart = _cartItems.value.toMutableList()
        val existingItem = currentCart.find { it.product.productId == product.productId }
        
        val currentQty = existingItem?.quantity ?: 0
        if (currentQty + 1 > product.stock) {
            Toast.makeText(getApplication(), "Sin stock suficiente", Toast.LENGTH_SHORT).show()
            return
        }

        if (existingItem != null) {
            existingItem.quantity++
        } else {
            currentCart.add(CartItem(product, 1))
        }
        _cartItems.value = currentCart
    }
    
    fun removeFromCart(product: Product) {
        val currentCart = _cartItems.value.toMutableList()
        val existingItem = currentCart.find { it.product.productId == product.productId }
        if (existingItem != null) {
            if (existingItem.quantity > 1) {
                existingItem.quantity--
            } else {
                currentCart.remove(existingItem)
            }
            _cartItems.value = currentCart
        }
    }
    
    fun clearCart() {
        _cartItems.value = emptyList()
    }

    fun getGooglePayPaymentDataRequest(price: Double): JSONObject {
        // Simple fixed configuration for MVP
        val baseRequest = JSONObject().apply {
            put("apiVersion", 2)
            put("apiVersionMinor", 0)
        }
        
        val tokenizationSpecification = JSONObject().apply {
            put("type", "PAYMENT_GATEWAY")
            put("parameters", JSONObject().apply {
                put("gateway", "example")
                put("gatewayMerchantId", "exampleGatewayMerchantId")
            })
        }

        val allowedCardNetworks = JSONArray(listOf("AMEX", "DISCOVER", "JCB", "MASTERCARD", "VISA"))
        val allowedAuthMethods = JSONArray(listOf("PAN_ONLY", "CRYPTOGRAM_3DS"))

        val cardPaymentMethod = JSONObject().apply {
            put("type", "CARD")
            put("parameters", JSONObject().apply {
                put("allowedAuthMethods", allowedAuthMethods)
                put("allowedCardNetworks", allowedCardNetworks)
            })
            put("tokenizationSpecification", tokenizationSpecification)
        }

        val paymentDataRequest = JSONObject(baseRequest.toString()).apply {
            put("allowedPaymentMethods", JSONArray().put(cardPaymentMethod))
            put("transactionInfo", JSONObject().apply {
                put("totalPriceStatus", "FINAL")
                put("totalPrice", String.format("%.2f", price).replace(",", "."))
                put("currencyCode", "EUR") // Assuming EUR
            })
            put("merchantInfo", JSONObject().apply {
                put("merchantName", "GeoRacing Test")
            })
        }
        
        return paymentDataRequest
    }

    fun createOrder(paymentToken: String) {
        viewModelScope.launch {
            _uiState.value = CartUiState.Processing
            try {
                val cart = _cartItems.value
                val total = cart.sumOf { it.product.price * it.quantity }
                
                // Map to OrderLine
                val orderLines = cart.map {
                    OrderLine(
                        productId = it.product.productId,
                        quantity = it.quantity,
                        unitPrice = it.product.price
                    )
                }
                
                // Temp user ID
                val userId = "test_user_uid" 
                
                val orderId = ordersRepository.createOrder(
                    userUid = userId,
                    items = orderLines,
                    totalAmount = total,
                    paymentToken = paymentToken
                )
                
                // Decrease stock logic (Fire and forget as requested)
                cart.forEach { item ->
                    val newStock = item.product.stock - item.quantity
                    productsRepository.updateProductStock(item.product.productId, newStock)
                }
                
                _cartItems.value = emptyList()
                _uiState.value = CartUiState.OrderPlaced(orderId)
                
            } catch (e: Exception) {
                _uiState.value = CartUiState.Error("Error creating order: ${e.message}")
            }
        }
    }
    
    fun resetState() {
        _uiState.value = CartUiState.Idle
    }
}

sealed class CartUiState {
    object Idle : CartUiState()
    object Loading : CartUiState()
    object Processing : CartUiState()
    data class OrderPlaced(val orderId: String) : CartUiState()
    data class Error(val message: String) : CartUiState()
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/orders/OrderStatusScreen.kt`

```kotlin
package com.georacing.georacing.ui.orders

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.georacing.georacing.domain.orders.Order
import com.georacing.georacing.domain.orders.OrderLine
import com.georacing.georacing.domain.orders.OrderStatus
import com.georacing.georacing.ui.components.background.CarbonBackground

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun OrderStatusScreen(
    orderId: String,
    onBack: () -> Unit,
    viewModel: OrderStatusViewModel = viewModel()
) {
    val order by viewModel.order.collectAsState()
    val loading by viewModel.loading.collectAsState()
    val error by viewModel.error.collectAsState()

    LaunchedEffect(orderId) {
        viewModel.loadOrder(orderId)
    }

    Box(modifier = Modifier.fillMaxSize()) {
        CarbonBackground()

        Scaffold(
            topBar = {
                TopAppBar(
                    title = { 
                         Text(
                            "ESTADO DEL PEDIDO",
                            style = MaterialTheme.typography.titleLarge.copy(
                                fontWeight = FontWeight.Bold,
                                letterSpacing = 1.sp
                            )
                        )
                    },
                    navigationIcon = {
                        IconButton(onClick = onBack) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Atr√°s")
                        }
                    },
                    actions = {
                        IconButton(onClick = { viewModel.loadOrder(orderId) }) {
                            Icon(Icons.Default.Refresh, contentDescription = "Refrescar")
                        }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = Color(0xFF0A0A0A).copy(alpha = 0.9f),
                        titleContentColor = Color.White,
                        navigationIconContentColor = Color.White,
                        actionIconContentColor = Color.White
                    )
                )
            },
            containerColor = Color.Transparent
        ) { padding ->
            Box(modifier = Modifier.padding(padding).fillMaxSize()) {
                if (loading) {
                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center), color = Color(0xFFEF4444))
                } else if (error != null) {
                    Column(
                        modifier = Modifier.align(Alignment.Center),
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            text = error ?: "Error desconocido",
                            color = MaterialTheme.colorScheme.error,
                            style = MaterialTheme.typography.bodyLarge
                        )
                        Button(
                            onClick = { viewModel.loadOrder(orderId) },
                            colors = ButtonDefaults.buttonColors(containerColor = Color(0xFFEF4444))
                        ) {
                            Text("Reintentar")
                        }
                    }
                } else {
                    order?.let { currentOrder ->
                        OrderDetails(currentOrder)
                    }
                }
            }
        }
    }
}

@Composable
fun OrderDetails(order: Order) {
    Column(modifier = Modifier.padding(16.dp)) {
        Text(
            text = "PEDIDO #${order.orderId.take(8).uppercase()}", 
            style = MaterialTheme.typography.headlineMedium,
            fontWeight = FontWeight.Bold,
            color = Color.White
        )
        Spacer(modifier = Modifier.height(16.dp))
        
        StatusBadge(status = order.status)
        
        Spacer(modifier = Modifier.height(24.dp))
        Text(
            text = "EL PEDIDO CONTIENE:", 
            style = MaterialTheme.typography.titleSmall,
            color = Color(0xFFA3A3A3),
            letterSpacing = 1.sp
        )
        Spacer(modifier = Modifier.height(8.dp))
        
        LazyColumn(modifier = Modifier.weight(1f)) {
            items(order.items) { item ->
                OrderLineItem(item)
            }
        }
        
        HorizontalDivider(color = Color(0xFF404040))
        Spacer(modifier = Modifier.height(8.dp))
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
             Text(
                "Total Pagado", 
                style = MaterialTheme.typography.titleMedium,
                color = Color(0xFFA3A3A3)
             )
             Text(
                "‚Ç¨${String.format("%.2f", order.totalAmount)}", 
                style = MaterialTheme.typography.headlineSmall,
                fontWeight = FontWeight.Bold,
                color = Color(0xFFEF4444)
            )
        }
    }
}

@Composable
fun StatusBadge(status: OrderStatus) {
    val (bgColor, textColor, text) = when (status) {
        OrderStatus.PENDING -> Triple(Color(0xFF3F3F46), Color.White, "PROCESANDO...")
        OrderStatus.PAID -> Triple(Color(0xFF1D4ED8), Color.White, "PAGADO")
        OrderStatus.PREPARING -> Triple(Color(0xFFEAB308), Color.Black, "PREPARANDO")
        OrderStatus.READY -> Triple(Color(0xFF22C55E), Color.Black, "¬°LISTO PARA RECOGER!")
        OrderStatus.DELIVERED -> Triple(Color(0xFF262626), Color(0xFFA3A3A3), "ENTREGADO")
        OrderStatus.CANCELLED -> Triple(Color(0xFFDC2626), Color.White, "CANCELADO")
    }
    
    Card(
        colors = CardDefaults.cardColors(containerColor = bgColor),
        modifier = Modifier.fillMaxWidth()
    ) {
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = text,
                color = textColor,
                style = MaterialTheme.typography.headlineSmall,
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.sp
            )
        }
    }
}

@Composable
fun OrderLineItem(item: OrderLine) {
    Card(
        colors = CardDefaults.cardColors(containerColor = Color(0xFF171717)),
        modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp)
    ) {
         Row(
            modifier = Modifier.fillMaxWidth().padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column {
                Text(
                    text = item.productId, // En un caso real buscar√≠amos el nombre del producto
                    style = MaterialTheme.typography.titleMedium,
                    color = Color.White
                )
                Text(
                    text = "Cantidad: ${item.quantity}", 
                    style = MaterialTheme.typography.bodyMedium,
                    color = Color(0xFFA3A3A3)
                )
            }
            Text(
                text = "‚Ç¨${String.format("%.2f", item.unitPrice * item.quantity)}",
                style = MaterialTheme.typography.titleMedium,
                color = Color.White,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/orders/OrderStatusViewModel.kt`

```kotlin
package com.georacing.georacing.ui.orders

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.data.orders.OrdersRepositoryImpl
import com.georacing.georacing.domain.orders.Order
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class OrderStatusViewModel(application: Application) : AndroidViewModel(application) {

    private val ordersRepository = OrdersRepositoryImpl()

    private val _order = MutableStateFlow<Order?>(null)
    val order: StateFlow<Order?> = _order.asStateFlow()

    private val _loading = MutableStateFlow(false)
    val loading: StateFlow<Boolean> = _loading.asStateFlow()

    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()

    fun loadOrder(orderId: String) {
        viewModelScope.launch {
            _loading.value = true
            _error.value = null
            try {
                val result = ordersRepository.getOrder(orderId)
                if (result != null) {
                    _order.value = result
                } else {
                    _error.value = "Pedido no encontrado"
                }
            } catch (e: Exception) {
                _error.value = "Error al cargar pedido: ${e.message}"
            } finally {
                _loading.value = false
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/achievements/AchievementsScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.achievements

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.*
import androidx.compose.animation.fadeIn
import androidx.compose.animation.slideInVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.data.gamification.GamificationRepository
import com.georacing.georacing.domain.model.Achievement
import com.georacing.georacing.domain.model.AchievementCategory
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.components.HomeIconButton
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.*

/**
 * AchievementsScreen ‚Äî Premium Gamification HUD
 * Logros, XP, niveles y progreso del fan en el circuito.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AchievementsScreen(
    navController: NavController,
    gamificationRepository: GamificationRepository
) {
    val backdrop = LocalBackdrop.current
    val energyProfile = LocalEnergyProfile.current

    // Si la bater√≠a est√° en modo supervivencia, bloquear gamificaci√≥n
    if (!energyProfile.canUseGamification) {
        Box(Modifier.fillMaxSize()) {
            CarbonBackground()
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                modifier = Modifier.fillMaxSize().padding(32.dp),
                verticalArrangement = Arrangement.Center
            ) {
                Box(
                    Modifier
                        .size(80.dp)
                        .clip(RoundedCornerShape(24.dp))
                        .background(StatusAmber.copy(alpha = 0.12f)),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(Icons.Default.BatteryAlert, null, tint = StatusAmber, modifier = Modifier.size(40.dp))
                }
                Spacer(Modifier.height(20.dp))
                Text("MODO AHORRO ACTIVO", color = TextPrimary, fontWeight = FontWeight.Black, fontSize = 20.sp, letterSpacing = 1.sp)
                Spacer(Modifier.height(8.dp))
                Text(
                    "La gamificaci√≥n se ha desactivado para ahorrar bater√≠a.\nRecarga tu dispositivo para continuar.",
                    color = TextSecondary,
                    textAlign = TextAlign.Center,
                    lineHeight = 20.sp
                )
                Spacer(Modifier.height(24.dp))
                Box(
                    Modifier
                        .clip(RoundedCornerShape(12.dp))
                        .liquidGlass(RoundedCornerShape(12.dp), GlassLevel.L2, accentGlow = RacingRed)
                        .padding(horizontal = 32.dp, vertical = 12.dp)
                ) {
                    Text("VOLVER", color = RacingRed, fontWeight = FontWeight.Black, letterSpacing = 1.sp,
                        modifier = Modifier.noRippleClickable { navController.popBackStack() })
                }
            }
        }
        return
    }

    val profile by gamificationRepository.profile.collectAsState()
    var selectedCategory by remember { mutableStateOf<AchievementCategory?>(null) }
    var showContent by remember { mutableStateOf(false) }
    LaunchedEffect(Unit) { showContent = true }

    val displayedAchievements = if (selectedCategory != null) {
        profile.achievements.filter { it.category == selectedCategory }
    } else {
        profile.achievements
    }

    val unlockedCount = profile.achievements.count { it.isUnlocked }
    val totalCount = profile.achievements.size

    Box(Modifier.fillMaxSize()) {
        CarbonBackground()

        Column(Modifier.fillMaxSize()) {
            // ‚îÄ‚îÄ Premium LiquidTopBar ‚îÄ‚îÄ
            LiquidTopBar(
                backdrop = backdrop,
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Volver", tint = TextPrimary)
                    }
                },
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Box(Modifier.size(8.dp).clip(CircleShape).background(ChampagneGold))
                        Spacer(Modifier.width(10.dp))
                        Column {
                            Text("LOGROS", style = MaterialTheme.typography.titleMedium, color = TextPrimary, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                            Text("Nivel ${profile.level} ¬∑ ${profile.levelName}", style = MaterialTheme.typography.labelSmall, color = TextTertiary)
                        }
                    }
                },
                actions = {
                    HomeIconButton { navController.navigate(Screen.Home.route) { popUpTo(Screen.Home.route) { inclusive = true } } }
                }
            )

            LazyColumn(
                modifier = Modifier.fillMaxSize().padding(horizontal = 16.dp),
                verticalArrangement = Arrangement.spacedBy(10.dp),
                contentPadding = PaddingValues(bottom = 100.dp)
            ) {
                // ‚îÄ‚îÄ Profile Hero Card ‚îÄ‚îÄ
                item {
                    Spacer(Modifier.height(4.dp))
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(500)) + slideInVertically(tween(500)) { 40 }
                    ) {
                        Box(
                            Modifier
                                .fillMaxWidth()
                                .clip(RoundedCornerShape(24.dp))
                                .liquidGlass(RoundedCornerShape(24.dp), GlassLevel.L3, accentGlow = RacingRed)
                        ) {
                            // Red glow overlay
                            Box(
                                Modifier
                                    .fillMaxWidth()
                                    .background(
                                        Brush.verticalGradient(
                                            listOf(RacingRed.copy(alpha = 0.1f), Color.Transparent)
                                        )
                                    )
                                    .padding(28.dp)
                            ) {
                                Column(
                                    horizontalAlignment = Alignment.CenterHorizontally,
                                    modifier = Modifier.fillMaxWidth()
                                ) {
                                    // Level badge with glow
                                    val pulseAnim = rememberInfiniteTransition(label = "lvl")
                                    val glowAlpha by pulseAnim.animateFloat(
                                        initialValue = 0.3f, targetValue = 0.6f,
                                        animationSpec = infiniteRepeatable(tween(2000), RepeatMode.Reverse), label = "g"
                                    )
                                    Box(
                                        Modifier
                                            .size(88.dp)
                                            .drawBehind {
                                                drawCircle(RacingRed.copy(alpha = glowAlpha * 0.3f), radius = size.minDimension / 1.5f)
                                            }
                                            .clip(CircleShape)
                                            .background(
                                                Brush.radialGradient(
                                                    listOf(RacingRed.copy(alpha = 0.25f), Color.Transparent)
                                                )
                                            )
                                            .border(2.dp, RacingRed.copy(alpha = 0.6f), CircleShape),
                                        contentAlignment = Alignment.Center
                                    ) {
                                        Text(
                                            "${profile.level}",
                                            style = MaterialTheme.typography.headlineLarge.copy(
                                                fontWeight = FontWeight.Black
                                            ),
                                            color = TextPrimary
                                        )
                                    }

                                    Spacer(Modifier.height(14.dp))
                                    Text(
                                        profile.levelName,
                                        style = MaterialTheme.typography.titleMedium,
                                        color = TextPrimary,
                                        fontWeight = FontWeight.Bold
                                    )
                                    Text(
                                        "${profile.totalXP} XP",
                                        style = MaterialTheme.typography.bodySmall,
                                        color = RacingRed,
                                        fontWeight = FontWeight.Bold
                                    )

                                    Spacer(Modifier.height(20.dp))

                                    // XP Progress Bar - premium gradient
                                    Column(Modifier.fillMaxWidth()) {
                                        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
                                            Text("Nivel ${profile.level}", fontSize = 11.sp, color = TextTertiary)
                                            Text("Nivel ${profile.level + 1}", fontSize = 11.sp, color = TextTertiary)
                                        }
                                        Spacer(Modifier.height(4.dp))
                                        Box(
                                            Modifier
                                                .fillMaxWidth()
                                                .height(10.dp)
                                                .clip(RoundedCornerShape(5.dp))
                                                .background(AsphaltGrey)
                                        ) {
                                            Box(
                                                Modifier
                                                    .fillMaxWidth(profile.xpProgress.coerceIn(0f, 1f))
                                                    .fillMaxHeight()
                                                    .clip(RoundedCornerShape(5.dp))
                                                    .background(
                                                        Brush.horizontalGradient(
                                                            listOf(RacingRed, Color(0xFFFF6B35))
                                                        )
                                                    )
                                            )
                                        }
                                        Spacer(Modifier.height(4.dp))
                                        Text(
                                            "${(profile.totalXP % profile.xpForNextLevel)} / ${profile.xpForNextLevel} XP",
                                            fontSize = 10.sp,
                                            color = TextTertiary,
                                            modifier = Modifier.fillMaxWidth(),
                                            textAlign = TextAlign.Center
                                        )
                                    }

                                    Spacer(Modifier.height(20.dp))

                                    // Stats row - glass sub-pills
                                    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                                        GlassStatPill("Logros", "$unlockedCount/$totalCount", ChampagneGold)
                                        GlassStatPill("Circuitos", "${profile.circuitsVisited}", NeonCyan)
                                        GlassStatPill("km", String.format("%.1f", profile.kmWalked), StatusGreen)
                                        GlassStatPill("Amigos", "${profile.friendsInGroup}", ElectricBlue)
                                    }
                                }
                            }
                        }
                    }
                }

                // ‚îÄ‚îÄ Category Filter Chips ‚îÄ‚îÄ
                item {
                    Spacer(Modifier.height(8.dp))
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(400, 200)) + slideInVertically(tween(400, 200)) { 20 }
                    ) {
                        Column {
                            Text("CATEGOR√çAS", style = MaterialTheme.typography.labelSmall, color = TextTertiary, letterSpacing = 2.sp, fontWeight = FontWeight.Bold)
                            Spacer(Modifier.height(8.dp))
                            LazyRow(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                                item {
                                    PremiumFilterChip(
                                        selected = selectedCategory == null,
                                        label = "Todos ($unlockedCount/$totalCount)",
                                        accentColor = RacingRed,
                                        onClick = { selectedCategory = null }
                                    )
                                }
                                items(AchievementCategory.entries.toList()) { cat ->
                                    val catCount = profile.achievements.count { it.category == cat && it.isUnlocked }
                                    val catTotal = profile.achievements.count { it.category == cat }
                                    PremiumFilterChip(
                                        selected = selectedCategory == cat,
                                        label = "${cat.emoji} $catCount/$catTotal",
                                        accentColor = ElectricBlue,
                                        onClick = { selectedCategory = if (selectedCategory == cat) null else cat }
                                    )
                                }
                            }
                        }
                    }
                    Spacer(Modifier.height(4.dp))
                }

                // ‚îÄ‚îÄ Achievement Cards ‚îÄ‚îÄ
                itemsIndexed(displayedAchievements) { index, achievement ->
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(300, 350 + index * 40)) + slideInVertically(tween(300, 350 + index * 40)) { 25 }
                    ) {
                        PremiumAchievementCard(achievement)
                    }
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚îÄ‚îÄ Premium Composables ‚îÄ‚îÄ
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumAchievementCard(achievement: Achievement) {
    val isUnlocked = achievement.isUnlocked
    val accentColor = if (isUnlocked) StatusGreen else TextTertiary

    Box(
        Modifier
            .fillMaxWidth()
            .alpha(if (isUnlocked) 1f else 0.6f)
            .clip(RoundedCornerShape(18.dp))
            .liquidGlass(
                RoundedCornerShape(18.dp),
                GlassLevel.L2,
                accentGlow = if (isUnlocked) StatusGreen else Color.Transparent
            )
    ) {
        // Unlocked shimmer overlay
        if (isUnlocked) {
            Box(
                Modifier
                    .fillMaxSize()
                    .background(
                        Brush.horizontalGradient(
                            listOf(Color.Transparent, StatusGreen.copy(alpha = 0.03f), Color.Transparent)
                        )
                    )
            )
        }

        Row(Modifier.padding(16.dp), verticalAlignment = Alignment.CenterVertically) {
            // Emoji badge with glass background
            Box(
                Modifier
                    .size(52.dp)
                    .clip(RoundedCornerShape(14.dp))
                    .background(
                        if (isUnlocked)
                            Brush.radialGradient(listOf(accentColor.copy(alpha = 0.12f), Color.Transparent))
                        else
                            Brush.radialGradient(listOf(MetalGrey.copy(alpha = 0.3f), Color.Transparent))
                    )
                    .then(
                        if (isUnlocked) Modifier.border(0.5.dp, accentColor.copy(alpha = 0.3f), RoundedCornerShape(14.dp))
                        else Modifier
                    ),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    if (isUnlocked) achievement.emoji else "üîí",
                    fontSize = 26.sp
                )
            }

            Spacer(Modifier.width(14.dp))

            Column(Modifier.weight(1f)) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(
                        achievement.title,
                        style = MaterialTheme.typography.titleSmall,
                        color = TextPrimary,
                        fontWeight = FontWeight.Bold
                    )
                    if (isUnlocked) {
                        Spacer(Modifier.width(6.dp))
                        Icon(Icons.Default.CheckCircle, "Desbloqueado", tint = StatusGreen, modifier = Modifier.size(14.dp))
                    }
                }
                Spacer(Modifier.height(2.dp))
                Text(
                    achievement.description,
                    style = MaterialTheme.typography.bodySmall,
                    color = TextSecondary,
                    lineHeight = 16.sp
                )

                if (!isUnlocked && achievement.progress > 0f) {
                    Spacer(Modifier.height(8.dp))
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Box(
                            Modifier
                                .weight(1f)
                                .height(5.dp)
                                .clip(RoundedCornerShape(3.dp))
                                .background(AsphaltGrey)
                        ) {
                            Box(
                                Modifier
                                    .fillMaxWidth(achievement.progress.coerceIn(0f, 1f))
                                    .fillMaxHeight()
                                    .clip(RoundedCornerShape(3.dp))
                                    .background(
                                        Brush.horizontalGradient(listOf(ElectricBlue, NeonCyan))
                                    )
                            )
                        }
                        Spacer(Modifier.width(8.dp))
                        Text(
                            "${(achievement.progress * 100).toInt()}%",
                            fontSize = 10.sp,
                            color = ElectricBlue,
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }

            Spacer(Modifier.width(8.dp))

            // XP badge
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                Text(
                    "+${achievement.xpReward}",
                    fontSize = 13.sp,
                    color = ChampagneGold,
                    fontWeight = FontWeight.Black
                )
                Text("XP", fontSize = 9.sp, color = TextTertiary)
            }
        }
    }
}

@Composable
private fun GlassStatPill(label: String, value: String, accentColor: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(
            value,
            style = MaterialTheme.typography.titleMedium,
            color = accentColor,
            fontWeight = FontWeight.Bold
        )
        Text(label, style = MaterialTheme.typography.labelSmall, color = TextTertiary, fontSize = 10.sp)
    }
}

@Composable
private fun PremiumFilterChip(
    selected: Boolean,
    label: String,
    accentColor: Color,
    onClick: () -> Unit
) {
    val bgColor = if (selected) accentColor.copy(alpha = 0.2f) else MetalGrey.copy(alpha = 0.3f)
    val textColor = if (selected) accentColor else TextSecondary

    Box(
        Modifier
            .clip(RoundedCornerShape(12.dp))
            .background(bgColor)
            .then(
                if (selected) Modifier.border(0.5.dp, accentColor.copy(alpha = 0.4f), RoundedCornerShape(12.dp))
                else Modifier
            )
            .noRippleClickable(onClick)
            .padding(horizontal = 14.dp, vertical = 8.dp)
    ) {
        Text(
            label,
            style = MaterialTheme.typography.labelMedium,
            color = textColor,
            fontWeight = if (selected) FontWeight.Bold else FontWeight.Normal
        )
    }
}

/**
 * No-ripple clickable modifier for premium feel.
 */
@Composable
private fun Modifier.noRippleClickable(onClick: () -> Unit): Modifier =
    this
        .graphicsLayer { clip = false }
        .clickable(
            interactionSource = remember { MutableInteractionSource() },
            indication = null,
            onClick = onClick
        )

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/achievements/CollectiblesScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.achievements

import android.util.Log
import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.itemsIndexed
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.draw.drawWithContent
import androidx.compose.ui.draw.scale
import androidx.compose.foundation.Image
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.compose.ui.window.DialogProperties
import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.theme.*
import kotlinx.coroutines.delay

/**
 * üé¥ Pantalla de Cromos / Coleccionables Digitales ‚Äî Premium Racing Edition.
 */
@Composable
fun CollectiblesScreen(
    onNavigateBack: () -> Unit = {}
) {
    val backdrop = LocalBackdrop.current
    val allCards = remember { generateAllCollectibles() }
    val unlockedIds = remember { mutableStateOf<Set<String>>(emptySet()) }
    var isLoadingProgress by remember { mutableStateOf(true) }

    LaunchedEffect(Unit) {
        while(true) {
            try {
                val userId = com.google.firebase.auth.FirebaseAuth.getInstance().currentUser?.uid ?: "current_user"
                val req = com.georacing.georacing.data.firestorelike.FirestoreLikeApi.GetRequest(
                    table = "user_collectibles",
                    where = mapOf("user_id" to userId)
                )
                val response = com.georacing.georacing.data.firestorelike.FirestoreLikeClient.api.get(req)
                val ids = response.mapNotNull { map ->
                    val id = map["collectible_id"]?.toString()
                    val unlocked = map["unlocked"] as? Boolean ?: false
                    if (unlocked) id else null
                }.toSet()
                unlockedIds.value = ids
            } catch (e: Exception) {
                Log.w("CollectiblesScreen", "Error cargando progreso: ${e.message}")
                // No limpiamos los IDs en caso de error para no parpadear la UI si hay un corte de red
            }
            isLoadingProgress = false
            delay(2000) // Poll every 2 seconds for updates
        }
    }

    var selectedCard by remember { mutableStateOf<Collectible?>(null) }
    var filterRarity by remember { mutableStateOf<Rarity?>(null) }

    val displayedCards = remember(filterRarity) {
        if (filterRarity == null) allCards
        else allCards.filter { it.rarity == filterRarity }
    }

    val unlockedCount = allCards.count { it.id in unlockedIds.value }
    val totalCount = allCards.size
    val progressPercent = if (totalCount > 0) unlockedCount.toFloat() / totalCount else 0f

    var screenVisible by remember { mutableStateOf(false) }
    LaunchedEffect(Unit) { screenVisible = true }

    Box(modifier = Modifier.fillMaxSize()) {
        CarbonBackground()

        Column(modifier = Modifier.fillMaxSize()) {
            // ‚îÄ‚îÄ Glass Top Bar ‚îÄ‚îÄ
            LiquidTopBar(
                backdrop = backdrop,
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Volver", tint = TextPrimary)
                    }
                },
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Box(
                            modifier = Modifier
                                .size(8.dp)
                                .clip(CircleShape)
                                .background(ChampagneGold)
                        )
                        Spacer(Modifier.width(10.dp))
                        Column {
                            Text(
                                "COLECCI√ìN",
                                color = TextPrimary,
                                fontSize = 16.sp,
                                fontWeight = FontWeight.ExtraBold,
                                letterSpacing = 2.sp
                            )
                            Text(
                                "$unlockedCount / $totalCount",
                                color = ChampagneGold,
                                fontSize = 11.sp,
                                fontWeight = FontWeight.Bold,
                                letterSpacing = 1.sp
                            )
                        }
                    }
                }
            )

            Spacer(Modifier.height(8.dp))

            // ‚îÄ‚îÄ Premium Progress Bar ‚îÄ‚îÄ
            AnimatedVisibility(
                visible = screenVisible,
                enter = fadeIn(tween(600)) + expandVertically(tween(600))
            ) {
                Column(modifier = Modifier.padding(horizontal = 20.dp)) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(
                            "PROGRESO",
                            color = TextTertiary,
                            fontSize = 10.sp,
                            fontWeight = FontWeight.Bold,
                            letterSpacing = 2.sp
                        )
                        Text(
                            "${(progressPercent * 100).toInt()}%",
                            color = ChampagneGold,
                            fontSize = 10.sp,
                            fontWeight = FontWeight.ExtraBold
                        )
                    }
                    Spacer(Modifier.height(6.dp))
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(4.dp)
                            .clip(RoundedCornerShape(2.dp))
                            .background(MetalGrey)
                    ) {
                        val animatedProgress by animateFloatAsState(
                            targetValue = progressPercent,
                            animationSpec = tween(1200, easing = EaseOutCubic),
                            label = "progress"
                        )
                        Box(
                            modifier = Modifier
                                .fillMaxWidth(animatedProgress)
                                .fillMaxHeight()
                                .clip(RoundedCornerShape(2.dp))
                                .background(
                                    Brush.horizontalGradient(
                                        listOf(ChampagneGold, NeonOrange)
                                    )
                                )
                        )
                    }
                }
            }

            Spacer(Modifier.height(12.dp))

            // ‚îÄ‚îÄ Premium Filter Chips ‚îÄ‚îÄ
            AnimatedVisibility(
                visible = screenVisible,
                enter = fadeIn(tween(600, 200)) + slideInVertically(tween(600, 200)) { it / 3 }
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    RarityFilterChip(
                        label = "TODOS",
                        color = TextSecondary,
                        selected = filterRarity == null,
                        onClick = { filterRarity = null }
                    )
                    Rarity.entries.forEach { rarity ->
                        RarityFilterChip(
                            label = rarity.label.uppercase(),
                            color = rarity.color,
                            selected = filterRarity == rarity,
                            onClick = { filterRarity = if (filterRarity == rarity) null else rarity }
                        )
                    }
                }
            }

            Spacer(Modifier.height(12.dp))

            // ‚îÄ‚îÄ Collectibles Grid ‚îÄ‚îÄ
            LazyVerticalGrid(
                columns = GridCells.Fixed(3),
                contentPadding = PaddingValues(horizontal = 14.dp, vertical = 8.dp),
                horizontalArrangement = Arrangement.spacedBy(10.dp),
                verticalArrangement = Arrangement.spacedBy(10.dp),
                modifier = Modifier.fillMaxSize()
            ) {
                itemsIndexed(displayedCards, key = { _, card -> card.id }) { index, card ->
                    val isUnlocked = card.id in unlockedIds.value

                    var itemVisible by remember { mutableStateOf(false) }
                    LaunchedEffect(Unit) {
                        delay(index * 40L)
                        itemVisible = true
                    }

                    AnimatedVisibility(
                        visible = itemVisible,
                        enter = fadeIn(spring(dampingRatio = 0.7f)) +
                                scaleIn(spring(dampingRatio = 0.6f), initialScale = 0.8f)
                    ) {
                        PremiumCollectibleCard(
                            card = card,
                            isUnlocked = isUnlocked,
                            onClick = { selectedCard = card }
                        )
                    }
                }
                item(span = { androidx.compose.foundation.lazy.grid.GridItemSpan(3) }) {
                    Spacer(Modifier.height(100.dp))
                }
            }
        }
    }

    selectedCard?.let { card ->
        PremiumCollectibleDialog(
            card = card,
            isUnlocked = card.id in unlockedIds.value,
            onDismiss = { selectedCard = null }
        )
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üé¥ Premium Collectible Card
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumCollectibleCard(
    card: Collectible,
    isUnlocked: Boolean,
    onClick: () -> Unit
) {
    val rarityColor = card.rarity.color

    val infiniteTransition = rememberInfiniteTransition(label = "shimmer_${card.id}")
    val shimmerPhase by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(3000, easing = LinearEasing),
            repeatMode = RepeatMode.Restart
        ),
        label = "shimmer"
    )

    val glowPulse by infiniteTransition.animateFloat(
        initialValue = 0.5f,
        targetValue = 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(2000, easing = EaseInOutCubic),
            repeatMode = RepeatMode.Reverse
        ),
        label = "glow"
    )

    val isLegendary = card.rarity == Rarity.LEGENDARY && isUnlocked
    val isEpic = card.rarity == Rarity.EPIC && isUnlocked

    Box(
        modifier = Modifier
            .aspectRatio(0.72f)
            .clip(RoundedCornerShape(16.dp))
            .then(
                if (isLegendary) {
                    Modifier.border(
                        width = 2.dp,
                        brush = Brush.sweepGradient(
                            0f to Color(0xFFFFD700).copy(alpha = 0.3f + shimmerPhase * 0.5f),
                            0.25f to Color(0xFFFF6B35),
                            0.5f to Color(0xFFFFD700).copy(alpha = 0.3f + (1f - shimmerPhase) * 0.5f),
                            0.75f to Color(0xFFFFA726),
                            1f to Color(0xFFFFD700).copy(alpha = 0.3f + shimmerPhase * 0.5f)
                        ),
                        shape = RoundedCornerShape(16.dp)
                    )
                } else if (isEpic) {
                    Modifier.border(
                        1.5.dp,
                        Brush.verticalGradient(
                            listOf(NeonPurple.copy(alpha = 0.6f), NeonPurple.copy(alpha = 0.15f))
                        ),
                        RoundedCornerShape(16.dp)
                    )
                } else if (isUnlocked) {
                    Modifier.border(
                        1.dp,
                        Brush.verticalGradient(
                            listOf(rarityColor.copy(alpha = 0.4f), rarityColor.copy(alpha = 0.08f))
                        ),
                        RoundedCornerShape(16.dp)
                    )
                } else {
                    Modifier.border(0.5.dp, Color.White.copy(alpha = 0.06f), RoundedCornerShape(16.dp))
                }
            )
            .background(
                if (isUnlocked) {
                    Brush.verticalGradient(
                        listOf(
                            rarityColor.copy(alpha = 0.08f),
                            AsphaltGrey.copy(alpha = 0.85f),
                            CarbonBlack.copy(alpha = 0.95f)
                        )
                    )
                } else {
                    Brush.verticalGradient(
                        listOf(
                            Color(0xFF14141C).copy(alpha = 0.6f),
                            Color(0xFF0E0E14).copy(alpha = 0.8f)
                        )
                    )
                },
                shape = RoundedCornerShape(16.dp)
            )
            .drawWithContent {
                drawContent()
                if (isUnlocked) {
                    drawRect(
                        Brush.verticalGradient(
                            listOf(Color.White.copy(alpha = 0.04f), Color.Transparent),
                            startY = 0f,
                            endY = size.height * 0.3f
                        )
                    )
                }
                if (isLegendary) {
                    drawRect(
                        Brush.radialGradient(
                            listOf(
                                Color(0xFFFFD700).copy(alpha = 0.06f * glowPulse),
                                Color.Transparent
                            ),
                            center = Offset(size.width / 2, size.height * 0.3f),
                            radius = size.width * 0.8f
                        )
                    )
                }
            }
            .clickable(
                interactionSource = remember { MutableInteractionSource() },
                indication = null,
                onClick = onClick
            ),
        contentAlignment = Alignment.Center
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(8.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            if (isUnlocked && card.imageRes != null) {
                Image(
                    painter = painterResource(id = card.imageRes),
                    contentDescription = card.name,
                    contentScale = ContentScale.Crop,
                    modifier = Modifier
                        .fillMaxWidth()
                        .weight(1f) // Takes up most of the card space
                        .clip(RoundedCornerShape(8.dp))
                )
                Spacer(Modifier.height(6.dp))
            } else {
                val emojiScale by animateFloatAsState(
                    targetValue = if (isUnlocked) 1f else 0.85f,
                    label = "emoji_scale"
                )
                Text(
                    text = if (isUnlocked) card.emoji else "‚ùì",
                    fontSize = 38.sp,
                    modifier = Modifier
                        .scale(emojiScale)
                        .alpha(if (isUnlocked) 1f else 0.35f)
                )
                Spacer(Modifier.height(6.dp))
            }

            Text(
                text = if (isUnlocked) card.name else "???",
                fontSize = 11.sp,
                fontWeight = FontWeight.Bold,
                textAlign = TextAlign.Center,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis,
                letterSpacing = 0.5.sp,
                color = if (isUnlocked) TextPrimary else TextTertiary.copy(alpha = 0.5f)
            )

            Spacer(Modifier.height(4.dp))

            Box(
                modifier = Modifier
                    .clip(RoundedCornerShape(50))
                    .background(
                        if (isUnlocked) rarityColor.copy(alpha = 0.18f)
                        else Color.White.copy(alpha = 0.04f)
                    )
                    .border(
                        0.5.dp,
                        if (isUnlocked) rarityColor.copy(alpha = 0.3f)
                        else Color.White.copy(alpha = 0.06f),
                        RoundedCornerShape(50)
                    )
                    .padding(horizontal = 8.dp, vertical = 2.dp)
            ) {
                Text(
                    text = card.rarity.label.uppercase(),
                    fontSize = 7.sp,
                    fontWeight = FontWeight.ExtraBold,
                    letterSpacing = 1.sp,
                    color = if (isUnlocked) rarityColor else TextTertiary.copy(alpha = 0.4f)
                )
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Filter Chip
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun RarityFilterChip(
    label: String,
    color: Color,
    selected: Boolean,
    onClick: () -> Unit
) {
    val bgAlpha by animateFloatAsState(if (selected) 0.2f else 0.05f, label = "chip_bg")
    val borderAlpha by animateFloatAsState(if (selected) 0.5f else 0.1f, label = "chip_border")
    val textAlpha by animateFloatAsState(if (selected) 1f else 0.5f, label = "chip_text")

    Box(
        modifier = Modifier
            .clip(RoundedCornerShape(50))
            .background(color.copy(alpha = bgAlpha))
            .border(0.5.dp, color.copy(alpha = borderAlpha), RoundedCornerShape(50))
            .clickable(onClick = onClick)
            .padding(horizontal = 12.dp, vertical = 6.dp)
    ) {
        Text(
            text = label,
            fontSize = 10.sp,
            fontWeight = FontWeight.ExtraBold,
            letterSpacing = 1.sp,
            color = color.copy(alpha = textAlpha)
        )
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Premium Detail Dialog
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumCollectibleDialog(
    card: Collectible,
    isUnlocked: Boolean,
    onDismiss: () -> Unit
) {
    val rarityColor = card.rarity.color

    var dialogVisible by remember { mutableStateOf(false) }
    LaunchedEffect(Unit) { dialogVisible = true }

    val dialogScale by animateFloatAsState(
        targetValue = if (dialogVisible) 1f else 0.85f,
        animationSpec = spring(dampingRatio = 0.7f, stiffness = 400f),
        label = "dialog_scale"
    )
    val dialogAlpha by animateFloatAsState(
        targetValue = if (dialogVisible) 1f else 0f,
        animationSpec = tween(300),
        label = "dialog_alpha"
    )

    Dialog(
        onDismissRequest = onDismiss,
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black.copy(alpha = 0.7f))
                .clickable(
                    interactionSource = remember { MutableInteractionSource() },
                    indication = null,
                    onClick = onDismiss
                ),
            contentAlignment = Alignment.Center
        ) {
            Box(
                modifier = Modifier
                    .fillMaxWidth(0.85f)
                    .graphicsLayer {
                        scaleX = dialogScale
                        scaleY = dialogScale
                        alpha = dialogAlpha
                    }
                    .clip(RoundedCornerShape(24.dp))
                    .then(
                        if (card.rarity == Rarity.LEGENDARY && isUnlocked) {
                            Modifier.border(
                                2.dp,
                                Brush.sweepGradient(
                                    listOf(
                                        Color(0xFFFFD700), Color(0xFFFF6B35),
                                        Color(0xFFFFD700), Color(0xFFFFA726), Color(0xFFFFD700)
                                    )
                                ),
                                RoundedCornerShape(24.dp)
                            )
                        } else {
                            Modifier.border(
                                1.dp,
                                Brush.verticalGradient(
                                    listOf(
                                        rarityColor.copy(alpha = if (isUnlocked) 0.4f else 0.1f),
                                        rarityColor.copy(alpha = 0.05f)
                                    )
                                ),
                                RoundedCornerShape(24.dp)
                            )
                        }
                    )
                    .background(
                        Brush.verticalGradient(
                            listOf(Color(0xFF1A1A24), Color(0xFF12121A), Color(0xFF0A0A12))
                        ),
                        RoundedCornerShape(24.dp)
                    )
                    .drawWithContent {
                        drawContent()
                        drawRect(
                            Brush.verticalGradient(
                                listOf(Color.White.copy(alpha = 0.04f), Color.Transparent),
                                startY = 0f,
                                endY = size.height * 0.25f
                            )
                        )
                        if (isUnlocked) {
                            drawRect(
                                Brush.radialGradient(
                                    listOf(rarityColor.copy(alpha = 0.08f), Color.Transparent),
                                    center = Offset(size.width / 2, size.height * 0.2f),
                                    radius = size.width * 0.6f
                                )
                            )
                        }
                    }
                    .clickable(
                        interactionSource = remember { MutableInteractionSource() },
                        indication = null,
                        onClick = {}
                    )
                    .padding(28.dp),
                contentAlignment = Alignment.Center
            ) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    // Image with glow or Big emoji
                    Box(contentAlignment = Alignment.Center) {
                        if (isUnlocked) {
                            Box(
                                modifier = Modifier
                                    .size(if (card.imageRes != null) 160.dp else 80.dp)
                                    .drawBehind {
                                        drawCircle(
                                            brush = Brush.radialGradient(
                                                listOf(rarityColor.copy(alpha = 0.2f), Color.Transparent)
                                            ),
                                            radius = size.width
                                        )
                                    }
                            )
                        }
                        
                        if (isUnlocked && card.imageRes != null) {
                            Image(
                                painter = painterResource(id = card.imageRes),
                                contentDescription = card.name,
                                contentScale = ContentScale.Crop,
                                modifier = Modifier
                                    .size(140.dp)
                                    .clip(RoundedCornerShape(16.dp))
                                    .border(1.dp, rarityColor.copy(alpha = 0.5f), RoundedCornerShape(16.dp))
                            )
                        } else {
                            Text(
                                text = if (isUnlocked) card.emoji else "üîí",
                                fontSize = 64.sp,
                                modifier = Modifier.alpha(if (isUnlocked) 1f else 0.4f)
                            )
                        }
                    }

                    Spacer(Modifier.height(16.dp))

                    Text(
                        text = if (isUnlocked) card.name else "Cromo Bloqueado",
                        fontSize = 20.sp,
                        fontWeight = FontWeight.ExtraBold,
                        color = TextPrimary,
                        textAlign = TextAlign.Center,
                        letterSpacing = 1.sp
                    )

                    Spacer(Modifier.height(10.dp))

                    // Rarity Badge
                    Box(
                        modifier = Modifier
                            .clip(RoundedCornerShape(50))
                            .background(rarityColor.copy(alpha = 0.15f))
                            .border(0.5.dp, rarityColor.copy(alpha = 0.3f), RoundedCornerShape(50))
                            .padding(horizontal = 14.dp, vertical = 4.dp)
                    ) {
                        Text(
                            card.rarity.label.uppercase(),
                            fontSize = 10.sp,
                            fontWeight = FontWeight.ExtraBold,
                            letterSpacing = 2.sp,
                            color = rarityColor
                        )
                    }

                    Spacer(Modifier.height(18.dp))

                    if (isUnlocked) {
                        Text(
                            card.description,
                            textAlign = TextAlign.Center,
                            fontSize = 14.sp,
                            color = TextSecondary,
                            lineHeight = 20.sp
                        )
                    } else {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.Center
                        ) {
                            Icon(Icons.Filled.Lock, null, tint = TextTertiary, modifier = Modifier.size(14.dp))
                            Spacer(Modifier.width(6.dp))
                            Text(card.unlockHint, textAlign = TextAlign.Center, fontSize = 13.sp, color = TextTertiary)
                        }
                    }

                    Spacer(Modifier.height(12.dp))

                    Text(
                        card.category.uppercase(),
                        fontSize = 9.sp,
                        fontWeight = FontWeight.Bold,
                        letterSpacing = 2.sp,
                        color = TextTertiary
                    )

                    Spacer(Modifier.height(20.dp))

                    Box(
                        modifier = Modifier
                            .clip(RoundedCornerShape(12.dp))
                            .background(MetalGrey.copy(alpha = 0.5f))
                            .border(0.5.dp, Color.White.copy(alpha = 0.1f), RoundedCornerShape(12.dp))
                            .clickable(onClick = onDismiss)
                            .padding(horizontal = 32.dp, vertical = 10.dp)
                    ) {
                        Text(
                            "CERRAR",
                            fontSize = 12.sp,
                            fontWeight = FontWeight.ExtraBold,
                            letterSpacing = 2.sp,
                            color = TextSecondary
                        )
                    }
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Modelos
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

private enum class Rarity(val label: String, val color: Color) {
    COMMON("Com√∫n", Color(0xFF9E9E9E)),
    RARE("Raro", ElectricBlue),
    EPIC("√âpico", NeonPurple),
    LEGENDARY("Legendario", ChampagneGold)
}

private data class Collectible(
    val id: String,
    val name: String,
    val emoji: String,
    val description: String,
    val rarity: Rarity,
    val category: String,
    val unlockHint: String,
    val imageRes: Int? = null
)

private fun generateAllCollectibles(): List<Collectible> = listOf(
    Collectible("c01", "Fernando Alonso", "üèéÔ∏è", "El Plan, Defensa Tit√°nica en Pista", Rarity.LEGENDARY, "F1", "Escanea Aston Martin", com.georacing.georacing.R.drawable.card_alonso),
    Collectible("c02", "Lewis Hamilton", "üèéÔ∏è", "Pilotaje maestro en Silverstone", Rarity.LEGENDARY, "F1", "Encuentra el casco", com.georacing.georacing.R.drawable.card_hamilton),
    Collectible("c03", "Max Verstappen", "üèéÔ∏è", "Dominio absoluto bajo la lluvia", Rarity.LEGENDARY, "F1", "Escanea Red Bull", com.georacing.georacing.R.drawable.card_verstappen),
    Collectible("c04", "Marc M√°rquez", "üèçÔ∏è", "Salvada imposible a 68¬∫", Rarity.LEGENDARY, "MotoGP", "Visita curva 9", com.georacing.georacing.R.drawable.card_marquez),
    Collectible("c05", "Pecco Bagnaia", "üèçÔ∏è", "Ritmo de campe√≥n mundial", Rarity.LEGENDARY, "MotoGP", "Forza Ducati", com.georacing.georacing.R.drawable.card_bagnaia),
    Collectible("c06", "Marchador", "üö∂", "Andaste 5.000 pasos en un evento", Rarity.COMMON, "Fitness", "Camina 5.000 pasos"),
    Collectible("c07", "Corredor", "üèÉ", "Andaste 10.000 pasos en un evento", Rarity.RARE, "Fitness", "Camina 10.000 pasos"),
    Collectible("c25", "Maratonista", "ü•á", "Andaste 20.000 pasos en un evento", Rarity.EPIC, "Fitness", "Camina 20.000 pasos"),
    Collectible("c08", "Primera Foto", "üì∏", "Capturaste tu primer momento", Rarity.COMMON, "Social", "Toma una foto"),
    Collectible("c09", "Fot√≥grafo", "üì∑", "10 momentos capturados", Rarity.RARE, "Social", "Captura 10 momentos"),
    Collectible("c10", "Paparazzi", "üé¨", "50 momentos capturados", Rarity.EPIC, "Social", "Captura 50 momentos"),
    Collectible("c11", "Primer Pedido", "üçî", "Hiciste tu primer pedido Click & Collect", Rarity.COMMON, "Foodie", "Haz un pedido"),
    Collectible("c12", "Gourmet", "üçΩÔ∏è", "Probaste 3 stands distintos", Rarity.RARE, "Foodie", "Pide en 3 stands distintos"),
    Collectible("c13", "Master Chef", "üë®‚Äçüç≥", "Probaste todos los stands", Rarity.LEGENDARY, "Foodie", "Pide en todos los stands"),
    Collectible("c14", "VIP Access", "üé´", "Entraste al Paddock", Rarity.RARE, "VIP", "Accede al Paddock"),
    Collectible("c15", "Pit Lane", "üîß", "Visitaste la zona de Pit Lane", Rarity.EPIC, "VIP", "Visita Pit Lane"),
    Collectible("c16", "Eco Warrior", "üå±", "Ahorraste 1 kg CO‚ÇÇ andando", Rarity.COMMON, "Eco", "Ahorra 1 kg CO‚ÇÇ"),
    Collectible("c17", "Planeta Verde", "üåé", "Ahorraste 5 kg CO‚ÇÇ", Rarity.RARE, "Eco", "Ahorra 5 kg CO‚ÇÇ"),
    Collectible("c18", "Nocturno", "üåô", "Estuviste en el circuito despu√©s de las 21h", Rarity.RARE, "Especial", "Visita al anochecer"),
    Collectible("c19", "Madrugador", "üåÖ", "Llegaste antes de las 8h", Rarity.RARE, "Especial", "Llega antes de las 8h"),
    Collectible("c20", "Bajo la Lluvia", "üåßÔ∏è", "Asististe con lluvia", Rarity.EPIC, "Especial", "Asiste cuando llueva"),
    Collectible("c21", "Leyenda GeoRacing", "üèÜ", "Completaste toda la colecci√≥n", Rarity.LEGENDARY, "Legendario", "Desbloquea todos los cromos"),
    Collectible("c22", "Fiel al Circuito", "‚ù§Ô∏è", "Asististe a 5 eventos", Rarity.LEGENDARY, "Legendario", "Asiste a 5 eventos"),
    Collectible("c23", "El Primero", "1Ô∏è‚É£", "Fuiste el primero en escanear un QR especial", Rarity.LEGENDARY, "Legendario", "Escanea QR especial el primero"),
    Collectible("c24", "Grupo Legendario", "üë•", "Tu grupo complet√≥ un reto conjunto", Rarity.LEGENDARY, "Legendario", "Completa un reto grupal")
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/alerts/AlertsScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.alerts

import android.util.Log
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.*
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.animation.fadeIn
import androidx.compose.animation.slideInVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Notifications
import androidx.compose.material3.*
import androidx.compose.material3.pulltorefresh.PullToRefreshBox
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.R
import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import com.georacing.georacing.domain.model.NewsCategory
import com.georacing.georacing.domain.model.NewsPriority
import com.georacing.georacing.domain.model.RaceNews
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.components.HomeIconButton
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.*
import kotlinx.coroutines.launch

/**
 * AlertsScreen ‚Äî Premium News & Alerts HUD
 * Noticias, incidencias y emergencias desde el backend Metropolis.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AlertsScreen(navController: NavController) {
    val backdrop = LocalBackdrop.current
    var selectedCategory by remember { mutableStateOf<NewsCategory?>(null) }
    var showContent by remember { mutableStateOf(false) }
    LaunchedEffect(Unit) { showContent = true }

    // Noticias + Incidencias + Emergencias desde el backend
    var allNews by remember { mutableStateOf<List<RaceNews>>(emptyList()) }
    var isLoading by remember { mutableStateOf(true) }
    var loadError by remember { mutableStateOf<String?>(null) }

    // Carga news + incidents (Panel Metropolis) + emergencies
    suspend fun loadNews() {
        isLoading = true
        loadError = null
        try {
            val combined = mutableListOf<RaceNews>()

            // 1) Tabla "news" ‚Äî noticias editoriales
            try {
                val newsResponse = FirestoreLikeClient.api.read("news")
                combined += newsResponse.mapNotNull { map ->
                    try {
                        RaceNews(
                            id = map["id"]?.toString() ?: return@mapNotNull null,
                            title = map["title"]?.toString() ?: "",
                            content = map["content"]?.toString() ?: "",
                            timestamp = (map["timestamp"] as? Number)?.toLong() ?: System.currentTimeMillis(),
                            category = try { NewsCategory.valueOf(map["category"]?.toString() ?: "RACE_UPDATE") } catch (_: Exception) { NewsCategory.RACE_UPDATE },
                            priority = try { NewsPriority.valueOf(map["priority"]?.toString() ?: "LOW") } catch (_: Exception) { NewsPriority.LOW }
                        )
                    } catch (_: Exception) { null }
                }
            } catch (e: Exception) {
                Log.w("AlertsScreen", "No se pudieron cargar news: ${e.message}")
            }

            // 2) Tabla "incidents" ‚Äî incidencias gestionadas desde Panel Metropolis
            try {
                val incidentsResponse = FirestoreLikeClient.api.read("incidents")
                combined += incidentsResponse.mapNotNull { map ->
                    try {
                        val status = map["status"]?.toString()?.uppercase() ?: "ACTIVE"
                        if (status == "RESOLVED") return@mapNotNull null

                        val level = map["level"]?.toString()?.uppercase() ?: "INFO"
                        val priority = when (level) {
                            "CRITICAL" -> NewsPriority.HIGH
                            "WARNING" -> NewsPriority.MEDIUM
                            else -> NewsPriority.LOW
                        }

                        RaceNews(
                            id = "incident_${map["id"]}",
                            title = "‚ö†Ô∏è ${map["category"]?.toString() ?: "Incidencia"}",
                            content = map["description"]?.toString() ?: "",
                            timestamp = parseTimestamp(map["created_at"]),
                            category = NewsCategory.SAFETY,
                            priority = priority
                        )
                    } catch (_: Exception) { null }
                }
            } catch (e: Exception) {
                Log.w("AlertsScreen", "No se pudieron cargar incidents: ${e.message}")
            }

            // 3) Tabla "emergencies" ‚Äî emergencias activas del Panel
            try {
                val emergResponse = FirestoreLikeClient.api.read("emergencies")
                combined += emergResponse.mapNotNull { map ->
                    try {
                        val status = map["status"]?.toString()?.uppercase() ?: "ACTIVE"
                        if (status == "RESOLVED") return@mapNotNull null

                        val level = map["level"]?.toString()?.uppercase() ?: "WARNING"
                        val priority = when (level) {
                            "CRITICAL" -> NewsPriority.HIGH
                            "WARNING" -> NewsPriority.HIGH
                            "ADVISORY" -> NewsPriority.MEDIUM
                            else -> NewsPriority.LOW
                        }

                        RaceNews(
                            id = "emergency_${map["id"]}",
                            title = "üö® ${map["title"]?.toString() ?: "Emergencia"}",
                            content = map["description"]?.toString() ?: "",
                            timestamp = parseTimestamp(map["startedAt"] ?: map["created_at"]),
                            category = NewsCategory.SAFETY,
                            priority = priority
                        )
                    } catch (_: Exception) { null }
                }
            } catch (e: Exception) {
                Log.w("AlertsScreen", "No se pudieron cargar emergencies: ${e.message}")
            }

            allNews = combined.sortedByDescending { it.timestamp }
        } catch (e: Exception) {
            Log.w("AlertsScreen", "Error general cargando alertas: ${e.message}")
            loadError = e.message
            allNews = emptyList()
        }
        isLoading = false
    }

    LaunchedEffect(Unit) { loadNews() }

    val filteredNews = if (selectedCategory == null) allNews else allNews.filter { it.category == selectedCategory }

    Box(Modifier.fillMaxSize()) {
        CarbonBackground()

        Column(Modifier.fillMaxSize()) {
            // ‚îÄ‚îÄ Premium LiquidTopBar ‚îÄ‚îÄ
            LiquidTopBar(
                backdrop = backdrop,
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, stringResource(R.string.cd_back), tint = TextPrimary)
                    }
                },
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Box(Modifier.size(8.dp).clip(CircleShape).background(RacingRed))
                        Spacer(Modifier.width(10.dp))
                        Column {
                            Text(stringResource(R.string.newsletter_title).uppercase(), style = MaterialTheme.typography.titleMedium, color = TextPrimary, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                            Text(stringResource(R.string.newsletter_subtitle), style = MaterialTheme.typography.labelSmall, color = TextTertiary)
                        }
                    }
                },
                actions = {
                    HomeIconButton {
                        navController.navigate(Screen.Home.route) {
                            popUpTo(Screen.Home.route) { inclusive = true }
                        }
                    }
                }
            )

            // ‚îÄ‚îÄ Filter Chips Row ‚îÄ‚îÄ
            AnimatedVisibility(
                visible = showContent,
                enter = fadeIn(tween(400, 100)) + slideInVertically(tween(400, 100)) { -15 }
            ) {
                LazyRow(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp, vertical = 12.dp),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    item {
                        PremiumFilterChip(
                            selected = selectedCategory == null,
                            label = stringResource(R.string.news_category_all),
                            accentColor = RacingRed,
                            onClick = { selectedCategory = null }
                        )
                    }
                    items(NewsCategory.values()) { category ->
                        PremiumFilterChip(
                            selected = selectedCategory == category,
                            label = category.displayName,
                            accentColor = RacingRed,
                            onClick = { selectedCategory = category }
                        )
                    }
                }
            }

            // Separator line
            Box(
                Modifier
                    .fillMaxWidth()
                    .height(1.dp)
                    .background(
                        Brush.horizontalGradient(
                            listOf(Color.Transparent, MetalGrey.copy(alpha = 0.3f), Color.Transparent)
                        )
                    )
            )

            // ‚îÄ‚îÄ News Content ‚îÄ‚îÄ
            if (filteredNews.isEmpty() && !isLoading) {
                // Empty state
                Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    androidx.compose.animation.AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(500, 200))
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            modifier = Modifier.padding(32.dp)
                        ) {
                            Box(
                                Modifier
                                    .size(80.dp)
                                    .clip(RoundedCornerShape(24.dp))
                                    .background(RacingRed.copy(alpha = 0.12f))
                                    .drawBehind {
                                        drawCircle(RacingRed.copy(alpha = 0.06f), radius = size.minDimension * 0.9f)
                                    },
                                contentAlignment = Alignment.Center
                            ) {
                                Icon(Icons.Default.Notifications, null, modifier = Modifier.size(40.dp), tint = RacingRed)
                            }
                            Spacer(Modifier.height(20.dp))
                            Text(
                                stringResource(R.string.news_empty_title),
                                style = MaterialTheme.typography.titleLarge,
                                fontWeight = FontWeight.Black,
                                color = TextPrimary,
                                letterSpacing = 0.5.sp
                            )
                            Spacer(Modifier.height(8.dp))
                            Text(
                                stringResource(R.string.news_empty_message),
                                style = MaterialTheme.typography.bodyMedium,
                                color = TextTertiary,
                                textAlign = TextAlign.Center
                            )
                        }
                    }
                }
            } else {
                var isRefreshing by remember { mutableStateOf(false) }
                val scope = rememberCoroutineScope()
                PullToRefreshBox(
                    isRefreshing = isRefreshing,
                    onRefresh = {
                        isRefreshing = true
                        scope.launch { loadNews(); isRefreshing = false }
                    },
                    modifier = Modifier.fillMaxSize()
                ) {
                    LazyColumn(
                        modifier = Modifier.fillMaxSize(),
                        verticalArrangement = Arrangement.spacedBy(2.dp),
                        contentPadding = PaddingValues(bottom = 100.dp)
                    ) {
                        itemsIndexed(filteredNews) { index, news ->
                            androidx.compose.animation.AnimatedVisibility(
                                visible = showContent,
                                enter = fadeIn(tween(300, 150 + index * 50)) + slideInVertically(tween(300, 150 + index * 50)) { 25 }
                            ) {
                                PremiumNewsCard(news = news)
                            }
                        }
                    }
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚îÄ‚îÄ Premium Composables ‚îÄ‚îÄ
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
fun PremiumNewsCard(news: RaceNews) {
    val priorityColor = when (news.priority) {
        NewsPriority.HIGH -> RacingRed
        NewsPriority.MEDIUM -> StatusAmber
        NewsPriority.LOW -> StatusGreen
    }

    val timeText = getTimeAgo(news.timestamp)

    Box(
        Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 4.dp)
            .clip(RoundedCornerShape(18.dp))
            .liquidGlass(RoundedCornerShape(18.dp), GlassLevel.L2, accentGlow = priorityColor)
    ) {
        Row(modifier = Modifier.padding(16.dp)) {
            // Priority indicator with glow
            Box(
                modifier = Modifier
                    .size(10.dp)
                    .drawBehind {
                        drawCircle(priorityColor.copy(alpha = 0.4f), radius = size.minDimension)
                    }
                    .clip(CircleShape)
                    .background(priorityColor)
                    .align(Alignment.Top)
            )

            Spacer(modifier = Modifier.width(14.dp))

            Column(modifier = Modifier.weight(1f)) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    // Category badge
                    Box(
                        Modifier
                            .clip(RoundedCornerShape(6.dp))
                            .background(priorityColor.copy(alpha = 0.12f))
                            .padding(horizontal = 8.dp, vertical = 3.dp)
                    ) {
                        Text(
                            news.category.displayName.uppercase(),
                            style = MaterialTheme.typography.labelSmall,
                            color = priorityColor,
                            fontWeight = FontWeight.Black,
                            letterSpacing = 1.5.sp,
                            fontSize = 9.sp
                        )
                    }
                    Text(
                        timeText,
                        style = MaterialTheme.typography.labelSmall,
                        color = TextTertiary,
                        letterSpacing = 0.5.sp
                    )
                }

                Spacer(modifier = Modifier.height(10.dp))

                Text(
                    news.title,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = TextPrimary
                )

                Spacer(modifier = Modifier.height(6.dp))

                Text(
                    news.content,
                    style = MaterialTheme.typography.bodyMedium,
                    color = TextSecondary,
                    lineHeight = 20.sp
                )
            }
        }
    }
}

@Composable
private fun PremiumFilterChip(
    selected: Boolean,
    label: String,
    accentColor: Color,
    onClick: () -> Unit
) {
    val bgColor = if (selected) accentColor.copy(alpha = 0.2f) else MetalGrey.copy(alpha = 0.25f)
    val textColor = if (selected) TextPrimary else TextSecondary

    Box(
        Modifier
            .clip(RoundedCornerShape(12.dp))
            .background(bgColor)
            .then(
                if (selected) Modifier.border(0.5.dp, accentColor.copy(alpha = 0.5f), RoundedCornerShape(12.dp))
                else Modifier
            )
            .graphicsLayer { clip = false }
            .clickable(
                interactionSource = remember { MutableInteractionSource() },
                indication = null,
                onClick = onClick
            )
            .padding(horizontal = 16.dp, vertical = 9.dp)
    ) {
        Text(
            label,
            style = MaterialTheme.typography.labelMedium,
            color = textColor,
            fontWeight = FontWeight.Bold,
            letterSpacing = 1.sp
        )
    }
}

@Composable
fun getTimeAgo(timestamp: Long): String {
    val now = System.currentTimeMillis()
    val diff = now - timestamp
    val minutes = diff / (60 * 1000)
    val hours = diff / (60 * 60 * 1000)

    return when {
        minutes < 1 -> stringResource(R.string.news_time_now)
        minutes < 60 -> stringResource(R.string.news_time_minutes, minutes.toInt())
        else -> stringResource(R.string.news_time_hours, hours.toInt())
    }
}

/**
 * Parsea timestamps del backend: puede ser Long (epoch millis), String ISO ("2024-01-15 10:30:00")
 */
private fun parseTimestamp(value: Any?): Long {
    return when (value) {
        is Number -> value.toLong().let { if (it < 1_000_000_000_000L) it * 1000 else it }
        is String -> try {
            val sdf = java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss", java.util.Locale.getDefault())
            sdf.parse(value)?.time ?: System.currentTimeMillis()
        } catch (_: Exception) {
            try {
                val sdf = java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", java.util.Locale.getDefault())
                sdf.parse(value)?.time ?: System.currentTimeMillis()
            } catch (_: Exception) { System.currentTimeMillis() }
        }
        else -> System.currentTimeMillis()
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/ar/ARCalculator.kt`

```kotlin
package com.georacing.georacing.ui.screens.ar

import android.location.Location
import com.georacing.georacing.car.PoiModel
import kotlin.math.*

object ARCalculator {

    data class ScreenPosition(
        val x: Float, // Relative 0..1 (or pixels if passed screen size)
        val y: Float, // Relative 0..1
        val isVisible: Boolean,
        val distanceMeters: Float
    )

    private const val FOV_HORIZONTAL = 60.0 // Approximate Phone Camera FOV
    private const val FOV_VERTICAL = 45.0
    private const val MAX_DISTANCE_METERS = 500.0 // Don't show POIs further than this

    fun calculatePosition(
        userLocation: Location,
        poi: PoiModel,
        deviceAzimuth: Float,
        devicePitch: Float
    ): ScreenPosition {
        val poiLocation = Location("POI").apply {
            latitude = poi.latitude
            longitude = poi.longitude
        }

        // 1. Calculate Distance
        val distance = userLocation.distanceTo(poiLocation)
        if (distance > MAX_DISTANCE_METERS) {
            return ScreenPosition(0f, 0f, false, distance)
        }

        // 2. Calculate Bearing (Direction to POI)
        val bearingToPoi = userLocation.bearingTo(poiLocation) // -180 to 180

        // 3. Calculate Delta Azimuth (Difference between where we look and where POI is)
        // Normalize both to 0-360
        val normalizedBearing = (bearingToPoi + 360) % 360
        var deltaAzimuth = normalizedBearing - deviceAzimuth

        // Handle wrap-around (e.g. 350 vs 10 degrees -> diff is 20, not 340)
        if (deltaAzimuth > 180) deltaAzimuth -= 360
        if (deltaAzimuth < -180) deltaAzimuth += 360

        // 4. Determine if visible (within FOV)
        val halfFov = FOV_HORIZONTAL / 2
        if (abs(deltaAzimuth) > halfFov) {
            return ScreenPosition(0f, 0f, false, distance)
        }

        // 5. Calculate X Position
        // -halfFov -> x=0, 0 -> x=0.5, +halfFov -> x=1
        val x = (0.5f + (deltaAzimuth / FOV_HORIZONTAL)).toFloat()

        // 6. Calculate Y Position based on Pitch (simplified)
        // If pitch is 0 (horizon), y=0.5.
        // If looking DOWN (positive pitch), object goes UP on screen.
        // We assume POI is at same altitude (horizon).
        val y = (0.5f + (devicePitch / FOV_VERTICAL)).toFloat()

        return ScreenPosition(x, y.coerceIn(0f, 1f), true, distance)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/ar/ARCameraView.kt`

```kotlin
package com.georacing.georacing.ui.screens.ar

import android.content.Context
import androidx.camera.core.CameraSelector
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.content.ContextCompat
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine

@Composable
fun ARCameraView(
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    val previewView = remember { PreviewView(context) }

    LaunchedEffect(Unit) {
        val cameraProvider = context.getCameraProvider()
        val preview = Preview.Builder().build()
        val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

        preview.setSurfaceProvider(previewView.surfaceProvider)

        try {
            cameraProvider.unbindAll()
            cameraProvider.bindToLifecycle(
                lifecycleOwner,
                cameraSelector,
                preview
            )
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    AndroidView(
        factory = { previewView },
        modifier = modifier.fillMaxSize()
    )
}

private suspend fun Context.getCameraProvider(): ProcessCameraProvider = suspendCoroutine { continuation ->
    val providerFuture = ProcessCameraProvider.getInstance(this)
    providerFuture.addListener({
        continuation.resume(providerFuture.get())
    }, ContextCompat.getMainExecutor(this))
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/ar/ARNavigationScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.ar

import android.Manifest
import android.location.Location
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Paint
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.georacing.georacing.car.PoiRepository
import com.georacing.georacing.data.sensors.OrientationEngine
import com.georacing.georacing.di.AppContainer
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.isGranted
import com.google.accompanist.permissions.rememberPermissionState

@OptIn(ExperimentalPermissionsApi::class)
@Composable
fun ARNavigationScreen(
    appContainer: AppContainer?,
    onBack: () -> Unit
) {
    if (appContainer == null) {
        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) { Text("Error: Dependencies missing") }
        return
    }

    // 1. Energy Check
    val energyProfile by appContainer.energyMonitor.energyProfile.collectAsStateWithLifecycle()
    if (!energyProfile.canUseAR) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black),
            contentAlignment = Alignment.Center
        ) {
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                Text(
                    text = "‚ö†Ô∏è AR Desactivada",
                    color = Color.Red,
                    style = MaterialTheme.typography.headlineMedium,
                    fontWeight = FontWeight.Bold
                )
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = "Bater√≠a baja (<30%) o Modo Ahorro activo.",
                    color = Color.White
                )
                Spacer(modifier = Modifier.height(24.dp))
                Button(onClick = onBack) {
                    Text("Volver")
                }
            }
        }
        return
    }

    // 2. Permissions
    val cameraPermissionState = rememberPermissionState(Manifest.permission.CAMERA)
    val locationPermissionState = rememberPermissionState(Manifest.permission.ACCESS_FINE_LOCATION)

    LaunchedEffect(Unit) {
        if (!cameraPermissionState.status.isGranted) {
            cameraPermissionState.launchPermissionRequest()
        }
        if (!locationPermissionState.status.isGranted) {
            locationPermissionState.launchPermissionRequest()
        }
    }

    if (!cameraPermissionState.status.isGranted) {
        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            Text("Se requiere permiso de c√°mara para AR", color = Color.White)
        }
        return
    }

    // 3. Sensor & Location Logic
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    
    val orientationEngine = remember { OrientationEngine(context) }
    val orientationState by orientationEngine.getOrientationFlow().collectAsStateWithLifecycle(
        initialValue = OrientationEngine.Orientation(0f, 0f),
        lifecycleOwner = lifecycleOwner
    )

    // Using Mock Location for now OR ParkingRepository's location if available, 
    // ideally we should inject a LocationManager in AppContainer.
    // For this task, I'll check if ParkingRepository has a location, otherwise fallback to Circuit Center Mock.
    val userLocationState = appContainer.parkingRepository.parkingLocation.collectAsStateWithLifecycle(initialValue = null)
    
    // Mock user location near the circuit if no real GPS (Hardcoded near Circuit de Catalunya entrance)
    val userLocation = remember(userLocationState.value) {
        val parkingLoc = userLocationState.value
        if (parkingLoc != null) {
            Location("GPS").apply { 
                latitude = parkingLoc.latitude
                longitude = parkingLoc.longitude 
                altitude = 0.0
            }
        } else {
            // Default Mock: Circuit Entrance
            Location("Mock").apply { 
                latitude = 41.569 // Near Gate 3
                longitude = 2.254 
                altitude = 0.0
            }
        }
    }

    val pois = remember { PoiRepository.getAllPois() }

    Box(modifier = Modifier.fillMaxSize()) {
        
        // A. Camera Layer
        ARCameraView()

        // B. Overlay Layer
        Canvas(modifier = Modifier.fillMaxSize()) {
            val width = size.width
            val height = size.height
            
            // F1 Style Crosshair
            drawLine(Color.Green, Offset(width/2 - 30, height/2), Offset(width/2 + 30, height/2), 2.dp.toPx())
            drawLine(Color.Green, Offset(width/2, height/2 - 30), Offset(width/2, height/2 + 30), 2.dp.toPx())

            // Draw POIs
            val paintText = Paint().asFrameworkPaint().apply {
                color = android.graphics.Color.WHITE
                textSize = 40f
                textAlign = android.graphics.Paint.Align.CENTER
                isFakeBoldText = true
                setShadowLayer(5f, 0f, 0f, android.graphics.Color.BLACK)
            }
            
            val paintBox = Paint().asFrameworkPaint().apply {
                color = android.graphics.Color.argb(150, 0, 0, 0) // Semi-transparent black bg
                style = android.graphics.Paint.Style.FILL
            }

            // Limit to max 5 visible items to reduce clutter
            var visibleCount = 0

            pois.forEach { poi ->
                if (visibleCount >= 10) return@forEach

                val screenPos = ARCalculator.calculatePosition(
                    userLocation = userLocation,
                    poi = poi,
                    deviceAzimuth = orientationState.azimuth,
                    devicePitch = orientationState.pitch
                )

                if (screenPos.isVisible) {
                    visibleCount++
                    val x = screenPos.x * width
                    // Adjust Y to center-ish but float based on pitch (already handled by ARCalculator)
                    // If y is 0.5 (horizon), draw at height/2.
                    // ARCalculator maps 0.5 -> horizon.
                    val y = screenPos.y * height

                    // Draw Marker
                    drawLine(
                        color = if(poi.type == com.georacing.georacing.car.PoiType.GATE) Color.White else Color.Green,
                        start = Offset(x, y),
                        end = Offset(x, y - 50),
                        strokeWidth = 3.dp.toPx()
                    )

                    // Draw Label Box
                    val text = "${poi.name} (${screenPos.distanceMeters.toInt()}m)"
                    drawContext.canvas.nativeCanvas.drawRect(
                        x - 150, y - 110, x + 150, y - 50, paintBox
                    )
                    drawContext.canvas.nativeCanvas.drawText(
                        text, x, y - 70, paintText
                    )
                }
            }
        }

        // C. Technical HUD decorations
        Column(
            modifier = Modifier
                .align(Alignment.BottomStart)
                .padding(20.dp)
        ) {
            Text(
                text = "HDG: ${orientationState.azimuth.toInt()}¬∞",
                style = MaterialTheme.typography.labelMedium,
                color = Color.Green,
                fontFamily = androidx.compose.ui.text.font.FontFamily.Monospace
            )
            Text(
                text = "PITCH: ${orientationState.pitch.toInt()}¬∞",
                style = MaterialTheme.typography.labelMedium,
                color = Color.Green,
                fontFamily = androidx.compose.ui.text.font.FontFamily.Monospace
            )
            Text(
                text = "GPS: ${userLocation.latitude}, ${userLocation.longitude}",
                style = MaterialTheme.typography.labelSmall,
                color = Color.White.copy(alpha = 0.5f),
                fontFamily = androidx.compose.ui.text.font.FontFamily.Monospace
            )
        }

        // Close Button
        Button(
            onClick = onBack,
            modifier = Modifier.align(Alignment.TopEnd).padding(16.dp),
            colors = ButtonDefaults.buttonColors(containerColor = Color.Red.copy(alpha=0.6f))
        ) {
            Text("CERRAR AR")
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/clima/ClimaSmartScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.clima

import android.util.Log
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.*
import androidx.compose.animation.fadeIn
import androidx.compose.animation.slideInVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.data.remote.OpenMeteoService
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.components.HomeIconButton
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.*
import java.time.LocalTime
import java.time.format.DateTimeFormatter

private data class HourlyForecast(val hour: String, val tempC: Int, val icon: String, val rainProb: Int)
private data class WeatherRecommendation(val icon: ImageVector, val title: String, val description: String, val color: Color, val priority: Int)

/**
 * ClimaSmartScreen ‚Äî Premium Weather HUD
 * Datos meteorol√≥gicos REALES via Open-Meteo API.
 * Circuit de Barcelona-Catalunya: 41.57¬∞N, 2.26¬∞E
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ClimaSmartScreen(navController: NavController) {
    val backdrop = LocalBackdrop.current

    // Coordenadas reales del Circuit de Barcelona-Catalunya
    val circuitLat = 41.57
    val circuitLon = 2.26

    var currentTemp by remember { mutableIntStateOf(0) }
    var feelsLike by remember { mutableIntStateOf(0) }
    var humidity by remember { mutableIntStateOf(0) }
    var windSpeed by remember { mutableIntStateOf(0) }
    var windDirection by remember { mutableStateOf("") }
    var uvIndex by remember { mutableIntStateOf(0) }
    var pressure by remember { mutableIntStateOf(0) }
    var sunrise by remember { mutableStateOf("--:--") }
    var sunset by remember { mutableStateOf("--:--") }
    var weatherCode by remember { mutableIntStateOf(0) }
    var hourlyForecast by remember { mutableStateOf<List<HourlyForecast>>(emptyList()) }
    var isLoading by remember { mutableStateOf(true) }
    var errorMsg by remember { mutableStateOf<String?>(null) }

    // Staggered entrance
    var showContent by remember { mutableStateOf(false) }
    LaunchedEffect(Unit) { showContent = true }

    // Fetch real weather data
    LaunchedEffect(Unit) {
        try {
            val response = OpenMeteoService.instance.getForecast(
                latitude = circuitLat,
                longitude = circuitLon
            )

            response.current?.let { c ->
                currentTemp = c.temperature_2m?.toInt() ?: 0
                feelsLike = c.apparent_temperature?.toInt() ?: 0
                humidity = c.relative_humidity_2m ?: 0
                windSpeed = c.wind_speed_10m?.toInt() ?: 0
                windDirection = degreesToCardinal(c.wind_direction_10m ?: 0)
                weatherCode = c.weather_code ?: 0
                pressure = c.surface_pressure?.toInt() ?: 0
            }

            response.daily?.let { d ->
                sunrise = d.sunrise?.firstOrNull()?.takeLast(5) ?: "--:--"
                sunset = d.sunset?.firstOrNull()?.takeLast(5) ?: "--:--"
                uvIndex = d.uv_index_max?.firstOrNull()?.toInt() ?: 0
            }

            response.hourly?.let { h ->
                val times = h.time ?: emptyList()
                val temps = h.temperature_2m ?: emptyList()
                val rain = h.precipitation_probability ?: emptyList()
                val codes = h.weather_code ?: emptyList()

                val currentHour = LocalTime.now().hour
                hourlyForecast = times.indices
                    .filter { i ->
                        val hour = try { times[i].takeLast(5).take(2).toInt() } catch (_: Exception) { -1 }
                        hour >= currentHour
                    }
                    .take(12)
                    .map { i ->
                        HourlyForecast(
                            hour = times.getOrNull(i)?.takeLast(5) ?: "",
                            tempC = temps.getOrNull(i)?.toInt() ?: 0,
                            icon = weatherCodeToEmoji(codes.getOrNull(i) ?: 0),
                            rainProb = rain.getOrNull(i) ?: 0
                        )
                    }
            }

            isLoading = false
        } catch (e: Exception) {
            Log.e("ClimaSmartScreen", "Error fetching weather", e)
            errorMsg = "Error al obtener datos meteorol√≥gicos: ${e.message}"
            isLoading = false
        }
    }

    val recommendations = remember(currentTemp, uvIndex, humidity, windSpeed) {
        buildList {
            if (uvIndex >= 6) add(WeatherRecommendation(Icons.Default.WbSunny, "Protecci√≥n Solar", "UV $uvIndex (Muy Alto). Usa protector solar FPS 50+ y gorra.", Color(0xFFFF9800), 1))
            if (currentTemp >= 28) add(WeatherRecommendation(Icons.Default.WaterDrop, "Hidrataci√≥n", "Temp. ${currentTemp}¬∞C. Bebe m√≠nimo 500ml/hora. Hay fuentes en el circuito.", ElectricBlue, 1))
            if (windSpeed >= 15) add(WeatherRecommendation(Icons.Default.Air, "Viento Fuerte", "R√°fagas de ${windSpeed} km/h direcci√≥n $windDirection. Sujeta bien gorras y pancartas.", NeonCyan, 2))
            if (currentTemp <= 10) add(WeatherRecommendation(Icons.Default.AcUnit, "Fr√≠o", "Temperatura baja: ${currentTemp}¬∞C. Lleva ropa de abrigo.", ElectricBlue, 1))
            if (weatherCode in 51..67 || weatherCode in 80..82) add(WeatherRecommendation(Icons.Default.Umbrella, "Lluvia", "Se espera lluvia. Lleva chubasquero o paraguas.", NeonPurple, 1))
            add(WeatherRecommendation(Icons.Default.Visibility, "Visibilidad", "Condiciones actuales: ${weatherCodeToText(weatherCode)}.", StatusGreen, 3))
        }.sortedBy { it.priority }
    }

    Box(Modifier.fillMaxSize()) {
        CarbonBackground()

        Column(Modifier.fillMaxSize()) {
            // ‚îÄ‚îÄ Premium LiquidTopBar ‚îÄ‚îÄ
            LiquidTopBar(
                backdrop = backdrop,
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Volver", tint = TextPrimary)
                    }
                },
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Box(Modifier.size(8.dp).clip(CircleShape).background(NeonCyan))
                        Spacer(Modifier.width(10.dp))
                        Column {
                            Text("CLIMA", style = MaterialTheme.typography.titleMedium, color = TextPrimary, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                            Text("Tiempo real ¬∑ Open-Meteo", style = MaterialTheme.typography.labelSmall, color = TextTertiary)
                        }
                    }
                },
                actions = {
                    HomeIconButton { navController.navigate(Screen.Home.route) { popUpTo(Screen.Home.route) { inclusive = true } } }
                }
            )

            when {
                isLoading -> {
                    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                        Column(horizontalAlignment = Alignment.CenterHorizontally) {
                            // Pulsing loading indicator
                            val pulseAnim = rememberInfiniteTransition(label = "pulse")
                            val pulseScale by pulseAnim.animateFloat(
                                initialValue = 0.8f, targetValue = 1.2f,
                                animationSpec = infiniteRepeatable(tween(800), RepeatMode.Reverse), label = "s"
                            )
                            Box(
                                Modifier
                                    .size(64.dp)
                                    .graphicsLayer { scaleX = pulseScale; scaleY = pulseScale }
                                    .drawBehind {
                                        drawCircle(NeonCyan.copy(alpha = 0.2f), radius = size.minDimension / 2)
                                    },
                                contentAlignment = Alignment.Center
                            ) {
                                CircularProgressIndicator(color = NeonCyan, strokeWidth = 3.dp, modifier = Modifier.size(40.dp))
                            }
                            Spacer(Modifier.height(16.dp))
                            Text("Sincronizando datos reales...", color = TextTertiary, fontSize = 12.sp, letterSpacing = 1.sp)
                        }
                    }
                }
                errorMsg != null -> {
                    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                        Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.padding(32.dp)) {
                            Box(
                                Modifier
                                    .size(72.dp)
                                    .clip(RoundedCornerShape(20.dp))
                                    .background(StatusRed.copy(alpha = 0.15f)),
                                contentAlignment = Alignment.Center
                            ) {
                                Icon(Icons.Default.Warning, null, tint = StatusRed, modifier = Modifier.size(36.dp))
                            }
                            Spacer(Modifier.height(16.dp))
                            Text("Error Meteorol√≥gico", style = MaterialTheme.typography.titleMedium, color = TextPrimary, fontWeight = FontWeight.Bold)
                            Spacer(Modifier.height(4.dp))
                            Text(errorMsg ?: "", style = MaterialTheme.typography.bodySmall, color = TextSecondary)
                        }
                    }
                }
                else -> {
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .verticalScroll(rememberScrollState())
                            .padding(horizontal = 16.dp)
                    ) {
                        Spacer(Modifier.height(8.dp))

                        // ‚îÄ‚îÄ Location pill ‚îÄ‚îÄ
                        AnimatedVisibility(
                            visible = showContent,
                            enter = fadeIn(tween(400)) + slideInVertically(tween(400)) { -20 }
                        ) {
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                modifier = Modifier
                                    .clip(RoundedCornerShape(20.dp))
                                    .background(RacingRed.copy(alpha = 0.1f))
                                    .padding(horizontal = 12.dp, vertical = 6.dp)
                            ) {
                                Icon(Icons.Default.LocationOn, null, tint = RacingRed, modifier = Modifier.size(14.dp))
                                Spacer(Modifier.width(6.dp))
                                Text("Circuit de Barcelona-Catalunya ¬∑ Montmel√≥", style = MaterialTheme.typography.labelSmall, color = TextSecondary, letterSpacing = 0.5.sp)
                            }
                        }

                        Spacer(Modifier.height(16.dp))

                        // ‚îÄ‚îÄ Hero Weather Card ‚îÄ‚îÄ (glass with gradient glow)
                        AnimatedVisibility(
                            visible = showContent,
                            enter = fadeIn(tween(500, 100)) + slideInVertically(tween(500, 100)) { 40 }
                        ) {
                            Box(
                                Modifier
                                    .fillMaxWidth()
                                    .clip(RoundedCornerShape(24.dp))
                                    .liquidGlass(RoundedCornerShape(24.dp), GlassLevel.L3, accentGlow = NeonCyan)
                            ) {
                                // Subtle sky gradient overlay
                                Box(
                                    Modifier
                                        .fillMaxWidth()
                                        .background(
                                            Brush.verticalGradient(
                                                listOf(
                                                    ElectricBlue.copy(alpha = 0.08f),
                                                    Color.Transparent
                                                )
                                            )
                                        )
                                        .padding(28.dp)
                                ) {
                                    Column(
                                        horizontalAlignment = Alignment.CenterHorizontally,
                                        modifier = Modifier.fillMaxWidth()
                                    ) {
                                        // Animated emoji
                                        val floatAnim = rememberInfiniteTransition(label = "float")
                                        val yOffset by floatAnim.animateFloat(
                                            initialValue = 0f, targetValue = -8f,
                                            animationSpec = infiniteRepeatable(tween(2500, easing = EaseInOutSine), RepeatMode.Reverse), label = "y"
                                        )
                                        Text(
                                            weatherCodeToEmoji(weatherCode), fontSize = 72.sp,
                                            modifier = Modifier.graphicsLayer { translationY = yOffset }
                                        )

                                        Spacer(Modifier.height(4.dp))

                                        // Temperature - large hero text
                                        Text(
                                            "${currentTemp}¬∞",
                                            style = MaterialTheme.typography.displayLarge.copy(
                                                fontWeight = FontWeight.Black,
                                                fontSize = 80.sp,
                                                letterSpacing = (-2).sp
                                            ),
                                            color = TextPrimary
                                        )
                                        Text(
                                            "Sensaci√≥n t√©rmica ${feelsLike}¬∞C",
                                            style = MaterialTheme.typography.bodyMedium,
                                            color = TextSecondary
                                        )

                                        Spacer(Modifier.height(24.dp))

                                        // Stats row - glass sub-cards
                                        Row(
                                            Modifier.fillMaxWidth(),
                                            horizontalArrangement = Arrangement.SpaceEvenly
                                        ) {
                                            PremiumWeatherStat(Icons.Default.WaterDrop, "$humidity%", "Humedad", NeonCyan)
                                            PremiumWeatherStat(Icons.Default.Air, "$windSpeed km/h", "Viento $windDirection", NeonCyan)
                                            PremiumWeatherStat(Icons.Default.WbSunny, "UV $uvIndex", "√çndice UV", ChampagneGold)
                                        }
                                    }
                                }
                            }
                        }

                        Spacer(Modifier.height(28.dp))

                        // ‚îÄ‚îÄ Hourly Forecast Section ‚îÄ‚îÄ
                        AnimatedVisibility(
                            visible = showContent,
                            enter = fadeIn(tween(500, 250)) + slideInVertically(tween(500, 250)) { 30 }
                        ) {
                            Column {
                                Text(
                                    "PREVISI√ìN HORARIA",
                                    style = MaterialTheme.typography.labelSmall,
                                    color = TextTertiary,
                                    letterSpacing = 2.sp,
                                    fontWeight = FontWeight.Bold
                                )
                                Spacer(Modifier.height(4.dp))
                                Text(
                                    "Datos del circuito en tiempo real",
                                    style = MaterialTheme.typography.labelSmall,
                                    color = TextTertiary.copy(alpha = 0.6f),
                                    fontSize = 10.sp
                                )
                            }
                        }

                        Spacer(Modifier.height(12.dp))

                        if (hourlyForecast.isNotEmpty()) {
                            LazyRow(horizontalArrangement = Arrangement.spacedBy(10.dp)) {
                                itemsIndexed(hourlyForecast) { index, forecast ->
                                    AnimatedVisibility(
                                        visible = showContent,
                                        enter = fadeIn(tween(300, 300 + index * 50)) + slideInVertically(tween(300, 300 + index * 50)) { 20 }
                                    ) {
                                        PremiumHourlyCard(forecast)
                                    }
                                }
                            }
                        } else {
                            Text("Sin datos horarios disponibles", color = TextTertiary, fontSize = 12.sp)
                        }

                        Spacer(Modifier.height(28.dp))

                        // ‚îÄ‚îÄ Recommendations Section ‚îÄ‚îÄ
                        AnimatedVisibility(
                            visible = showContent,
                            enter = fadeIn(tween(500, 400)) + slideInVertically(tween(500, 400)) { 30 }
                        ) {
                            Text(
                                "RECOMENDACIONES INTELIGENTES",
                                style = MaterialTheme.typography.labelSmall,
                                color = TextTertiary,
                                letterSpacing = 2.sp,
                                fontWeight = FontWeight.Bold
                            )
                        }

                        Spacer(Modifier.height(12.dp))

                        recommendations.forEachIndexed { index, rec ->
                            AnimatedVisibility(
                                visible = showContent,
                                enter = fadeIn(tween(400, 500 + index * 80)) + slideInVertically(tween(400, 500 + index * 80)) { 30 }
                            ) {
                                PremiumRecommendationCard(rec)
                            }
                            Spacer(Modifier.height(10.dp))
                        }

                        Spacer(Modifier.height(24.dp))

                        // ‚îÄ‚îÄ Bottom Stats Strip ‚îÄ‚îÄ
                        AnimatedVisibility(
                            visible = showContent,
                            enter = fadeIn(tween(500, 700)) + slideInVertically(tween(500, 700)) { 20 }
                        ) {
                            Box(
                                Modifier
                                    .fillMaxWidth()
                                    .clip(RoundedCornerShape(16.dp))
                                    .liquidGlass(RoundedCornerShape(16.dp), GlassLevel.L1)
                                    .padding(16.dp)
                            ) {
                                Row(
                                    Modifier.fillMaxWidth(),
                                    horizontalArrangement = Arrangement.SpaceEvenly
                                ) {
                                    PremiumMiniStat("Presi√≥n", "${pressure}hPa", NeonCyan)
                                    PremiumMiniStat("UV m√°x", "$uvIndex", ChampagneGold)
                                    PremiumMiniStat("Amanecer", sunrise, StatusAmber)
                                    PremiumMiniStat("Anochecer", sunset, NeonPurple)
                                }
                            }
                        }

                        Spacer(Modifier.height(12.dp))
                        Text(
                            "Fuente: Open-Meteo API (datos reales)",
                            fontSize = 10.sp,
                            color = TextTertiary.copy(alpha = 0.5f),
                            modifier = Modifier.fillMaxWidth(),
                            textAlign = androidx.compose.ui.text.style.TextAlign.Center
                        )
                        Spacer(Modifier.height(100.dp))
                    }
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚îÄ‚îÄ Premium Composables ‚îÄ‚îÄ
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumWeatherStat(icon: ImageVector, value: String, label: String, accentColor: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Box(
            Modifier
                .size(36.dp)
                .clip(CircleShape)
                .background(accentColor.copy(alpha = 0.1f)),
            contentAlignment = Alignment.Center
        ) {
            Icon(icon, label, tint = accentColor, modifier = Modifier.size(18.dp))
        }
        Spacer(Modifier.height(6.dp))
        Text(value, style = MaterialTheme.typography.titleSmall, color = TextPrimary, fontWeight = FontWeight.Bold)
        Text(label, style = MaterialTheme.typography.labelSmall, color = TextTertiary, fontSize = 10.sp)
    }
}

@Composable
private fun PremiumHourlyCard(forecast: HourlyForecast) {
    val isCurrent = try {
        LocalTime.now().hour == LocalTime.parse(forecast.hour, DateTimeFormatter.ofPattern("HH:mm")).hour
    } catch (_: Exception) { false }

    val accentColor = if (isCurrent) ElectricBlue else Color.Transparent

    Box(
        Modifier
            .width(76.dp)
            .clip(RoundedCornerShape(18.dp))
            .liquidGlass(RoundedCornerShape(18.dp), GlassLevel.L1, accentGlow = accentColor)
    ) {
        // Current hour highlight
        if (isCurrent) {
            Box(
                Modifier
                    .fillMaxWidth()
                    .background(
                        Brush.verticalGradient(
                            listOf(ElectricBlue.copy(alpha = 0.12f), Color.Transparent)
                        )
                    )
            )
        }
        Column(
            Modifier.padding(12.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                if (isCurrent) "AHORA" else forecast.hour,
                style = MaterialTheme.typography.labelSmall,
                color = if (isCurrent) ElectricBlue else TextTertiary,
                fontWeight = if (isCurrent) FontWeight.Black else FontWeight.Normal,
                fontSize = if (isCurrent) 9.sp else 11.sp,
                letterSpacing = if (isCurrent) 1.sp else 0.sp
            )
            Spacer(Modifier.height(8.dp))
            Text(forecast.icon, fontSize = 26.sp)
            Spacer(Modifier.height(8.dp))
            Text(
                "${forecast.tempC}¬∞",
                style = MaterialTheme.typography.titleMedium,
                color = TextPrimary,
                fontWeight = FontWeight.Bold
            )
            if (forecast.rainProb > 0) {
                Spacer(Modifier.height(4.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Icon(Icons.Default.WaterDrop, null, tint = ElectricBlue, modifier = Modifier.size(10.dp))
                    Spacer(Modifier.width(2.dp))
                    Text(
                        "${forecast.rainProb}%",
                        style = MaterialTheme.typography.labelSmall,
                        color = ElectricBlue,
                        fontSize = 10.sp,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
        }
    }
}

@Composable
private fun PremiumRecommendationCard(rec: WeatherRecommendation) {
    Box(
        Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(18.dp))
            .liquidGlass(RoundedCornerShape(18.dp), GlassLevel.L2, accentGlow = rec.color)
    ) {
        Row(Modifier.padding(16.dp), verticalAlignment = Alignment.Top) {
            // Icon box with colored glow
            Box(
                Modifier
                    .size(46.dp)
                    .clip(RoundedCornerShape(14.dp))
                    .background(rec.color.copy(alpha = 0.12f))
                    .drawBehind {
                        drawCircle(rec.color.copy(alpha = 0.08f), radius = size.minDimension * 0.8f)
                    },
                contentAlignment = Alignment.Center
            ) {
                Icon(rec.icon, rec.title, tint = rec.color, modifier = Modifier.size(22.dp))
            }
            Spacer(Modifier.width(14.dp))
            Column(Modifier.weight(1f)) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(
                        rec.title,
                        style = MaterialTheme.typography.titleSmall,
                        color = TextPrimary,
                        fontWeight = FontWeight.Bold
                    )
                    if (rec.priority == 1) {
                        Spacer(Modifier.width(8.dp))
                        Box(
                            Modifier
                                .clip(RoundedCornerShape(4.dp))
                                .background(rec.color.copy(alpha = 0.15f))
                                .padding(horizontal = 6.dp, vertical = 2.dp)
                        ) {
                            Text(
                                "IMPORTANTE",
                                style = MaterialTheme.typography.labelSmall,
                                color = rec.color,
                                fontSize = 9.sp,
                                fontWeight = FontWeight.Black,
                                letterSpacing = 1.sp
                            )
                        }
                    }
                }
                Spacer(Modifier.height(4.dp))
                Text(
                    rec.description,
                    style = MaterialTheme.typography.bodySmall,
                    color = TextSecondary,
                    lineHeight = 18.sp
                )
            }
        }
    }
}

@Composable
private fun PremiumMiniStat(label: String, value: String, accentColor: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(
            value,
            style = MaterialTheme.typography.labelLarge,
            color = accentColor,
            fontWeight = FontWeight.Bold
        )
        Text(
            label,
            style = MaterialTheme.typography.labelSmall,
            color = TextTertiary,
            fontSize = 10.sp
        )
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

private fun degreesToCardinal(degrees: Int): String = when {
    degrees < 23 -> "N"; degrees < 68 -> "NE"; degrees < 113 -> "E"; degrees < 158 -> "SE"
    degrees < 203 -> "S"; degrees < 248 -> "SO"; degrees < 293 -> "O"; degrees < 338 -> "NO"
    else -> "N"
}

private fun weatherCodeToEmoji(code: Int): String = when (code) {
    0 -> "‚òÄÔ∏è"; 1 -> "üå§Ô∏è"; 2 -> "‚õÖ"; 3 -> "‚òÅÔ∏è"
    in 45..48 -> "üå´Ô∏è"
    in 51..55 -> "üå¶Ô∏è"; in 56..57 -> "üåßÔ∏è‚ùÑÔ∏è"
    in 61..65 -> "üåßÔ∏è"; in 66..67 -> "üåßÔ∏è‚ùÑÔ∏è"
    in 71..77 -> "üå®Ô∏è"
    in 80..82 -> "üåßÔ∏è"
    in 85..86 -> "üå®Ô∏è"
    in 95..99 -> "‚õàÔ∏è"
    else -> "üå°Ô∏è"
}

private fun weatherCodeToText(code: Int): String = when (code) {
    0 -> "Cielo despejado"; 1 -> "Mayormente despejado"; 2 -> "Parcialmente nublado"; 3 -> "Nublado"
    in 45..48 -> "Niebla"
    in 51..55 -> "Llovizna"; in 56..57 -> "Llovizna helada"
    in 61..65 -> "Lluvia"; in 66..67 -> "Lluvia helada"
    in 71..77 -> "Nieve"
    in 80..82 -> "Chubascos"
    in 85..86 -> "Nieve"
    in 95..99 -> "Tormenta"
    else -> "Desconocido"
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/eco/EcoMeterScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.eco

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.*
import androidx.compose.animation.fadeIn
import androidx.compose.animation.slideInVertically
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.georacing.georacing.data.health.HealthConnectManager
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.theme.*

/**
 * EcoMeterScreen ‚Äî Premium Sustainability HUD
 * Pasos, distancia, CO2 evitado con Health Connect.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EcoMeterScreen(navController: NavController, appContainer: com.georacing.georacing.di.AppContainer? = null) {
    val backdrop = LocalBackdrop.current
    val context = LocalContext.current

    // Resolve HealthConnectManager via MainActivity's AppContainer
    val healthManager = (context as? com.georacing.georacing.MainActivity)?.appContainer?.healthConnectManager
        ?: com.georacing.georacing.data.health.FakeHealthConnectManager(context)

    // Instantiate UserPreferencesDataStore instance
    val userPrefs = com.georacing.georacing.data.local.UserPreferencesDataStore(context)

    val viewModel: EcoViewModel = viewModel(factory = EcoViewModel.Factory(healthManager, userPrefs))

    val state by viewModel.uiState.collectAsState()
    val scope = rememberCoroutineScope()

    var showContent by remember { mutableStateOf(false) }
    LaunchedEffect(Unit) { showContent = true }

    val lifecycleOwner = androidx.compose.ui.platform.LocalLifecycleOwner.current
    DisposableEffect(lifecycleOwner) {
        val observer = androidx.lifecycle.LifecycleEventObserver { _, event ->
            if (event == androidx.lifecycle.Lifecycle.Event.ON_RESUME) {
                viewModel.checkAvailabilityAndLoad()
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }

    Box(Modifier.fillMaxSize()) {
        CarbonBackground()

        Column(Modifier.fillMaxSize()) {
            // ‚îÄ‚îÄ Premium LiquidTopBar ‚îÄ‚îÄ
            LiquidTopBar(
                backdrop = backdrop,
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back", tint = TextPrimary)
                    }
                },
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Box(Modifier.size(8.dp).clip(CircleShape).background(StatusGreen))
                        Spacer(Modifier.width(10.dp))
                        Column {
                            Text("ECOMETER", style = MaterialTheme.typography.titleMedium, color = TextPrimary, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                            Text("Tu huella verde en el circuito", style = MaterialTheme.typography.labelSmall, color = TextTertiary)
                        }
                    }
                }
            )

            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(horizontal = 16.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(24.dp)
            ) {
                Spacer(Modifier.height(8.dp))

                // ‚îÄ‚îÄ Section Label ‚îÄ‚îÄ
                AnimatedVisibility(
                    visible = showContent,
                    enter = fadeIn(tween(400)) + slideInVertically(tween(400)) { -20 }
                ) {
                    Text(
                        "TU HUELLA VERDE",
                        style = MaterialTheme.typography.labelMedium,
                        color = StatusGreen,
                        letterSpacing = 2.sp,
                        fontWeight = FontWeight.Black
                    )
                }

                // ‚îÄ‚îÄ Hero Circular Progress ‚îÄ‚îÄ
                AnimatedVisibility(
                    visible = showContent,
                    enter = fadeIn(tween(600, 100)) + slideInVertically(tween(600, 100)) { 40 }
                ) {
                    Box(
                        Modifier
                            .clip(RoundedCornerShape(32.dp))
                            .liquidGlass(RoundedCornerShape(32.dp), GlassLevel.L3, accentGlow = StatusGreen)
                            .padding(32.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        // Outer glow pulse
                        val pulseAnim = rememberInfiniteTransition(label = "eco")
                        val glowAlpha by pulseAnim.animateFloat(
                            initialValue = 0.08f, targetValue = 0.2f,
                            animationSpec = infiniteRepeatable(tween(2500), RepeatMode.Reverse), label = "g"
                        )

                        Box(
                            Modifier
                                .size(220.dp)
                                .drawBehind {
                                    drawCircle(StatusGreen.copy(alpha = glowAlpha), radius = size.minDimension / 1.8f)
                                },
                            contentAlignment = Alignment.Center
                        ) {
                            PremiumCircularProgress(
                                percentage = (state.steps / 10000f).coerceIn(0f, 1f),
                                trackColor = AsphaltGrey,
                                progressColors = listOf(StatusGreen, NeonCyan),
                                size = 200.dp,
                                strokeWidth = 14.dp
                            )
                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                // Leaf icon
                                Icon(
                                    Icons.Default.Eco,
                                    null,
                                    tint = StatusGreen.copy(alpha = 0.4f),
                                    modifier = Modifier.size(24.dp)
                                )
                                Spacer(Modifier.height(4.dp))
                                Text(
                                    "${state.steps}",
                                    style = MaterialTheme.typography.displayMedium.copy(
                                        fontWeight = FontWeight.Black,
                                        letterSpacing = (-1).sp
                                    ),
                                    color = TextPrimary
                                )
                                Text(
                                    "PASOS HOY",
                                    style = MaterialTheme.typography.labelSmall,
                                    color = TextTertiary,
                                    letterSpacing = 2.sp
                                )
                            }
                        }
                    }
                }

                // ‚îÄ‚îÄ Info Cards Row ‚îÄ‚îÄ
                AnimatedVisibility(
                    visible = showContent,
                    enter = fadeIn(tween(500, 300)) + slideInVertically(tween(500, 300)) { 30 }
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        PremiumInfoCard(
                            icon = Icons.Default.Route,
                            title = "DISTANCIA",
                            value = String.format("%.2f km", state.distanceMeters / 1000),
                            accentColor = NeonCyan,
                            modifier = Modifier.weight(1f)
                        )
                        PremiumInfoCard(
                            icon = Icons.Default.Park,
                            title = "CO2 EVITADO",
                            value = String.format("%.1f g", state.co2SavedGrams),
                            accentColor = StatusGreen,
                            modifier = Modifier.weight(1f)
                        )
                    }
                }

                // ‚îÄ‚îÄ Permission / Sync Section ‚îÄ‚îÄ
                AnimatedVisibility(
                    visible = showContent,
                    enter = fadeIn(tween(500, 450)) + slideInVertically(tween(500, 450)) { 30 }
                ) {
                    Column(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(10.dp)
                    ) {
                        if (!state.hasPermissions) {
                            // Connect button - premium glass
                            Box(
                                Modifier
                                    .fillMaxWidth()
                                    .clip(RoundedCornerShape(14.dp))
                                    .background(StatusGreen)
                                    .clickable {
                                        viewModel.checkAndRequestPermissions()
                                    }
                                    .padding(vertical = 14.dp),
                                contentAlignment = Alignment.Center
                            ) {
                                Text(
                                    if (state.isHealthConnectAvailable) "CONECTAR SALUD" else "INSTALAR HEALTH CONNECT",
                                    color = CarbonBlack,
                                    fontWeight = FontWeight.Black,
                                    letterSpacing = 1.sp
                                )
                            }

                            if (state.isHealthConnectAvailable && !state.hasPermissions) {
                                Box(
                                    Modifier
                                        .fillMaxWidth()
                                        .clip(RoundedCornerShape(14.dp))
                                        .liquidGlass(RoundedCornerShape(14.dp), GlassLevel.L1)
                                        .clickable {
                                            val intent = android.content.Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                                                data = android.net.Uri.fromParts("package", context.packageName, null)
                                            }
                                            context.startActivity(intent)
                                        }
                                        .padding(vertical = 14.dp),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Text("ABRIR CONFIGURACI√ìN DE APP", color = TextSecondary, fontWeight = FontWeight.Bold, letterSpacing = 0.5.sp)
                                }
                            }

                            Text(
                                "Si el sistema no pregunta, √°brelo manualmente en Configuraci√≥n.",
                                style = MaterialTheme.typography.bodySmall,
                                color = TextTertiary,
                                modifier = Modifier.padding(top = 4.dp)
                            )
                        } else {
                            // Connected status pill
                            Row(
                                modifier = Modifier
                                    .clip(RoundedCornerShape(20.dp))
                                    .background(StatusGreen.copy(alpha = 0.1f))
                                    .padding(horizontal = 16.dp, vertical = 8.dp),
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Box(
                                    Modifier
                                        .size(8.dp)
                                        .clip(CircleShape)
                                        .background(StatusGreen)
                                )
                                Spacer(Modifier.width(8.dp))
                                Text(
                                    "Sincronizado con Health Connect",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = StatusGreen,
                                    fontWeight = FontWeight.Bold
                                )
                            }
                        }

                        // Debug status info
                        if (state.isHealthConnectAvailable && !state.hasPermissions) {
                            Box(
                                Modifier
                                    .fillMaxWidth()
                                    .clip(RoundedCornerShape(12.dp))
                                    .background(StatusAmber.copy(alpha = 0.08f))
                                    .padding(12.dp)
                            ) {
                                Text(
                                    "Estado: Disponible pero sin permisos.\nIntenta abrir 'Permisos' manualmente.",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = StatusAmber,
                                    lineHeight = 18.sp
                                )
                            }
                        } else if (!state.isHealthConnectAvailable) {
                            Box(
                                Modifier
                                    .fillMaxWidth()
                                    .clip(RoundedCornerShape(12.dp))
                                    .background(StatusRed.copy(alpha = 0.08f))
                                    .padding(12.dp)
                            ) {
                                Text(
                                    "Estado: Health Connect NO detectado/disponible.",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = StatusRed,
                                    lineHeight = 18.sp
                                )
                            }
                        }
                    }
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚îÄ‚îÄ Premium Composables ‚îÄ‚îÄ
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumInfoCard(
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    title: String,
    value: String,
    accentColor: Color,
    modifier: Modifier = Modifier
) {
    Box(
        modifier
            .clip(RoundedCornerShape(18.dp))
            .liquidGlass(RoundedCornerShape(18.dp), GlassLevel.L2, accentGlow = accentColor)
    ) {
        Column(Modifier.padding(18.dp)) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Box(
                    Modifier
                        .size(32.dp)
                        .clip(RoundedCornerShape(10.dp))
                        .background(accentColor.copy(alpha = 0.12f)),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(icon, null, tint = accentColor, modifier = Modifier.size(16.dp))
                }
                Spacer(Modifier.width(10.dp))
                Text(
                    title,
                    style = MaterialTheme.typography.labelSmall,
                    color = TextTertiary,
                    letterSpacing = 1.5.sp,
                    fontWeight = FontWeight.Bold
                )
            }
            Spacer(Modifier.height(10.dp))
            Text(
                value,
                style = MaterialTheme.typography.headlineSmall,
                color = accentColor,
                fontWeight = FontWeight.Black
            )
        }
    }
}

@Composable
fun PremiumCircularProgress(
    percentage: Float,
    trackColor: Color,
    progressColors: List<Color>,
    size: androidx.compose.ui.unit.Dp,
    strokeWidth: androidx.compose.ui.unit.Dp
) {
    val animatedProgress by animateFloatAsState(
        targetValue = percentage,
        animationSpec = tween(1200, easing = EaseOutQuart),
        label = "Progress"
    )

    Canvas(modifier = Modifier.size(size)) {
        val sweep = 360 * animatedProgress
        // Track
        drawArc(
            color = trackColor,
            startAngle = 0f,
            sweepAngle = 360f,
            useCenter = false,
            style = Stroke(width = strokeWidth.toPx(), cap = StrokeCap.Round)
        )
        // Gradient progress
        drawArc(
            brush = Brush.sweepGradient(progressColors),
            startAngle = -90f,
            sweepAngle = sweep,
            useCenter = false,
            style = Stroke(width = strokeWidth.toPx(), cap = StrokeCap.Round)
        )
    }
}

private val EaseOutQuart: Easing = CubicBezierEasing(0.165f, 0.84f, 0.44f, 1f)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/eco/EcoViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.eco

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.data.health.HealthConnectManager
import com.georacing.georacing.domain.calculator.EcoCalculator
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import java.time.Instant
import com.georacing.georacing.data.local.UserPreferencesDataStore

data class EcoUiState(
    val steps: Long = 0,
    val distanceMeters: Double = 0.0,
    val co2SavedGrams: Double = 0.0,
    val isHealthConnectAvailable: Boolean = false,
    val hasPermissions: Boolean = false,
    val isLoading: Boolean = false
)

class EcoViewModel(
    private val healthManager: HealthConnectManager,
    private val userPrefs: UserPreferencesDataStore
) : ViewModel() {

    private val _uiState = MutableStateFlow(EcoUiState())
    val uiState: StateFlow<EcoUiState> = _uiState.asStateFlow()

    // Event to trigger permission request in UI (Activity)
    private val _requestPermissionEvent = kotlinx.coroutines.flow.MutableSharedFlow<Unit>()
    val requestPermissionEvent: kotlinx.coroutines.flow.SharedFlow<Unit> = _requestPermissionEvent.asSharedFlow()

    fun checkAvailabilityAndLoad() {
        _uiState.value = _uiState.value.copy(
            isHealthConnectAvailable = healthManager.isAvailable()
        )
        refreshData()
    }

    fun checkAndRequestPermissions() {
        viewModelScope.launch {
            if (healthManager.isAvailable()) {
                if (healthManager.hasPermissions()) {
                    android.util.Log.d("EcoViewModel", "Permisos ya concedidos. Refrescando datos.")
                    refreshData() // Already have them
                } else {
                    android.util.Log.d("EcoViewModel", "Solicitando permisos via Evento.")
                    _requestPermissionEvent.emit(Unit) // Trigger Activity Launcher
                }
            } else {
                android.util.Log.e("EcoViewModel", "Health Connect no disponible.")
            }
        }
    }

    fun refreshData() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            
            val hasPerms = healthManager.hasPermissions()
            
            if (hasPerms) {
                // Get the circuit arrival time if any
                val arrivalTimeMs = userPrefs.circuitArrivalTime.first()
                val startTime = arrivalTimeMs?.let { Instant.ofEpochMilli(it) }

                val metrics = healthManager.readDailyMetrics(startTime)
                val co2 = EcoCalculator.calculateCo2Saved(metrics.distanceMeters)
                
                _uiState.value = _uiState.value.copy(
                    steps = metrics.steps,
                    distanceMeters = metrics.distanceMeters,
                    co2SavedGrams = co2,
                    hasPermissions = true,
                    isLoading = false
                )
            } else {
                 _uiState.value = _uiState.value.copy(
                    hasPermissions = false,
                    isLoading = false
                )
            }
        }
    }

    class Factory(
        private val healthConnectManager: HealthConnectManager,
        private val userPrefs: UserPreferencesDataStore
    ) : ViewModelProvider.Factory {
        @Suppress("UNCHECKED_CAST")
        override fun <T : ViewModel> create(modelClass: Class<T>): T {
            return EcoViewModel(healthConnectManager, userPrefs) as T
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/emergency/EmergencyScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.emergency

import android.content.Context
import android.content.Intent
import android.net.Uri
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.ui.theme.*
import com.georacing.georacing.ui.components.*

@Composable
fun EmergencyScreen(navController: NavController) {
    val context = LocalContext.current
    var flashlightOn by remember { mutableStateOf(false) }

    // Pulse Animation for the SOS Button
    val infiniteTransition = rememberInfiniteTransition(label = "sos_pulse")
    val pulseScale by infiniteTransition.animateFloat(
        initialValue = 1f,
        targetValue = 1.1f,
        animationSpec = infiniteRepeatable(
            animation = tween(1000, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "pulse_scale"
    )

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                Brush.verticalGradient(
                    listOf(Color(0xFF080810), Color(0xFF0A0A16), Color(0xFF080810))
                )
            )
    ) {
        // Red Glow Background
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(300.dp)
                .background(
                    brush = Brush.verticalGradient(
                        colors = listOf(
                            Color(0xFF3B0A0A),
                            Color(0xFF1A0505),
                            Color.Transparent
                        )
                    )
                )
        )

        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp)
                .verticalScroll(rememberScrollState()),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Header
            Row(
                modifier = Modifier.fillMaxWidth().padding(top = 16.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                IconButton(onClick = { navController.navigateUp() }) {
                    Icon(Icons.Default.Close, contentDescription = "Close", tint = Color(0xFFE2E8F0))
                }
                Text(
                    text = "SOS",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Black,
                    color = Color(0xFFEF4444),
                    letterSpacing = 4.sp
                )
                // Spacer to balance the Close button
                Spacer(modifier = Modifier.size(48.dp))
            }

            Spacer(modifier = Modifier.height(40.dp))

            // Main 112 Button
            Box(
                contentAlignment = Alignment.Center,
                modifier = Modifier.size(200.dp)
            ) {
                // Outer Ripple
                Box(
                    modifier = Modifier
                        .size(200.dp * pulseScale)
                        .background(Color(0xFFEF4444).copy(alpha = 0.15f), CircleShape)
                )
                // Middle Ripple
                Box(
                    modifier = Modifier
                        .size(170.dp * pulseScale)
                        .background(Color(0xFFDC2626).copy(alpha = 0.35f), CircleShape)
                )
                
                // Button
                Button(
                    onClick = {
                        val intent = Intent(Intent.ACTION_DIAL).apply {
                            data = Uri.parse("tel:112")
                        }
                        context.startActivity(intent)
                    },
                    modifier = Modifier.size(140.dp),
                    shape = CircleShape,
                    colors = ButtonDefaults.buttonColors(containerColor = Color(0xFFDC2626)),
                    elevation = ButtonDefaults.buttonElevation(defaultElevation = 12.dp)
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Icon(
                            imageVector = Icons.Default.Phone,
                            contentDescription = "Call 112",
                            modifier = Modifier.size(32.dp),
                            tint = Color(0xFFF8FAFC)
                        )
                        Text(
                            text = "112",
                            fontSize = 32.sp,
                            fontWeight = FontWeight.Black,
                            color = Color(0xFFF8FAFC),
                            letterSpacing = 2.sp
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))
            
            Text(
                text = "LLAMADA DE EMERGENCIA",
                color = Color(0xFFF8FAFC),
                fontWeight = FontWeight.Black,
                fontSize = 18.sp,
                letterSpacing = 3.sp
            )
            Text(
                text = "Presiona para conectar con el 112",
                color = Color(0xFF64748B),
                fontSize = 14.sp,
                letterSpacing = 0.5.sp
            )

            Spacer(modifier = Modifier.height(48.dp))

            // Grid of Tools
            Text(
                text = "HERRAMIENTAS R√ÅPIDAS",
                style = MaterialTheme.typography.labelSmall,
                color = Color(0xFF64748B),
                fontWeight = FontWeight.Bold,
                letterSpacing = 2.sp,
                modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp)
            )

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // Security
                SosToolCard(
                    title = "Seguridad",
                    icon = Icons.Default.Security,
                    color = Color(0xFF06B6D4), // NeonCyan
                    modifier = Modifier.weight(1f)
                ) {
                    val intent = Intent(Intent.ACTION_DIAL).apply {
                        data = Uri.parse("tel:+34934444444") // Dummy Internal Security Number
                    }
                    context.startActivity(intent)
                }
                
                // Share Location
                SosToolCard(
                    title = "Ubicaci√≥n",
                    icon = Icons.Default.Share,
                    color = Color(0xFF22C55E), // Green
                    modifier = Modifier.weight(1f)
                ) {
                    val intent = Intent(Intent.ACTION_SEND).apply {
                        type = "text/plain"
                        putExtra(Intent.EXTRA_TEXT, "¬°Ayuda! Emergencia en el Circuito. Mis coords: 41.5693, 2.2576")
                    }
                    context.startActivity(Intent.createChooser(intent, "Compartir Ubicaci√≥n"))
                }
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // Medical ID
                SosToolCard(
                    title = "Ficha M√©dica",
                    icon = Icons.Default.MedicalServices, // Or LocalHospital
                    color = Color(0xFFEF4444), // Red
                    modifier = Modifier.weight(1f)
                ) {
                   // üÜò Navegar a Lock Screen M√©dico
                   navController.navigate(com.georacing.georacing.ui.navigation.Screen.MedicalLockScreen.route)
                }
                
                // Flashlight
                SosToolCard(
                    title = "Linterna",
                    icon = if (flashlightOn) Icons.Default.FlashOn else Icons.Default.FlashOff,
                    color = if (flashlightOn) Color(0xFFF97316) else Color(0xFF64748B),
                    textColor = if (flashlightOn) Color(0xFF080810) else Color(0xFFE2E8F0),
                    modifier = Modifier.weight(1f)
                ) {
                    flashlightOn = !flashlightOn
                    // Toggle Flashlight Logic (Requires CameraManager, omitting for now to avoid permission crash complexity)
                }
            }
        }
    }
}

@Composable
fun SosToolCard(
    title: String,
    icon: ImageVector,
    color: Color,
    textColor: Color = Color.White,
    modifier: Modifier = Modifier,
    onClick: () -> Unit
) {
    Card(
        onClick = onClick,
        modifier = modifier.height(100.dp),
        colors = CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
        shape = RoundedCornerShape(16.dp)
    ) {
        Column(
            modifier = Modifier.fillMaxSize(),
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Box(
                modifier = Modifier
                    .size(40.dp)
                    .background(color.copy(alpha = 0.2f), CircleShape),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = icon,
                    contentDescription = title,
                    tint = color,
                    modifier = Modifier.size(24.dp)
                )
            }
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = title,
                fontSize = 14.sp,
                fontWeight = FontWeight.Bold,
                color = Color(0xFFE2E8F0),
                letterSpacing = 0.5.sp
            )
        }
    }
}

@androidx.compose.ui.tooling.preview.Preview
@Composable
fun EmergencyScreenPreview() {
    GeoRacingTheme {
        EmergencyScreen(navController = androidx.navigation.compose.rememberNavController())
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/fan/FanImmersiveScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.fan

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.*
import androidx.compose.animation.fadeIn
import androidx.compose.animation.slideInVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.components.HomeIconButton
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.*
import kotlinx.coroutines.delay

private data class DriverTelemetry(
    val position: Int,
    val number: Int,
    val name: String,
    val team: String,
    val teamColor: Color,
    val gap: String,
    val speed: Int,
    val tire: String,
    val tireAge: Int,
    val drs: Boolean = false,
    val sector1: String,
    val sector2: String,
    val sector3: String,
    val trackProgress: Float
)

/**
 * FanImmersiveScreen ‚Äî Premium F1 Live Telemetry HUD
 * Clasificaci√≥n en vivo con datos de pilotos simulados.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun FanImmersiveScreen(navController: NavController) {
    val backdrop = LocalBackdrop.current
    var isLive by remember { mutableStateOf(true) }
    var currentLap by remember { mutableIntStateOf(42) }
    val totalLaps = 66
    var showContent by remember { mutableStateOf(false) }
    LaunchedEffect(Unit) { showContent = true }

    // Simulated driver data for Circuit de Catalunya
    var drivers by remember {
        mutableStateOf(
            listOf(
                DriverTelemetry(1, 1, "M. Verstappen", "Red Bull Racing", Color(0xFF1E41FF), "LEADER", 312, "M", 18, true, "25.432", "28.871", "26.114", 0.78f),
                DriverTelemetry(2, 16, "C. Leclerc", "Ferrari", Color(0xFFE8002D), "+2.341", 308, "M", 18, false, "25.567", "28.912", "26.298", 0.73f),
                DriverTelemetry(3, 44, "L. Hamilton", "Ferrari", Color(0xFFE8002D), "+5.892", 305, "H", 24, false, "25.612", "29.001", "26.445", 0.68f),
                DriverTelemetry(4, 4, "L. Norris", "McLaren", Color(0xFFFF8000), "+8.124", 310, "M", 18, true, "25.501", "28.943", "26.332", 0.62f),
                DriverTelemetry(5, 81, "O. Piastri", "McLaren", Color(0xFFFF8000), "+9.567", 307, "M", 18, false, "25.589", "29.012", "26.401", 0.55f),
                DriverTelemetry(6, 63, "G. Russell", "Mercedes", Color(0xFF27F4D2), "+12.891", 306, "H", 30, false, "25.678", "29.098", "26.503", 0.48f),
                DriverTelemetry(7, 14, "F. Alonso", "Aston Martin", Color(0xFF229971), "+15.234", 303, "H", 30, false, "25.734", "29.145", "26.578", 0.42f),
                DriverTelemetry(8, 55, "C. Sainz", "Williams", Color(0xFF1868DB), "+17.891", 304, "M", 22, false, "25.789", "29.201", "26.623", 0.35f)
            )
        )
    }

    // Simulate live updates
    LaunchedEffect(isLive) {
        while (isLive) {
            delay(3000)
            drivers = drivers.map { d ->
                d.copy(
                    speed = d.speed + (-5..5).random(),
                    trackProgress = ((d.trackProgress + 0.02f) % 1.0f)
                )
            }
            if ((0..10).random() > 8) currentLap = (currentLap + 1).coerceAtMost(totalLaps)
        }
    }

    Box(Modifier.fillMaxSize()) {
        CarbonBackground()

        Column(Modifier.fillMaxSize()) {
            // ‚îÄ‚îÄ Premium LiquidTopBar ‚îÄ‚îÄ
            LiquidTopBar(
                backdrop = backdrop,
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Volver", tint = TextPrimary)
                    }
                },
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Box(Modifier.size(8.dp).clip(CircleShape).background(if (isLive) StatusRed else TextTertiary))
                        Spacer(Modifier.width(10.dp))
                        Column {
                            Text("F1 LIVE", style = MaterialTheme.typography.titleMedium, color = TextPrimary, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                            Text("Telemetr√≠a en directo", style = MaterialTheme.typography.labelSmall, color = TextTertiary)
                        }
                    }
                },
                actions = {
                    // Live toggle
                    IconButton(onClick = { isLive = !isLive }) {
                        Icon(
                            if (isLive) Icons.Default.Pause else Icons.Default.PlayArrow,
                            if (isLive) "Pausar" else "Reanudar",
                            tint = if (isLive) StatusGreen else TextTertiary
                        )
                    }
                    HomeIconButton { navController.navigate(Screen.Home.route) { popUpTo(Screen.Home.route) { inclusive = true } } }
                }
            )

            LazyColumn(
                modifier = Modifier.fillMaxSize().padding(horizontal = 12.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp),
                contentPadding = PaddingValues(bottom = 100.dp)
            ) {
                // ‚îÄ‚îÄ Circuit Location ‚îÄ‚îÄ
                item {
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(400)) + slideInVertically(tween(400)) { -15 }
                    ) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier
                                .clip(RoundedCornerShape(20.dp))
                                .background(RacingRed.copy(alpha = 0.1f))
                                .padding(horizontal = 12.dp, vertical = 6.dp)
                        ) {
                            Icon(Icons.Default.LocationOn, null, tint = RacingRed, modifier = Modifier.size(14.dp))
                            Spacer(Modifier.width(6.dp))
                            Text("Circuit de Barcelona-Catalunya", style = MaterialTheme.typography.labelSmall, color = TextSecondary, letterSpacing = 0.5.sp)
                        }
                    }
                    Spacer(Modifier.height(8.dp))
                }

                // ‚îÄ‚îÄ Race Status Card ‚îÄ‚îÄ
                item {
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(500, 100)) + slideInVertically(tween(500, 100)) { 30 }
                    ) {
                        Box(
                            Modifier
                                .fillMaxWidth()
                                .clip(RoundedCornerShape(20.dp))
                                .liquidGlass(RoundedCornerShape(20.dp), GlassLevel.L3, accentGlow = RacingRed)
                        ) {
                            Column(Modifier.padding(18.dp)) {
                                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                                    Column {
                                        Text("VUELTA", style = MaterialTheme.typography.labelSmall, color = TextTertiary, letterSpacing = 2.sp, fontWeight = FontWeight.Bold)
                                        Text(
                                            "$currentLap / $totalLaps",
                                            style = MaterialTheme.typography.headlineMedium.copy(
                                                fontWeight = FontWeight.Black,
                                                fontFamily = FontFamily.Monospace
                                            ),
                                            color = TextPrimary
                                        )
                                    }
                                    Column(horizontalAlignment = Alignment.End) {
                                        Text("BANDERA", style = MaterialTheme.typography.labelSmall, color = TextTertiary, letterSpacing = 2.sp, fontWeight = FontWeight.Bold)
                                        Row(verticalAlignment = Alignment.CenterVertically) {
                                            Box(
                                                Modifier
                                                    .size(10.dp)
                                                    .clip(CircleShape)
                                                    .background(StatusGreen)
                                                    .drawBehind {
                                                        drawCircle(StatusGreen.copy(alpha = 0.3f), radius = size.minDimension)
                                                    }
                                            )
                                            Spacer(Modifier.width(6.dp))
                                            Text("VERDE", style = MaterialTheme.typography.titleMedium, color = StatusGreen, fontWeight = FontWeight.Black)
                                        }
                                    }
                                }
                                Spacer(Modifier.height(14.dp))

                                // Premium lap progress
                                Box(
                                    Modifier
                                        .fillMaxWidth()
                                        .height(6.dp)
                                        .clip(RoundedCornerShape(3.dp))
                                        .background(AsphaltGrey)
                                ) {
                                    Box(
                                        Modifier
                                            .fillMaxWidth(currentLap.toFloat() / totalLaps)
                                            .fillMaxHeight()
                                            .clip(RoundedCornerShape(3.dp))
                                            .background(
                                                Brush.horizontalGradient(listOf(RacingRed, Color(0xFFFF6B35)))
                                            )
                                    )
                                }

                                Spacer(Modifier.height(10.dp))
                                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
                                    Row(verticalAlignment = Alignment.CenterVertically) {
                                        Box(
                                            Modifier
                                                .clip(RoundedCornerShape(4.dp))
                                                .background(StatusGreen.copy(alpha = 0.12f))
                                                .padding(horizontal = 6.dp, vertical = 2.dp)
                                        ) {
                                            Text("DRS ACTIVO", fontSize = 9.sp, color = StatusGreen, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                                        }
                                        Spacer(Modifier.width(6.dp))
                                        Text("Zona 1", fontSize = 10.sp, color = TextTertiary)
                                    }
                                    Row(verticalAlignment = Alignment.CenterVertically) {
                                        Text("Vuelta r√°pida: ", fontSize = 10.sp, color = TextTertiary)
                                        Text("1:19.432", fontSize = 10.sp, color = NeonPurple, fontWeight = FontWeight.Bold, fontFamily = FontFamily.Monospace)
                                    }
                                }
                            }
                        }
                    }
                }

                // ‚îÄ‚îÄ Column Headers ‚îÄ‚îÄ
                item {
                    Spacer(Modifier.height(4.dp))
                    Row(Modifier.fillMaxWidth().padding(horizontal = 8.dp)) {
                        Text("POS", Modifier.width(32.dp), fontSize = 9.sp, color = TextTertiary, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                        Text("PILOTO", Modifier.weight(1f), fontSize = 9.sp, color = TextTertiary, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                        Text("GAP", Modifier.width(64.dp), fontSize = 9.sp, color = TextTertiary, fontWeight = FontWeight.Black, textAlign = TextAlign.End, letterSpacing = 1.sp)
                        Text("VEL", Modifier.width(48.dp), fontSize = 9.sp, color = TextTertiary, fontWeight = FontWeight.Black, textAlign = TextAlign.End, letterSpacing = 1.sp)
                        Text("NEUM", Modifier.width(40.dp), fontSize = 9.sp, color = TextTertiary, fontWeight = FontWeight.Black, textAlign = TextAlign.End, letterSpacing = 1.sp)
                    }
                }

                // ‚îÄ‚îÄ Driver Rows ‚îÄ‚îÄ
                itemsIndexed(drivers) { index, driver ->
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(300, 250 + index * 50)) + slideInVertically(tween(300, 250 + index * 50)) { 20 }
                    ) {
                        PremiumDriverRow(driver)
                    }
                }

                // ‚îÄ‚îÄ Sectors Comparison ‚îÄ‚îÄ
                item {
                    Spacer(Modifier.height(8.dp))
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(500, 700)) + slideInVertically(tween(500, 700)) { 20 }
                    ) {
                        Box(
                            Modifier
                                .fillMaxWidth()
                                .clip(RoundedCornerShape(18.dp))
                                .liquidGlass(RoundedCornerShape(18.dp), GlassLevel.L2, accentGlow = NeonPurple)
                        ) {
                            Column(Modifier.padding(18.dp)) {
                                Text("SECTORES ‚Äî L√çDER", style = MaterialTheme.typography.labelSmall, color = TextTertiary, letterSpacing = 2.sp, fontWeight = FontWeight.Black)
                                Spacer(Modifier.height(14.dp))
                                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                                    PremiumSectorBlock("S1", drivers[0].sector1, StatusGreen)
                                    PremiumSectorBlock("S2", drivers[0].sector2, NeonPurple)
                                    PremiumSectorBlock("S3", drivers[0].sector3, StatusAmber)
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚îÄ‚îÄ Premium Composables ‚îÄ‚îÄ
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumDriverRow(driver: DriverTelemetry) {
    val isTopThree = driver.position <= 3
    val positionColor = when (driver.position) {
        1 -> ChampagneGold
        2 -> Color(0xFFC0C0C0)
        3 -> Color(0xFFCD7F32)
        else -> TextPrimary
    }

    Box(
        Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(12.dp))
            .liquidGlass(
                RoundedCornerShape(12.dp),
                if (isTopThree) GlassLevel.L2 else GlassLevel.L1,
                accentGlow = if (isTopThree) driver.teamColor else Color.Transparent
            )
    ) {
        Row(
            Modifier.fillMaxWidth().padding(horizontal = 10.dp, vertical = 10.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Position
            Text(
                "${driver.position}",
                modifier = Modifier.width(28.dp),
                style = MaterialTheme.typography.titleMedium.copy(
                    fontWeight = FontWeight.Black,
                    fontFamily = FontFamily.Monospace
                ),
                color = positionColor
            )

            // Team color bar
            Box(
                Modifier
                    .width(3.dp)
                    .height(28.dp)
                    .clip(RoundedCornerShape(2.dp))
                    .background(driver.teamColor)
            )
            Spacer(Modifier.width(8.dp))

            // Name
            Column(Modifier.weight(1f)) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text("#${driver.number}", fontSize = 10.sp, color = driver.teamColor, fontWeight = FontWeight.Bold)
                    Spacer(Modifier.width(4.dp))
                    Text(driver.name, style = MaterialTheme.typography.bodySmall, color = TextPrimary, fontWeight = FontWeight.Bold, maxLines = 1)
                }
                Text(driver.team, fontSize = 9.sp, color = TextTertiary, maxLines = 1)
            }

            // Gap
            Text(
                driver.gap,
                modifier = Modifier.width(64.dp),
                style = MaterialTheme.typography.labelMedium.copy(fontFamily = FontFamily.Monospace),
                color = if (driver.position == 1) RacingRed else TextSecondary,
                textAlign = TextAlign.End,
                fontWeight = FontWeight.Bold
            )

            // Speed
            Text(
                "${driver.speed}",
                modifier = Modifier.width(44.dp),
                style = MaterialTheme.typography.labelMedium.copy(fontFamily = FontFamily.Monospace),
                color = TextPrimary,
                textAlign = TextAlign.End
            )

            // Tire
            Spacer(Modifier.width(4.dp))
            val tireColor = when (driver.tire) {
                "S" -> StatusRed
                "M" -> StatusAmber
                "H" -> TextPrimary
                else -> TextTertiary
            }
            Box(
                Modifier
                    .clip(RoundedCornerShape(4.dp))
                    .background(tireColor.copy(alpha = 0.15f))
                    .padding(horizontal = 4.dp, vertical = 1.dp)
            ) {
                Text(driver.tire, fontSize = 10.sp, color = tireColor, fontWeight = FontWeight.Black, textAlign = TextAlign.Center)
            }
            Text("${driver.tireAge}", fontSize = 8.sp, color = TextTertiary, modifier = Modifier.width(16.dp), textAlign = TextAlign.End)

            // DRS indicator
            if (driver.drs) {
                Spacer(Modifier.width(4.dp))
                Box(
                    Modifier
                        .clip(RoundedCornerShape(4.dp))
                        .background(StatusGreen.copy(alpha = 0.15f))
                        .padding(horizontal = 3.dp, vertical = 1.dp)
                ) {
                    Text("DRS", fontSize = 8.sp, color = StatusGreen, fontWeight = FontWeight.Black)
                }
            }
        }
    }
}

@Composable
private fun PremiumSectorBlock(label: String, time: String, color: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Box(
            Modifier
                .clip(RoundedCornerShape(6.dp))
                .background(color.copy(alpha = 0.12f))
                .padding(horizontal = 8.dp, vertical = 3.dp)
        ) {
            Text(label, style = MaterialTheme.typography.labelSmall, color = color, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
        }
        Spacer(Modifier.height(6.dp))
        Text(
            time,
            style = MaterialTheme.typography.titleMedium.copy(fontFamily = FontFamily.Monospace),
            color = TextPrimary,
            fontWeight = FontWeight.Bold
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/fan/FanZoneScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.fan

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.components.HomeIconButton
import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.*
import kotlinx.coroutines.delay

// ‚îÄ‚îÄ Team data model ‚îÄ‚îÄ
private data class RacingTeam(
    val id: String,
    val name: String,
    val series: String, // "F1" or "MotoGP"
    val primaryColor: Color,
    val secondaryColor: Color,
    val icon: String
)

// ‚îÄ‚îÄ Trivia question model ‚îÄ‚îÄ
private data class TriviaQuestion(
    val question: String,
    val options: List<String>,
    val correctIndex: Int,
    val category: String
)

private val allTeams = listOf(
    // F1
    RacingTeam("ferrari", "Ferrari", "F1", Color(0xFFDC0000), Color(0xFFFFF200), "üèéÔ∏è"),
    RacingTeam("redbull", "Red Bull Racing", "F1", Color(0xFF1E41FF), Color(0xFFFFD700), "üêÇ"),
    RacingTeam("mercedes", "Mercedes-AMG", "F1", Color(0xFF00D2BE), Color(0xFFC0C0C0), "‚≠ê"),
    RacingTeam("mclaren", "McLaren", "F1", Color(0xFFFF8700), Color(0xFF47C7FC), "üß°"),
    RacingTeam("astonmartin", "Aston Martin", "F1", Color(0xFF006F62), Color(0xFFC6FF00), "üíö"),
    RacingTeam("alpine", "Alpine", "F1", Color(0xFF0090FF), Color(0xFFFF69B4), "üîµ"),
    RacingTeam("williams", "Williams", "F1", Color(0xFF005AFF), Color(0xFF00A0DE), "üèÅ"),
    RacingTeam("haas", "Haas F1 Team", "F1", Color(0xFFB6BABD), Color(0xFFE10600), "üá∫üá∏"),
    RacingTeam("sauber", "Kick Sauber", "F1", Color(0xFF52E252), Color(0xFF000000), "üü¢"),
    RacingTeam("racingbulls", "RB", "F1", Color(0xFF6692FF), Color(0xFFED1A3B), "üî∑"),
    // MotoGP
    RacingTeam("ducati", "Ducati Lenovo", "MotoGP", Color(0xFFCC0000), Color(0xFFFFFFFF), "üèçÔ∏è"),
    RacingTeam("yamaha", "Monster Yamaha", "MotoGP", Color(0xFF0C4DA2), Color(0xFF000000), "üíô"),
    RacingTeam("honda", "Repsol Honda", "MotoGP", Color(0xFFFF6A13), Color(0xFFCC0000), "üî∂"),
    RacingTeam("ktm", "Red Bull KTM", "MotoGP", Color(0xFFFF6900), Color(0xFF1E1E2E), "üß°"),
    RacingTeam("aprilia", "Aprilia Racing", "MotoGP", Color(0xFF9B0000), Color(0xFF000000), "üè¥")
)

private val triviaQuestions = listOf(
    TriviaQuestion("¬øCu√°ntas curvas tiene el Circuit de Barcelona-Catalunya?", listOf("14", "16", "12", "18"), 1, "Circuito"),
    TriviaQuestion("¬øEn qu√© a√±o se inaugur√≥ el Circuito de Montmel√≥?", listOf("1989", "1991", "1985", "1993"), 1, "Historia"),
    TriviaQuestion("¬øCu√°l es la velocidad m√°xima estimada en la recta principal?", listOf("280 km/h", "310 km/h", "340 km/h", "360 km/h"), 2, "Datos"),
    TriviaQuestion("¬øQu√© piloto tiene m√°s victorias en Montmel√≥?", listOf("Hamilton", "Schumacher", "Alonso", "Vettel"), 1, "Pilotos"),
    TriviaQuestion("¬øCu√°l es la longitud del circuito de Montmel√≥?", listOf("3.9 km", "4.2 km", "4.6 km", "5.1 km"), 2, "Circuito"),
    TriviaQuestion("¬øQu√© significa DRS en F1?", listOf("Drag Reduction System", "Drive Recovery System", "Dynamic Racing Speed", "Double Rate Shift"), 0, "T√©cnica"),
    TriviaQuestion("¬øCu√°ntos GP de Espa√±a se han celebrado en Montmel√≥?", listOf("M√°s de 20", "M√°s de 30", "M√°s de 15", "M√°s de 25"), 1, "Historia"),
    TriviaQuestion("¬øQu√© tipo de neum√°tico es el m√°s blando en F1?", listOf("Duro", "Medio", "Blando", "Intermedio"), 2, "T√©cnica")
)

/**
 * FanZoneScreen ‚Äî Premium Fan Experience.
 * Mirrors iOS: FanZoneView.swift
 *
 * Features:
 * - Series selector (F1 / MotoGP)
 * - Team selection with team-colored theming
 * - Interactive trivia
 * - Team news section
 * - Collectibles preview
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun FanZoneScreen(navController: NavController) {
    val backdrop = LocalBackdrop.current

    // State
    var selectedSeries by remember { mutableStateOf("F1") }
    var selectedTeam by remember { mutableStateOf<RacingTeam?>(null) }
    var showTeamSelector by remember { mutableStateOf(false) }
    var showContent by remember { mutableStateOf(false) }

    // Trivia state
    var currentQuestionIndex by remember { mutableIntStateOf(0) }
    var selectedAnswer by remember { mutableIntStateOf(-1) }
    var triviaScore by remember { mutableIntStateOf(0) }
    var answeredCount by remember { mutableIntStateOf(0) }
    var showTriviaResult by remember { mutableStateOf(false) }

    val currentQuestion = triviaQuestions[currentQuestionIndex]
    val teamColor = selectedTeam?.primaryColor ?: RacingRed

    LaunchedEffect(Unit) {
        delay(150)
        showContent = true
    }

    Box(Modifier.fillMaxSize()) {
        CarbonBackground()

        Scaffold(
            containerColor = Color.Transparent,
            topBar = {
                LiquidTopBar(
                    backdrop = backdrop,
                    navigationIcon = {
                        IconButton(onClick = { navController.popBackStack() }) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Volver", tint = TextPrimary)
                        }
                    },
                    title = {
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            Box(Modifier.size(8.dp).clip(CircleShape).background(teamColor))
                            Spacer(Modifier.width(10.dp))
                            Column {
                                Text("FAN ZONE", style = MaterialTheme.typography.titleMedium, color = TextPrimary, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                                Text(selectedTeam?.name ?: "Elige tu equipo", style = MaterialTheme.typography.labelSmall, color = TextTertiary)
                            }
                        }
                    },
                    actions = {
                        // Team selector button
                        IconButton(onClick = { showTeamSelector = true }) {
                            Icon(
                                Icons.Default.SportsMotorsports,
                                "Seleccionar equipo",
                                tint = teamColor
                            )
                        }
                        HomeIconButton {
                            navController.navigate(Screen.Home.route) {
                                popUpTo(Screen.Home.route) { inclusive = true }
                            }
                        }
                    }
                )
            }
        ) { padding ->
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
                    .padding(horizontal = 16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp),
                contentPadding = PaddingValues(bottom = 100.dp, top = 8.dp)
            ) {
                // ‚îÄ‚îÄ Series Selector ‚îÄ‚îÄ
                item {
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(300)) + slideInVertically(tween(300)) { -20 }
                    ) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            listOf("F1", "MotoGP").forEach { series ->
                                val isSelected = selectedSeries == series
                                Box(
                                    modifier = Modifier
                                        .weight(1f)
                                        .clip(RoundedCornerShape(14.dp))
                                        .background(
                                            if (isSelected) teamColor.copy(alpha = 0.2f)
                                            else AsphaltGrey.copy(alpha = 0.5f)
                                        )
                                        .border(
                                            1.dp,
                                            if (isSelected) teamColor.copy(alpha = 0.5f) else Color.Transparent,
                                            RoundedCornerShape(14.dp)
                                        )
                                        .clickable { selectedSeries = series }
                                        .padding(vertical = 14.dp),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Text(
                                        series,
                                        fontWeight = FontWeight.Black,
                                        letterSpacing = 1.sp,
                                        color = if (isSelected) TextPrimary else TextTertiary
                                    )
                                }
                            }
                        }
                    }
                }

                // ‚îÄ‚îÄ Team Selection (Horizontal scroll) ‚îÄ‚îÄ
                item {
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(400, 100)) + slideInVertically(tween(400, 100)) { -20 }
                    ) {
                        Column {
                            Text(
                                "TU EQUIPO",
                                style = MaterialTheme.typography.labelMedium,
                                color = TextTertiary,
                                letterSpacing = 2.sp
                            )
                            Spacer(Modifier.height(10.dp))
                            LazyRow(
                                horizontalArrangement = Arrangement.spacedBy(10.dp)
                            ) {
                                items(allTeams.filter { it.series == selectedSeries }) { team ->
                                    val isSelected = selectedTeam?.id == team.id
                                    Box(
                                        modifier = Modifier
                                            .clip(RoundedCornerShape(14.dp))
                                            .background(
                                                if (isSelected)
                                                    Brush.horizontalGradient(listOf(team.primaryColor.copy(alpha = 0.3f), team.secondaryColor.copy(alpha = 0.15f)))
                                                else
                                                    Brush.horizontalGradient(listOf(AsphaltGrey.copy(alpha = 0.4f), AsphaltGrey.copy(alpha = 0.3f)))
                                            )
                                            .border(
                                                if (isSelected) 1.5.dp else 0.5.dp,
                                                if (isSelected) team.primaryColor.copy(alpha = 0.7f) else MetalGrey.copy(alpha = 0.3f),
                                                RoundedCornerShape(14.dp)
                                            )
                                            .clickable { selectedTeam = team }
                                            .padding(horizontal = 16.dp, vertical = 12.dp)
                                    ) {
                                        Row(verticalAlignment = Alignment.CenterVertically) {
                                            Text(team.icon, fontSize = 18.sp)
                                            Spacer(Modifier.width(8.dp))
                                            Text(
                                                team.name,
                                                style = MaterialTheme.typography.labelMedium,
                                                fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal,
                                                color = if (isSelected) TextPrimary else TextSecondary,
                                                maxLines = 1
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // ‚îÄ‚îÄ Trivia Section ‚îÄ‚îÄ
                item {
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(500, 200)) + slideInVertically(tween(500, 200)) { -20 }
                    ) {
                        LiquidCard(
                            backdrop = backdrop,
                            modifier = Modifier.fillMaxWidth(),
                            cornerRadius = 20.dp,
                            surfaceColor = CarbonBlack.copy(alpha = 0.85f),
                            tint = teamColor.copy(alpha = 0.08f)
                        ) {
                            Column(modifier = Modifier.padding(20.dp)) {
                                Row(verticalAlignment = Alignment.CenterVertically) {
                                    Icon(Icons.Default.QuestionMark, null, tint = teamColor, modifier = Modifier.size(24.dp))
                                    Spacer(Modifier.width(10.dp))
                                    Text("TRIVIA DEL CIRCUITO", style = MaterialTheme.typography.titleSmall, fontWeight = FontWeight.Black, color = TextPrimary, letterSpacing = 1.sp)
                                    Spacer(Modifier.weight(1f))
                                    Text(
                                        "${currentQuestionIndex + 1}/${triviaQuestions.size}",
                                        style = MaterialTheme.typography.labelSmall,
                                        color = TextTertiary
                                    )
                                }

                                Spacer(Modifier.height(16.dp))

                                // Category badge
                                Box(
                                    Modifier
                                        .clip(RoundedCornerShape(8.dp))
                                        .background(teamColor.copy(alpha = 0.15f))
                                        .padding(horizontal = 10.dp, vertical = 4.dp)
                                ) {
                                    Text(currentQuestion.category.uppercase(), style = MaterialTheme.typography.labelSmall, color = teamColor, letterSpacing = 1.sp, fontWeight = FontWeight.Bold)
                                }

                                Spacer(Modifier.height(14.dp))

                                Text(
                                    currentQuestion.question,
                                    style = MaterialTheme.typography.bodyLarge,
                                    fontWeight = FontWeight.Bold,
                                    color = TextPrimary
                                )

                                Spacer(Modifier.height(16.dp))

                                // 2x2 Answer grid (like iOS)
                                Column(verticalArrangement = Arrangement.spacedBy(10.dp)) {
                                    for (row in 0..1) {
                                        Row(
                                            modifier = Modifier.fillMaxWidth(),
                                            horizontalArrangement = Arrangement.spacedBy(10.dp)
                                        ) {
                                            for (col in 0..1) {
                                                val idx = row * 2 + col
                                                if (idx < currentQuestion.options.size) {
                                                    val isCorrect = idx == currentQuestion.correctIndex
                                                    val isSelectedOption = selectedAnswer == idx
                                                    val bgColor = when {
                                                        selectedAnswer == -1 -> AsphaltGrey.copy(alpha = 0.6f)
                                                        isCorrect -> StatusGreen.copy(alpha = 0.25f)
                                                        isSelectedOption -> StatusRed.copy(alpha = 0.25f)
                                                        else -> AsphaltGrey.copy(alpha = 0.3f)
                                                    }
                                                    val borderColor = when {
                                                        selectedAnswer == -1 -> MetalGrey.copy(alpha = 0.3f)
                                                        isCorrect -> StatusGreen.copy(alpha = 0.6f)
                                                        isSelectedOption -> StatusRed.copy(alpha = 0.6f)
                                                        else -> Color.Transparent
                                                    }

                                                    Box(
                                                        modifier = Modifier
                                                            .weight(1f)
                                                            .clip(RoundedCornerShape(12.dp))
                                                            .background(bgColor)
                                                            .border(1.dp, borderColor, RoundedCornerShape(12.dp))
                                                            .clickable(enabled = selectedAnswer == -1) {
                                                                selectedAnswer = idx
                                                                answeredCount++
                                                                if (isCorrect) triviaScore++
                                                                showTriviaResult = true
                                                            }
                                                            .padding(12.dp),
                                                        contentAlignment = Alignment.Center
                                                    ) {
                                                        Text(
                                                            currentQuestion.options[idx],
                                                            style = MaterialTheme.typography.bodyMedium,
                                                            fontWeight = FontWeight.Medium,
                                                            color = TextPrimary,
                                                            textAlign = TextAlign.Center
                                                        )
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                // Result & Next
                                AnimatedVisibility(visible = showTriviaResult) {
                                    Column {
                                        Spacer(Modifier.height(14.dp))
                                        Row(
                                            modifier = Modifier.fillMaxWidth(),
                                            horizontalArrangement = Arrangement.SpaceBetween,
                                            verticalAlignment = Alignment.CenterVertically
                                        ) {
                                            Text(
                                                if (selectedAnswer == currentQuestion.correctIndex) "‚úÖ ¬°Correcto!" else "‚ùå Incorrecto",
                                                style = MaterialTheme.typography.bodyMedium,
                                                fontWeight = FontWeight.Bold,
                                                color = if (selectedAnswer == currentQuestion.correctIndex) StatusGreen else StatusRed
                                            )
                                            TextButton(onClick = {
                                                currentQuestionIndex = (currentQuestionIndex + 1) % triviaQuestions.size
                                                selectedAnswer = -1
                                                showTriviaResult = false
                                            }) {
                                                Text("Siguiente ‚Üí", color = teamColor, fontWeight = FontWeight.Bold)
                                            }
                                        }
                                        // Score
                                        Text(
                                            "Puntuaci√≥n: $triviaScore/$answeredCount",
                                            style = MaterialTheme.typography.labelSmall,
                                            color = TextTertiary
                                        )
                                    }
                                }
                            }
                        }
                    }
                }

                // ‚îÄ‚îÄ Team News Section ‚îÄ‚îÄ
                item {
                    AnimatedVisibility(
                        visible = showContent && selectedTeam != null,
                        enter = fadeIn(tween(500, 300)) + slideInVertically(tween(500, 300)) { -20 }
                    ) {
                        Column {
                            Text(
                                "NOTICIAS ${selectedTeam?.name?.uppercase() ?: ""}",
                                style = MaterialTheme.typography.labelMedium,
                                color = TextTertiary,
                                letterSpacing = 2.sp
                            )
                            Spacer(Modifier.height(10.dp))

                            // Mock team news (like iOS)
                            val teamNews = listOf(
                                "Resultados del √∫ltimo GP: ${selectedTeam?.name} destaca en clasificaci√≥n",
                                "Nuevas mejoras aerodin√°micas confirmadas para Barcelona",
                                "Entrevista exclusiva con el equipo t√©cnico"
                            )

                            teamNews.forEachIndexed { idx, title ->
                                LiquidCard(
                                    backdrop = backdrop,
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .padding(vertical = 4.dp),
                                    cornerRadius = 14.dp,
                                    surfaceColor = AsphaltGrey.copy(alpha = 0.7f),
                                    tint = teamColor.copy(alpha = 0.06f)
                                ) {
                                    Row(
                                        modifier = Modifier.padding(14.dp),
                                        verticalAlignment = Alignment.CenterVertically
                                    ) {
                                        Box(
                                            modifier = Modifier
                                                .size(36.dp)
                                                .clip(RoundedCornerShape(10.dp))
                                                .background(teamColor.copy(alpha = 0.15f)),
                                            contentAlignment = Alignment.Center
                                        ) {
                                            Icon(
                                                when (idx) {
                                                    0 -> Icons.Default.EmojiEvents
                                                    1 -> Icons.Default.Build
                                                    else -> Icons.Default.Mic
                                                },
                                                contentDescription = null,
                                                tint = teamColor,
                                                modifier = Modifier.size(20.dp)
                                            )
                                        }
                                        Spacer(Modifier.width(12.dp))
                                        Column(modifier = Modifier.weight(1f)) {
                                            Text(
                                                title,
                                                style = MaterialTheme.typography.bodyMedium,
                                                fontWeight = FontWeight.Medium,
                                                color = TextPrimary,
                                                maxLines = 2
                                            )
                                            Text(
                                                "Hace ${idx + 1}h",
                                                style = MaterialTheme.typography.labelSmall,
                                                color = TextTertiary
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // ‚îÄ‚îÄ Collectibles Preview ‚îÄ‚îÄ
                item {
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(500, 400)) + slideInVertically(tween(500, 400)) { -20 }
                    ) {
                        Column {
                            Text(
                                "COLECCIONABLES",
                                style = MaterialTheme.typography.labelMedium,
                                color = TextTertiary,
                                letterSpacing = 2.sp
                            )
                            Spacer(Modifier.height(10.dp))
                            LazyRow(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                                items(3) { idx ->
                                    LiquidCard(
                                        backdrop = backdrop,
                                        modifier = Modifier.size(120.dp),
                                        cornerRadius = 16.dp,
                                        surfaceColor = AsphaltGrey.copy(alpha = 0.6f),
                                        tint = teamColor.copy(alpha = 0.1f)
                                    ) {
                                        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                                Icon(
                                                    Icons.Default.Lock,
                                                    contentDescription = null,
                                                    tint = TextTertiary,
                                                    modifier = Modifier.size(32.dp)
                                                )
                                                Spacer(Modifier.height(6.dp))
                                                Text(
                                                    "Caja Secreta",
                                                    style = MaterialTheme.typography.labelSmall,
                                                    color = TextTertiary,
                                                    fontWeight = FontWeight.Bold
                                                )
                                                Text(
                                                    "#${idx + 1}",
                                                    style = MaterialTheme.typography.labelSmall,
                                                    color = teamColor
                                                )
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // ‚îÄ‚îÄ Team Selector Bottom Sheet ‚îÄ‚îÄ
        if (showTeamSelector) {
            TeamSelectorSheet(
                selectedSeries = selectedSeries,
                selectedTeam = selectedTeam,
                onSeriesChange = { selectedSeries = it },
                onTeamSelected = { team ->
                    selectedTeam = team
                    showTeamSelector = false
                },
                onDismiss = { showTeamSelector = false }
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun TeamSelectorSheet(
    selectedSeries: String,
    selectedTeam: RacingTeam?,
    onSeriesChange: (String) -> Unit,
    onTeamSelected: (RacingTeam) -> Unit,
    onDismiss: () -> Unit
) {
    val sheetState = rememberModalBottomSheetState()
    ModalBottomSheet(
        onDismissRequest = onDismiss,
        sheetState = sheetState,
        containerColor = CarbonBlack,
        contentColor = TextPrimary
    ) {
        Column(modifier = Modifier.padding(24.dp)) {
            Text(
                "SELECCIONA TU EQUIPO",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Black,
                color = TextPrimary,
                letterSpacing = 1.sp
            )
            Spacer(Modifier.height(16.dp))

            // Series toggle
            Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                listOf("F1", "MotoGP").forEach { series ->
                    FilterChip(
                        selected = selectedSeries == series,
                        onClick = { onSeriesChange(series) },
                        label = { Text(series, fontWeight = FontWeight.Bold) },
                        colors = FilterChipDefaults.filterChipColors(
                            selectedContainerColor = RacingRed.copy(alpha = 0.2f),
                            selectedLabelColor = TextPrimary
                        )
                    )
                }
            }

            Spacer(Modifier.height(16.dp))

            allTeams.filter { it.series == selectedSeries }.forEach { team ->
                val isSelected = selectedTeam?.id == team.id
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .clip(RoundedCornerShape(12.dp))
                        .background(if (isSelected) team.primaryColor.copy(alpha = 0.15f) else Color.Transparent)
                        .clickable { onTeamSelected(team) }
                        .padding(horizontal = 14.dp, vertical = 12.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(team.icon, fontSize = 22.sp)
                    Spacer(Modifier.width(14.dp))
                    Text(
                        team.name,
                        style = MaterialTheme.typography.bodyLarge,
                        fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal,
                        color = TextPrimary
                    )
                    Spacer(Modifier.weight(1f))
                    if (isSelected) {
                        Icon(Icons.Default.CheckCircle, null, tint = team.primaryColor)
                    }
                }
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/group/GroupMapScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.group

import android.Manifest
import android.content.pm.PackageManager
import android.content.Context
import android.os.Bundle
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.MyLocation
import androidx.compose.material.icons.filled.List
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.content.ContextCompat
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import androidx.navigation.NavController
import com.georacing.georacing.data.map.MapLibreConfig
import com.georacing.georacing.data.model.GroupMemberLocation
import com.georacing.georacing.data.repository.NetworkGroupRepository
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.components.HomeIconButton
import com.google.android.gms.location.LocationServices
import org.maplibre.android.MapLibre
import org.maplibre.android.camera.CameraPosition
import org.maplibre.android.geometry.LatLng
import org.maplibre.android.maps.MapView
import org.maplibre.android.maps.MapLibreMap
import org.maplibre.android.maps.Style
import org.maplibre.android.annotations.MarkerOptions
import org.maplibre.android.style.sources.GeoJsonSource
import org.maplibre.android.style.layers.LineLayer
import org.maplibre.android.style.layers.CircleLayer
import org.maplibre.android.style.layers.PropertyFactory
import org.maplibre.android.location.LocationComponentActivationOptions
import org.maplibre.android.location.modes.CameraMode
import org.maplibre.android.location.modes.RenderMode
import java.net.URI

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun GroupMapScreen(
    navController: NavController,
    viewModel: GroupMapViewModel
) {
    val context = LocalContext.current
    
    val groupLocations by viewModel.groupLocations.collectAsState()
    val errorMessage by viewModel.errorMessage.collectAsState()
    val hasLocationPermission by viewModel.hasLocationPermission.collectAsState()
    var showMembersSheet by remember { mutableStateOf(false) }
    var focusMember by remember { mutableStateOf<GroupMemberLocation?>(null) }
    
    // Estado para centrar el mapa en mi ubicaci√≥n
    var shouldCenterOnMyLocation by remember { mutableStateOf(false) }

    // Launcher para solicitar permisos
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        val granted = permissions[Manifest.permission.ACCESS_FINE_LOCATION] == true ||
                      permissions[Manifest.permission.ACCESS_COARSE_LOCATION] == true
        if (granted) {
            Log.d("GroupMapScreen", "Permisos de ubicaci√≥n concedidos")
            viewModel.checkLocationPermission(context)
        } else {
            Log.d("GroupMapScreen", "Permisos de ubicaci√≥n denegados")
        }
    }
    
    // Inicializar MapLibre una sola vez al entrar a la pantalla
    DisposableEffect(Unit) {
        try {
            MapLibre.getInstance(context)
            Log.d("GroupMapScreen", "MapLibre inicializado")
        } catch (e: Exception) {
            Log.e("GroupMapScreen", "Error inicializando MapLibre", e)
        }
        
        viewModel.checkLocationPermission(context)
        
        // Obtener el ID del grupo activo de las preferencias
        val prefs = context.getSharedPreferences("georacing_prefs", android.content.Context.MODE_PRIVATE)
        val activeGroupId = prefs.getString("active_group_id", null)
        
        if (activeGroupId != null) {
            viewModel.startListeningGroupLocations(activeGroupId, context)
        } else {
            Log.d("GroupMapScreen", "Sin grupo activo; no se inicia listener")
        }
        
        onDispose {
            Log.d("GroupMapScreen", "GroupMapScreen disposed")
        }
    }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Mapa del Grupo") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Atr√°s")
                    }
                },
                actions = {
                    HomeIconButton {
                        navController.navigate(Screen.Home.route) {
                            popUpTo(Screen.Home.route) { inclusive = true }
                        }
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.surface
                )
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = { 
                    if (hasLocationPermission) {
                        shouldCenterOnMyLocation = true
                        viewModel.getMyCurrentLocation(context) { lat, lng ->
                            Log.d("GroupMapScreen", "Ubicaci√≥n obtenida: ($lat, $lng)")
                        }
                    } else {
                        // Solicitar permisos
                        permissionLauncher.launch(
                            arrayOf(
                                Manifest.permission.ACCESS_FINE_LOCATION,
                                Manifest.permission.ACCESS_COARSE_LOCATION
                            )
                        )
                    }
                },
                containerColor = MaterialTheme.colorScheme.primaryContainer
            ) {
                Icon(Icons.Default.MyLocation, contentDescription = "Mi ubicaci√≥n")
            }
        }
    ) { innerPadding ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
        ) {
            // Mapa con MapLibre
            MapLibreMapView(
                groupLocations = groupLocations,
                shouldCenterOnMyLocation = shouldCenterOnMyLocation,
                onLocationCentered = { shouldCenterOnMyLocation = false },
                onMapReady = { map ->
                    Log.d("GroupMapScreen", "Mapa listo con ${groupLocations.size} miembros")
                },
                focusMember = focusMember,
                onFocusHandled = { focusMember = null },
                modifier = Modifier.fillMaxSize()
            )
            
            // Mostrar errores
            errorMessage?.let { error ->
                Snackbar(
                    modifier = Modifier
                        .align(Alignment.BottomCenter)
                        .padding(16.dp),
                    action = {
                        TextButton(onClick = { viewModel.clearError() }) {
                            Text("OK")
                        }
                    }
                ) {
                    Text(error)
                }
            }
            
            // Contador de miembros compartiendo
            if (groupLocations.isNotEmpty()) {
                Card(
                    modifier = Modifier
                        .align(Alignment.TopEnd)
                        .padding(16.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)
                    )
                ) {
                    Text(
                        text = "${groupLocations.filter { it.sharing }.size} compartiendo",
                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            }

            // Bot√≥n flotante para lista de miembros
            FloatingActionButton(
                onClick = { showMembersSheet = true },
                modifier = Modifier
                    .align(Alignment.BottomStart)
                    .padding(16.dp),
                containerColor = MaterialTheme.colorScheme.primaryContainer,
                contentColor = MaterialTheme.colorScheme.onPrimaryContainer
            ) {
                Icon(Icons.Default.List, contentDescription = "Ver miembros")
            }

            if (showMembersSheet) {
                ModalBottomSheet(
                    onDismissRequest = { showMembersSheet = false },
                    sheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Text(
                            text = "Miembros del grupo",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        if (groupLocations.isEmpty()) {
                            Text(
                                text = "No hay miembros",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        } else {
                            groupLocations.forEach { member ->
                                ListItem(
                                    headlineContent = { Text(member.displayName ?: member.userId) },
                                    supportingContent = { Text(member.getStatusText()) },
                                    leadingContent = {
                                        Icon(Icons.Default.Person, contentDescription = null)
                                    },
                                    modifier = Modifier.clickable {
                                        focusMember = member
                                        showMembersSheet = false
                                    }
                                )
                            }
                        }
                        Spacer(modifier = Modifier.height(8.dp))
                    }
                }
            }
        }
    }
}

@Composable
fun MapLibreMapView(
    groupLocations: List<GroupMemberLocation>,
    shouldCenterOnMyLocation: Boolean,
    onLocationCentered: () -> Unit,
    onMapReady: (MapLibreMap) -> Unit,
    focusMember: GroupMemberLocation?,
    onFocusHandled: () -> Unit,
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    
    // Estados que sobreviven recomposiciones
    var mapView by remember { mutableStateOf<MapView?>(null) }
    var mapLibreMap by remember { mutableStateOf<MapLibreMap?>(null) }
    var isStyleLoaded by remember { mutableStateOf(false) }
    var currentMarkers by remember { mutableStateOf<Map<String, org.maplibre.android.annotations.Marker>>(emptyMap()) }
    
    // Estado para el miembro seleccionado
    var selectedMember by remember { mutableStateOf<GroupMemberLocation?>(null) }

    // Actualizar selectedMember si la lista cambia (para mantener datos frescos)
    LaunchedEffect(groupLocations) {
        if (selectedMember != null) {
            selectedMember = groupLocations.find { it.userId == selectedMember?.userId }
        }
    }

    fun assetExists(ctx: Context, name: String): Boolean {
        return try {
            ctx.assets.open(name).close()
            true
        } catch (_: Exception) {
            false
        }
    }

    // Centrar en miembro seleccionado desde la sheet
    LaunchedEffect(focusMember, isStyleLoaded) {
        if (focusMember != null && isStyleLoaded) {
            val map = mapLibreMap
            if (map != null) {
                try {
                    val member = focusMember!!
                    val camera = CameraPosition.Builder()
                        .target(LatLng(member.latitude, member.longitude))
                        .zoom(17.5)
                        .build()
                    map.cameraPosition = camera
                    selectedMember = member
                } catch (e: Exception) {
                    Log.e("MapLibreMapView", "Error centrando en miembro", e)
                } finally {
                    onFocusHandled()
                }
            }
        }
    }

    fun addRoutesOverlay(style: Style) {
        try {
            val sourceId = "circuit_routes_source"
            val layerId = "circuit_routes_layer"
            val assetName = MapLibreConfig.ROUTES_GEOJSON_ASSET
            // Carga GeoJSON desde assets si existe
            if (assetExists(context, assetName)) {
                if (style.getSource(sourceId) == null) {
                    style.addSource(GeoJsonSource(sourceId, URI("asset://$assetName")))
                }
                if (style.getLayer(layerId) == null) {
                    val layer = LineLayer(layerId, sourceId).withProperties(
                        PropertyFactory.lineColor(MapLibreConfig.ROUTES_VEHICLE_COLOR),
                        PropertyFactory.lineWidth(MapLibreConfig.ROUTES_WIDTH)
                    )
                    style.addLayer(layer)
                }
                Log.d("MapLibreMapView", "Overlay de rutas cargado desde assets")
            } else {
                Log.d("MapLibreMapView", "No se encontr√≥ GeoJSON de rutas en assets")
            }
        } catch (e: Exception) {
            Log.e("MapLibreMapView", "Error a√±adiendo rutas al mapa", e)
        }
    }

    fun addPoisOverlay(style: Style) {
        try {
            val sourceId = MapLibreConfig.POI_SOURCE_ID
            val layerId = MapLibreConfig.POI_LAYER_ID
            val assetName = MapLibreConfig.POIS_GEOJSON_ASSET

            if (!assetExists(context, assetName)) {
                Log.d("MapLibreMapView", "No se encontr√≥ GeoJSON de POIs en assets")
                return
            }

            if (style.getSource(sourceId) == null) {
                style.addSource(GeoJsonSource(sourceId, URI("asset://$assetName")))
            }
            if (style.getLayer(layerId) == null) {
                val layer = CircleLayer(layerId, sourceId).withProperties(
                    PropertyFactory.circleRadius(MapLibreConfig.POI_RADIUS),
                    PropertyFactory.circleColor(MapLibreConfig.POI_COLOR_DEFAULT),
                    PropertyFactory.circleOpacity(0.9f)
                )
                style.addLayer(layer)
            }
            Log.d("MapLibreMapView", "Overlay de POIs cargado desde assets")
        } catch (e: Exception) {
            Log.e("MapLibreMapView", "Error a√±adiendo POIs al mapa", e)
        }
    }
    
    // Centrar mapa en mi ubicaci√≥n cuando se solicita
    LaunchedEffect(shouldCenterOnMyLocation) {
        if (shouldCenterOnMyLocation && isStyleLoaded) {
            val map = mapLibreMap
            if (map != null) {
                try {
                    // Obtener ubicaci√≥n actual
                    val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
                    
                    // Verificar permisos
                    if (ContextCompat.checkSelfPermission(
                            context,
                            Manifest.permission.ACCESS_FINE_LOCATION
                        ) == PackageManager.PERMISSION_GRANTED ||
                        ContextCompat.checkSelfPermission(
                            context,
                            Manifest.permission.ACCESS_COARSE_LOCATION
                        ) == PackageManager.PERMISSION_GRANTED
                    ) {
                        fusedLocationClient.getCurrentLocation(
                            com.google.android.gms.location.Priority.PRIORITY_HIGH_ACCURACY,
                            null
                        ).addOnSuccessListener { location ->
                            if (location != null) {
                                val myPosition = CameraPosition.Builder()
                                    .target(LatLng(location.latitude, location.longitude))
                                    .zoom(16.0) // Zoom m√°s cercano para ubicaci√≥n personal
                                    .build()
                                
                                map.cameraPosition = myPosition
                                Log.d("MapLibreMapView", "Mapa centrado en mi ubicaci√≥n: (${location.latitude}, ${location.longitude})")
                            } else {
                                Log.w("MapLibreMapView", "Ubicaci√≥n nula, no se puede centrar")
                            }
                            onLocationCentered()
                        }.addOnFailureListener { e ->
                            Log.e("MapLibreMapView", "Error obteniendo ubicaci√≥n", e)
                            onLocationCentered()
                        }
                    } else {
                        Log.w("MapLibreMapView", "Sin permisos de ubicaci√≥n")
                        onLocationCentered()
                    }
                } catch (e: Exception) {
                    Log.e("MapLibreMapView", "Error centrando en ubicaci√≥n", e)
                    onLocationCentered()
                }
            }
        }
    }
    
    // Gestionar ciclo de vida del MapView
    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event ->
            try {
                when (event) {
                    Lifecycle.Event.ON_START -> {
                        Log.d("MapLibreMapView", "Lifecycle: ON_START")
                        mapView?.onStart()
                    }
                    Lifecycle.Event.ON_RESUME -> {
                        Log.d("MapLibreMapView", "Lifecycle: ON_RESUME")
                        mapView?.onResume()
                    }
                    Lifecycle.Event.ON_PAUSE -> {
                        Log.d("MapLibreMapView", "Lifecycle: ON_PAUSE")
                        mapView?.onPause()
                    }
                    Lifecycle.Event.ON_STOP -> {
                        Log.d("MapLibreMapView", "Lifecycle: ON_STOP")
                        mapView?.onStop()
                    }
                    Lifecycle.Event.ON_DESTROY -> {
                        Log.d("MapLibreMapView", "Lifecycle: ON_DESTROY")
                        // Limpiar marcadores
                        currentMarkers.values.forEach { marker ->
                            try {
                                mapLibreMap?.removeMarker(marker)
                            } catch (e: Exception) {
                                Log.e("MapLibreMapView", "Error eliminando marcador", e)
                            }
                        }
                        currentMarkers = emptyMap()
                        
                        // Destruir mapa
                        mapView?.onDestroy()
                        mapView = null
                        mapLibreMap = null
                        isStyleLoaded = false
                    }
                    else -> {}
                }
            } catch (e: Exception) {
                Log.e("MapLibreMapView", "Error en lifecycle event: $event", e)
            }
        }
        
        lifecycleOwner.lifecycle.addObserver(observer)
        
        onDispose {
            Log.d("MapLibreMapView", "DisposableEffect: onDispose")
            lifecycleOwner.lifecycle.removeObserver(observer)
            
            // Limpieza final solo si no se hizo en ON_DESTROY
            try {
                currentMarkers.values.forEach { marker ->
                    mapLibreMap?.removeMarker(marker)
                }
                currentMarkers = emptyMap()
                
                mapView?.onDestroy()
            } catch (e: Exception) {
                Log.e("MapLibreMapView", "Error en cleanup final", e)
            }
        }
    }
    
    // Actualizar marcadores cuando cambien las ubicaciones (solo si el estilo est√° cargado)
    LaunchedEffect(groupLocations, isStyleLoaded) {
        if (!isStyleLoaded) {
            Log.d("MapLibreMapView", "Estilo no cargado a√∫n, esperando...")
            return@LaunchedEffect
        }
        
        val map = mapLibreMap ?: run {
            Log.w("MapLibreMapView", "MapLibreMap es null, no se pueden actualizar marcadores")
            return@LaunchedEffect
        }
        
        try {
            Log.d("MapLibreMapView", "Actualizando marcadores: ${groupLocations.size} ubicaciones")
            
            // Filtrar solo miembros que est√°n compartiendo con coordenadas v√°lidas
            val validLocations = groupLocations.filter { member ->
                member.sharing && 
                member.latitude != 0.0 && 
                member.longitude != 0.0 &&
                member.latitude >= -90.0 && member.latitude <= 90.0 &&
                member.longitude >= -180.0 && member.longitude <= 180.0
            }
            
            Log.d("MapLibreMapView", "Ubicaciones v√°lidas: ${validLocations.size}")
            
            // IDs actuales
            val currentIds = validLocations.map { it.userId }.toSet()
            
            // Eliminar marcadores de usuarios que ya no est√°n
            val markersToRemove = currentMarkers.keys.filter { it !in currentIds }
            markersToRemove.forEach { userId ->
                currentMarkers[userId]?.let { marker ->
                    try {
                        map.removeMarker(marker)
                        Log.d("MapLibreMapView", "Marcador eliminado: $userId")
                    } catch (e: Exception) {
                        Log.e("MapLibreMapView", "Error eliminando marcador $userId", e)
                    }
                }
            }
            
            // Actualizar mapa de marcadores
            val updatedMarkers = currentMarkers.toMutableMap()
            markersToRemove.forEach { updatedMarkers.remove(it) }
            
            // A√±adir o actualizar marcadores
            validLocations.forEach { member ->
                try {
                    val existingMarker = updatedMarkers[member.userId]
                    
                    if (existingMarker != null) {
                        // Actualizar posici√≥n del marcador existente
                        existingMarker.position = LatLng(member.latitude, member.longitude)
                        existingMarker.title = member.displayName ?: "Usuario" // Actualizar t√≠tulo tambi√©n
                        existingMarker.snippet = member.getStatusText()
                        Log.d("MapLibreMapView", "Marcador actualizado: ${member.displayName}")
                    } else {
                        // Crear nuevo marcador
                        val markerOptions = MarkerOptions()
                            .position(LatLng(member.latitude, member.longitude))
                            .title(member.displayName ?: "Usuario")
                            .snippet(member.getStatusText())
                        
                        val newMarker = map.addMarker(markerOptions)
                        if (newMarker != null) {
                            updatedMarkers[member.userId] = newMarker
                            Log.d("MapLibreMapView", "üìç Marcador creado para: ${member.displayName} en (${member.latitude}, ${member.longitude})")
                        }
                    }
                } catch (e: Exception) {
                    Log.e("MapLibreMapView", "Error gestionando marcador para ${member.userId}", e)
                }
            }
            
            currentMarkers = updatedMarkers
            Log.d("MapLibreMapView", "Total marcadores en mapa: ${currentMarkers.size}")
            
        } catch (e: Exception) {
            Log.e("MapLibreMapView", "Error actualizando marcadores", e)
        }
    }
    
    Box(modifier = modifier) {
        // Crear el MapView
        AndroidView(
            factory = { ctx ->
                Log.d("MapLibreMapView", "AndroidView factory: Creando MapView")
                
                MapView(ctx).apply {
                    mapView = this
                    
                    // Inicializar con Bundle vac√≠o
                    try {
                        onCreate(Bundle())
                        Log.d("MapLibreMapView", "MapView.onCreate() completado")
                    } catch (e: Exception) {
                        Log.e("MapLibreMapView", "Error en MapView.onCreate()", e)
                    }
                    
                    // Obtener referencia al mapa de forma as√≠ncrona
                    try {
                        getMapAsync { map ->
                            Log.d("MapLibreMapView", "getMapAsync: Mapa recibido")
                            mapLibreMap = map
                            


                            // Funci√≥n para habilitar el componente de ubicaci√≥n
                            fun enableLocationComponent(style: Style) {
                                try {
                                    // Verificar permisos de nuevo por seguridad
                                    if (ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED ||
                                        ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED
                                    ) {
                                        val locationComponent = map.locationComponent
                                        val locationComponentActivationOptions = LocationComponentActivationOptions.builder(context, style)
                                            .build()

                                        locationComponent.activateLocationComponent(locationComponentActivationOptions)
                                        locationComponent.isLocationComponentEnabled = true
                                        locationComponent.cameraMode = CameraMode.TRACKING
                                        locationComponent.renderMode = RenderMode.COMPASS
                                        
                                        Log.d("MapLibreMapView", "‚úÖ Componente de ubicaci√≥n nativo activado")
                                    } else {
                                        Log.w("MapLibreMapView", "‚ö†Ô∏è No se pudo activar LocationComponent: faltan permisos")
                                    }
                                } catch (e: Exception) {
                                    Log.e("MapLibreMapView", "‚ùå Error activando LocationComponent", e)
                                }
                            }

                            // Funci√≥n local para configurar el mapa tras cargar el estilo
                            fun configureMapAfterStyleLoad(style: Style) {
                                try {
                                    Log.d("MapLibreMapView", "‚úÖ Estilo cargado correctamente")
                                    isStyleLoaded = true
                                    
                                    // Habilitar ubicaci√≥n nativa
                                    enableLocationComponent(style)
                                    
                                    // Configurar zoom
                                    try {
                                        val maxZoom = 18.5
                                        map.setMinZoomPreference(12.0)
                                        map.setMaxZoomPreference(maxZoom) // limitar para evitar tiles negros
                                        map.addOnCameraIdleListener {
                                            val cam = map.cameraPosition
                                            if (cam.zoom > maxZoom) {
                                                map.cameraPosition = CameraPosition.Builder(cam)
                                                    .zoom(maxZoom)
                                                    .build()
                                            }
                                        }
                                        Log.d("MapLibreMapView", "‚úÖ Zoom configurado (max $maxZoom)")
                                    } catch (e: Exception) {
                                        Log.e("MapLibreMapView", "Error configurando zoom", e)
                                    }
                                    
                                    // Centrar c√°mara en el Circuit de Barcelona-Catalunya
                                    val circuitPosition = CameraPosition.Builder()
                                        .target(MapLibreConfig.CircuitBarcelona.getLatLng())
                                        .zoom(MapLibreConfig.CircuitBarcelona.DEFAULT_ZOOM)
                                        .build()
                                    
                                    map.cameraPosition = circuitPosition
                                    
                                    // A√±adir overlay de rutas si existe GeoJSON
                                    addRoutesOverlay(style)
                                    // A√±adir overlay de POIs si existe GeoJSON
                                    addPoisOverlay(style)

                                    Log.d("MapLibreMapView", "‚úÖ Mapa racing inicializado en Circuit Barcelona")
                                    onMapReady(map)
                                    
                                } catch (e: Exception) {
                                    Log.e("MapLibreMapView", "‚ùå Error configurando estilo del mapa", e)
                                }
                            }

                            // Configurar listener de clicks en marcadores
                            map.setOnMarkerClickListener { marker ->
                                // Buscar el miembro correspondiente al marcador
                                val userId = currentMarkers.entries.find { it.value == marker }?.key
                                if (userId != null) {
                                    selectedMember = groupLocations.find { it.userId == userId }
                                }
                                // Retornar true para indicar que hemos consumido el evento (no mostrar info window default)
                                true
                            }
                            
                            // Limpiar selecci√≥n al hacer click en el mapa
                            map.addOnMapClickListener { 
                                selectedMember = null
                                true
                            }

                            // Cargar estilo: primero offline asset (si existe), luego remoto, luego fallback
                            val offlineStyle = MapLibreConfig.OFFLINE_STYLE_ASSET
                            val triedOffline = if (assetExists(context, offlineStyle)) {
                                try {
                                    map.setStyle("asset://$offlineStyle") { loadedStyle ->
                                        Log.d("MapLibreMapView", "‚úÖ Estilo offline cargado")
                                        configureMapAfterStyleLoad(loadedStyle)
                                    }
                                    true
                                } catch (e: Exception) {
                                    Log.e("MapLibreMapView", "Error cargando estilo offline", e)
                                    false
                                }
                            } else false

                            if (!triedOffline) {
                                try {
                                    map.setStyle(MapLibreConfig.MAP_STYLE_URL) { loadedStyle ->
                                        configureMapAfterStyleLoad(loadedStyle)
                                    }
                                } catch (e: Exception) {
                                    Log.e("MapLibreMapView", "Error cargando estilo principal, intentando fallback", e)
                                    try {
                                        map.setStyle(MapLibreConfig.FALLBACK_STYLE_URL) { loadedStyle ->
                                            Log.w("MapLibreMapView", "‚ö†Ô∏è Usando estilo de fallback")
                                            configureMapAfterStyleLoad(loadedStyle)
                                        }
                                    } catch (e2: Exception) {
                                        Log.e("MapLibreMapView", "Error cargando estilo fallback", e2)
                                    }
                                }
                            }
                        }
                    } catch (e: Exception) {
                        Log.e("MapLibreMapView", "Error en getMapAsync", e)
                    }
                }
            },
            modifier = Modifier.fillMaxSize()
        )
        
        // Tarjeta de informaci√≥n del miembro seleccionado
        if (selectedMember != null) {
            Card(
                modifier = Modifier
                    .align(Alignment.BottomCenter)
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 16.dp)
                    .padding(bottom = 96.dp), // levantarla sobre los FABs para que se vea bien
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surface
                ),
                elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)
            ) {
                Column(
                    modifier = Modifier.padding(8.dp)
                ) {
                    // Usamos el mismo componente que en la lista
                    GroupMemberItem(member = selectedMember!!)
                }
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/group/GroupMapViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.group

import android.Manifest
import android.annotation.SuppressLint
import android.content.Context
import android.content.pm.PackageManager
import android.util.Log
import androidx.core.content.ContextCompat
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.data.model.GroupMemberLocation
import com.georacing.georacing.data.repository.NetworkGroupRepository
import com.georacing.georacing.data.repository.NetworkUserRepository
import com.google.android.gms.location.*
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch

/**
 * ViewModel para gestionar el estado de la pantalla "Mi grupo"
 * Maneja ubicaci√≥n en tiempo real y lista de miembros usando la API del NAS
 */
class GroupMapViewModel(
    private val repository: NetworkGroupRepository
) : ViewModel() {
    private val userRepository = NetworkUserRepository()
    
    // Estado de ubicaciones de miembros del grupo
    private val _groupLocations = MutableStateFlow<List<GroupMemberLocation>>(emptyList())
    val groupLocations: StateFlow<List<GroupMemberLocation>> = _groupLocations.asStateFlow()
    
    // Estado del switch "Compartir mi ubicaci√≥n"
    private val _isSharingLocation = MutableStateFlow(false)
    val isSharingLocation: StateFlow<Boolean> = _isSharingLocation.asStateFlow()
    
    // Estado de permisos de ubicaci√≥n
    private val _hasLocationPermission = MutableStateFlow(false)
    val hasLocationPermission: StateFlow<Boolean> = _hasLocationPermission.asStateFlow()
    
    // Estado de carga y errores
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
    
    private val _errorMessage = MutableStateFlow<String?>(null)
    val errorMessage: StateFlow<String?> = _errorMessage.asStateFlow()
    
    // ID del grupo activo (en producci√≥n vendr√≠a del perfil del usuario)
    private var activeGroupId: String = "default_group"
    
    // Cliente de ubicaci√≥n de Google
    private var fusedLocationClient: FusedLocationProviderClient? = null
    private var locationUpdateJob: Job? = null
    
    // Job para escuchar miembros
    private var membersListenJob: Job? = null
    
    // Scanner local para detectar compa√±eros por BLE
    @SuppressLint("StaticFieldLeak") // ViewModel lifecycle is shorter than App Context but we use it carefully
    private var beaconScanner: com.georacing.georacing.data.ble.BeaconScanner? = null
    
    companion object {
        private const val TAG = "GroupMapViewModel"
        private const val LOCATION_UPDATE_INTERVAL = 20_000L // 20 segundos para ahorrar bater√≠a
        private const val LOCATION_MIN_DISTANCE_METERS = 15f
        private const val LOCATION_BALANCED_UPDATE_INTERVAL = 30_000L
        
        // Coordenadas del Circuit de Barcelona-Catalunya
        const val CIRCUIT_LAT = 41.5700
        const val CIRCUIT_LNG = 2.2611
    }
    
    /**
     * Inicia la escucha de ubicaciones del grupo
     */
    fun startListeningGroupLocations(groupId: String, context: Context) {
        activeGroupId = groupId
        Log.d(TAG, "Iniciando polling para grupo: $groupId")
        _groupLocations.value = emptyList()
        ensureBackendEntities(groupId)
        
        // Init Scanner locally for Map View
        beaconScanner?.stopScanning()
        beaconScanner = com.georacing.georacing.data.ble.BeaconScanner(context)
        beaconScanner?.startScanning()

        // Restaurar estado de sharing desde SharedPreferences
        val prefs = context.getSharedPreferences("georacing_prefs", Context.MODE_PRIVATE)
        val wasSharing = prefs.getBoolean("is_sharing_$groupId", false)
        
        if (wasSharing) {
            Log.d(TAG, "Restaurando estado de sharing: ACTIVO")
            _isSharingLocation.value = true
            checkLocationPermission(context)
            if (_hasLocationPermission.value) {
                startSharingLocation(context)
            }
        }
        
        membersListenJob?.cancel()
        membersListenJob = viewModelScope.launch {
            val currentUser = com.google.firebase.auth.FirebaseAuth.getInstance().currentUser
            val currentUserId = currentUser?.uid ?: ""
            val currentName = currentUser?.displayName
            
            kotlinx.coroutines.flow.combine(
                repository.getGroupMembers(groupId, pollIntervalMs = 10_000L),
                beaconScanner!!.detectedUsers
            ) { netMembers, bleMembers ->
                 // PRIORITY 1: ONLINE - If we have network data, use ONLY network data.
                 // This effectively "disables" Bluetooth visualization when online.
                 if (netMembers.isNotEmpty()) {
                     // Log.d(TAG, "Online Mode: ${netMembers.size} members. BLE Visualization Disabled.") // Removed to reduce spam
                     return@combine netMembers
                 }
                 
                 // PRIORITY 2: OFFLINE - If Network is empty/down, show BLE signals.
                 // Log.d(TAG, "Offline Mode: Network empty/down. Showing ${bleMembers.size} BLE signals.") // Removed to reduce spam
                 
                 bleMembers.filter { it.latitude != null && it.longitude != null }.map { bleUser ->
                      GroupMemberLocation(
                          userId = "ble_${bleUser.idHash}",
                          displayName = "Guest ${Integer.toHexString(bleUser.idHash).uppercase().takeLast(4)}",
                          latitude = bleUser.latitude!!,
                          longitude = bleUser.longitude!!,
                          photoUrl = null,
                          lastUpdated = com.google.firebase.Timestamp(java.util.Date(bleUser.timestamp)),
                          sharing = true
                      )
                 }
            }.collectLatest { locations ->
                // Normalizamos nombres para evitar mostrar IDs crudos
                val updatedLocations = locations.map { member ->
                    val name = when {
                        member.userId == currentUserId && !currentName.isNullOrBlank() ->
                            currentName
                        !member.displayName.isNullOrBlank() &&
                                !member.displayName!!.startsWith("User ", ignoreCase = true) ->
                            member.displayName
                        else -> "Miembro"
                    }
                    member.copy(displayName = name)
                }.distinctBy { it.userId }
                _groupLocations.value = updatedLocations
                Log.d(TAG, "Ubicaciones actualizadas: ${updatedLocations.size} miembros")
            }
        }
    }

    /**
     * Asegura que el usuario y el grupo existan en el backend (idempotente)
     */
    private fun ensureBackendEntities(groupId: String) {
        viewModelScope.launch {
            try {
                val user = com.google.firebase.auth.FirebaseAuth.getInstance().currentUser ?: return@launch
                // Registrar/actualizar usuario
                userRepository.registerUser(
                    uid = user.uid,
                    name = user.displayName,
                    email = user.email,
                    photoUrl = user.photoUrl?.toString()
                )
                // Registrar/actualizar grupo
                repository.createGroup(
                    groupId = groupId,
                    ownerUserId = user.uid,
                    groupName = groupId
                )
            } catch (e: Exception) {
                Log.e(TAG, "Error asegurando entidades backend", e)
                _errorMessage.value = "Error al sincronizar grupo. Reintenta m√°s tarde."
            }
        }
    }
    
    /**
     * Verifica si la app tiene permisos de ubicaci√≥n
     */
    fun checkLocationPermission(context: Context) {
        val hasFineLocation = ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED
        
        val hasCoarseLocation = ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_COARSE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED
        
        _hasLocationPermission.value = hasFineLocation || hasCoarseLocation
        Log.d(TAG, "Permiso de ubicaci√≥n: ${_hasLocationPermission.value}")
    }
    
    /**
     * Inicia el servicio de compartir ubicaci√≥n en tiempo real
     */
    @SuppressLint("MissingPermission")
    fun startSharingLocation(context: Context) {
        if (!_hasLocationPermission.value) {
            _errorMessage.value = "Se necesitan permisos de ubicaci√≥n"
            return
        }
        
        _isSharingLocation.value = true
        
        // Guardar preferencia
        val prefs = context.getSharedPreferences("georacing_prefs", Context.MODE_PRIVATE)
        prefs.edit().putBoolean("is_sharing_$activeGroupId", true).apply()
        
        // Inicializar cliente de ubicaci√≥n
        if (fusedLocationClient == null) {
            fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
        }
        
        // Cancelar job anterior si existe
        locationUpdateJob?.cancel()
        
        // Obtener UID y nombre del usuario
        val currentUser = com.google.firebase.auth.FirebaseAuth.getInstance().currentUser
        val userId = currentUser?.uid ?: "unknown_user"
        val displayName = currentUser?.displayName ?: "Usuario"
        
        // Job que actualiza la ubicaci√≥n peri√≥dicamente
        locationUpdateJob = viewModelScope.launch {
            try {
                while (isActive && _isSharingLocation.value) {
                    try {
                        // Solicitar ubicaci√≥n con prioridad balanceada y distancia m√≠nima
                        val request = LocationRequest.Builder(
                            Priority.PRIORITY_BALANCED_POWER_ACCURACY,
                            LOCATION_BALANCED_UPDATE_INTERVAL
                        ).setMinUpdateDistanceMeters(LOCATION_MIN_DISTANCE_METERS)
                            .setGranularity(Granularity.GRANULARITY_PERMISSION_LEVEL)
                            .build()

                        fusedLocationClient?.getCurrentLocation(
                            Priority.PRIORITY_BALANCED_POWER_ACCURACY,
                            null
                        )?.addOnSuccessListener { location ->
                            if (location != null) {
                                viewModelScope.launch {
                                    val result = repository.sendLocation(
                                        userId = userId,
                                        groupName = activeGroupId,
                                        lat = location.latitude,
                                        lon = location.longitude,
                                        displayName = displayName
                                    )
                                    
                                    if (result.isSuccess) {
                                        Log.d(TAG, "‚úÖ Ubicaci√≥n enviada: (${location.latitude}, ${location.longitude})")
                                    } else {
                                        Log.e(TAG, "‚ùå Error enviando ubicaci√≥n", result.exceptionOrNull())
                                    }
                                }
                            } else {
                                Log.w(TAG, "‚ö†Ô∏è Ubicaci√≥n nula (GPS desactivado o sin se√±al)")
                            }
                        }?.addOnFailureListener { e ->
                            Log.e(TAG, "Error obteniendo ubicaci√≥n fresca", e)
                        }

                        delay(LOCATION_UPDATE_INTERVAL)
                    } catch (e: CancellationException) {
                        Log.d(TAG, "Job de ubicaci√≥n cancelado")
                        throw e
                    } catch (e: Exception) {
                        Log.e(TAG, "Error obteniendo ubicaci√≥n", e)
                        _errorMessage.value = "Error al obtener ubicaci√≥n: ${e.message}"
                        delay(5000) // Esperar un poco si hay error antes de reintentar
                    }
                }
            } catch (e: CancellationException) {
                Log.d(TAG, "Limpieza de compartir ubicaci√≥n")
            }
        }
        
        Log.d(TAG, "üöÄ Compartir ubicaci√≥n iniciado")
    }
    
    /**
     * Detiene el servicio de compartir ubicaci√≥n
     */
    fun stopSharingLocation(context: Context? = null) {
        _isSharingLocation.value = false
        
        // Guardar preferencia (si tenemos contexto)
        context?.let {
            val prefs = it.getSharedPreferences("georacing_prefs", Context.MODE_PRIVATE)
            prefs.edit().putBoolean("is_sharing_$activeGroupId", false).apply()
        }
        
        // Cancelar el job de forma segura
        locationUpdateJob?.cancel()
        locationUpdateJob = null
        
        Log.d(TAG, "üõë Compartir ubicaci√≥n detenido localmente")
    }
    
    /**
     * Alterna el estado de compartir ubicaci√≥n
     */
    fun toggleSharingLocation(context: Context) {
        if (_isSharingLocation.value) {
            stopSharingLocation(context)
        } else {
            startSharingLocation(context)
        }
    }
    
    /**
     * Abandona el grupo actual
     */
    fun leaveGroup(context: Context) {
        val groupToLeave = activeGroupId
        // 1. Detener compartir ubicaci√≥n
        stopSharingLocation(context)
        
        // 2. Limpiar preferencia de grupo activo
        val prefs = context.getSharedPreferences("georacing_prefs", Context.MODE_PRIVATE)
        prefs.edit().remove("active_group_id").apply()
        
        // 3. Limpiar estado local
        clearGroupData()

        // 4. Borrar mi fila de group_gps en backend
        viewModelScope.launch {
            try {
                val userId = com.google.firebase.auth.FirebaseAuth.getInstance().currentUser?.uid
                if (!userId.isNullOrEmpty() && groupToLeave.isNotEmpty()) {
                    repository.removeUserFromGroup(userId, groupToLeave)
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error removing user from group backend", e)
                _errorMessage.value = "Error al abandonar el grupo. Reintenta m√°s tarde."
            }
        }
        
        Log.d(TAG, "üëã Grupo abandonado: $activeGroupId")
    }

    /**
     * Limpia el estado local del grupo y detiene escuchas
     */
    fun clearGroupData() {
        membersListenJob?.cancel()
        _groupLocations.value = emptyList()
        _isSharingLocation.value = false
        _errorMessage.value = null
        activeGroupId = ""
    }
    
    /**
     * Obtiene la ubicaci√≥n actual del dispositivo (una sola vez)
     */
    @SuppressLint("MissingPermission")
    fun getMyCurrentLocation(context: Context, onLocationReceived: (Double, Double) -> Unit) {
        if (!_hasLocationPermission.value) {
            _errorMessage.value = "Se necesitan permisos de ubicaci√≥n"
            return
        }
        
        try {
            if (fusedLocationClient == null) {
                fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
            }
            
            fusedLocationClient?.lastLocation?.addOnSuccessListener { location ->
                if (location != null) {
                    Log.d(TAG, "Ubicaci√≥n obtenida: (${location.latitude}, ${location.longitude})")
                    onLocationReceived(location.latitude, location.longitude)
                } else {
                    Log.w(TAG, "Ubicaci√≥n nula")
                    _errorMessage.value = "No se pudo obtener la ubicaci√≥n"
                }
            }?.addOnFailureListener { e ->
                Log.e(TAG, "Error obteniendo ubicaci√≥n", e)
                _errorMessage.value = "Error obteniendo ubicaci√≥n: ${e.message}"
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error en getMyCurrentLocation", e)
            _errorMessage.value = "Error: ${e.message}"
        }
    }
    
    /**
     * Limpieza al destruir el ViewModel
     */
    override fun onCleared() {
        super.onCleared()
        membersListenJob?.cancel()
        locationUpdateJob?.cancel()
        beaconScanner?.stopScanning()
        Log.d(TAG, "ViewModel limpiado")
    }
    
    /**
     * Limpia mensaje de error
     */
    fun clearError() {
        _errorMessage.value = null
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/group/GroupScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.group

import android.Manifest
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material.icons.automirrored.filled.Logout
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.QrCode
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.tooling.preview.Preview
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import androidx.navigation.NavController
import com.georacing.georacing.data.model.GroupMemberLocation
import com.georacing.georacing.data.repository.NetworkGroupRepository
import com.georacing.georacing.ui.theme.*
import com.georacing.georacing.ui.components.*
import kotlinx.coroutines.launch
import com.georacing.georacing.data.local.UserPreferencesDataStore

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun GroupScreen(
    navController: NavController, 
    userPreferences: UserPreferencesDataStore,
    viewModel: GroupMapViewModel
) {
    val context = LocalContext.current
    
    // ViewModel hoisted to Navigation Graph level
    
    val groupLocations by viewModel.groupLocations.collectAsState()
    val isSharingLocation by viewModel.isSharingLocation.collectAsState()
    val hasLocationPermission by viewModel.hasLocationPermission.collectAsState()
    val errorMessage by viewModel.errorMessage.collectAsState()
    
    // Obtener UID del usuario actual
    val currentUserId = remember { 
        com.google.firebase.auth.FirebaseAuth.getInstance().currentUser?.uid ?: "unknown"
    }
    
    val scope = rememberCoroutineScope()
    // userPreferences passed as parameter
    
    // Obtener ID del grupo activo desde DataStore (Sincronizado con ShareQRViewModel)
    val activeGroupId by userPreferences.activeGroupId.collectAsState(initial = null)
    val groupId = activeGroupId
    
    val defaultGroupId = remember(currentUserId) { "group_${currentUserId}_${System.currentTimeMillis()}" }
    
    // Launcher para pedir permisos de ubicaci√≥n
    val locationPermissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        val granted = permissions[Manifest.permission.ACCESS_FINE_LOCATION] == true ||
                permissions[Manifest.permission.ACCESS_COARSE_LOCATION] == true
        
        if (granted) {
            viewModel.checkLocationPermission(context)
            viewModel.startSharingLocation(context)
        }
    }
    
    // Iniciar listener cuando haya un grupo activo
    LaunchedEffect(groupId) {
        viewModel.checkLocationPermission(context)
        if (groupId != null) {
            viewModel.startListeningGroupLocations(groupId, context)
        } else {
            viewModel.stopSharingLocation(context)
            viewModel.clearGroupData()
        }
    }
    
    // Detener listener al salir
    DisposableEffect(Unit) {
        onDispose {
            // No detenemos el sharing al salir
        }
    }
    
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    listOf(Color(0xFF080810), Color(0xFF0A0A16), Color(0xFF080810))
                )
            )
    ) {
        Scaffold(
            containerColor = Color.Transparent,
            topBar = {
                TopAppBar(
                    title = { 
                        Text(
                            "MI GRUPO",
                            style = MaterialTheme.typography.titleLarge.copy(
                                fontWeight = FontWeight.Black,
                                letterSpacing = 1.5.sp
                            ),
                            color = TextPrimary
                        ) 
                    },
                    navigationIcon = {
                        IconButton(onClick = { navController.popBackStack() }) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Atr√°s", tint = TextPrimary)
                        }
                    },
                    actions = {
                        com.georacing.georacing.ui.components.HomeIconButton {
                            navController.navigate(com.georacing.georacing.ui.navigation.Screen.Home.route) {
                                popUpTo(com.georacing.georacing.ui.navigation.Screen.Home.route) { inclusive = true }
                            }
                        }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = Color.Transparent,
                        titleContentColor = TextPrimary
                    )
                )
            },
            snackbarHost = {
                errorMessage?.let { error ->
                    Snackbar(
                        modifier = Modifier.padding(16.dp),
                        action = {
                            TextButton(onClick = { viewModel.clearError() }) {
                                Text("OK", color = RacingRed)
                            }
                        },
                        containerColor = AsphaltGrey,
                        contentColor = TextPrimary
                    ) {
                        Text(error)
                    }
                }
            }
        ) { innerPadding ->
            if (groupId != null) {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(innerPadding),
                    verticalArrangement = Arrangement.spacedBy(12.dp),
                    contentPadding = PaddingValues(bottom = 24.dp)
                ) {
                    item {
                        LocationSharingCard(
                            isSharing = isSharingLocation,
                            hasPermission = hasLocationPermission,
                            onToggle = {
                                if (!hasLocationPermission) {
                                    locationPermissionLauncher.launch(
                                        arrayOf(
                                            Manifest.permission.ACCESS_FINE_LOCATION,
                                            Manifest.permission.ACCESS_COARSE_LOCATION
                                        )
                                    )
                                } else {
                                    viewModel.toggleSharingLocation(context)
                                }
                            }
                        )
                    }
                    item {
                        MapStubCard(
                            memberCount = groupLocations.filter { it.sharing }.size,
                            onOpenMap = {
                                navController.navigate(com.georacing.georacing.ui.navigation.Screen.GroupMap.route)
                            }
                        )
                    }
                    item {
                        ShareQRCard(
                            onOpenQR = {
                                navController.navigate(com.georacing.georacing.ui.navigation.Screen.ShareQR.createRoute(groupId))
                            }
                        )
                    }
                    item {
                        LeaveGroupCard(
                            onLeaveGroup = {
                                viewModel.leaveGroup(context)
                                scope.launch { userPreferences.setActiveGroupId(null) }
                                navController.popBackStack() // Volver atr√°s al salir
                            }
                        )
                    }
                    item {
                        Text(
                            text = "MIEMBROS DEL GRUPO (${groupLocations.size})",
                            style = MaterialTheme.typography.labelLarge.copy(
                                fontWeight = FontWeight.Bold,
                                letterSpacing = 1.5.sp
                            ),
                            color = Color(0xFF64748B),
                            modifier = Modifier
                                .padding(horizontal = 16.dp)
                                .padding(top = 4.dp, bottom = 8.dp)
                        )
                    }
                    if (groupLocations.isEmpty()) {
                        item {
                            Box(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(16.dp),
                                contentAlignment = Alignment.Center
                            ) {
                                Text(
                                    text = "No hay miembros en el grupo",
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = TextTertiary
                                )
                            }
                        }
                    } else {
                        items(groupLocations) { member ->
                            GroupMemberItem(
                                member = member,
                                modifier = Modifier.padding(horizontal = 16.dp)
                            )
                        }
                    }
                }
            } else {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(innerPadding)
                ) {
                    NoActiveGroupCard(
                        onCreateGroup = {
                            scope.launch { userPreferences.setActiveGroupId(defaultGroupId) }
                            // activeGroupId will update via Flow
                            viewModel.startListeningGroupLocations(defaultGroupId, context)
                        },
                        onJoinWithQr = {
                            navController.navigate(com.georacing.georacing.ui.navigation.Screen.QRScanner.route)
                        },
                        modifier = Modifier.fillMaxWidth()
                    )
                }
            }
        }
    }
}

@Preview
@Composable
fun GroupScreenPreview() {
    val context = LocalContext.current
    val viewModel: GroupMapViewModel = viewModel(
        factory = viewModelFactory {
            initializer {
                GroupMapViewModel(NetworkGroupRepository())
            }
        }
    )
    
    GroupScreen(
        navController = androidx.navigation.compose.rememberNavController(),
        userPreferences = com.georacing.georacing.data.local.UserPreferencesDataStore(context),
        viewModel = viewModel
    )
}

@Preview
@Composable
fun LocationSharingCardPreview() {
    LocationSharingCard(
        isSharing = true,
        hasPermission = true,
        onToggle = {}
    )
}

@Preview
@Composable
fun MapStubCardPreview() {
    MapStubCard(
        memberCount = 5,
        onOpenMap = {}
    )
}

@Composable
fun LocationSharingCard(
    isSharing: Boolean,
    hasPermission: Boolean,
    onToggle: () -> Unit,
    modifier: Modifier = Modifier
) {
    GlassCard(
        modifier = modifier.fillMaxWidth(),
        shape = RoundedCornerShape(16.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = "COMPARTIR UBICACI√ìN",
                    style = MaterialTheme.typography.titleMedium.copy(
                        fontWeight = FontWeight.Bold,
                        letterSpacing = 1.5.sp
                    ),
                    color = TextPrimary
                )
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = if (isSharing) {
                        "Tu grupo puede ver d√≥nde est√°s"
                    } else if (!hasPermission) {
                        "Se necesitan permisos de ubicaci√≥n"
                    } else {
                        "Tu grupo no puede verte"
                    },
                    style = MaterialTheme.typography.bodySmall,
                    color = TextSecondary
                )
            }
            
            Switch(
                checked = isSharing,
                onCheckedChange = { onToggle() },
                colors = SwitchDefaults.colors(
                    checkedThumbColor = Color(0xFFF8FAFC),
                    checkedTrackColor = Color(0xFF22C55E),
                    uncheckedThumbColor = TextTertiary,
                    uncheckedTrackColor = Color(0xFF0E0E18)
                )
            )
        }
    }
}

@Composable
fun MapStubCard(
    memberCount: Int,
    onOpenMap: () -> Unit,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier
            .fillMaxWidth()
            .height(250.dp)
            .padding(horizontal = 16.dp)
            .liquidGlass(shape = RoundedCornerShape(24.dp), level = GlassLevel.L2)
            .clickable { onOpenMap() }
    ) {
        // Placeholder background (could be an image)
        Box(modifier = Modifier.fillMaxSize().background(Color(0xFF0E0E18)))
        
        Column(
            modifier = Modifier.align(Alignment.Center),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                text = "MAPA DEL CIRCUITO",
                style = MaterialTheme.typography.titleLarge.copy(
                    fontWeight = FontWeight.Black,
                    letterSpacing = 1.5.sp
                ),
                color = TextPrimary
            )
            Text(
                text = "Circuit de Barcelona-Catalunya",
                style = MaterialTheme.typography.bodyMedium,
                color = TextSecondary
            )
            Text(
                text = "$memberCount miembros activos",
                style = MaterialTheme.typography.labelMedium.copy(
                    fontWeight = FontWeight.Bold,
                    letterSpacing = 1.sp
                ),
                color = Color(0xFF06B6D4)
            )
            Spacer(modifier = Modifier.height(16.dp))
            RacingButton(
                text = "Ver Mapa Completo",
                onClick = onOpenMap,
                modifier = Modifier.width(200.dp)
            )
        }
    }
}

@Composable
fun GroupMemberItem(
    member: GroupMemberLocation,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
            .fillMaxWidth()
            .liquidGlass(shape = RoundedCornerShape(12.dp), level = GlassLevel.L1)
            .padding(12.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        // Avatar
        Box(
            modifier = Modifier
                .size(48.dp)
                .clip(CircleShape)
                .background(RacingRed.copy(alpha = 0.2f)),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = Icons.Default.Person,
                contentDescription = "Avatar del miembro",
                tint = RacingRed,
                modifier = Modifier.size(28.dp)
            )
        }
        
        // Info
        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = member.displayName ?: "Usuario",
                style = MaterialTheme.typography.titleSmall,
                fontWeight = FontWeight.Bold,
                color = TextPrimary
            )
            Text(
                text = member.getStatusText(),
                style = MaterialTheme.typography.bodySmall,
                color = if (member.sharing && member.getSecondsAgo() < 60) 
                    CircuitGreen
                else 
                    TextTertiary
            )
        }
        
        // Indicador
        if (member.sharing) {
            Box(
                modifier = Modifier
                    .size(10.dp)
                    .clip(CircleShape)
                    .background(
                        if (member.getSecondsAgo() < 60) CircuitGreen else CircuitCongestion
                    )
            )
        }
    }
}

@Composable
fun ShareQRCard(
    onOpenQR: () -> Unit,
    modifier: Modifier = Modifier
) {
    GlassCard(
        modifier = modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp)
            .clickable { onOpenQR() }
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Box(
                modifier = Modifier
                    .size(48.dp)
                    .clip(RoundedCornerShape(12.dp))
                    .background(Color(0xFFF8FAFC).copy(alpha = 0.08f)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = androidx.compose.material.icons.Icons.Default.QrCode,
                    contentDescription = "C√≥digo QR",
                    modifier = Modifier.size(24.dp),
                    tint = TextPrimary
                )
            }
            
            Spacer(modifier = Modifier.width(16.dp))
            
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = "COMPARTIR CON QR",
                    style = MaterialTheme.typography.titleMedium.copy(
                        fontWeight = FontWeight.Bold,
                        letterSpacing = 1.5.sp
                    ),
                    color = TextPrimary
                )
                Text(
                    text = "Genera un c√≥digo QR para compartir",
                    style = MaterialTheme.typography.bodySmall,
                    color = TextSecondary
                )
            }
            
            Icon(
                imageVector = androidx.compose.material.icons.Icons.AutoMirrored.Filled.ArrowForward,
                contentDescription = "Ir a compartir QR",
                tint = TextTertiary
            )
        }
    }
}

@Composable
fun NoActiveGroupCard(
    onCreateGroup: () -> Unit,
    onJoinWithQr: () -> Unit,
    modifier: Modifier = Modifier
) {
    GlassCard(
        modifier = modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Column {
                Text(
                    text = "NO HAY GRUPO ACTIVO",
                    style = MaterialTheme.typography.titleMedium.copy(
                        fontWeight = FontWeight.Bold,
                        letterSpacing = 1.5.sp
                    ),
                    color = TextPrimary
                )
                Text(
                    text = "Crea un grupo o √∫nete para ver a tus amigos.",
                    style = MaterialTheme.typography.bodySmall,
                    color = TextSecondary
                )
            }
            
            RacingButton(
                text = "Crear Nuevo Grupo",
                onClick = onCreateGroup
            )
            
            OutlinedButton(
                onClick = onJoinWithQr,
                modifier = Modifier.fillMaxWidth().height(56.dp),
                colors = ButtonDefaults.outlinedButtonColors(
                    contentColor = TextPrimary
                ),
                border = androidx.compose.foundation.BorderStroke(1.dp, Color(0xFF64748B).copy(alpha = 0.5f)),
                shape = RoundedCornerShape(12.dp)
            ) {
                Icon(Icons.Default.QrCode, "Unirme con c√≥digo QR")
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    "UNIRME CON QR",
                    letterSpacing = 1.5.sp,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

@Composable
fun LeaveGroupCard(
    onLeaveGroup: () -> Unit,
    modifier: Modifier = Modifier
) {
    var showConfirmDialog by remember { mutableStateOf(false) }
    
    GlassCard(
        modifier = modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp)
            .clickable { showConfirmDialog = true }
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = Icons.AutoMirrored.Filled.Logout,
                contentDescription = "Salir del grupo",
                tint = Color(0xFFEF4444)
            )
            
            Spacer(modifier = Modifier.width(12.dp))
            
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = "SALIR DEL GRUPO",
                    style = MaterialTheme.typography.titleMedium.copy(
                        fontWeight = FontWeight.Bold,
                        letterSpacing = 1.5.sp
                    ),
                    color = Color(0xFFEF4444)
                )
                Text(
                    text = "Detener ubicaci√≥n y salir",
                    style = MaterialTheme.typography.bodySmall,
                    color = TextTertiary
                )
            }
            
            Icon(
                imageVector = androidx.compose.material.icons.Icons.AutoMirrored.Filled.ArrowForward,
                contentDescription = "Ir a salir del grupo",
                tint = TextTertiary
            )
        }
    }
    
    if (showConfirmDialog) {
        AlertDialog(
            onDismissRequest = { showConfirmDialog = false },
            containerColor = Color(0xFF14141C),
            title = {
                Text(
                    "¬øSalir del grupo?",
                    color = Color(0xFFF8FAFC),
                    fontWeight = FontWeight.Bold
                )
            },
            text = {
                Text(
                    "Dejar√°s de compartir tu ubicaci√≥n con el grupo y no podr√°s ver a los dem√°s miembros.",
                    color = Color(0xFF64748B)
                )
            },
            confirmButton = {
                TextButton(onClick = {
                    showConfirmDialog = false
                    onLeaveGroup()
                }) {
                    Text("SALIR", color = Color(0xFFEF4444), fontWeight = FontWeight.ExtraBold, letterSpacing = 1.sp)
                }
            },
            dismissButton = {
                TextButton(onClick = { showConfirmDialog = false }) {
                    Text("CANCELAR", color = Color(0xFF64748B))
                }
            },
            modifier = Modifier.border(1.dp, Color(0xFFEF4444).copy(alpha = 0.3f), RoundedCornerShape(24.dp))
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/health/EcoViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.health

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.domain.model.EcoMetrics
import com.georacing.georacing.domain.usecase.CalculateEcoMetricsUseCase
import com.georacing.georacing.infrastructure.health.HealthConnectManager
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

// Estado de la Vista
sealed class EcoUiState {
    object Loading : EcoUiState()
    object NotAvailable : EcoUiState() // Health Connect no instalado o soportado
    object PermissionsRequired : EcoUiState() // Falta conceder los permisos
    data class Success(val metrics: EcoMetrics) : EcoUiState()
    data class Error(val message: String) : EcoUiState()
}

class EcoViewModel(
    private val healthConnectManager: HealthConnectManager,
    private val calculateEcoMetricsUseCase: CalculateEcoMetricsUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow<EcoUiState>(EcoUiState.Loading)
    val uiState: StateFlow<EcoUiState> = _uiState.asStateFlow()

    // Este es el contrato que enviaremos a la UI (Compose)
    val permissionsContract = healthConnectManager.requestPermissionsActivityContract()
    val requiredPermissions = healthConnectManager.requiredPermissions

    init {
        checkHealthConnectStatus()
    }

    /**
     * Verifica la disponibilidad y permisos. Compose lo llamar√° en el onResume
     * o al pulsar "Recargar" tras otorgar permisos.
     */
    fun checkHealthConnectStatus() {
        viewModelScope.launch {
            _uiState.value = EcoUiState.Loading
            
            if (!healthConnectManager.isAvailable()) {
                _uiState.value = EcoUiState.NotAvailable
                return@launch
            }

            if (!healthConnectManager.hasAllPermissions()) {
                _uiState.value = EcoUiState.PermissionsRequired
                return@launch
            }

            // Tenemos permisos, leemos los datos silenciosamente
            loadEcoMetrics()
        }
    }

    /**
     * Callback que la UI invocar√° despu√©s de que el usuario vuelva
     * del popup de permisos de Health Connect.
     */
    fun onPermissionsResult(grantedPermissions: Set<String>) {
        if (grantedPermissions.containsAll(requiredPermissions)) {
            loadEcoMetrics()
        } else {
            // El usuario deneg√≥ los permisos
            _uiState.value = EcoUiState.PermissionsRequired
        }
    }

    private fun loadEcoMetrics() {
        viewModelScope.launch {
            try {
                val metrics = calculateEcoMetricsUseCase()
                _uiState.value = EcoUiState.Success(metrics)
            } catch (e: Exception) {
                _uiState.value = EcoUiState.Error("Error al calcular el progreso ecol√≥gico: ${e.message}")
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/health/PrivacyPolicyActivity.kt`

```kotlin
package com.georacing.georacing.ui.screens.health

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

class PrivacyPolicyActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MaterialTheme {
                Scaffold(
                    containerColor = Color(0xFF0D0D0D)
                ) { innerPadding ->
                    Box(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(innerPadding)
                            .padding(16.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = "Pol√≠tica de Privacidad de GeoRacing\n\nProtegemos tus datos de salud. Solo usamos tus pasos para calcular tu huella de carbono.",
                            color = Color.White,
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                }
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/home/EditDashboardScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.home

import android.widget.Toast
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDownward
import androidx.compose.material.icons.filled.ArrowUpward
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.DragHandle
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.georacing.georacing.data.local.UserPreferencesDataStore
import com.georacing.georacing.domain.model.WidgetType
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EditDashboardScreen(
    navController: NavController,
    userPreferences: UserPreferencesDataStore
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    
    // Default fallback if empty
    val defaultList = com.georacing.georacing.domain.model.DashboardLayout.DEFAULT.widgets
    
    // Load current layout
    val savedLayout by userPreferences.dashboardLayout.collectAsState(initial = defaultList)
    
    // Mutable state for editing
    // We only init this once from savedLayout to avoid reset on every recomposition, 
    // but need to handle initial load.
    var currentOrder by remember { mutableStateOf<List<WidgetType>>(emptyList()) }
    
    LaunchedEffect(savedLayout) {
        if (currentOrder.isEmpty()) {
            currentOrder = savedLayout
        }
    }
    
    // Available widgets (all possible types minus protected ones potentially)
    val allItems = WidgetType.values().toList().filter { it != WidgetType.STAFF_ACTIONS } 


    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        "EDITAR DASHBOARD",
                        color = Color(0xFFF8FAFC),
                        fontWeight = FontWeight.Bold,
                        letterSpacing = 1.5.sp
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back", tint = Color(0xFFF8FAFC))
                    }
                },
                actions = {
                    IconButton(onClick = {
                        scope.launch {
                            userPreferences.setDashboardLayout(currentOrder)
                            Toast.makeText(context, "Dise√±o guardado", Toast.LENGTH_SHORT).show()
                            navController.popBackStack()
                        }
                    }) {
                        Icon(Icons.Default.Check, contentDescription = "Save", tint = Color(0xFF22C55E))
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color(0xFF080810))
            )
        },
        containerColor = Color(0xFF080810)
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .padding(innerPadding)
                .background(Brush.verticalGradient(listOf(Color(0xFF080810), Color(0xFF0A0A16), Color(0xFF080810))))
                .padding(16.dp)
        ) {
            Text(
                "ORGANIZA TU PANTALLA DE INICIO",
                color = Color(0xFF64748B),
                fontSize = 14.sp,
                fontWeight = FontWeight.Medium,
                letterSpacing = 1.5.sp
            )
            Spacer(modifier = Modifier.height(16.dp))

            LazyColumn {
                itemsIndexed(currentOrder) { index, widget ->
                     WidgetItemRow(
                         widget = widget,
                         isFirst = index == 0,
                         isLast = index == currentOrder.size - 1,
                         onMoveUp = { 
                             if (index > 0) {
                                 val mutable = currentOrder.toMutableList()
                                 java.util.Collections.swap(mutable, index, index - 1)
                                 currentOrder = mutable
                             }
                         },
                         onMoveDown = {
                             if (index < currentOrder.size - 1) {
                                 val mutable = currentOrder.toMutableList()
                                 java.util.Collections.swap(mutable, index, index + 1)
                                 currentOrder = mutable
                             }
                         },
                         onToggleVisibility = {
                             // Remove from list
                             val mutable = currentOrder.toMutableList()
                             mutable.removeAt(index)
                             currentOrder = mutable
                         }
                     )
                     Spacer(modifier = Modifier.height(8.dp))
                }
                
                // Add hidden items section
                 item {
                     Spacer(modifier = Modifier.height(24.dp))
                     Text(
                         "WIDGETS OCULTOS",
                         color = Color(0xFF64748B),
                         fontWeight = FontWeight.Bold,
                         letterSpacing = 1.5.sp
                     )
                     Spacer(modifier = Modifier.height(8.dp))
                 }
                 
                 val hiddenItems = allItems.filter { !currentOrder.contains(it) }
                 itemsIndexed(hiddenItems) { _, widget ->
                     Card(
                        colors = CardDefaults.cardColors(containerColor = Color(0xFF0E0E18)),
                        modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp),
                        shape = RoundedCornerShape(12.dp)
                     ) {
                         Row(
                             modifier = Modifier.fillMaxWidth().padding(16.dp),
                             horizontalArrangement = Arrangement.SpaceBetween,
                             verticalAlignment = Alignment.CenterVertically
                         ) {
                             Text(widget.name, color = Color(0xFF64748B))
                             Button(
                                 onClick = {
                                     val mutable = currentOrder.toMutableList()
                                     mutable.add(widget)
                                     currentOrder = mutable
                                 },
                                 colors = ButtonDefaults.buttonColors(
                                     containerColor = Color(0xFFE8253A),
                                     contentColor = Color(0xFFF8FAFC)
                                 ),
                                 shape = RoundedCornerShape(8.dp)
                             ) {
                                 Text("A√ëADIR +", letterSpacing = 1.sp, fontWeight = FontWeight.Bold)
                             }
                         }
                     }
                 }
            }
        }
    }
}

@Composable
fun WidgetItemRow(
    widget: WidgetType,
    isFirst: Boolean,
    isLast: Boolean,
    onMoveUp: () -> Unit,
    onMoveDown: () -> Unit,
    onToggleVisibility: () -> Unit
) {
    Card(
        colors = CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
        modifier = Modifier.fillMaxWidth(),
        shape = RoundedCornerShape(12.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(Icons.Default.DragHandle, contentDescription = "Arrastrar para reordenar", tint = Color(0xFF64748B))
            Spacer(modifier = Modifier.width(16.dp))
            Column(modifier = Modifier.weight(1f)) {
                Text(widget.name, color = Color(0xFFF8FAFC), fontWeight = FontWeight.Bold)
                Text("VISIBLE", color = Color(0xFF22C55E), fontSize = 12.sp, letterSpacing = 1.sp)
            }
            
            // Reorder Buttons
            if (!isFirst) {
                IconButton(onClick = onMoveUp) {
                    Icon(Icons.Default.ArrowUpward, contentDescription = "Up", tint = Color(0xFFF8FAFC))
                }
            }
            if (!isLast) {
                IconButton(onClick = onMoveDown) {
                    Icon(Icons.Default.ArrowDownward, contentDescription = "Down", tint = Color(0xFFF8FAFC))
                }
            }
            
            // Remove Button
             IconButton(onClick = onToggleVisibility) {
                //Icon(Icons.Default.VisibilityOff, contentDescription = "Hide", tint = Color.Red.copy(0.7f))
                Text("X", color = Color(0xFFEF4444), fontWeight = FontWeight.Bold)
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/home/HomeScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.home

import java.time.format.DateTimeFormatter
import java.util.Locale
import androidx.compose.animation.animateColorAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.outlined.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import androidx.navigation.NavController
import androidx.navigation.compose.currentBackStackEntryAsState
import com.georacing.georacing.domain.repository.CircuitStateRepository
import com.georacing.georacing.ui.components.*
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.*
import androidx.compose.ui.tooling.preview.Preview
import androidx.navigation.compose.rememberNavController
import com.georacing.georacing.ui.glass.LiquidPill
import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LocalBackdrop

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun HomeScreen(
    navController: NavController,
    circuitStateRepository: CircuitStateRepository,
    beaconScanner: com.georacing.georacing.data.ble.BeaconScanner? = null,
    isOnline: Boolean = true,
    bleBeaconsCount: Int = 0,
    userPreferences: com.georacing.georacing.data.local.UserPreferencesDataStore,
    appContainer: com.georacing.georacing.di.AppContainer? = null // Nullable for Preview/Compat
) {
    val viewModel: HomeViewModel = viewModel(
        factory = viewModelFactory {
            initializer {
                HomeViewModel(circuitStateRepository, beaconScanner) 
            }
        }
    )

    val circuitState by viewModel.circuitState.collectAsState()
    val appMode by viewModel.appMode.collectAsState()
    val newsItems by viewModel.newsItems.collectAsState()
    
    // Load Dashboard Layout
    val dashboardLayout by userPreferences.dashboardLayout.collectAsState(
        initial = com.georacing.georacing.domain.model.DashboardLayout.DEFAULT.widgets
    )

    // Dashboard Layout with Offline Indicator
    Box(modifier = Modifier.fillMaxSize()) {
        androidx.compose.foundation.lazy.LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(horizontal = 20.dp),
            contentPadding = PaddingValues(bottom = 100.dp)
        ) {
            // Extra top spacing for offline indicator
            // item { Spacer(modifier = Modifier.height(if (!isOnline) 60.dp else 20.dp)) }
            
            item {
                Spacer(modifier = Modifier.height(if (!isOnline) 60.dp else 20.dp))
                // Smart Ticket (Shows always, expands when at gate)
                com.georacing.georacing.ui.components.ticket.SmartTicketCard()
                Spacer(modifier = Modifier.height(16.dp))
            }

            // Dynamic Widgets
            items(dashboardLayout.size) { index ->
                val widgetType = dashboardLayout[index]
                 
                 // Special animation wrapper could go here using animateItemPlacement() if key provided
                 
                 RenderWidget(
                     type = widgetType,
                     navController = navController,
                     circuitState = circuitState,
                     temperature = circuitState?.temperature ?: "22¬∞",
                     onNavigateToEdit = { navController.navigate("edit_dashboard") },
                     appContainer = appContainer,
                     newsItems = newsItems,
                     isOnline = isOnline
                 )
            }

            item { Spacer(modifier = Modifier.height(100.dp)) } // Bottom bar spacer
        }
        
        // Edit Button (Floating Top Right)
        Box(
            modifier = Modifier
                .align(Alignment.TopEnd)
                .padding(top = 40.dp, end = 20.dp)
        ) {
             androidx.compose.material3.IconButton(
                 onClick = { navController.navigate("edit_dashboard") }
             ) {
                 androidx.compose.material3.Icon(
                     Icons.Default.Edit, 
                     contentDescription = "Edit Dashboard",
                     tint = Color.White.copy(alpha = 0.5f)
                 )
             }
        }
        
        // üì° Offline Indicator
        OfflineIndicator(
            isOnline = isOnline,
            bleBeaconsDetected = bleBeaconsCount
        )
    }
}

@Composable
fun GreetingsHeader(temperature: String) {
    val currentDate = java.time.LocalDate.now()
    val formatter = DateTimeFormatter.ofPattern("EEEE, d 'de' MMMM", Locale("es", "ES"))
    val dateString = currentDate.format(formatter)
        .replaceFirstChar { it.uppercase() }

    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column {
            Text(
                text = "BIENVENIDO",
                style = MaterialTheme.typography.labelMedium,
                letterSpacing = 2.sp,
                color = Color(0xFF64748B)
            )
            Spacer(modifier = Modifier.height(4.dp))
            Text(
                text = dateString,
                style = MaterialTheme.typography.titleMedium.copy(
                    fontWeight = FontWeight.ExtraBold
                ),
                color = Color.White
            )
        }
        
        // Weather Pill
        val backdrop = LocalBackdrop.current
        LiquidPill(
            backdrop = backdrop,
            modifier = Modifier,
            surfaceColor = Color(0xFF14141C).copy(alpha = 0.7f)
        ) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Icon(
                    imageVector = Icons.Default.WbSunny,
                    contentDescription = "Clima actual",
                    tint = Color(0xFFFF5E00), // NeonOrange
                    modifier = Modifier.size(16.dp)
                )
                Spacer(modifier = Modifier.width(6.dp))
                Text(
                    text = temperature,
                    style = MaterialTheme.typography.labelLarge.copy(
                        fontWeight = FontWeight.ExtraBold
                    ),
                    color = Color.White
                )
            }
        }
    }
}

@Composable
fun DashboardGrid(navController: NavController) {
    // 4 Columns is tight on mobile, reference showed 4 but maybe 3 is safer?
    // Reference image shows 4 items in a row (Map, Store, Food, Bath).
    // Let's use GridCells.Fixed(4) and adjust FeatureCard size.
    
    // 4 Columns is tight on mobile, reference showed 4 but maybe 3 is safer?
    // Reference image shows 4 items in a row (Map, Store, Food, Bath).
    // Let's use GridCells.Fixed(4) and adjust FeatureCard size.

    
    val features = listOf(
        FeatureItem("Mapa", Icons.Filled.AltRoute, Color(0xFF00F0FF), Screen.Map.route),
        FeatureItem("Shop", Icons.Filled.Flag, Color(0xFF06D6A0), Screen.Orders.route),
        FeatureItem("Comida", Icons.Filled.Restaurant, Color(0xFFFF5E00), Screen.Orders.route), 
        FeatureItem("Ba√±os", Icons.Filled.Wc, Color(0xFF4361EE), Screen.PoiList.route), 
        
        FeatureItem("Parking", Icons.Filled.LocalParking, Color(0xFFA0AAB2), Screen.Parking.route),
        FeatureItem("Buscar", Icons.Filled.Search, Color(0xFF00F0FF), Screen.Search.route),
        FeatureItem("Logros", Icons.Filled.EmojiEvents, Color(0xFFFFD166), Screen.Achievements.route),
        FeatureItem("Alertas", Icons.Filled.Warning, Color(0xFFFF2A3C), Screen.IncidentReport.route),
        
        FeatureItem("Recoger", Icons.Filled.ShoppingCart, Color(0xFFF72585), Screen.ClickCollect.route),
        FeatureItem("Tr√°fico", Icons.Filled.Traffic, Color(0xFFFF2A3C), Screen.RouteTraffic.route),
        FeatureItem("Resumen", Icons.Filled.Star, Color(0xFFB5179E), Screen.Wrapped.route),
        FeatureItem("Cromos", Icons.Filled.AccountBox, Color(0xFFFFD166), Screen.Collectibles.route),
        FeatureItem("Chat", Icons.Filled.Forum, Color(0xFF06D6A0), Screen.ProximityChat.route),
        FeatureItem("Fan Zone", Icons.Filled.SportsMotorsports, Color(0xFFFF4D6D), Screen.FanZone.route)
    )


    LazyVerticalGrid(
        columns = GridCells.Fixed(4),
        horizontalArrangement = Arrangement.spacedBy(12.dp),
        verticalArrangement = Arrangement.spacedBy(20.dp),
        userScrollEnabled = false,
        modifier = Modifier.height(400.dp) 
    ) {
        items(features.size) { index ->
            val feature = features[index]
            FeatureCard(
                title = feature.title,
                description = "", 
                icon = feature.icon,
                accentColor = feature.accentColor,
                onClick = { navController.navigate(feature.route) },
                index = index
            )
        }
    }
}

@Composable
fun LatestNewsCard() {
    val backdrop = LocalBackdrop.current
    LiquidCard(
        backdrop = backdrop,
        modifier = Modifier
            .fillMaxWidth()
            .height(150.dp),
        cornerRadius = 24.dp,
        surfaceColor = AsphaltGrey.copy(alpha = 0.6f),
        tint = RacingRedBright.copy(alpha = 0.15f)
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(22.dp),
            verticalArrangement = Arrangement.Center
        ) {
            // Tag with racing red accent
            Row(verticalAlignment = Alignment.CenterVertically) {
                Box(
                    modifier = Modifier
                        .size(6.dp)
                        .clip(CircleShape)
                        .background(RacingRedBright)
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "LIVE EVENT",
                    style = MaterialTheme.typography.labelSmall.copy(
                        fontWeight = FontWeight.ExtraBold,
                        letterSpacing = 1.5.sp
                    ),
                    color = RacingRedBright
                )
            }
            
            Spacer(modifier = Modifier.height(14.dp))
            
            Text(
                text = "Welcome to GeoRacing",
                style = MaterialTheme.typography.titleLarge.copy(
                    fontWeight = FontWeight.ExtraBold
                ),
                color = Color.White
            )
            Spacer(modifier = Modifier.height(6.dp))
            Text(
                text = "Live updates from the circuit ‚Ä¢ Real-time telemetry",
                style = MaterialTheme.typography.bodyMedium,
                color = Color(0xFF94A3B8)
            )
        }
    }
}

// DashboardBottomBar Removed from here


@Preview(showBackground = true)
@Composable
fun HomeScreenPreview() {
    GeoRacingTheme {
        HomeScreen(
            navController = rememberNavController(),
            circuitStateRepository = object : CircuitStateRepository {
                override fun getCircuitState() = kotlinx.coroutines.flow.flowOf(
                    com.georacing.georacing.domain.model.CircuitState(
                         com.georacing.georacing.domain.model.CircuitMode.NORMAL, 
                         "Preview", 
                         "24¬∞C",
                         updatedAt = "Now"
                    )
                )
                override fun setCircuitState(mode: com.georacing.georacing.domain.model.CircuitMode, message: String?) {}
                override val appMode = kotlinx.coroutines.flow.flowOf(com.georacing.georacing.domain.model.AppMode.ONLINE)
                override val debugInfo = kotlinx.coroutines.flow.flowOf("Debug Info")
            },
            userPreferences = com.georacing.georacing.data.local.UserPreferencesDataStore(androidx.compose.ui.platform.LocalContext.current) // Mock for preview
        )
    }
}

// Data class
data class FeatureItem(
    val title: String,
    val icon: ImageVector,
    val accentColor: Color,
    val route: String,
    val description: String = ""
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/home/HomeViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.home

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import com.georacing.georacing.domain.model.AppMode
import com.georacing.georacing.domain.model.CircuitState
import com.georacing.georacing.domain.repository.CircuitStateRepository
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.flow.stateIn

/**
 * News article loaded from the API ‚Äî mirrors iOS NewsRepository.NewsArticle
 */
data class NewsArticle(
    val id: String,
    val title: String,
    val subtitle: String,
    val content: String,
    val imageUrl: String?,
    val timestamp: Long,
    val category: String = "general"
)

class HomeViewModel(
    circuitStateRepository: CircuitStateRepository,
    private val beaconScanner: com.georacing.georacing.data.ble.BeaconScanner? // üÜï Optional Injection
) : ViewModel() {

    val circuitState: StateFlow<CircuitState?> = circuitStateRepository.getCircuitState()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = null
        )

    val appMode: StateFlow<AppMode> = circuitStateRepository.appMode
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = AppMode.ONLINE
        )

    // --- News from API (iOS parity: HomeViewModel.fetchData ‚Üí NewsRepository) ---
    private val _newsItems = MutableStateFlow<List<NewsArticle>>(emptyList())
    val newsItems: StateFlow<List<NewsArticle>> = _newsItems.asStateFlow()

    private val _isLoadingNews = MutableStateFlow(false)
    val isLoadingNews: StateFlow<Boolean> = _isLoadingNews.asStateFlow()

    init {
        // üÜï Pruning Loop (User Requirement: 2-3s loop, 5-10s TTL)
        beaconScanner?.let { scanner ->
            viewModelScope.launch {
                while (true) {
                    kotlinx.coroutines.delay(3000) // Loop every 3s
                    scanner.pruneInactiveDevices(10000) // TTL 10s
                }
            }
        }

        // Load news from API on init
        loadNews()
    }

    fun loadNews() {
        viewModelScope.launch {
            _isLoadingNews.value = true
            try {
                val response = FirestoreLikeClient.api.read("news")
                val articles = response.mapNotNull { map ->
                    try {
                        NewsArticle(
                            id = map["id"]?.toString() ?: return@mapNotNull null,
                            title = map["title"]?.toString() ?: "",
                            subtitle = map["subtitle"]?.toString() ?: "",
                            content = map["content"]?.toString() ?: "",
                            imageUrl = map["image_url"]?.toString(),
                            timestamp = (map["timestamp"] as? Number)?.toLong() ?: 0L,
                            category = map["category"]?.toString() ?: "general"
                        )
                    } catch (_: Exception) { null }
                }.sortedByDescending { it.timestamp }
                _newsItems.value = articles
            } catch (e: Exception) {
                Log.w("HomeViewModel", "Error loading news: ${e.message}")
                // Fallback: keep empty or show mock
                if (_newsItems.value.isEmpty()) {
                    _newsItems.value = listOf(
                        NewsArticle(
                            id = "welcome",
                            title = "Welcome to GeoRacing",
                            subtitle = "Tu compa√±ero digital para el circuito",
                            content = "Explora todas las funcionalidades de la app",
                            imageUrl = null,
                            timestamp = System.currentTimeMillis()
                        )
                    )
                }
            }
            _isLoadingNews.value = false
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/home/WidgetRegistry.kt`

```kotlin
package com.georacing.georacing.ui.screens.home

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ChevronRight
import androidx.compose.material.icons.filled.Eco
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.Fastfood
import androidx.compose.material.icons.filled.LocalParking
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.ViewInAr
import androidx.compose.material.icons.filled.Wc
import androidx.compose.material.icons.filled.ShoppingCart
import androidx.compose.material.icons.filled.Star
import androidx.compose.material.icons.filled.AccountBox
import androidx.compose.material.icons.filled.Forum
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.domain.model.WidgetType
import com.georacing.georacing.ui.components.CircuitStatusCard
import com.georacing.georacing.ui.components.contextual.ContextualCardWidget

@Composable
fun RenderWidget(
    type: WidgetType,
    navController: NavController,
    circuitState: com.georacing.georacing.domain.model.CircuitState?,
    temperature: String,
    onNavigateToEdit: () -> Unit,
    appContainer: com.georacing.georacing.di.AppContainer? = null,
    newsItems: List<com.georacing.georacing.ui.screens.home.NewsArticle> = emptyList(),
    isOnline: Boolean = true
) {
    when (type) {
        WidgetType.CONTEXTUAL_CARD -> {
            ContextualCardWidget(
                circuitState = circuitState,
                isOnline = isOnline,
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(24.dp))
        }
        WidgetType.METEOROLOGY -> {
            // Reusing existing GreetingHeader, slightly modified or wrapped
            // Ideally we should refactor GreetingsHeader to be cleaner here, but we can pass params
             com.georacing.georacing.ui.screens.home.GreetingsHeader(temperature = temperature)
             Spacer(modifier = Modifier.height(24.dp))
        }
        WidgetType.STATUS_CARD -> {
            val state = circuitState ?: com.georacing.georacing.domain.model.CircuitState(
                com.georacing.georacing.domain.model.CircuitMode.UNKNOWN,
                "Cargando...",
                "--",
                ""
            )
            com.georacing.georacing.ui.components.CircuitStatusCard(
                mode = state.mode,
                message = state.message,
                temperature = state.temperature ?: "--",
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(32.dp))
        }
        WidgetType.ACTIONS_GRID -> {
             com.georacing.georacing.ui.screens.home.DashboardGrid(navController)
             Spacer(modifier = Modifier.height(32.dp))
        }
        WidgetType.NEWS_FEED -> {
            // Real news from API (iOS parity: HomeView ‚Üí newsSection)
            if (newsItems.isNotEmpty()) {
                newsItems.take(3).forEach { article ->
                    val backdrop = com.georacing.georacing.ui.glass.LocalBackdrop.current
                    com.georacing.georacing.ui.glass.LiquidCard(
                        backdrop = backdrop,
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 4.dp),
                        cornerRadius = 18.dp,
                        surfaceColor = Color(0xFF14141C).copy(alpha = 0.75f),
                        tint = Color(0xFFE8253A).copy(alpha = 0.05f)
                    ) {
                        androidx.compose.foundation.layout.Column(
                            modifier = Modifier.padding(16.dp)
                        ) {
                            androidx.compose.foundation.layout.Row(verticalAlignment = androidx.compose.ui.Alignment.CenterVertically) {
                                androidx.compose.foundation.layout.Box(
                                    modifier = Modifier
                                        .size(6.dp)
                                        .clip(androidx.compose.foundation.shape.CircleShape)
                                        .background(Color(0xFFE8253A))
                                )
                                Spacer(modifier = Modifier.width(8.dp))
                                androidx.compose.material3.Text(
                                    article.category.uppercase(),
                                    style = androidx.compose.material3.MaterialTheme.typography.labelSmall.copy(
                                        fontWeight = androidx.compose.ui.text.font.FontWeight.ExtraBold,
                                        letterSpacing = 1.sp
                                    ),
                                    color = Color(0xFFE8253A)
                                )
                            }
                            Spacer(modifier = Modifier.height(8.dp))
                            androidx.compose.material3.Text(
                                article.title,
                                style = androidx.compose.material3.MaterialTheme.typography.titleSmall.copy(
                                    fontWeight = androidx.compose.ui.text.font.FontWeight.Bold
                                ),
                                color = Color.White,
                                maxLines = 2
                            )
                            if (article.subtitle.isNotBlank()) {
                                Spacer(modifier = Modifier.height(4.dp))
                                androidx.compose.material3.Text(
                                    article.subtitle,
                                    style = androidx.compose.material3.MaterialTheme.typography.bodySmall,
                                    color = Color(0xFF94A3B8),
                                    maxLines = 2
                                )
                            }
                        }
                    }
                }
            } else {
                // Fallback static card
                com.georacing.georacing.ui.screens.home.LatestNewsCard()
            }
            Spacer(modifier = Modifier.height(24.dp))
        }
        WidgetType.PARKING_INFO -> {
             // Parking Widget - Dynamic
             val parkingLocation = appContainer?.parkingRepository?.parkingLocation?.collectAsState(initial = null)?.value
             
             androidx.compose.material3.Card(
                 colors = androidx.compose.material3.CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
                 modifier = Modifier.fillMaxWidth().clickable {
                     navController.navigate(com.georacing.georacing.ui.navigation.Screen.Parking.route)
                 }
             ) {
                 androidx.compose.foundation.layout.Row(
                     modifier = Modifier.padding(16.dp),
                     verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
                 ) {
                     androidx.compose.material3.Icon(
                         androidx.compose.material.icons.Icons.Default.LocalParking,
                         contentDescription = "Parking",
                         tint = if (parkingLocation != null) Color(0xFF22C55E) else Color(0xFF64748B)
                     )
                     Spacer(modifier = Modifier.width(16.dp))
                     androidx.compose.foundation.layout.Column {
                         androidx.compose.material3.Text("Tu Coche", color = Color(0xFFF8FAFC), fontWeight = androidx.compose.ui.text.font.FontWeight.Bold)
                         if (parkingLocation != null) {
                              androidx.compose.material3.Text("Ubicaci√≥n guardada", color = Color(0xFF22C55E), fontSize = 12.sp)
                         } else {
                              androidx.compose.material3.Text("No hay ubicaci√≥n guardada", color = Color(0xFF64748B), fontSize = 12.sp)
                         }
                     }
                 }
             }
             Spacer(modifier = Modifier.height(24.dp))
        }
        WidgetType.STAFF_ACTIONS -> {
             // Only visible for staff - placeholder
        }
        WidgetType.ECO_METER -> {
            // Eco Meter (Mini)
             androidx.compose.material3.Card(
                 colors = androidx.compose.material3.CardDefaults.cardColors(containerColor = Color(0xFF0A2A1A)),
                 modifier = Modifier.fillMaxWidth().clickable {
                      navController.navigate(com.georacing.georacing.ui.navigation.Screen.EcoMeter.route)
                 }
             ) {
                 androidx.compose.foundation.layout.Column(modifier = Modifier.padding(16.dp)) {
                    androidx.compose.foundation.layout.Row(verticalAlignment = androidx.compose.ui.Alignment.CenterVertically) {
                        androidx.compose.material3.Icon(androidx.compose.material.icons.Icons.Default.Eco, contentDescription=null, tint=Color(0xFF22C55E))
                        Spacer(modifier = Modifier.width(8.dp))
                        androidx.compose.material3.Text("EcoMeter", color = Color(0xFFF8FAFC), fontWeight = androidx.compose.ui.text.font.FontWeight.Bold)
                    }
                    Spacer(modifier = Modifier.height(12.dp))
                    androidx.compose.material3.LinearProgressIndicator(
                        progress = 0.7f,
                        modifier = Modifier.fillMaxWidth().height(8.dp).clip(androidx.compose.foundation.shape.RoundedCornerShape(4.dp)),
                        color = Color(0xFF22C55E),
                        trackColor = Color(0xFF64748B).copy(alpha=0.3f)
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    androidx.compose.foundation.layout.Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = androidx.compose.foundation.layout.Arrangement.SpaceBetween) {
                         androidx.compose.material3.Text("CO2 Ahorrado: 12kg", color = Color(0xFFF8FAFC).copy(0.7f), fontSize = 12.sp)
                         androidx.compose.material3.Text("Nivel 5", color = Color(0xFFE8253A), fontSize = 12.sp, fontWeight = androidx.compose.ui.text.font.FontWeight.Bold)
                    }
                 }
             }
             Spacer(modifier = Modifier.height(24.dp))
        }
        WidgetType.AR_ACCESS -> {
            androidx.compose.material3.Card(
                colors = androidx.compose.material3.CardDefaults.cardColors(containerColor = Color(0xFF1A1040)),
                modifier = Modifier.fillMaxWidth().clickable {
                    navController.navigate(com.georacing.georacing.ui.navigation.Screen.AR.route)
                }
            ) {
                 androidx.compose.foundation.layout.Row(
                     modifier = Modifier.padding(16.dp),
                     verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
                 ) {
                     androidx.compose.material3.Icon(
                         androidx.compose.material.icons.Icons.Default.ViewInAr,
                         contentDescription = "Experiencia AR",
                         tint = Color(0xFF06B6D4)
                     )
                     Spacer(modifier = Modifier.width(16.dp))
                     androidx.compose.material3.Text("Experiencia AR", color = Color(0xFFF8FAFC), fontWeight = androidx.compose.ui.text.font.FontWeight.Bold)
                 }
            }
            Spacer(modifier = Modifier.height(24.dp))
        }
        WidgetType.FIND_RESTROOMS -> {
            // Placeholder
            androidx.compose.material3.Card(
                colors = androidx.compose.material3.CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
                modifier = Modifier.fillMaxWidth()
            ) {
                 androidx.compose.foundation.layout.Row(
                     modifier = Modifier.padding(16.dp),
                     verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
                 ) {
                     androidx.compose.material3.Icon(
                         androidx.compose.material.icons.Icons.Default.Wc,
                         contentDescription = "Buscar aseos",
                         tint = Color(0xFF64748B)
                     )
                     Spacer(modifier = Modifier.width(16.dp))
                     androidx.compose.material3.Text("Buscar Aseos", color = Color(0xFFF8FAFC))
                 }
            }
            Spacer(modifier = Modifier.height(24.dp))
        }
        WidgetType.FOOD_OFFERS -> {
             androidx.compose.material3.Card(
                colors = androidx.compose.material3.CardDefaults.cardColors(containerColor = Color(0xFF2A1508)),
                modifier = Modifier.fillMaxWidth()
            ) {
                 androidx.compose.foundation.layout.Row(
                     modifier = Modifier.padding(16.dp),
                     verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
                 ) {
                     androidx.compose.material3.Icon(
                         androidx.compose.material.icons.Icons.Default.Fastfood,
                         contentDescription = "Ofertas de comida",
                         tint = Color(0xFFF97316)
                     )
                     Spacer(modifier = Modifier.width(16.dp))
                     androidx.compose.material3.Text("Ofertas Gastron√≥micas", color = Color(0xFFF8FAFC), fontWeight = androidx.compose.ui.text.font.FontWeight.Bold)
                 }
            }
            Spacer(modifier = Modifier.height(24.dp))
        }
        WidgetType.ACHIEVEMENTS -> {
            // Gamification widget - Fan level mini card
            val profile = appContainer?.gamificationRepository?.profile?.collectAsState()?.value
            if (profile != null) {
                val unlockedCount = profile.achievements.count { it.isUnlocked }
                val totalCount = profile.achievements.size
                androidx.compose.material3.Card(
                    colors = androidx.compose.material3.CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
                    modifier = Modifier.fillMaxWidth().clickable {
                        navController.navigate(com.georacing.georacing.ui.navigation.Screen.Achievements.route)
                    },
                    shape = androidx.compose.foundation.shape.RoundedCornerShape(16.dp),
                    border = androidx.compose.foundation.BorderStroke(0.5.dp, Color(0xFFE8253A).copy(alpha = 0.2f))
                ) {
                    androidx.compose.foundation.layout.Row(
                        modifier = Modifier.padding(16.dp),
                        verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
                    ) {
                        // Level badge
                        androidx.compose.foundation.layout.Box(
                            modifier = Modifier
                                .size(48.dp)
                                .clip(androidx.compose.foundation.shape.CircleShape)
                                .background(
                                    androidx.compose.ui.graphics.Brush.radialGradient(
                                        listOf(Color(0xFFE8253A).copy(alpha = 0.3f), Color.Transparent)
                                    )
                                )
                                .border(1.5.dp, Color(0xFFE8253A).copy(alpha = 0.4f), androidx.compose.foundation.shape.CircleShape),
                            contentAlignment = androidx.compose.ui.Alignment.Center
                        ) {
                            androidx.compose.material3.Text(
                                "${profile.level}",
                                color = Color.White,
                                fontWeight = androidx.compose.ui.text.font.FontWeight.Black,
                                fontSize = 18.sp
                            )
                        }
                        Spacer(modifier = Modifier.width(14.dp))
                        androidx.compose.foundation.layout.Column(modifier = Modifier.weight(1f)) {
                            androidx.compose.material3.Text(profile.levelName, color = Color(0xFFF8FAFC), fontWeight = androidx.compose.ui.text.font.FontWeight.Bold)
                            Spacer(modifier = Modifier.height(4.dp))
                            androidx.compose.material3.LinearProgressIndicator(
                                progress = { profile.xpProgress },
                                modifier = Modifier.fillMaxWidth().height(4.dp).clip(androidx.compose.foundation.shape.RoundedCornerShape(2.dp)),
                                color = Color(0xFFE8253A),
                                trackColor = Color(0xFF1E1E2A)
                            )
                            Spacer(modifier = Modifier.height(4.dp))
                            androidx.compose.material3.Text(
                                "üèÜ $unlockedCount/$totalCount logros ¬∑ ${profile.totalXP} XP",
                                color = Color(0xFF64748B), fontSize = 11.sp
                            )
                        }
                        androidx.compose.material3.Icon(
                            androidx.compose.material.icons.Icons.Default.ChevronRight,
                            contentDescription = "Ver logros",
                            tint = Color(0xFF475569)
                        )
                    }
                }
            }
            Spacer(modifier = Modifier.height(24.dp))
        }
        WidgetType.SEARCH_ACCESS -> {
            // Quick search bar
            androidx.compose.material3.Card(
                colors = androidx.compose.material3.CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
                modifier = Modifier.fillMaxWidth().clickable {
                    navController.navigate(com.georacing.georacing.ui.navigation.Screen.Search.route)
                },
                shape = androidx.compose.foundation.shape.RoundedCornerShape(12.dp)
            ) {
                androidx.compose.foundation.layout.Row(
                    modifier = Modifier.padding(14.dp),
                    verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
                ) {
                    androidx.compose.material3.Icon(
                        androidx.compose.material.icons.Icons.Default.Search,
                        contentDescription = "Buscar",
                        tint = Color(0xFF64748B)
                    )
                    Spacer(modifier = Modifier.width(12.dp))
                    androidx.compose.material3.Text(
                        "Buscar en el circuito...",
                        color = Color(0xFF64748B),
                        fontSize = 14.sp
                    )
                }
            }
            Spacer(modifier = Modifier.height(24.dp))
        }

        WidgetType.CLICK_COLLECT -> {
            androidx.compose.material3.Card(
                colors = androidx.compose.material3.CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
                modifier = Modifier.fillMaxWidth().clickable {
                    navController.navigate(com.georacing.georacing.ui.navigation.Screen.ClickCollect.route)
                },
                shape = androidx.compose.foundation.shape.RoundedCornerShape(16.dp)
            ) {
                androidx.compose.foundation.layout.Row(
                    modifier = Modifier.padding(16.dp),
                    verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
                ) {
                    androidx.compose.material3.Icon(
                        androidx.compose.material.icons.Icons.Default.ShoppingCart,
                        contentDescription = null,
                        tint = Color(0xFFEC4899),
                        modifier = Modifier.size(28.dp)
                    )
                    Spacer(modifier = Modifier.width(12.dp))
                    androidx.compose.foundation.layout.Column {
                        androidx.compose.material3.Text(
                            "Click & Collect",
                            color = Color.White,
                            fontWeight = androidx.compose.ui.text.font.FontWeight.Bold,
                            fontSize = 16.sp
                        )
                        androidx.compose.material3.Text(
                            "Pide comida y recoge sin colas",
                            color = Color(0xFF64748B),
                            fontSize = 12.sp
                        )
                    }
                }
            }
            Spacer(modifier = Modifier.height(24.dp))
        }

        WidgetType.WRAPPED -> {
            androidx.compose.material3.Card(
                colors = androidx.compose.material3.CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
                modifier = Modifier.fillMaxWidth().clickable {
                    navController.navigate(com.georacing.georacing.ui.navigation.Screen.Wrapped.route)
                },
                shape = androidx.compose.foundation.shape.RoundedCornerShape(16.dp)
            ) {
                androidx.compose.foundation.layout.Row(
                    modifier = Modifier.padding(16.dp),
                    verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
                ) {
                    androidx.compose.material3.Icon(
                        androidx.compose.material.icons.Icons.Default.Star,
                        contentDescription = null,
                        tint = Color(0xFF8B5CF6),
                        modifier = Modifier.size(28.dp)
                    )
                    Spacer(modifier = Modifier.width(12.dp))
                    androidx.compose.foundation.layout.Column {
                        androidx.compose.material3.Text(
                            "GeoRacing Wrapped",
                            color = Color.White,
                            fontWeight = androidx.compose.ui.text.font.FontWeight.Bold,
                            fontSize = 16.sp
                        )
                        androidx.compose.material3.Text(
                            "Tu resumen post-evento",
                            color = Color(0xFF64748B),
                            fontSize = 12.sp
                        )
                    }
                }
            }
            Spacer(modifier = Modifier.height(24.dp))
        }

        WidgetType.COLLECTIBLES -> {
            androidx.compose.material3.Card(
                colors = androidx.compose.material3.CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
                modifier = Modifier.fillMaxWidth().clickable {
                    navController.navigate(com.georacing.georacing.ui.navigation.Screen.Collectibles.route)
                },
                shape = androidx.compose.foundation.shape.RoundedCornerShape(16.dp)
            ) {
                androidx.compose.foundation.layout.Row(
                    modifier = Modifier.padding(16.dp),
                    verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
                ) {
                    androidx.compose.material3.Icon(
                        androidx.compose.material.icons.Icons.Default.AccountBox,
                        contentDescription = null,
                        tint = Color(0xFFF59E0B),
                        modifier = Modifier.size(28.dp)
                    )
                    Spacer(modifier = Modifier.width(12.dp))
                    androidx.compose.foundation.layout.Column {
                        androidx.compose.material3.Text(
                            "Cromos Digitales",
                            color = Color.White,
                            fontWeight = androidx.compose.ui.text.font.FontWeight.Bold,
                            fontSize = 16.sp
                        )
                        androidx.compose.material3.Text(
                            "Colecciona 24 cromos exclusivos",
                            color = Color(0xFF64748B),
                            fontSize = 12.sp
                        )
                    }
                }
            }
            Spacer(modifier = Modifier.height(24.dp))
        }

        WidgetType.PROXIMITY_CHAT -> {
            androidx.compose.material3.Card(
                colors = androidx.compose.material3.CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
                modifier = Modifier.fillMaxWidth().clickable {
                    navController.navigate(com.georacing.georacing.ui.navigation.Screen.ProximityChat.route)
                },
                shape = androidx.compose.foundation.shape.RoundedCornerShape(16.dp)
            ) {
                androidx.compose.foundation.layout.Row(
                    modifier = Modifier.padding(16.dp),
                    verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
                ) {
                    androidx.compose.material3.Icon(
                        androidx.compose.material.icons.Icons.Default.Forum,
                        contentDescription = null,
                        tint = Color(0xFF10B981),
                        modifier = Modifier.size(28.dp)
                    )
                    Spacer(modifier = Modifier.width(12.dp))
                    androidx.compose.foundation.layout.Column {
                        androidx.compose.material3.Text(
                            "Chat Cercano",
                            color = Color.White,
                            fontWeight = androidx.compose.ui.text.font.FontWeight.Bold,
                            fontSize = 16.sp
                        )
                        androidx.compose.material3.Text(
                            "Habla con fans cercanos via BLE",
                            color = Color(0xFF64748B),
                            fontSize = 12.sp
                        )
                    }
                }
            }
            Spacer(modifier = Modifier.height(24.dp))
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/incidents/IncidentReportScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.incidents

import android.app.Application
import android.graphics.ImageDecoder
import android.os.Build
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.*
import androidx.compose.animation.fadeIn
import androidx.compose.animation.slideInVertically
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.AddAPhoto
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import androidx.navigation.NavController
import com.georacing.georacing.R
import com.georacing.georacing.domain.model.IncidentCategory
import com.georacing.georacing.domain.repository.IncidentsRepository
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.components.GlassCard
import com.georacing.georacing.ui.components.HomeIconButton
import com.georacing.georacing.ui.components.RacingButton
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.*

/**
 * IncidentReportScreen ‚Äî Premium Incident Report HUD
 * Reportar incidencias al staff con fotos y categor√≠a.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun IncidentReportScreen(
    navController: NavController,
    incidentsRepository: IncidentsRepository
) {
    val backdrop = LocalBackdrop.current
    val context = androidx.compose.ui.platform.LocalContext.current
    val application = context.applicationContext as Application

    val viewModel: IncidentViewModel = viewModel(
        factory = viewModelFactory {
            initializer { IncidentViewModel(application, incidentsRepository) }
        }
    )

    var category by remember { mutableStateOf(IncidentCategory.OTRA) }
    var description by remember { mutableStateOf("") }
    var expanded by remember { mutableStateOf(false) }
    val snackbarHostState = remember { SnackbarHostState() }
    var showContent by remember { mutableStateOf(false) }
    LaunchedEffect(Unit) { showContent = true }

    // Observe ViewModel states
    val isProcessing by viewModel.isProcessing.collectAsState()
    val selectedPhotoUri by viewModel.selectedPhotoUri.collectAsState()

    // Photo picker launcher
    val photoPickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri ->
        viewModel.setPhotoUri(uri)
    }

    LaunchedEffect(true) {
        viewModel.uiEvent.collect { event ->
            when (event) {
                is IncidentViewModel.UiEvent.Success -> {
                    snackbarHostState.showSnackbar("Incidencia enviada al staff correctamente")
                    navController.popBackStack()
                }
                is IncidentViewModel.UiEvent.Error -> {
                    snackbarHostState.showSnackbar(event.message)
                }
            }
        }
    }

    Box(Modifier.fillMaxSize()) {
        CarbonBackground()

        Column(Modifier.fillMaxSize()) {
            // ‚îÄ‚îÄ Premium LiquidTopBar ‚îÄ‚îÄ
            LiquidTopBar(
                backdrop = backdrop,
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, stringResource(R.string.cd_back), tint = TextPrimary)
                    }
                },
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Box(Modifier.size(8.dp).clip(CircleShape).background(StatusAmber))
                        Spacer(Modifier.width(10.dp))
                        Column {
                            Text(stringResource(R.string.incident_report_title).uppercase(), style = MaterialTheme.typography.titleMedium, color = TextPrimary, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                            Text("Reporte directo al staff", style = MaterialTheme.typography.labelSmall, color = TextTertiary)
                        }
                    }
                },
                actions = {
                    HomeIconButton {
                        navController.navigate(Screen.Home.route) {
                            popUpTo(Screen.Home.route) { inclusive = true }
                        }
                    }
                }
            )

            Box(Modifier.fillMaxSize()) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .verticalScroll(rememberScrollState())
                        .padding(20.dp)
                ) {
                    // Help text
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(400)) + slideInVertically(tween(400)) { -15 }
                    ) {
                        Text(
                            "El staff recibir√° tu reporte y lo atender√° lo antes posible",
                            style = MaterialTheme.typography.bodyMedium,
                            color = TextTertiary,
                            modifier = Modifier.padding(bottom = 24.dp)
                        )
                    }

                    // ‚îÄ‚îÄ Category Section ‚îÄ‚îÄ
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(400, 100)) + slideInVertically(tween(400, 100)) { 20 }
                    ) {
                        Column {
                            Text(
                                stringResource(R.string.incident_category_label).uppercase(),
                                style = MaterialTheme.typography.labelLarge.copy(
                                    fontWeight = FontWeight.Black,
                                    letterSpacing = 2.sp
                                ),
                                color = TextTertiary,
                                modifier = Modifier.padding(bottom = 8.dp)
                            )

                            ExposedDropdownMenuBox(
                                expanded = expanded,
                                onExpandedChange = { expanded = !expanded }
                            ) {
                                OutlinedTextField(
                                    value = category.displayName,
                                    onValueChange = {},
                                    readOnly = true,
                                    trailingIcon = {
                                        Icon(Icons.Default.ArrowDropDown, "Expandir", tint = RacingRed)
                                    },
                                    modifier = Modifier.fillMaxWidth().menuAnchor(),
                                    colors = OutlinedTextFieldDefaults.colors(
                                        focusedBorderColor = RacingRed,
                                        unfocusedBorderColor = MetalGrey,
                                        focusedTextColor = TextPrimary,
                                        unfocusedTextColor = TextPrimary,
                                        cursorColor = RacingRed,
                                        focusedContainerColor = AsphaltGrey.copy(alpha = 0.5f),
                                        unfocusedContainerColor = AsphaltGrey.copy(alpha = 0.3f)
                                    ),
                                    shape = RoundedCornerShape(14.dp)
                                )

                                ExposedDropdownMenu(
                                    expanded = expanded,
                                    onDismissRequest = { expanded = false },
                                    modifier = Modifier
                                        .background(AsphaltGrey)
                                        .border(1.dp, MetalGrey.copy(alpha = 0.5f), RoundedCornerShape(12.dp))
                                ) {
                                    IncidentCategory.values().forEach { item ->
                                        DropdownMenuItem(
                                            text = { Text(item.displayName, color = TextPrimary, fontWeight = FontWeight.SemiBold) },
                                            onClick = { category = item; expanded = false },
                                            colors = MenuDefaults.itemColors(
                                                textColor = TextPrimary,
                                                leadingIconColor = TextPrimary
                                            )
                                        )
                                    }
                                }
                            }
                        }
                    }

                    Spacer(Modifier.height(24.dp))

                    // ‚îÄ‚îÄ Description Section ‚îÄ‚îÄ
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(400, 200)) + slideInVertically(tween(400, 200)) { 20 }
                    ) {
                        Column {
                            Text(
                                stringResource(R.string.incident_description_label).uppercase(),
                                style = MaterialTheme.typography.labelLarge.copy(
                                    fontWeight = FontWeight.Black,
                                    letterSpacing = 2.sp
                                ),
                                color = TextTertiary,
                                modifier = Modifier.padding(bottom = 8.dp)
                            )

                            OutlinedTextField(
                                value = description,
                                onValueChange = { description = it },
                                placeholder = {
                                    Text(
                                        stringResource(R.string.incident_description_hint),
                                        color = TextTertiary,
                                        style = MaterialTheme.typography.bodyMedium
                                    )
                                },
                                modifier = Modifier.fillMaxWidth().height(160.dp),
                                maxLines = 8,
                                colors = OutlinedTextFieldDefaults.colors(
                                    focusedBorderColor = RacingRed,
                                    unfocusedBorderColor = MetalGrey,
                                    focusedTextColor = TextPrimary,
                                    unfocusedTextColor = TextPrimary,
                                    cursorColor = RacingRed,
                                    focusedContainerColor = AsphaltGrey.copy(alpha = 0.5f),
                                    unfocusedContainerColor = AsphaltGrey.copy(alpha = 0.3f)
                                ),
                                shape = RoundedCornerShape(14.dp)
                            )
                        }
                    }

                    Spacer(Modifier.height(24.dp))

                    // ‚îÄ‚îÄ Photos Section ‚îÄ‚îÄ
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(400, 300)) + slideInVertically(tween(400, 300)) { 20 }
                    ) {
                        Column {
                            Text(
                                stringResource(R.string.incident_photos_label).uppercase(),
                                style = MaterialTheme.typography.labelLarge.copy(
                                    fontWeight = FontWeight.Black,
                                    letterSpacing = 2.sp
                                ),
                                color = TextTertiary,
                                modifier = Modifier.padding(bottom = 8.dp)
                            )

                            GlassCard(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .clickable { photoPickerLauncher.launch("image/*") },
                                shape = RoundedCornerShape(14.dp)
                            ) {
                                if (selectedPhotoUri != null) {
                                    Column(
                                        modifier = Modifier.fillMaxWidth().padding(16.dp),
                                        horizontalAlignment = Alignment.CenterHorizontally
                                    ) {
                                        val ctx = androidx.compose.ui.platform.LocalContext.current
                                        val bitmap = remember(selectedPhotoUri) {
                                            try {
                                                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                                                    val source = ImageDecoder.createSource(ctx.contentResolver, selectedPhotoUri!!)
                                                    ImageDecoder.decodeBitmap(source)
                                                } else {
                                                    @Suppress("DEPRECATION")
                                                    android.provider.MediaStore.Images.Media.getBitmap(ctx.contentResolver, selectedPhotoUri)
                                                }
                                            } catch (_: Exception) { null }
                                        }
                                        if (bitmap != null) {
                                            Image(
                                                bitmap = bitmap.asImageBitmap(),
                                                contentDescription = "Foto seleccionada",
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .height(150.dp)
                                                    .clip(RoundedCornerShape(12.dp))
                                            )
                                        }
                                        Spacer(Modifier.height(8.dp))
                                        Text("Tocar para cambiar", style = MaterialTheme.typography.bodySmall, color = TextTertiary)
                                    }
                                } else {
                                    Row(
                                        modifier = Modifier.fillMaxWidth().padding(16.dp),
                                        verticalAlignment = Alignment.CenterVertically,
                                        horizontalArrangement = Arrangement.Center
                                    ) {
                                        Box(
                                            Modifier
                                                .size(40.dp)
                                                .clip(RoundedCornerShape(12.dp))
                                                .background(StatusAmber.copy(alpha = 0.12f))
                                                .drawBehind {
                                                    drawCircle(StatusAmber.copy(alpha = 0.06f), radius = size.minDimension * 0.9f)
                                                },
                                            contentAlignment = Alignment.Center
                                        ) {
                                            Icon(Icons.Default.AddAPhoto, stringResource(R.string.cd_camera), modifier = Modifier.size(20.dp), tint = StatusAmber)
                                        }
                                        Spacer(Modifier.width(14.dp))
                                        Text(
                                            stringResource(R.string.incident_add_photo),
                                            style = MaterialTheme.typography.titleMedium,
                                            color = TextPrimary,
                                            fontWeight = FontWeight.Bold
                                        )
                                    }
                                }
                            }
                        }
                    }

                    Spacer(Modifier.height(32.dp))

                    // ‚îÄ‚îÄ Submit Button ‚îÄ‚îÄ
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(500, 450)) + slideInVertically(tween(500, 450)) { 20 }
                    ) {
                        RacingButton(
                            text = stringResource(R.string.incident_send),
                            onClick = { viewModel.sendIncident(category, description) },
                            enabled = description.isNotBlank() && !isProcessing
                        )
                    }

                    Spacer(Modifier.height(100.dp))
                }

                // ‚îÄ‚îÄ Loading Overlay ‚îÄ‚îÄ
                if (isProcessing) {
                    Box(
                        modifier = Modifier
                            .fillMaxSize()
                            .background(CarbonBlack.copy(alpha = 0.85f)),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(horizontalAlignment = Alignment.CenterHorizontally) {
                            val pulseAnim = rememberInfiniteTransition(label = "proc")
                            val pulseScale by pulseAnim.animateFloat(
                                initialValue = 0.9f, targetValue = 1.1f,
                                animationSpec = infiniteRepeatable(tween(600), RepeatMode.Reverse), label = "s"
                            )
                            Box(
                                Modifier
                                    .size(64.dp)
                                    .graphicsLayer { scaleX = pulseScale; scaleY = pulseScale }
                                    .drawBehind {
                                        drawCircle(RacingRed.copy(alpha = 0.15f), radius = size.minDimension / 2)
                                    },
                                contentAlignment = Alignment.Center
                            ) {
                                CircularProgressIndicator(color = RacingRed, strokeWidth = 3.dp, modifier = Modifier.size(40.dp))
                            }
                            Spacer(Modifier.height(16.dp))
                            Text(
                                "Procesando imagen...",
                                color = TextPrimary,
                                style = MaterialTheme.typography.bodyMedium,
                                letterSpacing = 0.5.sp
                            )
                        }
                    }
                }

                // Snackbar
                SnackbarHost(
                    hostState = snackbarHostState,
                    modifier = Modifier.align(Alignment.BottomCenter)
                )
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/incidents/IncidentViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.incidents

import android.app.Application
import android.net.Uri
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.domain.model.IncidentCategory
import com.georacing.georacing.domain.model.IncidentReport
import com.georacing.georacing.domain.repository.IncidentsRepository
import com.georacing.georacing.utils.ImageUtils
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.receiveAsFlow
import kotlinx.coroutines.launch

class IncidentViewModel(
    application: Application,
    private val incidentsRepository: IncidentsRepository
) : AndroidViewModel(application) {

    private val _uiEvent = Channel<UiEvent>()
    val uiEvent = _uiEvent.receiveAsFlow()
    
    // Loading state for compression
    private val _isProcessing = MutableStateFlow(false)
    val isProcessing: StateFlow<Boolean> = _isProcessing.asStateFlow()
    
    // Selected photo URI
    private val _selectedPhotoUri = MutableStateFlow<Uri?>(null)
    val selectedPhotoUri: StateFlow<Uri?> = _selectedPhotoUri.asStateFlow()

    fun setPhotoUri(uri: Uri?) {
        _selectedPhotoUri.value = uri
    }

    // Ubicaci√≥n actual para geolocalizar incidencias
    private val _currentLocation = MutableStateFlow<android.location.Location?>(null)
    
    fun updateLocation(location: android.location.Location) {
        _currentLocation.value = location
    }
    
    init {
        // Obtener √∫ltima ubicaci√≥n conocida al inicializar
        try {
            val fusedClient = com.google.android.gms.location.LocationServices
                .getFusedLocationProviderClient(application)
            fusedClient.lastLocation.addOnSuccessListener { location ->
                location?.let { _currentLocation.value = it }
            }
        } catch (e: SecurityException) {
            // Sin permisos de ubicaci√≥n
        }
    }
    
    fun sendIncident(category: IncidentCategory, description: String) {
        viewModelScope.launch {
            try {
                _isProcessing.value = true
                
                // Compress image if present
                var compressedImageData: ByteArray? = null
                val photoUri = _selectedPhotoUri.value
                
                if (photoUri != null) {
                    compressedImageData = ImageUtils.compressImage(
                        getApplication<Application>().applicationContext,
                        photoUri
                    )
                    
                    if (compressedImageData == null) {
                        _uiEvent.send(UiEvent.Error("Error al procesar la imagen"))
                        _isProcessing.value = false
                        return@launch
                    }
                }
                
                // Geolocalizaci√≥n autom√°tica del incidente
                val location = _currentLocation.value
                val zoneDescription = location?.let {
                    "Lat: ${String.format("%.6f", it.latitude)}, Lon: ${String.format("%.6f", it.longitude)}"
                }
                
                val incident = IncidentReport(
                    category = category,
                    description = description,
                    beaconId = location?.let { "GPS:${String.format("%.4f", it.latitude)},${String.format("%.4f", it.longitude)}" },
                    zone = zoneDescription,
                    timestamp = System.currentTimeMillis(),
                    photoData = compressedImageData
                )
                
                incidentsRepository.reportIncident(incident)
                _isProcessing.value = false
                _uiEvent.send(UiEvent.Success)
                
            } catch (e: Exception) {
                _isProcessing.value = false
                _uiEvent.send(UiEvent.Error(e.message ?: "Error desconocido"))
            }
        }
    }

    sealed class UiEvent {
        object Success : UiEvent()
        data class Error(val message: String = "Error al enviar incidencia") : UiEvent()
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/login/LoginScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.login

import android.app.Activity
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.core.*
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Speed
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.credentials.CredentialManager
import androidx.credentials.GetCredentialRequest
import androidx.credentials.exceptions.GetCredentialException
import androidx.credentials.exceptions.NoCredentialException
import androidx.navigation.NavController
import com.georacing.georacing.R
import com.georacing.georacing.data.firebase.FirebaseAuthService
import com.georacing.georacing.data.repository.NetworkUserRepository
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.CarbonBlack
import com.georacing.georacing.ui.theme.RacingRed
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInClient
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
import com.google.android.gms.common.api.ApiException
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import com.georacing.georacing.ui.theme.*
import androidx.compose.ui.graphics.Brush

@Composable
fun LoginScreen(navController: NavController) {
    val context = LocalContext.current
    val backdrop = com.georacing.georacing.ui.glass.LocalBackdrop.current
    val scope = rememberCoroutineScope()
    val authService = remember { FirebaseAuthService() }
    val userRepository = remember { NetworkUserRepository() }
    
    var isLoading by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf<String?>(null) }
    
    // Web Client ID de Firebase (OAuth 2.0)
    val webClientId = "62243274149-iv3ra1epplkgsr3oeipgrej6i9r62qfs.apps.googleusercontent.com"
    
    // GoogleSignInClient (fallback para Credential Manager)
    val googleSignInClient = remember {
        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
            .requestIdToken(webClientId)
            .requestEmail()
            .build()
        GoogleSignIn.getClient(context, gso)
    }
    
    // Launcher para el resultado del Intent de Google Sign-In
    val googleSignInLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)
            try {
                val account = task.getResult(ApiException::class.java)
                val idToken = account.idToken
                
                if (idToken != null) {
                    Log.d("LoginScreen", "‚úÖ Google ID Token obtenido (GoogleSignInClient)")
                    scope.launch {
                        isLoading = true
                        val authResult = authService.signInWithGoogle(idToken)
                        
                        if (authResult.isSuccess) {
                            val user = authResult.getOrNull()
                            Log.d("LoginScreen", "‚úÖ Login exitoso: ${user?.email}")
                            user?.let {
                                userRepository.registerUser(
                                    uid = it.uid,
                                    name = it.displayName,
                                    email = it.email,
                                    photoUrl = it.photoUrl?.toString()
                                )
                            }
                            
                            // Consultar rol del usuario en Firestore
                            var userRole = "user"
                            try {
                                val firestore = FirebaseFirestore.getInstance()
                                val doc = firestore.collection("staff_roles")
                                    .document(user?.uid ?: "")
                                    .get()
                                    .await()
                                if (doc.exists()) {
                                    userRole = doc.getString("role") ?: "user"
                                    Log.d("LoginScreen", "üîë Rol del usuario: $userRole")
                                }
                            } catch (e: Exception) {
                                Log.w("LoginScreen", "No se pudo consultar rol, default=user", e)
                            }
                            
                            // Redirigir seg√∫n rol
                            when (userRole) {
                                "staff", "admin" -> {
                                    Log.d("LoginScreen", "üîê Redirigiendo a modo Staff")
                                    navController.navigate(Screen.StaffMode.route) {
                                        popUpTo(0) { inclusive = true }
                                    }
                                }
                                else -> {
                                    navController.navigate(Screen.Home.route) {
                                        popUpTo(0) { inclusive = true }
                                    }
                                }
                            }
                        } else {
                            errorMessage = "Error al autenticar con Firebase"
                            Log.e("LoginScreen", "Error Firebase", authResult.exceptionOrNull())
                        }
                        isLoading = false
                    }
                } else {
                    errorMessage = "No se pudo obtener el token de Google"
                    isLoading = false
                }
            } catch (e: ApiException) {
                Log.e("LoginScreen", "Error Google Sign-In: ${e.statusCode}", e)
                errorMessage = "Error al iniciar sesi√≥n con Google"
                isLoading = false
            }
        } else {
            Log.d("LoginScreen", "Login cancelado por el usuario")
            isLoading = false
        }
    }
    
    // Log de debug al entrar en la pantalla
    LaunchedEffect(Unit) {
        Log.d("LoginScreen", "üé¨ LoginScreen cargada correctamente")
    }
    
    // Animaci√≥n de pulsaci√≥n del logo
    val infiniteTransition = rememberInfiniteTransition(label = "pulse")
    val pulseScale by infiniteTransition.animateFloat(
        initialValue = 1f,
        targetValue = 1.05f,
        animationSpec = infiniteRepeatable(
            animation = tween(1500, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "pulse"
    )
    
    fun handleGoogleSignIn() {
        Log.d("LoginScreen", "üöÄ Iniciando Google Sign-In con GoogleSignInClient (compatible con emuladores)")
        isLoading = true
        errorMessage = null
        
        // Usar Intent directo de Google Sign-In
        val signInIntent = googleSignInClient.signInIntent
        googleSignInLauncher.launch(signInIntent)
    }
    
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        Color(0xFF06060C),
                        Color(0xFF0A0A12),
                        Color(0xFF0E0E18),
                        Color(0xFF080810)
                    )
                )
            )
    ) {
        // ‚îÄ‚îÄ Ambient racing glows ‚îÄ‚îÄ
        androidx.compose.foundation.Canvas(modifier = Modifier.fillMaxSize()) {
            // Racing red glow
            drawCircle(
                brush = Brush.radialGradient(
                    colors = listOf(
                        Color(0xFFE8253A).copy(alpha = 0.08f),
                        Color.Transparent
                    ),
                    center = androidx.compose.ui.geometry.Offset(size.width * 0.5f, size.height * 0.25f),
                    radius = size.width * 0.6f
                ),
                radius = size.width * 0.6f,
                center = androidx.compose.ui.geometry.Offset(size.width * 0.5f, size.height * 0.25f)
            )
        }
        
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(32.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // Logo / Icono con glow sutil
            Box(contentAlignment = Alignment.Center) {
                // Glow ring
                Box(
                    modifier = Modifier
                        .size(140.dp)
                        .background(
                            brush = Brush.radialGradient(
                                colors = listOf(
                                    RacingRed.copy(alpha = 0.15f * pulseScale),
                                    Color.Transparent
                                )
                            ),
                            shape = androidx.compose.foundation.shape.CircleShape
                        )
                )
                Icon(
                    imageVector = Icons.Default.Speed,
                    contentDescription = "GeoRacing",
                    modifier = Modifier
                        .size(100.dp)
                        .graphicsLayer {
                            scaleX = pulseScale
                            scaleY = pulseScale
                        },
                    tint = RacingRed
                )
            }
            
            Spacer(modifier = Modifier.height(28.dp))
            
            // T√≠tulo con accent dot
            Row(verticalAlignment = Alignment.CenterVertically) {
                Box(
                    modifier = Modifier
                        .size(8.dp)
                        .background(RacingRed, shape = androidx.compose.foundation.shape.CircleShape)
                )
                Spacer(modifier = Modifier.width(10.dp))
                Text(
                    text = "GEORACING",
                    style = MaterialTheme.typography.displaySmall.copy(
                        fontWeight = FontWeight.Black,
                        letterSpacing = 3.sp
                    ),
                    color = TextPrimary
                )
            }
            
            Text(
                text = "CIRCUIT DE BARCELONA CATALUNYA",
                style = MaterialTheme.typography.labelMedium,
                color = TextTertiary,
                modifier = Modifier.padding(top = 8.dp),
                letterSpacing = 2.sp
            )
            
            Spacer(modifier = Modifier.height(56.dp))
            
            // Texto de bienvenida
            Text(
                text = "La experiencia racing\ndefinitiva",
                style = MaterialTheme.typography.headlineMedium.copy(
                    fontWeight = FontWeight.ExtraBold
                ),
                color = TextPrimary,
                textAlign = TextAlign.Center
            )
            
            Spacer(modifier = Modifier.height(12.dp))
            
            Text(
                text = "Inicia sesi√≥n con tu cuenta de Google\npara acceder a todas las funciones",
                style = MaterialTheme.typography.bodyMedium,
                color = TextSecondary,
                textAlign = TextAlign.Center
            )
            
            Spacer(modifier = Modifier.height(48.dp))
            
            // Bot√≥n de Google Sign-In (Custom Styled)
            // Bot√≥n de Google Sign-In (Liquid Glass Styled)
            com.georacing.georacing.ui.glass.LiquidButton(
                onClick = { handleGoogleSignIn() },
                backdrop = backdrop,
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                isInteractive = !isLoading,
                surfaceColor = Color.White.copy(alpha = 0.9f)
            ) {
                if (isLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(24.dp),
                        color = RacingRed,
                        strokeWidth = 2.dp
                    )
                } else {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.Center
                    ) {
                        // Icono de Google
                        Icon(
                            imageVector = Icons.Default.Speed, // Placeholder, idealmente logo G real
                            contentDescription = "Google",
                            modifier = Modifier.size(24.dp),
                            tint = Color.Black 
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Text(
                            text = "CONTINUAR CON GOOGLE",
                            style = MaterialTheme.typography.labelLarge.copy(fontWeight = FontWeight.Bold),
                            color = Color.Black
                        )
                    }
                }
            }
            
            // Mensaje de error
            if (errorMessage != null) {
                Spacer(modifier = Modifier.height(24.dp))
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .liquidGlass(
                            shape = RoundedCornerShape(12.dp),
                            level = GlassLevel.L1
                        )
                        .background(CircuitStop.copy(alpha = 0.1f))
                        .padding(16.dp)
                ) {
                    Text(
                        text = errorMessage ?: "",
                        color = StatusRed,
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center,
                        modifier = Modifier.fillMaxWidth()
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(32.dp))
            
            // T√©rminos y condiciones
            Text(
                text = "Al continuar, aceptas nuestros t√©rminos\ny condiciones de uso",
                style = MaterialTheme.typography.bodySmall,
                color = TextTertiary,
                textAlign = TextAlign.Center
            )
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/map/MapScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.map

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import androidx.navigation.NavController
import com.georacing.georacing.car.MapStyleManager
import com.georacing.georacing.data.local.UserPreferencesDataStore
import com.georacing.georacing.domain.model.Confidence
import com.georacing.georacing.domain.model.NodeType
import com.georacing.georacing.domain.repository.BeaconsRepository
import com.georacing.georacing.ui.components.Sidebar
import com.georacing.georacing.ui.components.menu.SideMenuContent
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.*
import com.google.gson.Gson
import com.google.gson.JsonObject

import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LiquidPill
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.kyant.backdrop.Backdrop

// Racing Dark Theme Colors
private val RacingAccent = Color(0xFF06B6D4)    // NeonCyan
private val SearchBarBg = Color(0xFF14141C)       // Dark surface
private val SearchBarText = Color(0xFFF8FAFC)     // Light text
private val ChipBg = Color(0xFF14141C)            // Dark surface
private val ChipBgSelected = Color(0xFF14141C).copy(alpha = 0.8f)
private val ChipText = Color(0xFFF8FAFC)          // Light text
private val SheetBg = Color(0xFF0E0E18)           // Darker surface
private val SubtleGray = Color(0xFF64748B)        // Slate

// Category chips data
data class CategoryChip(
    val emoji: String,
    val label: String,
    val type: NodeType?
)

private val categoryChips = listOf(
    CategoryChip("üçî", "Comida", NodeType.FOOD),
    CategoryChip("üöª", "Ba√±os", NodeType.RESTROOM),
    CategoryChip("üëï", "Merch", NodeType.MERCHANDISE),
    CategoryChip("üéüÔ∏è", "Mi Puerta", NodeType.GATE)
)

@OptIn(ExperimentalMaterial3Api::class, com.google.accompanist.permissions.ExperimentalPermissionsApi::class)
@Composable
fun MapScreen(
    navController: NavController,
    beaconsRepository: BeaconsRepository,
    userPreferences: UserPreferencesDataStore
) {
    val viewModel: MapViewModel = viewModel(
        factory = viewModelFactory {
            initializer {
                val app = (this[androidx.lifecycle.ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY] as android.app.Application)
                MapViewModel(app, beaconsRepository, userPreferences)
            }
        }
    )

    val selectedType by viewModel.selectedType.collectAsState()
    val visibleNodes by viewModel.visibleNodes.collectAsState()
    var isSidebarOpen by remember { mutableStateOf(false) }
    var mapError by remember { mutableStateOf<String?>(null) }
    val snackbarHostState = remember { SnackbarHostState() }

    // Map Lifecycle & Context
    val context = androidx.compose.ui.platform.LocalContext.current
    val lifecycleOwner = androidx.lifecycle.compose.LocalLifecycleOwner.current
    val mapStyleManager = remember { MapStyleManager(context) }
    var mapInstance by remember { mutableStateOf<org.maplibre.android.maps.MapLibreMap?>(null) }
    var isMapStyleLoaded by remember { mutableStateOf(false) }

    // Permissions
    val permissions = mutableListOf(
        android.Manifest.permission.ACCESS_FINE_LOCATION,
        android.Manifest.permission.ACCESS_COARSE_LOCATION
    )
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
        permissions.add(android.Manifest.permission.BLUETOOTH_SCAN)
        permissions.add(android.Manifest.permission.BLUETOOTH_CONNECT)
    }
    val permissionsState = com.google.accompanist.permissions.rememberMultiplePermissionsState(permissions = permissions)
    
    LaunchedEffect(Unit) { permissionsState.launchMultiplePermissionRequest() }
    
    // Camera Updates
    LaunchedEffect(mapInstance) {
        viewModel.cameraUpdate.collect { update -> mapInstance?.animateCamera(update) }
    }

    // Dynamic GeoJSON Update
    LaunchedEffect(visibleNodes, mapInstance, isMapStyleLoaded) {
        val map = mapInstance
        if (map != null && isMapStyleLoaded && map.style != null) {
            try {
                val features = visibleNodes.map { node ->
                    var iconImage = if (node.type == NodeType.GATE) MapStyleManager.IMAGE_GATE else MapStyleManager.IMAGE_PARKING
                    val properties = JsonObject()
                    properties.addProperty("name", node.name)
                    properties.addProperty("id", node.id)
                    properties.addProperty("icon_image", iconImage)
                    properties.addProperty("confidence", node.confidence.name)
                    
                    org.maplibre.geojson.Feature.fromGeometry(
                        org.maplibre.geojson.Point.fromLngLat(node.lon, node.lat),
                        properties
                    )
                }
                
                val featureCollection = org.maplibre.geojson.FeatureCollection.fromFeatures(features)
                val source = map.style!!.getSourceAs<org.maplibre.android.style.sources.GeoJsonSource>(MapStyleManager.SOURCE_POIS)
                source?.setGeoJson(featureCollection)
            } catch (e: Exception) {
                e.printStackTrace()
                mapError = "Error al cargar los POIs: ${e.localizedMessage}"
            }
        }
    }

    // Initialize MapLibre
    org.maplibre.android.MapLibre.getInstance(context)

    val mapView = remember {
        org.maplibre.android.maps.MapView(context).apply { onCreate(null) }
    }
    
    DisposableEffect(lifecycleOwner) {
        val observer = androidx.lifecycle.LifecycleEventObserver { _, event ->
            when (event) {
                androidx.lifecycle.Lifecycle.Event.ON_START -> mapView.onStart()
                androidx.lifecycle.Lifecycle.Event.ON_RESUME -> mapView.onResume()
                androidx.lifecycle.Lifecycle.Event.ON_PAUSE -> mapView.onPause()
                androidx.lifecycle.Lifecycle.Event.ON_STOP -> mapView.onStop()
                androidx.lifecycle.Lifecycle.Event.ON_DESTROY -> mapView.onDestroy()
                else -> {}
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }
    }

    // Show map errors via Snackbar
    LaunchedEffect(mapError) {
        mapError?.let {
            snackbarHostState.showSnackbar(it)
            mapError = null
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
    GoogleMapsStyleContent(
        selectedType = selectedType,
        onFilterSelect = { viewModel.filterNodes(it) },
        onMenuClick = { isSidebarOpen = true },
        onLocationClick = {
            mapView.getMapAsync { map ->
                if (permissionsState.allPermissionsGranted && map.locationComponent.isLocationComponentActivated) {
                    map.locationComponent.cameraMode = org.maplibre.android.location.modes.CameraMode.TRACKING
                }
            }
        },
        onCompassClick = {
            mapView.getMapAsync { map ->
                map.animateCamera(
                    org.maplibre.android.camera.CameraUpdateFactory.newCameraPosition(
                        org.maplibre.android.camera.CameraPosition.Builder()
                            .target(map.cameraPosition.target)
                            .zoom(map.cameraPosition.zoom)
                            .bearing(0.0)
                            .tilt(0.0)
                            .build()
                    ),
                    1000
                )
            }
        },
        onSearchClick = { /* TODO: Open search */ },
        isSidebarOpen = isSidebarOpen,
        onSidebarClose = { isSidebarOpen = false },
        navController = navController,
        mapContent = {
            androidx.compose.ui.viewinterop.AndroidView(
                factory = { mapView },
                modifier = Modifier.fillMaxSize(),
                update = { mv ->
                    mv.getMapAsync { map ->
                        mapInstance = map
                        
                        map.cameraPosition = org.maplibre.android.camera.CameraPosition.Builder()
                            .target(org.maplibre.android.geometry.LatLng(41.5700, 2.2600))
                            .zoom(15.0)
                            .build()

                        map.setStyle(com.georacing.georacing.data.map.MapLibreConfig.MAP_STYLE_URL) { style ->
                            mapStyleManager.applyLayers(style)
                            isMapStyleLoaded = true
                            
                            try {
                                val geoJson = context.assets.open("circuit_routes.geojson").bufferedReader().use { it.readText() }
                                val source = style.getSourceAs<org.maplibre.android.style.sources.GeoJsonSource>(MapStyleManager.SOURCE_ROUTE)
                                source?.setGeoJson(geoJson)
                            } catch (e: Exception) {
                                e.printStackTrace()
                                mapError = "Error al cargar las rutas del circuito: ${e.localizedMessage}"
                            }
                            
                            if (permissionsState.allPermissionsGranted) {
                                val locationComponent = map.locationComponent
                                val options = org.maplibre.android.location.LocationComponentActivationOptions.builder(context, style)
                                    .useDefaultLocationEngine(true)
                                    .build()
                                
                                locationComponent.activateLocationComponent(options)
                                locationComponent.isLocationComponentEnabled = true
                                
                                val lastLocation = locationComponent.lastKnownLocation
                                if (lastLocation != null) {
                                    map.animateCamera(
                                        org.maplibre.android.camera.CameraUpdateFactory.newCameraPosition(
                                            org.maplibre.android.camera.CameraPosition.Builder()
                                                .target(org.maplibre.android.geometry.LatLng(lastLocation.latitude, lastLocation.longitude))
                                                .zoom(16.0)
                                                .build()
                                        ),
                                        1000
                                    )
                                }
                                
                                locationComponent.cameraMode = org.maplibre.android.location.modes.CameraMode.TRACKING
                                locationComponent.renderMode = org.maplibre.android.location.modes.RenderMode.COMPASS
                            }
                        }

                        if (!permissionsState.allPermissionsGranted) {
                             map.cameraPosition = org.maplibre.android.camera.CameraPosition.Builder()
                                .target(com.georacing.georacing.data.map.MapLibreConfig.CircuitBarcelona.toLatLng())
                                .zoom(14.5)
                                .tilt(0.0)
                                .bearing(0.0)
                                .build()
                        }
                        map.uiSettings.isLogoEnabled = false
                        map.uiSettings.isAttributionEnabled = false
                        map.uiSettings.isCompassEnabled = false
                    }
                }
            )
            
            // Crowd Heatmap Overlay
            val crowdIntensity by com.georacing.georacing.debug.ScenarioSimulator.crowdIntensity.collectAsState()
            
            LaunchedEffect(crowdIntensity, mapInstance) {
                val map = mapInstance
                if (map != null) {
                    if (crowdIntensity > 0.5f) {
                        map.animateCamera(
                            org.maplibre.android.camera.CameraUpdateFactory.newCameraPosition(
                                org.maplibre.android.camera.CameraPosition.Builder()
                                    .target(org.maplibre.android.geometry.LatLng(41.569502, 2.2541165))
                                    .zoom(16.0)
                                    .build()
                            ),
                            1500
                        )
                        map.uiSettings.isScrollGesturesEnabled = false
                        map.uiSettings.isZoomGesturesEnabled = false
                        map.uiSettings.isTiltGesturesEnabled = false
                        map.uiSettings.isRotateGesturesEnabled = false
                    } else {
                        map.uiSettings.isScrollGesturesEnabled = true
                        map.uiSettings.isZoomGesturesEnabled = true
                        map.uiSettings.isTiltGesturesEnabled = true
                        map.uiSettings.isRotateGesturesEnabled = true
                    }
                }
            }

            val trafficRepository = remember { com.georacing.georacing.data.repository.NetworkTrafficRepository() }
            val heatPoints by produceState(initialValue = emptyList<com.georacing.georacing.data.repository.HeatPoint>()) {
                trafficRepository.observeZoneTraffic(15000).collect { zones ->
                    value = trafficRepository.getHeatPointsFromZones(zones)
                }
            }
            
            com.georacing.georacing.ui.components.map.CrowdHeatmapOverlay(
                heatPoints = heatPoints,
                cameraPositionLatitude = 41.5695,
                cameraPositionLongitude = 2.2541,
                zoomLevel = 16f
            )
        },
        permissionsGranted = permissionsState.allPermissionsGranted
    )

    SnackbarHost(
        hostState = snackbarHostState,
        modifier = Modifier.align(Alignment.BottomCenter)
    )
    } // end Box
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun GoogleMapsStyleContent(
    selectedType: NodeType?,
    onFilterSelect: (NodeType?) -> Unit,
    onMenuClick: () -> Unit,
    onLocationClick: () -> Unit,
    onCompassClick: () -> Unit,
    onSearchClick: () -> Unit,
    isSidebarOpen: Boolean,
    onSidebarClose: () -> Unit,
    navController: NavController,
    mapContent: @Composable () -> Unit,
    permissionsGranted: Boolean
) {
    // Bottom sheet state
    var selectedPlace by remember { mutableStateOf<String?>(null) }
    val backdrop = LocalBackdrop.current
    
    Box(modifier = Modifier.fillMaxSize()) {
        
        // 1. Map Layer (Bottom)
        mapContent()
        
        // 2. UI Overlay Layer
        Column(
            modifier = Modifier.fillMaxSize()
        ) {
            // =============================================
            // TOP: Floating Search Pill
            // =============================================
            LiquidPill(
                backdrop = backdrop,
                modifier = Modifier
                    .fillMaxWidth()
                    .statusBarsPadding()
                    .padding(horizontal = 16.dp, vertical = 12.dp),
                surfaceColor = SearchBarBg.copy(alpha = 0.5f)
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { onSearchClick() }
                        .padding(horizontal = 4.dp, vertical = 2.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    // Menu Icon
                    IconButton(onClick = onMenuClick) {
                        Icon(
                            Icons.Default.Menu,
                            contentDescription = "Men√∫",
                            tint = ChipText
                        )
                    }
                    
                    // Search Text
                    Text(
                        text = "Buscar en el Circuit...",
                        color = SubtleGray,
                        style = MaterialTheme.typography.bodyLarge,
                        modifier = Modifier
                            .weight(1f)
                            .padding(horizontal = 8.dp)
                    )
                    
                    // Profile Avatar
                    Box(
                        modifier = Modifier
                            .size(36.dp)
                            .clip(CircleShape)
                            .background(RacingAccent),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            "G",
                            color = Color(0xFFF8FAFC),
                            fontWeight = FontWeight.Bold,
                            fontSize = 16.sp
                        )
                    }
                    
                    Spacer(modifier = Modifier.width(8.dp))
                }
            }
            
            // =============================================
            // CHIPS: Category Filters
            // =============================================
            LazyRow(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(categoryChips) { chip ->
                    val isSelected = selectedType == chip.type
                    
                    LiquidPill(
                        backdrop = backdrop,
                        modifier = Modifier.clickable { onFilterSelect(if (isSelected) null else chip.type) },
                        surfaceColor = if (isSelected) RacingAccent.copy(alpha = 0.2f) else ChipBg.copy(alpha = 0.5f),
                        tint = if (isSelected) RacingAccent else Color.Unspecified
                    ) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(6.dp),
                            modifier = Modifier.padding(vertical = 4.dp, horizontal = 4.dp)
                        ) {
                            Text(chip.emoji, fontSize = 14.sp)
                            Text(
                                chip.label,
                                color = if (isSelected) Color.White else ChipText,
                                fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal
                            )
                        }
                    }
                }
            }
            
            Spacer(modifier = Modifier.weight(1f))
        }
        
        // =============================================
        // FABs: Location and Compass Buttons (Bottom Right)
        // =============================================
        Column(
            modifier = Modifier
                .align(Alignment.BottomEnd)
                .padding(end = 16.dp, bottom = 200.dp)
                .navigationBarsPadding(),
            verticalArrangement = Arrangement.spacedBy(12.dp),
            horizontalAlignment = Alignment.End
        ) {
            // Compass FAB
            FloatingActionButton(
                onClick = onCompassClick,
                containerColor = Color(0xFF14141C),
                contentColor = ChipText,
                shape = CircleShape,
                elevation = FloatingActionButtonDefaults.elevation(
                    defaultElevation = 4.dp,
                    pressedElevation = 8.dp
                )
            ) {
                Icon(
                    Icons.Default.Explore,
                    contentDescription = "Orientar mapa al norte",
                    tint = ChipText
                )
            }
            
            // Location FAB
            FloatingActionButton(
                onClick = onLocationClick,
                containerColor = Color(0xFF14141C),
                contentColor = RacingAccent,
                shape = CircleShape,
                elevation = FloatingActionButtonDefaults.elevation(
                    defaultElevation = 4.dp,
                    pressedElevation = 8.dp
                )
            ) {
                Icon(
                    if (permissionsGranted) Icons.Default.MyLocation else Icons.Default.LocationSearching,
                    contentDescription = "Mi ubicaci√≥n",
                    tint = if (permissionsGranted) RacingAccent else SubtleGray
                )
            }
        }
        
        // =============================================
        // BOTTOM SHEET: Place Info / Explore
        // =============================================
        LiquidCard(
            backdrop = backdrop,
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .fillMaxWidth()
                .padding(bottom = 84.dp), // Prevent overlap with bottom nav bar
            cornerRadius = 32.dp,
            surfaceColor = SheetBg.copy(alpha = 0.65f)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 12.dp, bottom = 24.dp, start = 20.dp, end = 20.dp)
            ) {
                // Drag Handle
                Box(
                    modifier = Modifier
                        .width(40.dp)
                        .height(4.dp)
                        .clip(RoundedCornerShape(2.dp))
                        .background(Color(0xFF2A2A3C))
                        .align(Alignment.CenterHorizontally)
                )
                
                Spacer(modifier = Modifier.height(20.dp))
                
                if (selectedPlace != null) {
                    // Selected Place Info
                    Text(
                        selectedPlace!!,
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.SemiBold,
                        color = SearchBarText
                    )
                } else {
                    // Explore Mode
                    Text(
                        "Explorar el Circuit",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Medium,
                        color = SearchBarText
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Text(
                        "Toca el mapa para ver informaci√≥n de los puntos de inter√©s",
                        style = MaterialTheme.typography.bodyMedium,
                        color = SubtleGray
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    // Quick Actions Row
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        QuickActionButton(
                            backdrop = backdrop,
                            icon = Icons.Default.Navigation,
                            label = "Navegar",
                            onClick = { navController.navigate(Screen.CircuitDestinations.route) },
                            modifier = Modifier.weight(1f)
                        )
                        QuickActionButton(
                            backdrop = backdrop,
                            icon = Icons.Default.DirectionsWalk,
                            label = "A mi puerta",
                            onClick = { navController.navigate(Screen.CircuitDestinations.route) },
                            modifier = Modifier.weight(1f)
                        )
                        QuickActionButton(
                            backdrop = backdrop,
                            icon = Icons.Default.LocalParking,
                            label = "Mi Coche",
                            onClick = { /* TODO */ },
                            modifier = Modifier.weight(1f)
                        )
                    }
                }
            }
        }

        // Sidebar ‚Äî iOS parity: FeatureRegistry + categorized features
        Sidebar(
            isOpen = isSidebarOpen,
            onClose = onSidebarClose
        ) {
            SideMenuContent(
                navController = navController,
                onClose = onSidebarClose
            )
        }
    }
}

@Composable
private fun QuickActionButton(
    backdrop: Backdrop,
    icon: ImageVector,
    label: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    LiquidCard(
        backdrop = backdrop,
        modifier = modifier.height(80.dp),
        onClick = onClick,
        cornerRadius = 16.dp,
        surfaceColor = Color(0xFF14141C).copy(alpha = 0.5f)
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(12.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Icon(
                icon,
                contentDescription = label,
                tint = RacingAccent,
                modifier = Modifier.size(24.dp)
            )
            Spacer(modifier = Modifier.height(4.dp))
            Text(
                label.uppercase(),
                style = MaterialTheme.typography.labelMedium,
                color = SearchBarText,
                letterSpacing = 1.5.sp
            )
        }
    }
}

@androidx.compose.ui.tooling.preview.Preview(showBackground = true)
@Composable
fun MapScreenPreview() {
    GeoRacingTheme {
        GoogleMapsStyleContent(
            selectedType = null,
            onFilterSelect = {},
            onMenuClick = {},
            onLocationClick = {},
            onCompassClick = {},
            onSearchClick = {},
            isSidebarOpen = false,
            onSidebarClose = {},
            navController = androidx.navigation.compose.rememberNavController(),
            mapContent = {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .background(Color(0xFF0E0E18)), 
                    contentAlignment = Alignment.Center
                ) {
                    Text("Map", color = SubtleGray)
                }
            },
            permissionsGranted = true
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/map/MapViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.map

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.data.local.UserPreferencesDataStore
import com.georacing.georacing.data.repository.CircuitLocationsRepository
import com.georacing.georacing.domain.model.BeaconConfig
import com.georacing.georacing.domain.model.CircuitNode
import com.georacing.georacing.domain.model.Confidence
import com.georacing.georacing.domain.model.NodeType
import com.georacing.georacing.domain.model.SeatInfo
import com.georacing.georacing.domain.repository.BeaconsRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import org.maplibre.android.camera.CameraUpdate
import org.maplibre.android.camera.CameraUpdateFactory
import org.maplibre.android.geometry.LatLng
import org.maplibre.android.camera.CameraPosition

class MapViewModel(
    application: android.app.Application,
    beaconsRepository: BeaconsRepository,
    // PoiRepository deprecated/removed in favor of CircuitLocationsRepository
    userPreferences: UserPreferencesDataStore
) : androidx.lifecycle.AndroidViewModel(application) {

    // Camera Event to drive MapLibre View
    private val _cameraUpdate = kotlinx.coroutines.flow.MutableSharedFlow<CameraUpdate>()
    val cameraUpdate = _cameraUpdate.asSharedFlow()

    val beacons: StateFlow<List<BeaconConfig>> = beaconsRepository.getBeacons()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    // Source of Truth: CircuitLocationsRepository (Official Dataset)
    private val _allNodes = MutableStateFlow(CircuitLocationsRepository.getAllNodes())
    val allNodes: StateFlow<List<CircuitNode>> = _allNodes.asStateFlow()

    val seatInfo: StateFlow<SeatInfo?> = userPreferences.seatInfo
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), null)

    private val _selectedType = MutableStateFlow<NodeType?>(null)
    val selectedType = _selectedType.asStateFlow()

    val visibleNodes: StateFlow<List<CircuitNode>> = combine(allNodes, _selectedType) { nodes, type ->
        val filtered = if (type == null) nodes else nodes.filter { it.type == type }
        // Rule: Do not show PENDING nodes in standard map view to avoid confusion
        // (Only show them if explicitly debugging or if we decide to show them as "Works in Progress")
        // User said: "Si intenta ir a un PENDING: Mostrar aviso". "En el mapa: Ocultar o desactivar navegaci√≥n a PENDING".
        // Let's show them but visual treatment will be different in MapScreen (Greyed out).
        filtered
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    // Mock user position for canvas fallback (deprecated by real GPS)
    val userPositionX = MutableStateFlow(0.5f)
    val userPositionY = MutableStateFlow(0.6f)

    fun filterNodes(type: NodeType?) {
        _selectedType.value = type
    }

    fun centerOnSeat() {
        val seat = seatInfo.value ?: return
        viewModelScope.launch {
            try {
                // Read grandstands.json from assets
                val json = getApplication<android.app.Application>().assets.open("grandstands.json").bufferedReader().use { it.readText() }
                val jsonObject = org.json.JSONObject(json)
                val grandstands = jsonObject.getJSONArray("grandstands")
                
                var foundLat = 0.0
                var foundLon = 0.0
                var found = false

                // Simplified match
                for (i in 0 until grandstands.length()) {
                    val g = grandstands.getJSONObject(i)
                    if (seat.grandstand.contains(g.getString("id"), ignoreCase = true) || 
                        seat.grandstand.contains(g.getString("name"), ignoreCase = true)) {
                        foundLat = g.getDouble("lat")
                        foundLon = g.getDouble("lon")
                        found = true
                        break
                    }
                }

                if (found) {
                    _cameraUpdate.emit(
                        CameraUpdateFactory.newCameraPosition(
                            CameraPosition.Builder()
                                .target(LatLng(foundLat, foundLon))
                                .zoom(18.0)
                                .build()
                        )
                    )
                } else {
                    // Fallback to general circuit center
                     _cameraUpdate.emit(
                        CameraUpdateFactory.newCameraPosition(
                            CameraPosition.Builder()
                                .target(LatLng(41.5700, 2.2600))
                                .zoom(15.0)
                                .build()
                        )
                    )
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}


```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/medical/MedicalLockScreenScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.medical

import android.widget.Toast
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.georacing.georacing.data.local.GeoRacingDatabase
import com.georacing.georacing.utils.MedicalLockScreenGenerator
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MedicalLockScreenScreen(
    navController: NavController,
    userQrData: String = "GEORACING_USER_001"  // ID de entrada del usuario
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    
    // Database
    val database = remember { GeoRacingDatabase.getInstance(context) }
    val medicalInfoDao = database.medicalInfoDao()
    
    // States
    var userName by remember { mutableStateOf("") }
    var bloodType by remember { mutableStateOf("") }
    var allergies by remember { mutableStateOf("") }
    var emergencyContact by remember { mutableStateOf("") }
    var emergencyPhone by remember { mutableStateOf("") }
    var medicalNotes by remember { mutableStateOf("") }
    
    var showPreview by remember { mutableStateOf(false) }
    var isLoading by remember { mutableStateOf(false) }
    
    // Cargar datos guardados
    LaunchedEffect(Unit) {
        medicalInfoDao.getMedicalInfoOnce()?.let { info ->
            bloodType = info.bloodType ?: ""
            allergies = info.allergies ?: ""
            emergencyContact = info.emergencyContactName ?: ""
            emergencyPhone = info.emergencyContactPhone ?: ""
            medicalNotes = info.medicalNotes ?: ""
        }
    }
    
    // Dropdown para grupo sangu√≠neo
    val bloodTypes = listOf("A+", "A-", "B+", "B-", "AB+", "AB-", "O+", "O-")
    var bloodTypeExpanded by remember { mutableStateOf(false) }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        "üÜò Lock Screen M√©dico",
                        fontWeight = FontWeight.Black,
                        letterSpacing = 1.sp
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Atr√°s", tint = Color(0xFFE2E8F0))
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = Color(0xFF0E0E18),
                    titleContentColor = Color(0xFFE2E8F0)
                )
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .background(
                    Brush.verticalGradient(
                        listOf(Color(0xFF080810), Color(0xFF0A0A16), Color(0xFF080810))
                    )
                )
                .padding(padding)
                .verticalScroll(rememberScrollState())
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Explicaci√≥n
            Card(
                colors = CardDefaults.cardColors(
                    containerColor = Color(0xFF14141C)
                )
            ) {
                Column(modifier = Modifier.padding(16.dp)) {
                    Text(
                        "‚ö†Ô∏è Informaci√≥n Vital",
                        style = MaterialTheme.typography.titleMedium,
                        color = Color(0xFFEF4444),
                        fontWeight = FontWeight.Black,
                        letterSpacing = 1.sp
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        "Esta informaci√≥n se mostrar√° en tu pantalla de bloqueo para que el personal de emergencia pueda verla sin desbloquear tu tel√©fono.",
                        style = MaterialTheme.typography.bodyMedium,
                        color = Color(0xFF94A3B8)
                    )
                }
            }
            
            // Nombre
            OutlinedTextField(
                value = userName,
                onValueChange = { userName = it },
                label = { Text("Tu Nombre") },
                leadingIcon = { Icon(Icons.Default.Person, null) },
                modifier = Modifier.fillMaxWidth(),
                singleLine = true
            )
            
            // Grupo Sangu√≠neo (Dropdown)
            ExposedDropdownMenuBox(
                expanded = bloodTypeExpanded,
                onExpandedChange = { bloodTypeExpanded = it }
            ) {
                OutlinedTextField(
                    value = bloodType,
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Grupo Sangu√≠neo") },
                    leadingIcon = { Icon(Icons.Default.Favorite, null, tint = Color(0xFFEF4444)) },
                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = bloodTypeExpanded) },
                    modifier = Modifier
                        .fillMaxWidth()
                        .menuAnchor()
                )
                ExposedDropdownMenu(
                    expanded = bloodTypeExpanded,
                    onDismissRequest = { bloodTypeExpanded = false }
                ) {
                    bloodTypes.forEach { type ->
                        DropdownMenuItem(
                            text = { Text(type) },
                            onClick = {
                                bloodType = type
                                bloodTypeExpanded = false
                            }
                        )
                    }
                }
            }
            
            // Alergias
            OutlinedTextField(
                value = allergies,
                onValueChange = { allergies = it },
                label = { Text("Alergias (separadas por coma)") },
                leadingIcon = { Icon(Icons.Default.Warning, null, tint = Color(0xFFFFA726)) },
                modifier = Modifier.fillMaxWidth(),
                minLines = 2
            )
            
            // Contacto de Emergencia
            OutlinedTextField(
                value = emergencyContact,
                onValueChange = { emergencyContact = it },
                label = { Text("Nombre Contacto Emergencia") },
                leadingIcon = { Icon(Icons.Default.Call, null) },
                modifier = Modifier.fillMaxWidth(),
                singleLine = true
            )
            
            OutlinedTextField(
                value = emergencyPhone,
                onValueChange = { emergencyPhone = it },
                label = { Text("Tel√©fono Emergencia") },
                leadingIcon = { Icon(Icons.Default.Phone, null) },
                modifier = Modifier.fillMaxWidth(),
                singleLine = true
            )
            
            // Notas m√©dicas
            OutlinedTextField(
                value = medicalNotes,
                onValueChange = { medicalNotes = it },
                label = { Text("Notas M√©dicas (diabetes, epilepsia, etc.)") },
                leadingIcon = { Icon(Icons.Default.Info, null) },
                modifier = Modifier.fillMaxWidth(),
                minLines = 2
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Bot√≥n Preview
            Button(
                onClick = { showPreview = true },
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color(0xFF06B6D4)
                )
            ) {
                Icon(Icons.Default.Search, null)
                Spacer(modifier = Modifier.width(8.dp))
                Text("Vista Previa")
            }
            
            // Bot√≥n Guardar en Galer√≠a
            Button(
                onClick = {
                    scope.launch {
                        isLoading = true
                        
                        // Guardar en DB
                        medicalInfoDao.saveMedicalInfo(
                            com.georacing.georacing.data.local.entities.MedicalInfoEntity(
                                bloodType = bloodType.takeIf { it.isNotBlank() },
                                allergies = allergies.takeIf { it.isNotBlank() },
                                emergencyContactName = emergencyContact.takeIf { it.isNotBlank() },
                                emergencyContactPhone = emergencyPhone.takeIf { it.isNotBlank() },
                                medicalNotes = medicalNotes.takeIf { it.isNotBlank() }
                            )
                        )
                        
                        // Generar bitmap
                        val bitmap = MedicalLockScreenGenerator.generateBitmap(
                            qrData = userQrData,
                            userName = userName.ifBlank { "USUARIO" },
                            bloodType = bloodType.takeIf { it.isNotBlank() },
                            allergies = allergies.takeIf { it.isNotBlank() },
                            emergencyContact = emergencyContact.takeIf { it.isNotBlank() },
                            emergencyPhone = emergencyPhone.takeIf { it.isNotBlank() },
                            medicalNotes = medicalNotes.takeIf { it.isNotBlank() }
                        )
                        
                        // Guardar en galer√≠a
                        val uri = MedicalLockScreenGenerator.saveToGallery(context, bitmap)
                        
                        isLoading = false
                        
                        if (uri != null) {
                            Toast.makeText(context, "‚úÖ Imagen guardada en Galer√≠a", Toast.LENGTH_LONG).show()
                        } else {
                            Toast.makeText(context, "‚ùå Error al guardar", Toast.LENGTH_SHORT).show()
                        }
                    }
                },
                modifier = Modifier.fillMaxWidth(),
                enabled = !isLoading,
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color(0xFF22C55E)
                )
            ) {
                if (isLoading) {
                    CircularProgressIndicator(modifier = Modifier.size(20.dp), color = Color(0xFFF8FAFC))
                } else {
                    Icon(Icons.Default.Share, null)
                }
                Spacer(modifier = Modifier.width(8.dp))
                Text("Guardar en Galer√≠a")
            }
            
            // Bot√≥n Establecer como Wallpaper
            Button(
                onClick = {
                    scope.launch {
                        isLoading = true
                        
                        val bitmap = MedicalLockScreenGenerator.generateBitmap(
                            qrData = userQrData,
                            userName = userName.ifBlank { "USUARIO" },
                            bloodType = bloodType.takeIf { it.isNotBlank() },
                            allergies = allergies.takeIf { it.isNotBlank() },
                            emergencyContact = emergencyContact.takeIf { it.isNotBlank() },
                            emergencyPhone = emergencyPhone.takeIf { it.isNotBlank() },
                            medicalNotes = medicalNotes.takeIf { it.isNotBlank() }
                        )
                        
                        val success = MedicalLockScreenGenerator.setAsLockScreenWallpaper(context, bitmap)
                        
                        isLoading = false
                        
                        if (success) {
                            Toast.makeText(context, "‚úÖ Establecido como fondo de bloqueo", Toast.LENGTH_LONG).show()
                        } else {
                            Toast.makeText(context, "‚ùå Error. Intenta guardar en galer√≠a y configurarlo manualmente.", Toast.LENGTH_LONG).show()
                        }
                    }
                },
                modifier = Modifier.fillMaxWidth(),
                enabled = !isLoading,
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color(0xFFDC2626)
                )
            ) {
                Icon(Icons.Default.Lock, null)
                Spacer(modifier = Modifier.width(8.dp))
                Text("Establecer como Pantalla de Bloqueo")
            }
        }
    }
    
    // Dialog Preview
    if (showPreview) {
        val previewBitmap = remember(userName, bloodType, allergies, emergencyContact, emergencyPhone, medicalNotes) {
            MedicalLockScreenGenerator.generateBitmap(
                qrData = userQrData,
                userName = userName.ifBlank { "USUARIO" },
                bloodType = bloodType.takeIf { it.isNotBlank() },
                allergies = allergies.takeIf { it.isNotBlank() },
                emergencyContact = emergencyContact.takeIf { it.isNotBlank() },
                emergencyPhone = emergencyPhone.takeIf { it.isNotBlank() },
                medicalNotes = medicalNotes.takeIf { it.isNotBlank() }
            )
        }
        
        AlertDialog(
            onDismissRequest = { showPreview = false },
            title = { Text("Vista Previa") },
            text = {
                Image(
                    bitmap = previewBitmap.asImageBitmap(),
                    contentDescription = "Preview",
                    modifier = Modifier
                        .fillMaxWidth()
                        .aspectRatio(9f / 16f)
                )
            },
            confirmButton = {
                TextButton(onClick = { showPreview = false }) {
                    Text("Cerrar")
                }
            }
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/moments/MomentsScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.moments

import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import android.content.ContentValues
import android.net.Uri
import android.os.Build
import android.os.Environment
import android.provider.MediaStore
import android.widget.Toast
import com.georacing.georacing.ui.components.HomeIconButton
import com.georacing.georacing.ui.navigation.Screen
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

private data class Moment(
    val id: String,
    val title: String,
    val zone: String,
    val timestamp: LocalDateTime,
    val emoji: String, // Representing the photo visually
    val color: Color,
    val likes: Int = 0
)

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MomentsScreen(navController: NavController) {
    var selectedTab by remember { mutableIntStateOf(0) }
    val tabs = listOf("Mis Momentos", "Comunidad", "Favoritos")
    val context = LocalContext.current

    // ‚îÄ‚îÄ Captura de c√°mara ‚îÄ‚îÄ
    var capturedPhotoUri by remember { mutableStateOf<Uri?>(null) }
    var capturedMoments by remember { mutableStateOf<List<Moment>>(emptyList()) }
    
    // Crear URI para la foto antes de lanzar la c√°mara
    val createImageUri: () -> Uri? = {
        val contentValues = ContentValues().apply {
            put(MediaStore.MediaColumns.DISPLAY_NAME, "GeoRacing_${System.currentTimeMillis()}.jpg")
            put(MediaStore.MediaColumns.MIME_TYPE, "image/jpeg")
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_PICTURES + "/GeoRacing")
            }
        }
        context.contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)
    }
    
    val cameraLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.TakePicture()
    ) { success ->
        if (success && capturedPhotoUri != null) {
            val newMoment = Moment(
                id = "cap_${System.currentTimeMillis()}",
                title = "Momento capturado",
                zone = "Circuit de BCN-CAT",
                timestamp = LocalDateTime.now(),
                emoji = "üì∑",
                color = Color(0xFF3B82F6),
                likes = 0
            )
            capturedMoments = listOf(newMoment) + capturedMoments
            Toast.makeText(context, "üì∏ ¬°Momento guardado en galer√≠a!", Toast.LENGTH_SHORT).show()
        }
    }
    
    // Permiso de c√°mara
    val cameraPermissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission()
    ) { granted ->
        if (granted) {
            val uri = createImageUri()
            if (uri != null) {
                capturedPhotoUri = uri
                cameraLauncher.launch(uri)
            }
        } else {
            Toast.makeText(context, "Se necesita permiso de c√°mara", Toast.LENGTH_SHORT).show()
        }
    }

    // Simulated gallery
    val myMoments = remember {
        listOf(
            Moment("1", "Salida de la carrera", "Recta principal", LocalDateTime.now().minusHours(2), "üèÅ", Color(0xFFE8253A), 24),
            Moment("2", "Parrilla de salida", "Pit Lane", LocalDateTime.now().minusHours(3), "üèéÔ∏è", Color(0xFF3B82F6), 18),
            Moment("3", "Mi grada", "Tribuna G", LocalDateTime.now().minusHours(4), "üéüÔ∏è", Color(0xFFA855F7), 7),
            Moment("4", "Con amigos", "Fan Zone", LocalDateTime.now().minusHours(5), "üë•", Color(0xFF22C55E), 31),
            Moment("5", "Atardecer en pista", "Curva 5", LocalDateTime.now().minusHours(1), "üåÖ", Color(0xFFFF6B2C), 42),
            Moment("6", "Podio", "Recta principal", LocalDateTime.now().minusMinutes(30), "üèÜ", Color(0xFFD4A855), 89)
        )
    }
    val communityMoments = remember {
        listOf(
            Moment("c1", "Vuelta r√°pida!", "Curva 9", LocalDateTime.now().minusMinutes(15), "‚ö°", Color(0xFF00E5FF), 156),
            Moment("c2", "Pit stop incre√≠ble", "Pit Lane", LocalDateTime.now().minusMinutes(25), "üîß", Color(0xFFFFA726), 234),
            Moment("c3", "Adelantamiento T1", "Curva 1", LocalDateTime.now().minusMinutes(40), "üí®", Color(0xFF3B82F6), 312),
            Moment("c4", "El ambiente!", "Fan Zone", LocalDateTime.now().minusHours(1), "üéâ", Color(0xFFEC4899), 198),
            Moment("c5", "Desde mi grada", "Tribuna A", LocalDateTime.now().minusHours(2), "üì∏", Color(0xFF8B5CF6), 87),
            Moment("c6", "Recta de meta", "Recta principal", LocalDateTime.now().minusMinutes(5), "üöÄ", Color(0xFFEF4444), 445)
        )
    }

    val displayedMoments = when (selectedTab) {
        0 -> capturedMoments + myMoments
        1 -> communityMoments
        else -> (capturedMoments + myMoments + communityMoments).filter { it.likes > 20 || it.id.startsWith("cap_") }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Momentos", fontWeight = FontWeight.Bold) },
                navigationIcon = { IconButton(onClick = { navController.popBackStack() }) { Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Volver atr√°s") } },
                actions = { HomeIconButton { navController.navigate(Screen.Home.route) { popUpTo(Screen.Home.route) { inclusive = true } } } },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = {
                    cameraPermissionLauncher.launch(android.Manifest.permission.CAMERA)
                },
                containerColor = Color(0xFFE8253A),
                contentColor = Color.White,
                shape = CircleShape
            ) {
                Icon(Icons.Default.CameraAlt, contentDescription = "Capturar momento")
            }
        },
        containerColor = Color(0xFF080810)
    ) { innerPadding ->
        Column(Modifier.fillMaxSize().padding(innerPadding)) {
            // Location
            Row(Modifier.padding(horizontal = 16.dp), verticalAlignment = Alignment.CenterVertically) {
                Icon(Icons.Default.LocationOn, null, tint = Color(0xFFE8253A), modifier = Modifier.size(16.dp))
                Spacer(Modifier.width(4.dp))
                Text("Circuit de Barcelona-Catalunya", style = MaterialTheme.typography.bodySmall, color = Color(0xFF94A3B8))
            }

            Spacer(Modifier.height(12.dp))

            // Tabs
            TabRow(
                selectedTabIndex = selectedTab,
                containerColor = Color.Transparent,
                contentColor = Color.White,
                indicator = { tabPositions ->
                    if (selectedTab < tabPositions.size) {
                        TabRowDefaults.SecondaryIndicator(
                            Modifier.width(tabPositions[selectedTab].contentWidth),
                            color = Color(0xFFE8253A)
                        )
                    }
                }
            ) {
                tabs.forEachIndexed { index, title ->
                    Tab(
                        selected = selectedTab == index,
                        onClick = { selectedTab = index },
                        text = { Text(title, fontSize = 13.sp, fontWeight = if (selectedTab == index) FontWeight.Bold else FontWeight.Normal) },
                        selectedContentColor = Color.White,
                        unselectedContentColor = Color(0xFF64748B)
                    )
                }
            }

            Spacer(Modifier.height(12.dp))

            // Stats bar
            Row(Modifier.fillMaxWidth().padding(horizontal = 16.dp), horizontalArrangement = Arrangement.SpaceBetween) {
                Text("${displayedMoments.size} momentos", style = MaterialTheme.typography.bodySmall, color = Color(0xFF64748B))
                Text("üì∏ Hoy en el circuito", style = MaterialTheme.typography.bodySmall, color = Color(0xFF64748B))
            }

            Spacer(Modifier.height(8.dp))

            // Photo Grid
            LazyVerticalGrid(
                columns = GridCells.Fixed(2),
                modifier = Modifier.fillMaxSize().padding(horizontal = 12.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp),
                contentPadding = PaddingValues(bottom = 100.dp)
            ) {
                items(displayedMoments) { moment ->
                    MomentCard(moment)
                }
            }
        }
    }
}

@Composable
private fun MomentCard(moment: Moment) {
    var isLiked by remember { mutableStateOf(false) }
    val timeFormatter = DateTimeFormatter.ofPattern("HH:mm")

    Card(
        modifier = Modifier.fillMaxWidth().aspectRatio(0.85f),
        colors = CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
        shape = RoundedCornerShape(16.dp)
    ) {
        Box(Modifier.fillMaxSize()) {
            // Visual area (emoji as "photo" placeholder)
            Box(
                modifier = Modifier.fillMaxWidth().fillMaxHeight(0.65f)
                    .background(
                        Brush.verticalGradient(
                            listOf(moment.color.copy(alpha = 0.3f), moment.color.copy(alpha = 0.05f))
                        )
                    ),
                contentAlignment = Alignment.Center
            ) {
                Text(moment.emoji, fontSize = 48.sp)
            }

            // Gradient overlay at bottom
            Box(
                modifier = Modifier.fillMaxWidth().fillMaxHeight(0.5f).align(Alignment.BottomCenter)
                    .background(Brush.verticalGradient(listOf(Color.Transparent, Color(0xFF14141C))))
            )

            // Info at bottom
            Column(
                modifier = Modifier.align(Alignment.BottomStart).padding(12.dp)
            ) {
                Text(moment.title, style = MaterialTheme.typography.titleSmall, color = Color.White, fontWeight = FontWeight.Bold, maxLines = 1, overflow = TextOverflow.Ellipsis)
                Spacer(Modifier.height(2.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(moment.zone, style = MaterialTheme.typography.labelSmall, color = Color(0xFF94A3B8), fontSize = 10.sp)
                    Text(" ¬∑ ", color = Color(0xFF64748B))
                    Text(moment.timestamp.format(timeFormatter), style = MaterialTheme.typography.labelSmall, color = Color(0xFF94A3B8), fontSize = 10.sp)
                }
            }

            // Like button
            Row(
                modifier = Modifier.align(Alignment.TopEnd).padding(8.dp)
                    .background(Color.Black.copy(alpha = 0.5f), RoundedCornerShape(8.dp))
                    .clickable { isLiked = !isLiked }.padding(horizontal = 8.dp, vertical = 4.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    if (isLiked) Icons.Default.Favorite else Icons.Default.FavoriteBorder,
                    contentDescription = "Me gusta",
                    tint = if (isLiked) Color(0xFFEF4444) else Color.White,
                    modifier = Modifier.size(14.dp)
                )
                Spacer(Modifier.width(4.dp))
                Text("${moment.likes + if (isLiked) 1 else 0}", fontSize = 11.sp, color = Color.White)
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/navigation/CircuitDestinationSelector.kt`

```kotlin
package com.georacing.georacing.ui.screens.navigation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.georacing.georacing.car.PoiModel
import com.georacing.georacing.car.PoiRepository
import com.georacing.georacing.car.PoiType
import com.georacing.georacing.ui.components.HomeIconButton
import com.georacing.georacing.ui.navigation.Screen

/**
 * Pantalla de selecci√≥n de destino del circuito.
 * 
 * Permite al usuario elegir un punto del Circuit de Barcelona Catalunya
 * para iniciar navegaci√≥n hacia ese destino.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CircuitDestinationSelector(
    navController: NavController
) {
    var selectedCategory by remember { mutableStateOf<PoiType?>(null) }
    
    val allPois = remember { PoiRepository.getAllPois() }
    
    val filteredPois = if (selectedCategory != null) {
        allPois.filter { it.type == selectedCategory }
    } else {
        allPois
    }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Ir al Circuit", fontWeight = FontWeight.Bold) },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Atr√°s")
                    }
                },
                actions = {
                    HomeIconButton {
                        navController.navigate(Screen.Home.route) {
                            popUpTo(Screen.Home.route) { inclusive = true }
                        }
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
        ) {
            // Filtros de categor√≠a
            CategoryFilterRow(
                selectedCategory = selectedCategory,
                onCategorySelected = { selectedCategory = it }
            )
            
            // Lista de POIs
            LazyColumn(
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                // Entrada principal destacada (si no hay filtro)
                if (selectedCategory == null) {
                    item {
                        FeaturedDestinationCard(
                            title = "Entrada Principal",
                            description = "Acceso Principal del Circuit de Barcelona-Catalunya",
                            icon = Icons.Default.Stadium,
                            onClick = {
                                navController.navigate("circuit_navigation/main_gate")
                            }
                        )
                    }
                    
                    item {
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = "Otros destinos",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            modifier = Modifier.padding(vertical = 8.dp)
                        )
                    }
                }
                
                // Lista de POIs
                items(filteredPois) { poi ->
                    DestinationCard(
                        poi = poi,
                        onClick = {
                            navController.navigate("circuit_navigation/${poi.id}")
                        }
                    )
                }
                
                if (filteredPois.isEmpty()) {
                    item {
                        Box(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(32.dp),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(
                                text = "No hay destinos en esta categor√≠a",
                                style = MaterialTheme.typography.bodyLarge,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                }
            }
        }
    }
}

/**
 * Fila de filtros de categor√≠a.
 */
@Composable
fun CategoryFilterRow(
    selectedCategory: PoiType?,
    onCategorySelected: (PoiType?) -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // Filtro "Todos"
        FilterChip(
            selected = selectedCategory == null,
            onClick = { onCategorySelected(null) },
            label = { Text("Todos") },
            leadingIcon = {
                Icon(
                    Icons.Default.Place,
                    contentDescription = null,
                    modifier = Modifier.size(18.dp)
                )
            }
        )
        
        // Filtro "Parkings"
        FilterChip(
            selected = selectedCategory == PoiType.PARKING,
            onClick = { onCategorySelected(PoiType.PARKING) },
            label = { Text("Parkings") },
            leadingIcon = {
                Icon(
                    Icons.Default.LocalParking,
                    contentDescription = null,
                    modifier = Modifier.size(18.dp)
                )
            }
        )
        
        // Filtro "Accesos"
        FilterChip(
            selected = selectedCategory == PoiType.GATE,
            onClick = { onCategorySelected(PoiType.GATE) },
            label = { Text("Accesos") },
            leadingIcon = {
                Icon(
                    Icons.Default.Login,
                    contentDescription = null,
                    modifier = Modifier.size(18.dp)
                )
            }
        )
    }
}

/**
 * Tarjeta destacada para destino principal.
 */
@Composable
fun FeaturedDestinationCard(
    title: String,
    description: String,
    icon: ImageVector,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick),
        shape = RoundedCornerShape(16.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.primaryContainer
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(20.dp),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Box(
                modifier = Modifier
                    .size(60.dp)
                    .clip(RoundedCornerShape(12.dp))
                    .background(MaterialTheme.colorScheme.primary),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = icon,
                    contentDescription = null,
                    tint = MaterialTheme.colorScheme.onPrimary,
                    modifier = Modifier.size(32.dp)
                )
            }
            
            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Text(
                    text = title,
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onPrimaryContainer
                )
                Text(
                    text = description,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f)
                )
            }
            
            Icon(
                Icons.Default.Navigation,
                contentDescription = "Navegar",
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(28.dp)
            )
        }
    }
}

/**
 * Tarjeta de destino individual.
 */
@Composable
fun DestinationCard(
    poi: PoiModel,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Icono seg√∫n tipo
            Box(
                modifier = Modifier
                    .size(48.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(getPoiColor(poi.type).copy(alpha = 0.15f)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = getPoiIcon(poi.type),
                    contentDescription = null,
                    tint = getPoiColor(poi.type),
                    modifier = Modifier.size(24.dp)
                )
            }
            
            // Informaci√≥n
            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(2.dp)
            ) {
                Text(
                    text = poi.name,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.SemiBold
                )
                Text(
                    text = poi.description,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            
            Icon(
                Icons.Default.ChevronRight,
                contentDescription = "Navegar",
                tint = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

/**
 * Obtiene el icono correspondiente al tipo de POI.
 */
fun getPoiIcon(type: PoiType): ImageVector {
    return when (type) {
        PoiType.PARKING -> Icons.Default.LocalParking
        PoiType.GATE -> Icons.Default.Login
        PoiType.FANZONE -> Icons.Default.Stadium
        PoiType.SERVICE -> Icons.Default.HomeRepairService
        else -> Icons.Default.Place
    }
}

/**
 * Obtiene el color correspondiente al tipo de POI.
 */
@Composable
fun getPoiColor(type: PoiType): androidx.compose.ui.graphics.Color {
    return when (type) {
        PoiType.PARKING -> MaterialTheme.colorScheme.primary
        PoiType.GATE -> MaterialTheme.colorScheme.tertiary
        PoiType.FANZONE -> MaterialTheme.colorScheme.secondary
        PoiType.SERVICE -> MaterialTheme.colorScheme.error
        else -> MaterialTheme.colorScheme.onSurface
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/navigation/CircuitNavigationScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.navigation

import android.Manifest
import android.content.Context
import android.graphics.Color
import android.view.ViewGroup
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.georacing.georacing.R
import com.georacing.georacing.car.MapStyleManager
import com.georacing.georacing.navigation.NavigationState
import com.georacing.georacing.ui.components.GamifiedSpeedometer
import com.georacing.georacing.ui.components.HazardAlertOverlay
import com.georacing.georacing.ui.components.RaceStatusPill
import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LocalBackdrop
import org.maplibre.android.MapLibre
import org.maplibre.android.camera.CameraPosition
import org.maplibre.android.camera.CameraUpdateFactory
import org.maplibre.android.geometry.LatLng
import org.maplibre.android.location.LocationComponentActivationOptions
import org.maplibre.android.location.modes.CameraMode
import org.maplibre.android.location.modes.RenderMode
import org.maplibre.android.maps.MapView
import org.maplibre.android.maps.MapLibreMap
import org.maplibre.android.maps.Style
import org.maplibre.android.style.layers.LineLayer
import org.maplibre.android.style.layers.PropertyFactory
import org.maplibre.android.style.sources.GeoJsonSource
import org.maplibre.geojson.Feature
import org.maplibre.geojson.LineString
import org.maplibre.geojson.Point
import kotlin.math.roundToInt

/**
 * Pantalla de navegaci√≥n m√≥vil para GeoRacing.
 * 
 * Muestra un mapa de MapLibre con:
 * - Ruta calculada desde OSRM
 * - Posici√≥n actual del usuario
 * - Informaci√≥n de navegaci√≥n (distancia, ETA, pr√≥xima maniobra)
 * - Detecci√≥n autom√°tica de off-route y rec√°lculo
 * - Instrucciones de voz progresivas
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CircuitNavigationScreen(
    navController: NavController,
    poiId: String? = null,  // ID del POI al que navegar (opcional)
    viewModel: CircuitNavigationViewModel = viewModel()
) {
    val context = LocalContext.current
    val navigationState by viewModel.navigationState.collectAsState()
    val currentLocation by viewModel.currentLocation.collectAsState()
    val locationPermissionGranted by viewModel.locationPermissionGranted.collectAsState()
    val isFollowMode by viewModel.isFollowMode.collectAsState()
    val showArrivalDialog by viewModel.showArrivalDialog.collectAsState()
    val errorMessage by viewModel.errorMessage.collectAsState()
    
    // Waze-style state
    val circuitMode by viewModel.circuitMode.collectAsState()
    val activeHazards by viewModel.activeHazards.collectAsState()
    val currentSpeed by viewModel.currentSpeed.collectAsState()
    val speedLimit by viewModel.speedLimit.collectAsState()
    
    // MapView y MapLibreMap
    var mapView by remember { mutableStateOf<MapView?>(null) }
    var mapLibreMap by remember { mutableStateOf<MapLibreMap?>(null) }
    
    // Launcher para solicitar permisos
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        val granted = permissions[Manifest.permission.ACCESS_FINE_LOCATION] == true
        viewModel.onPermissionResult(granted)
    }
    
    // Solicitar permisos al inicio
    LaunchedEffect(Unit) {
        if (!locationPermissionGranted) {
            permissionLauncher.launch(
                arrayOf(
                    Manifest.permission.ACCESS_FINE_LOCATION,
                    Manifest.permission.ACCESS_COARSE_LOCATION
                )
            )
        }
    }
    
    // Iniciar navegaci√≥n si se proporciona un POI
    LaunchedEffect(poiId) {
        if (poiId != null && locationPermissionGranted) {
            viewModel.startNavigationToPoi(poiId)
        }
    }
    
    // Actualizar mapa cuando cambie el estado de navegaci√≥n
    LaunchedEffect(navigationState) {
        if (navigationState is NavigationState.Active) {
            val state = navigationState as NavigationState.Active
            updateMapRoute(mapLibreMap, state.route.points)
        }
    }
    
    // Actualizar posici√≥n del usuario en el mapa
    LaunchedEffect(currentLocation, isFollowMode) {
        currentLocation?.let { location ->
            if (isFollowMode) {
                mapLibreMap?.animateCamera(
                    CameraUpdateFactory.newCameraPosition(
                        CameraPosition.Builder()
                            .target(LatLng(location.latitude, location.longitude))
                            .zoom(17.0)
                            .bearing(location.bearing.toDouble())
                            .tilt(45.0)
                            .build()
                    ),
                    1000
                )
            }
        }
    }
    
    Box(modifier = Modifier.fillMaxSize()) {
        // Mapa de MapLibre
        AndroidView(
            factory = { ctx ->
                MapLibre.getInstance(ctx)
                MapView(ctx).apply {
                    layoutParams = ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        ViewGroup.LayoutParams.MATCH_PARENT
                    )
                    mapView = this
                    
                    getMapAsync { map ->
                        mapLibreMap = map
                        setupMap(ctx, map)
                    }
                }
            },
            modifier = Modifier.fillMaxSize()
        )
        
        // Race Status Pill (reemplaza TopAppBar)
        RaceStatusPill(
            circuitMode = circuitMode,
            modifier = Modifier
                .align(Alignment.TopCenter)
                .statusBarsPadding()
                .padding(top = 12.dp)
        )
        
        // Hazard Alert Overlay (pop-ups de incidentes)
        HazardAlertOverlay(
            hazards = activeHazards,
            modifier = Modifier.align(Alignment.TopCenter)
        )
        
        // Gamified Speedometer (esquina inferior izquierda)
        GamifiedSpeedometer(
            currentSpeed = currentSpeed,
            speedLimit = speedLimit,
            modifier = Modifier
                .align(Alignment.BottomStart)
                .padding(start = 16.dp, bottom = 100.dp)
        )
        
        // Action Buttons (esquina superior derecha - reemplazo de TopAppBar actions)
        Row(
            modifier = Modifier
                .align(Alignment.TopEnd)
                .statusBarsPadding()
                .padding(top = 12.dp, end = 12.dp),
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            // Bot√≥n de seguimiento de c√°mara
            FloatingActionButton(
                onClick = { viewModel.toggleFollowMode() },
                containerColor = MaterialTheme.colorScheme.surface,
                modifier = Modifier.size(48.dp)
            ) {
                Icon(
                    if (isFollowMode) Icons.Default.MyLocation else Icons.Default.LocationSearching,
                    "Modo seguimiento",
                    tint = if (isFollowMode) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface
                )
            }
            
            // Bot√≥n de cerrar
            FloatingActionButton(
                onClick = {
                    viewModel.stopNavigation()
                    navController.popBackStack()
                },
                containerColor = MaterialTheme.colorScheme.surface,
                modifier = Modifier.size(48.dp)
            ) {
                Icon(Icons.Default.Close, "Cerrar")
            }
            
            // Bot√≥n de abrir en Google Maps
            if (navigationState is NavigationState.Active) {
                FloatingActionButton(
                    onClick = { viewModel.openInGoogleMaps(context) },
                    containerColor = MaterialTheme.colorScheme.surface,
                    modifier = Modifier.size(48.dp)
                ) {
                    Icon(Icons.Default.Navigation, "Abrir en Google Maps")
                }
            }
        }
        
        // Panel de informaci√≥n de navegaci√≥n (parte inferior)
        if (navigationState is NavigationState.Active) {
            val state = navigationState as NavigationState.Active
            NavigationInfoPanel(
                state = state,
                modifier = Modifier
                    .align(Alignment.BottomCenter)
                    .fillMaxWidth()
                    .padding(16.dp)
            )
        }
        
        // Indicador de carga
        if (navigationState is NavigationState.Loading || navigationState is NavigationState.WaitingForLocation) {
            Box(
                modifier = Modifier
                    .align(Alignment.Center)
                    .background(
                        MaterialTheme.colorScheme.surface.copy(alpha = 0.9f),
                        RoundedCornerShape(16.dp)
                    )
                    .padding(24.dp)
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    CircularProgressIndicator()
                    Text(
                        text = when (navigationState) {
                            is NavigationState.Loading -> "Calculando ruta..."
                            is NavigationState.WaitingForLocation -> "Obteniendo ubicaci√≥n..."
                            else -> ""
                        },
                        style = MaterialTheme.typography.bodyLarge
                    )
                }
            }
        }
        
        // Di√°logo de llegada
        if (showArrivalDialog) {
            ArrivalDialog(
                destinationName = (navigationState as? NavigationState.Arrived)?.destinationName ?: "Destino",
                onDismiss = {
                    viewModel.dismissArrivalDialog()
                    navController.popBackStack()
                }
            )
        }
        
        // Snackbar de errores
        errorMessage?.let { message ->
            LaunchedEffect(message) {
                kotlinx.coroutines.delay(3000)
                viewModel.clearError()
            }
            
            Snackbar(
                modifier = Modifier
                    .align(Alignment.BottomCenter)
                    .padding(16.dp),
                action = {
                    TextButton(onClick = { viewModel.clearError() }) {
                        Text("OK")
                    }
                }
            ) {
                Text(message)
            }
        }
    }
    
    // Lifecycle del MapView
    DisposableEffect(Unit) {
        onDispose {
            mapView?.onDestroy()
        }
    }
}

/**
 * Configura el mapa inicial.
 */
private fun setupMap(context: Context, map: MapLibreMap) {
    val styleManager = MapStyleManager(context)
    
    map.setStyle(Style.Builder().fromJson(styleManager.STYLE_DAY_JSON)) { style ->
        // Habilitar componente de ubicaci√≥n con icono de F1
        try {
            val locationComponentOptions = org.maplibre.android.location.LocationComponentOptions.builder(context)
                .pulseEnabled(true)
                .pulseColor(android.graphics.Color.BLUE)
                // Usar icono de F1 car (igual que Android Auto)
                .foregroundDrawable(R.drawable.ic_f1_car_scaled)
                .gpsDrawable(R.drawable.ic_f1_car_scaled)
                .bearingDrawable(R.drawable.ic_f1_car_scaled)
                .accuracyAlpha(0.4f)
                .build()
            
            map.locationComponent.apply {
                activateLocationComponent(
                    LocationComponentActivationOptions.builder(context, style)
                        .locationComponentOptions(locationComponentOptions)
                        .useDefaultLocationEngine(true)
                        .build()
                )
                isLocationComponentEnabled = true
                cameraMode = CameraMode.TRACKING_GPS
                renderMode = RenderMode.GPS
            }
        } catch (e: SecurityException) {
            android.util.Log.e("CircuitNavScreen", "Error activando componente de ubicaci√≥n", e)
        }
        
        // Agregar fuente y capa para la ruta
        style.addSource(GeoJsonSource(MapStyleManager.SOURCE_ROUTE))
        
        style.addLayer(
            LineLayer(MapStyleManager.LAYER_ROUTE, MapStyleManager.SOURCE_ROUTE)
                .withProperties(
                    PropertyFactory.lineColor(Color.parseColor("#2563EB")),
                    PropertyFactory.lineWidth(6f),
                    PropertyFactory.lineCap("round"),
                    PropertyFactory.lineJoin("round")
                )
        )
    }
}

/**
 * Actualiza la ruta en el mapa.
 */
private fun updateMapRoute(map: MapLibreMap?, routePoints: List<LatLng>) {
    map?.getStyle { style ->
        val source = style.getSourceAs<GeoJsonSource>(MapStyleManager.SOURCE_ROUTE)
        
        if (routePoints.isNotEmpty()) {
            val points = routePoints.map { Point.fromLngLat(it.longitude, it.latitude) }
            val lineString = LineString.fromLngLats(points)
            val feature = Feature.fromGeometry(lineString)
            
            source?.setGeoJson(feature)
        }
    }
}

/**
 * Panel de informaci√≥n de navegaci√≥n (parte inferior).
 */
@Composable
fun NavigationInfoPanel(
    state: NavigationState.Active,
    modifier: Modifier = Modifier
) {
    val backdrop = LocalBackdrop.current
    
    LiquidCard(
        modifier = modifier,
        backdrop = backdrop,
        cornerRadius = 16.dp,
        surfaceColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.8f) // Partially transparent surface
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(20.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Pr√≥xima maniobra
            state.currentStep?.let { step ->
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    // Icono de maniobra
                    Box(
                        modifier = Modifier
                            .size(48.dp)
                            .clip(CircleShape)
                            .background(MaterialTheme.colorScheme.primaryContainer),
                        contentAlignment = Alignment.Center
                    ) {
                        Icon(
                            imageVector = getManeuverIcon(step.maneuver.type),
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onPrimaryContainer,
                            modifier = Modifier.size(28.dp)
                        )
                    }
                    
                    // Instrucci√≥n
                    Column(modifier = Modifier.weight(1f)) {
                        Text(
                            text = formatDistance(state.distanceToNextManeuver),
                            style = MaterialTheme.typography.titleLarge,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.primary
                        )
                        Text(
                            text = getManeuverText(step.maneuver.type, step.name),
                            style = MaterialTheme.typography.bodyLarge,
                            color = MaterialTheme.colorScheme.onSurface
                        )
                    }
                }
            }
            
            Divider()
            
            // Distancia y ETA
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                // Distancia restante
                InfoItem(
                    icon = Icons.Default.Route,
                    label = "Distancia",
                    value = formatDistance(state.remainingDistance)
                )
                
                // Tiempo estimado
                InfoItem(
                    icon = Icons.Default.Schedule,
                    label = "Tiempo",
                    value = formatDuration(state.estimatedTimeRemaining)
                )
                
                // Paso actual
                InfoItem(
                    icon = Icons.Default.TurnRight,
                    label = "Paso",
                    value = "${state.currentStepIndex + 1}/${state.route.steps.size}"
                )
            }
        }
    }
}

/**
 * Componente de informaci√≥n individual.
 */
@Composable
fun InfoItem(
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    label: String,
    value: String
) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            tint = MaterialTheme.colorScheme.primary,
            modifier = Modifier.size(20.dp)
        )
        Text(
            text = value,
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold
        )
        Text(
            text = label,
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
    }
}

/**
 * Di√°logo de llegada al destino.
 */
@Composable
fun ArrivalDialog(
    destinationName: String,
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        icon = {
            Icon(
                Icons.Default.CheckCircle,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(48.dp)
            )
        },
        title = {
            Text(
                text = "¬°Has llegado!",
                style = MaterialTheme.typography.headlineSmall
            )
        },
        text = {
            Text("Has llegado a $destinationName")
        },
        confirmButton = {
            Button(onClick = onDismiss) {
                Text("Finalizar")
            }
        }
    )
}

/**
 * Obtiene el icono correspondiente a un tipo de maniobra.
 */
fun getManeuverIcon(type: String): androidx.compose.ui.graphics.vector.ImageVector {
    return when {
        type.contains("left", ignoreCase = true) -> Icons.Default.TurnLeft
        type.contains("right", ignoreCase = true) -> Icons.Default.TurnRight
        type.contains("straight", ignoreCase = true) -> Icons.Default.ArrowUpward
        type.contains("roundabout", ignoreCase = true) -> Icons.Default.Sync
        else -> Icons.Default.Navigation
    }
}

/**
 * Genera texto de instrucci√≥n legible.
 */
fun getManeuverText(type: String, roadName: String?): String {
    val action = when {
        type.contains("turn") && type.contains("left") -> "Gira a la izquierda"
        type.contains("turn") && type.contains("right") -> "Gira a la derecha"
        type.contains("straight") -> "Contin√∫a recto"
        type.contains("roundabout") -> "Toma la rotonda"
        type.contains("end of road") -> "Al final de la calle"
        else -> "Contin√∫a"
    }
    
    return if (!roadName.isNullOrBlank() && roadName != "unknown") {
        "$action hacia $roadName"
    } else {
        action
    }
}

/**
 * Formatea distancia en metros a texto legible.
 */
fun formatDistance(meters: Double): String {
    return when {
        meters < 100 -> "${meters.roundToInt()} m"
        meters < 1000 -> "${(meters / 100).roundToInt() * 100} m"
        else -> "${"%.1f".format(meters / 1000)} km"
    }
}

/**
 * Formatea duraci√≥n en segundos a texto legible.
 */
fun formatDuration(seconds: Double): String {
    val minutes = (seconds / 60).roundToInt()
    return when {
        minutes < 60 -> "$minutes min"
        else -> {
            val hours = minutes / 60
            val remainingMinutes = minutes % 60
            "${hours}h ${remainingMinutes}min"
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/navigation/CircuitNavigationViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.navigation

import android.Manifest
import android.app.Application
import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import android.speech.tts.TextToSpeech
import android.util.Log
import androidx.core.content.ContextCompat
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.car.PoiRepository
import com.georacing.georacing.debug.ScenarioSimulator
import com.georacing.georacing.domain.model.CircuitMode
import com.georacing.georacing.navigation.NavigationEngine
import com.georacing.georacing.navigation.NavigationState
import com.georacing.georacing.utils.TTSManager
import com.google.android.gms.location.*
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import org.maplibre.android.geometry.LatLng
import java.util.Locale

/**
 * ViewModel para la pantalla de navegaci√≥n m√≥vil.
 * 
 * Gestiona:
 * - Motor de navegaci√≥n compartido (NavigationEngine)
 * - Actualizaciones de ubicaci√≥n GPS
 * - Gesti√≥n de permisos
 * - Text-to-Speech para instrucciones
 * - Estado de UI (mapa, informaci√≥n de navegaci√≥n)
 */
class CircuitNavigationViewModel(
    application: Application
) : AndroidViewModel(application), TextToSpeech.OnInitListener {
    
    private val TAG = "CircuitNavViewModel"
    
    // Motor de navegaci√≥n compartido
    private val navigationEngine = NavigationEngine()
    
    // Exposici√≥n del estado de navegaci√≥n
    val navigationState: StateFlow<NavigationState> = navigationEngine.navigationState
    
    // Ubicaci√≥n GPS
    private val fusedLocationClient: FusedLocationProviderClient =
        LocationServices.getFusedLocationProviderClient(application)
    
    private val _currentLocation = MutableStateFlow<Location?>(null)
    val currentLocation: StateFlow<Location?> = _currentLocation.asStateFlow()
    
    // Estado de permisos
    private val _locationPermissionGranted = MutableStateFlow(false)
    val locationPermissionGranted: StateFlow<Boolean> = _locationPermissionGranted.asStateFlow()
    
    // Text-to-Speech
    private var tts: TextToSpeech? = null
    private var isTtsReady = false
    
    // Estado de UI
    private val _isFollowMode = MutableStateFlow(true)
    val isFollowMode: StateFlow<Boolean> = _isFollowMode.asStateFlow()
    
    private val _showArrivalDialog = MutableStateFlow(false)
    val showArrivalDialog: StateFlow<Boolean> = _showArrivalDialog.asStateFlow()
    
    private val _errorMessage = MutableStateFlow<String?>(null)
    val errorMessage: StateFlow<String?> = _errorMessage.asStateFlow()
    
    // ==========================================
    // WAZE-STYLE DATA FLOWS
    // ==========================================
    
    // Circuit State (Green/Red Flag)
    private val _circuitMode = MutableStateFlow(CircuitMode.GREEN_FLAG)
    val circuitMode: StateFlow<CircuitMode> = _circuitMode.asStateFlow()
    
    // Active Hazards (for pop-up alerts)
    private val _activeHazards = MutableStateFlow<List<ScenarioSimulator.RoadHazard>>(emptyList())
    val activeHazards: StateFlow<List<ScenarioSimulator.RoadHazard>> = _activeHazards.asStateFlow()
    
    // Speed tracking
    private val _currentSpeed = MutableStateFlow(0f)
    val currentSpeed: StateFlow<Float> = _currentSpeed.asStateFlow()
    
    private val _speedLimit = MutableStateFlow<Int?>(null)
    val speedLimit: StateFlow<Int?> = _speedLimit.asStateFlow()
    
    // Callback de ubicaci√≥n
    private val locationCallback = object : LocationCallback() {
        override fun onLocationResult(locationResult: LocationResult) {
            locationResult.lastLocation?.let { location ->
                handleLocationUpdate(location)
            }
        }
    }
    
    init {
        // Inicializar TTS
        tts = TextToSpeech(application, this)
        
        // Verificar permisos
        checkLocationPermission()
        
        // Observar estado de navegaci√≥n para detectar llegada
        viewModelScope.launch {
            navigationState.collect { state ->
                when (state) {
                    is NavigationState.Arrived -> {
                        _showArrivalDialog.value = true
                        stopLocationUpdates()
                    }
                    is NavigationState.Error -> {
                        _errorMessage.value = state.message
                    }
                    else -> {
                        // Estados normales, no hacer nada especial
                    }
                }
            }
        }
        
        // Manejar instrucciones de voz
        viewModelScope.launch {
            navigationState.collect { state ->
                if (state is NavigationState.Active && state.currentStep != null) {
                    handleVoiceInstruction(state)
                }
            }
        }
        
        // ==========================================
        // WAZE-STYLE OBSERVERS
        // ==========================================
        
        // Observar estado del circuito desde ScenarioSimulator
        viewModelScope.launch {
            ScenarioSimulator.crowdIntensity.collect { intensity ->
                _circuitMode.value = when {
                    intensity > 0.9f -> CircuitMode.RED_FLAG
                    intensity > 0.7f -> CircuitMode.SAFETY_CAR
                    intensity > 0.5f -> CircuitMode.YELLOW_FLAG
                    else -> CircuitMode.GREEN_FLAG
                }
            }
        }
        
        // Observar hazards activos
        viewModelScope.launch {
            ScenarioSimulator.activeHazards.collect { hazards ->
                _activeHazards.value = hazards
            }
        }
        
        // Observar l√≠mite de velocidad (inicialmente simulado)
        viewModelScope.launch {
            ScenarioSimulator.speedLimit.collect { limit ->
                _speedLimit.value = limit.toInt()
            }
        }
    }
    
    /**
     * Verifica si el permiso de ubicaci√≥n est√° concedido.
     */
    private fun checkLocationPermission() {
        val context = getApplication<Application>()
        _locationPermissionGranted.value = ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED
    }
    
    /**
     * Inicia la navegaci√≥n hacia un POI del circuito.
     */
    fun startNavigationToPoi(poiId: String) {
        val poi = PoiRepository.getById(poiId)
        if (poi == null) {
            _errorMessage.value = "Punto de inter√©s no encontrado"
            return
        }
        
        startNavigation(
            destination = LatLng(poi.latitude, poi.longitude),
            destinationName = poi.name
        )
    }
    
    /**
     * Inicia la navegaci√≥n hacia coordenadas espec√≠ficas.
     */
    fun startNavigation(destination: LatLng, destinationName: String) {
        Log.i(TAG, "Iniciando navegaci√≥n a $destinationName")
        
        if (!_locationPermissionGranted.value) {
            _errorMessage.value = "Se requiere permiso de ubicaci√≥n para navegar"
            return
        }
        
        viewModelScope.launch {
            val currentLoc = _currentLocation.value
            val success = navigationEngine.startNavigation(
                destination = destination,
                destinationName = destinationName,
                currentLocation = currentLoc
            )
            
            if (success) {
                startLocationUpdates()
            }
        }
    }
    
    /**
     * Inicia las actualizaciones de ubicaci√≥n GPS.
     */
    @Suppress("MissingPermission")
    private fun startLocationUpdates() {
        if (!_locationPermissionGranted.value) {
            Log.w(TAG, "No se puede iniciar actualizaciones de ubicaci√≥n sin permiso")
            return
        }
        
        val locationRequest = LocationRequest.Builder(
            Priority.PRIORITY_HIGH_ACCURACY,
            1000L // Actualizaci√≥n cada segundo
        ).apply {
            setMinUpdateIntervalMillis(500L)
            setMaxUpdateDelayMillis(2000L)
        }.build()
        
        fusedLocationClient.requestLocationUpdates(
            locationRequest,
            locationCallback,
            android.os.Looper.getMainLooper()
        )
        
        Log.i(TAG, "Actualizaciones de ubicaci√≥n iniciadas")
    }
    
    /**
     * Detiene las actualizaciones de ubicaci√≥n GPS.
     */
    private fun stopLocationUpdates() {
        fusedLocationClient.removeLocationUpdates(locationCallback)
        Log.i(TAG, "Actualizaciones de ubicaci√≥n detenidas")
    }
    
    /**
     * Maneja una nueva actualizaci√≥n de ubicaci√≥n.
     */
    private fun handleLocationUpdate(location: Location) {
        // Filtrar se√±ales GPS de mala calidad
        if (location.accuracy > 50f) {
            Log.d(TAG, "GPS poco preciso (accuracy=${location.accuracy}m), ignorando")
            return
        }
        
        _currentLocation.value = location
        
        // Actualizar velocidad actual (para veloc√≠metro)
        _currentSpeed.value = if (location.hasSpeed()) {
            location.speed * 3.6f // m/s to km/h
        } else {
            0f
        }
        
        // Actualizar motor de navegaci√≥n
        viewModelScope.launch {
            navigationEngine.updateLocation(location)
        }
    }
    
    /**
     * Maneja las instrucciones de voz progresivas.
     */
    private fun handleVoiceInstruction(state: NavigationState.Active) {
        if (!isTtsReady || state.currentStep == null) return
        
        val instruction = TTSManager.getInstructionText(
            maneuverType = state.currentStep.maneuver.type,
            modifier = state.currentStep.maneuver.modifier,
            streetName = state.currentStep.name
        )
        
        TTSManager.handleProgressiveTTS(
            instruction = instruction,
            distanceToManeuver = state.distanceToNextManeuver,
            tts = tts,
            forceSpeak = false
        )
    }
    
    /**
     * Callback de inicializaci√≥n de TTS.
     */
    override fun onInit(status: Int) {
        if (status == TextToSpeech.SUCCESS) {
            val result = tts?.setLanguage(Locale("es", "ES"))
            isTtsReady = result != TextToSpeech.LANG_MISSING_DATA && result != TextToSpeech.LANG_NOT_SUPPORTED
            Log.i(TAG, "TTS inicializado: ${if (isTtsReady) "OK" else "ERROR"}")
        } else {
            Log.e(TAG, "Error al inicializar TTS")
        }
    }
    
    /**
     * Alterna el modo de seguimiento del mapa.
     */
    fun toggleFollowMode() {
        _isFollowMode.value = !_isFollowMode.value
    }
    
    /**
     * Actualiza el estado del permiso de ubicaci√≥n.
     */
    fun onPermissionResult(granted: Boolean) {
        _locationPermissionGranted.value = granted
        if (granted) {
            // Intentar obtener √∫ltima ubicaci√≥n conocida
            requestLastKnownLocation()
        } else {
            _errorMessage.value = "Se requiere permiso de ubicaci√≥n para usar la navegaci√≥n"
        }
    }
    
    /**
     * Solicita la √∫ltima ubicaci√≥n conocida.
     */
    @Suppress("MissingPermission")
    private fun requestLastKnownLocation() {
        if (!_locationPermissionGranted.value) return
        
        fusedLocationClient.lastLocation.addOnSuccessListener { location ->
            location?.let {
                _currentLocation.value = it
                Log.d(TAG, "√öltima ubicaci√≥n conocida: ${it.latitude}, ${it.longitude}")
            }
        }
    }
    
    /**
     * Cierra el di√°logo de llegada.
     */
    fun dismissArrivalDialog() {
        _showArrivalDialog.value = false
    }
    
    /**
     * Limpia el mensaje de error.
     */
    fun clearError() {
        _errorMessage.value = null
    }
    
    /**
     * Detiene la navegaci√≥n.
     */
    fun stopNavigation() {
        navigationEngine.stopNavigation()
        stopLocationUpdates()
    }
    
    /**
     * Abre Google Maps con el destino actual.
     */
    fun openInGoogleMaps(context: Context) {
        val state = navigationState.value
        if (state is NavigationState.Active) {
            val uri = android.net.Uri.parse(
                "google.navigation:q=${state.destination.latitude},${state.destination.longitude}"
            )
            val intent = android.content.Intent(android.content.Intent.ACTION_VIEW, uri)
            intent.setPackage("com.google.android.apps.maps")
            
            if (intent.resolveActivity(context.packageManager) != null) {
                context.startActivity(intent)
            } else {
                // Fallback a navegaci√≥n web
                val webUri = android.net.Uri.parse(
                    "https://www.google.com/maps/dir/?api=1&destination=${state.destination.latitude},${state.destination.longitude}"
                )
                context.startActivity(android.content.Intent(android.content.Intent.ACTION_VIEW, webUri))
            }
        }
    }
    
    override fun onCleared() {
        super.onCleared()
        stopLocationUpdates()
        tts?.stop()
        tts?.shutdown()
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/onboarding/OnboardingQuizScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.onboarding

import androidx.compose.animation.*
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.outlined.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.domain.model.Interest
import com.georacing.georacing.domain.model.F1Team
import com.georacing.georacing.domain.model.TransportMethod
import com.georacing.georacing.domain.model.UserType

@OptIn(ExperimentalAnimationApi::class)
@Composable
fun OnboardingQuizScreen(
    viewModel: WelcomeViewModel,
    onOnboardingComplete: () -> Unit
) {
    val currentStep by viewModel.currentStep.collectAsState()
    val isConfiguring by viewModel.isConfiguring.collectAsState()
    val onboardingComplete by viewModel.onboardingComplete.collectAsState()

    LaunchedEffect(onboardingComplete) {
        if (onboardingComplete) {
            onOnboardingComplete()
        }
    }

    Scaffold(
        modifier = Modifier.fillMaxSize(),
        containerColor = Color(0xFF080810)
    ) { padding ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Brush.verticalGradient(listOf(Color(0xFF080810), Color(0xFF0A0A16), Color(0xFF080810))))
                .padding(padding)
        ) {
            if (isConfiguring) {
                MagicLoadingScreen()
            } else {
                
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    // Header with Progress
                    QuizProgressBar(currentStep = currentStep, totalSteps = 5)
                    
                    Spacer(modifier = Modifier.height(24.dp))

                    AnimatedContent(
                        targetState = currentStep,
                        transitionSpec = {
                            if (targetState > initialState) {
                                slideInHorizontally { width -> width } + fadeIn() togetherWith
                                        slideOutHorizontally { width -> -width } + fadeOut()
                            } else {
                                slideInHorizontally { width -> -width } + fadeIn() togetherWith
                                        slideOutHorizontally { width -> width } + fadeOut()
                            }.using(
                                SizeTransform(clip = false)
                            )
                        },
                        label = "quiz_transition"
                    ) { step ->
                        when(step) {
                            0 -> StepUserType(viewModel)
                            1 -> StepTransport(viewModel)
                            2 -> StepInterests(viewModel)
                            3 -> StepFavoriteTeam(viewModel)
                            4 -> StepAccessibility(viewModel)
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun QuizProgressBar(currentStep: Int, totalSteps: Int) {
    Row(
        modifier = Modifier.fillMaxWidth().height(8.dp),
        horizontalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        for (i in 0 until totalSteps) {
            val color = if (i <= currentStep) Color(0xFFE8253A) else Color(0xFF14141C)
            Box(modifier = Modifier.weight(1f).fillMaxHeight().clip(RoundedCornerShape(4.dp)).background(color))
        }
    }
}

@Composable
fun MagicLoadingScreen() {
    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        CircularProgressIndicator(
            modifier = Modifier.size(64.dp),
            strokeWidth = 6.dp,
            color = Color(0xFFE8253A),
            trackColor = Color(0xFF14141C)
        )
        Spacer(modifier = Modifier.height(24.dp))
        Text(
            text = "CONFIGURANDO TU GEORACING...",
            style = MaterialTheme.typography.headlineSmall.copy(
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.5.sp,
                color = Color(0xFFF8FAFC)
            )
        )
        Text(
            text = "Personalizando experiencia seg√∫n tus respuestas",
            style = MaterialTheme.typography.bodyMedium,
            color = Color(0xFF64748B),
            modifier = Modifier.padding(top = 8.dp)
        )
    }
}

@Composable
fun StepUserType(viewModel: WelcomeViewModel) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(
            text = "¬øQU√â TE TRAE AL CIRCUITO?",
            style = MaterialTheme.typography.headlineMedium.copy(
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.5.sp,
                color = Color(0xFFF8FAFC)
            ),
            modifier = Modifier.padding(bottom = 32.dp)
        )

        val options = listOf(
            Triple(UserType.FAN, "Aficionado", Icons.Default.SportsMotorsports),
            Triple(UserType.FAMILY, "Familia", Icons.Default.FamilyRestroom),
            Triple(UserType.VIP, "Experiencia VIP", Icons.Default.EmojiEvents),
            Triple(UserType.STAFF, "Staff / Equipo", Icons.Default.Badge)
        )

        options.forEach { (type, label, icon) ->
            SelectionCard(
                text = label,
                icon = icon,
                onClick = { viewModel.selectUserType(type) }
            )
            Spacer(modifier = Modifier.height(12.dp))
        }
    }
}

@Composable
fun StepTransport(viewModel: WelcomeViewModel) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(
            text = "¬øC√ìMO HAS VENIDO HOY?",
            style = MaterialTheme.typography.headlineMedium.copy(
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.5.sp,
                color = Color(0xFFF8FAFC)
            ),
            modifier = Modifier.padding(bottom = 32.dp)
        )

        val options = listOf(
            Triple(TransportMethod.CAR, "Coche Propio", Icons.Default.DirectionsCar),
            Triple(TransportMethod.PUBLIC_TRANSPORT, "Tren / Bus", Icons.Default.Train),
            Triple(TransportMethod.WALKING, "A pie / Taxi", Icons.Default.DirectionsWalk)
        )

        options.forEach { (method, label, icon) ->
            SelectionCard(
                text = label,
                icon = icon,
                onClick = { viewModel.selectTransport(method) }
            )
            Spacer(modifier = Modifier.height(12.dp))
        }
        
        Spacer(modifier = Modifier.height(16.dp))
        TextButton(onClick = { viewModel.previousStep() }) {
            Text("Volver")
        }
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun StepInterests(viewModel: WelcomeViewModel) {
    val selectedInterests by viewModel.selectedInterests.collectAsState()

    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(
            text = "¬øQU√â TE INTERESA M√ÅS?",
            style = MaterialTheme.typography.headlineMedium.copy(
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.5.sp,
                color = Color(0xFFF8FAFC)
            ),
            modifier = Modifier.padding(bottom = 8.dp)
        )
        Text(
            text = "Selecciona todo lo que aplique",
            style = MaterialTheme.typography.bodyMedium,
            color = Color(0xFF64748B),
            modifier = Modifier.padding(bottom = 32.dp)
        )

        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.Center,
            verticalArrangement = Arrangement.spacedBy(8.dp),
            maxItemsInEachRow = 2
        ) {
             val options = listOf(
                Triple(Interest.RACING, "Tiempos & Carreras", Icons.Default.Flag),
                Triple(Interest.FOOD, "Comida & Bebida", Icons.Default.Restaurant),
                Triple(Interest.EVENTS, "Eventos Fan", Icons.Default.Event),
                Triple(Interest.TECH, "Tech & Sostenibilidad", Icons.Default.Smartphone)
            )
            
            options.forEach { (interest, label, icon) ->
                InterestChip(
                    text = label,
                    icon = icon,
                    selected = selectedInterests.contains(interest),
                    onClick = { viewModel.toggleInterest(interest) }
                )
            }
        }
        
        Spacer(modifier = Modifier.weight(1f))

        Button(
            onClick = { viewModel.nextStep() },
            modifier = Modifier.fillMaxWidth().height(56.dp),
            enabled = selectedInterests.isNotEmpty(),
            colors = ButtonDefaults.buttonColors(
                containerColor = Color(0xFFE8253A),
                contentColor = Color(0xFFF8FAFC),
                disabledContainerColor = Color(0xFF14141C),
                disabledContentColor = Color(0xFF64748B)
            ),
            shape = RoundedCornerShape(12.dp)
        ) {
            Text(
                "SIGUIENTE",
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.5.sp
            )
        }
         Spacer(modifier = Modifier.height(16.dp))
        TextButton(onClick = { viewModel.previousStep() }) {
            Text("Volver")
        }
    }
}

@Composable
fun SelectionCard(
    text: String,
    icon: ImageVector,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .height(72.dp)
            .clickable { onClick() },
        shape = RoundedCornerShape(16.dp),
        colors = CardDefaults.cardColors(containerColor = Color(0xFF14141C))
    ) {
        Row(
            modifier = Modifier
                .fillMaxSize()
                .padding(horizontal = 24.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = icon,
                contentDescription = null,
                tint = Color(0xFFE8253A),
                modifier = Modifier.size(32.dp)
            )
            Spacer(modifier = Modifier.width(24.dp))
            Text(
                text = text,
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.SemiBold,
                color = Color(0xFFF8FAFC)
            )
            Spacer(modifier = Modifier.weight(1f))
            Icon(
                imageVector = Icons.Default.ChevronRight,
                contentDescription = null,
                tint = Color(0xFF64748B)
            )
        }
    }
}

@Composable
fun InterestChip(
    text: String,
    icon: ImageVector,
    selected: Boolean,
    onClick: () -> Unit
) {
    FilterChip(
        selected = selected,
        onClick = onClick,
        label = { Text(text) },
        leadingIcon = {
             Icon(
                imageVector = icon,
                contentDescription = null,
                modifier = Modifier.size(18.dp)
            )
        },
        modifier = Modifier.padding(4.dp)
    )
}

@Composable
fun StepFavoriteTeam(viewModel: WelcomeViewModel) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.fillMaxWidth()
    ) {
        Text(
            text = "¬øTU EQUIPO FAVORITO?",
            style = MaterialTheme.typography.headlineMedium.copy(
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.5.sp,
                color = Color(0xFFF8FAFC)
            ),
            modifier = Modifier.padding(bottom = 8.dp)
        )
        Text(
            text = "Personaliza tu experiencia con tu equipo",
            style = MaterialTheme.typography.bodyMedium,
            color = Color(0xFF64748B),
            modifier = Modifier.padding(bottom = 24.dp)
        )

        val teams = F1Team.entries.toList()
        
        androidx.compose.foundation.lazy.LazyColumn(
            modifier = Modifier.weight(1f).fillMaxWidth(),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            items(teams.size) { index ->
                val team = teams[index]
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(56.dp)
                        .clickable { viewModel.selectFavoriteTeam(team) },
                    shape = RoundedCornerShape(12.dp),
                    colors = CardDefaults.cardColors(containerColor = Color(0xFF14141C))
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(horizontal = 16.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Box(
                            modifier = Modifier
                                .size(24.dp)
                                .background(Color(team.color), shape = CircleShape)
                        )
                        Spacer(modifier = Modifier.width(16.dp))
                        Text(
                            text = team.displayName,
                            style = MaterialTheme.typography.titleSmall,
                            fontWeight = FontWeight.SemiBold,
                            color = Color(0xFFF8FAFC)
                        )
                        Spacer(modifier = Modifier.weight(1f))
                        Icon(
                            imageVector = Icons.Default.ChevronRight,
                            contentDescription = null,
                            tint = Color(0xFF64748B)
                        )
                    }
                }
            }
        }
        
        Spacer(modifier = Modifier.height(16.dp))
        TextButton(onClick = { viewModel.previousStep() }) {
            Text("Volver")
        }
    }
}

@Composable
fun StepAccessibility(viewModel: WelcomeViewModel) {
    val needsAccessibility by viewModel.needsAccessibility.collectAsState()

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.fillMaxWidth()
    ) {
        Text(
            text = "ACCESIBILIDAD",
            style = MaterialTheme.typography.headlineMedium.copy(
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.5.sp,
                color = Color(0xFFF8FAFC)
            ),
            modifier = Modifier.padding(bottom = 8.dp)
        )
        Text(
            text = "¬øNecesitas rutas adaptadas?",
            style = MaterialTheme.typography.bodyMedium,
            color = Color(0xFF64748B),
            modifier = Modifier.padding(bottom = 32.dp)
        )

        // Toggle accesibilidad
        Card(
            modifier = Modifier.fillMaxWidth(),
            shape = RoundedCornerShape(16.dp),
            colors = CardDefaults.cardColors(
                containerColor = if (needsAccessibility) Color(0xFF1A2A1A) else Color(0xFF14141C)
            )
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { viewModel.setAccessibility(!needsAccessibility) }
                    .padding(20.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    imageVector = Icons.Default.Accessible,
                    contentDescription = null,
                    tint = if (needsAccessibility) Color(0xFF22C55E) else Color(0xFF64748B),
                    modifier = Modifier.size(32.dp)
                )
                Spacer(modifier = Modifier.width(16.dp))
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = "Evitar escaleras",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.SemiBold,
                        color = Color(0xFFF8FAFC)
                    )
                    Text(
                        text = "Rutas accesibles sin escaleras ni desniveles",
                        style = MaterialTheme.typography.bodySmall,
                        color = Color(0xFF64748B)
                    )
                }
                Switch(
                    checked = needsAccessibility,
                    onCheckedChange = { viewModel.setAccessibility(it) },
                    colors = SwitchDefaults.colors(
                        checkedTrackColor = Color(0xFF22C55E),
                        checkedThumbColor = Color.White
                    )
                )
            }
        }

        Spacer(modifier = Modifier.weight(1f))

        Button(
            onClick = { viewModel.completeQuiz() },
            modifier = Modifier.fillMaxWidth().height(56.dp),
            colors = ButtonDefaults.buttonColors(
                containerColor = Color(0xFFE8253A),
                contentColor = Color(0xFFF8FAFC)
            ),
            shape = RoundedCornerShape(12.dp)
        ) {
            Text(
                "PERSONALIZAR MI EXPERIENCIA",
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.5.sp
            )
        }

        Spacer(modifier = Modifier.height(16.dp))
        TextButton(onClick = { viewModel.previousStep() }) {
            Text("Volver")
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/onboarding/OnboardingScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.onboarding

import android.Manifest
import android.os.Build
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.sp
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import androidx.navigation.NavController
import com.georacing.georacing.data.local.UserPreferencesDataStore
import com.georacing.georacing.ui.navigation.Screen
import kotlinx.coroutines.launch

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun OnboardingScreen(
    navController: NavController,
    userPreferences: UserPreferencesDataStore
) {
    val backdrop = com.georacing.georacing.ui.glass.LocalBackdrop.current
    val viewModel: OnboardingViewModel = viewModel(
        factory = viewModelFactory {
            initializer {
                OnboardingViewModel(userPreferences)
            }
        }
    )

    val pagerState = rememberPagerState(pageCount = { 3 })
    val scope = rememberCoroutineScope()

    val permissionsToRequest = mutableListOf(
        Manifest.permission.ACCESS_FINE_LOCATION,
        Manifest.permission.ACCESS_COARSE_LOCATION
    ).apply {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            add(Manifest.permission.BLUETOOTH_SCAN)
            add(Manifest.permission.BLUETOOTH_CONNECT)
        } else {
            add(Manifest.permission.BLUETOOTH)
            add(Manifest.permission.BLUETOOTH_ADMIN)
        }
    }.toTypedArray()

    val permissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { _ ->
        // Handle permission results if needed
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(Brush.verticalGradient(listOf(Color(0xFF080810), Color(0xFF0A0A16), Color(0xFF080810))))
            .padding(16.dp)
    ) {
        HorizontalPager(
            state = pagerState,
            modifier = Modifier.weight(1f)
        ) { page ->
            OnboardingPage(page = page)
        }

        Row(
            Modifier
                .height(50.dp)
                .fillMaxWidth(),
            horizontalArrangement = Arrangement.Center
        ) {
            repeat(pagerState.pageCount) { iteration ->
                val color = if (pagerState.currentPage == iteration) Color(0xFFE8253A) else Color(0xFF64748B)
                Box(
                    modifier = Modifier
                        .padding(2.dp)
                        .clip(CircleShape)
                        .background(color)
                        .size(if (pagerState.currentPage == iteration) 10.dp else 8.dp)
                )
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        if (pagerState.currentPage == 2) {
            com.georacing.georacing.ui.glass.LiquidButton(
                onClick = { permissionLauncher.launch(permissionsToRequest) },
                backdrop = backdrop,
                modifier = Modifier.fillMaxWidth(),
                surfaceColor = MaterialTheme.colorScheme.secondary.copy(alpha = 0.6f)
            ) {
                Text("Solicitar Permisos")
            }
            Spacer(modifier = Modifier.height(8.dp))
            com.georacing.georacing.ui.glass.LiquidButton(
                onClick = {
                    viewModel.completeOnboarding()
                    navController.navigate(Screen.Home.route) {
                        popUpTo(Screen.Onboarding.route) { inclusive = true }
                    }
                },
                backdrop = backdrop,
                modifier = Modifier.fillMaxWidth(),
                surfaceColor = MaterialTheme.colorScheme.primary.copy(alpha = 0.7f),
                tint = MaterialTheme.colorScheme.primary.copy(alpha = 0.3f)
            ) {
                Text("Empezar")
            }
        } else {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                com.georacing.georacing.ui.glass.LiquidButton(
                    onClick = {
                        scope.launch {
                            pagerState.animateScrollToPage(2)
                        }
                    },
                    backdrop = backdrop,
                    surfaceColor = Color.Transparent, // Transparent for outlined feel
                    tint = Color(0xFFF8FAFC).copy(alpha = 0.1f)
                ) {
                    Text("Saltar")
                }
                com.georacing.georacing.ui.glass.LiquidButton(
                    onClick = {
                        scope.launch {
                            pagerState.animateScrollToPage(pagerState.currentPage + 1)
                        }
                    },
                    backdrop = backdrop,
                    surfaceColor = MaterialTheme.colorScheme.primary.copy(alpha = 0.7f)
                ) {
                    Text("Siguiente")
                }
            }
        }
    }
}

@Composable
fun OnboardingPage(page: Int) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            text = when (page) {
                0 -> "BIENVENIDO A GEORACING"
                1 -> "NAVEGACI√ìN INTELIGENTE"
                else -> "SEGURIDAD Y AVISOS"
            },
            style = MaterialTheme.typography.titleLarge.copy(
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.5.sp,
                color = Color(0xFFF8FAFC)
            ),
            textAlign = TextAlign.Center
        )
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            text = when (page) {
                0 -> "Tu compa√±ero digital para el Circuit de Barcelona-Catalunya."
                1 -> "Encuentra tu asiento, puntos de inter√©s y servicios usando nuestra tecnolog√≠a de balizas."
                else -> "Recibe avisos en tiempo real y reporta incidencias para mejorar la experiencia de todos."
            },
            style = MaterialTheme.typography.bodyLarge.copy(
                color = Color(0xFF64748B)
            ),
            textAlign = TextAlign.Center
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/onboarding/OnboardingViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.onboarding

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.data.local.UserPreferencesDataStore
import kotlinx.coroutines.launch

class OnboardingViewModel(
    private val userPreferences: UserPreferencesDataStore
) : ViewModel() {

    fun completeOnboarding() {
        viewModelScope.launch {
            userPreferences.setOnboardingCompleted(true)
        }
    }

    fun setLanguage(language: String) {
        viewModelScope.launch {
            userPreferences.setPreferredLanguage(language)
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/onboarding/WelcomeViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.onboarding

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
// import com.georacing.georacing.data.repository.LayoutPreferencesRepository // Replaced by UserPreferencesDataStore as per context
import com.georacing.georacing.data.local.UserPreferencesDataStore
import com.georacing.georacing.domain.model.Interest
import com.georacing.georacing.domain.model.F1Team
import com.georacing.georacing.domain.model.OnboardingAnswers
import com.georacing.georacing.domain.model.TransportMethod
import com.georacing.georacing.domain.model.UserType
import com.georacing.georacing.domain.usecases.ProfileGenerator
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class WelcomeViewModel(
    private val userPreferences: UserPreferencesDataStore
) : ViewModel() {

    private val profileGenerator = ProfileGenerator()

    // State
    private val _currentStep = MutableStateFlow(0)
    val currentStep: StateFlow<Int> = _currentStep.asStateFlow()

    private val _userType = MutableStateFlow<UserType?>(null)
    val userType: StateFlow<UserType?> = _userType.asStateFlow()

    private val _transportMethod = MutableStateFlow<TransportMethod?>(null)
    val transportMethod: StateFlow<TransportMethod?> = _transportMethod.asStateFlow()

    private val _selectedInterests = MutableStateFlow<List<Interest>>(emptyList())
    val selectedInterests: StateFlow<List<Interest>> = _selectedInterests.asStateFlow()

    private val _favoriteTeam = MutableStateFlow(F1Team.NONE)
    val favoriteTeam: StateFlow<F1Team> = _favoriteTeam.asStateFlow()

    private val _needsAccessibility = MutableStateFlow(false)
    val needsAccessibility: StateFlow<Boolean> = _needsAccessibility.asStateFlow()

    private val _isConfiguring = MutableStateFlow(false)
    val isConfiguring: StateFlow<Boolean> = _isConfiguring.asStateFlow()
    
    private val _onboardingComplete = MutableStateFlow(false)
    val onboardingComplete: StateFlow<Boolean> = _onboardingComplete.asStateFlow()

    fun selectUserType(type: UserType) {
        _userType.value = type
        nextStep()
    }

    fun selectTransport(method: TransportMethod) {
        _transportMethod.value = method
        nextStep()
    }

    fun toggleInterest(interest: Interest) {
        val currentList = _selectedInterests.value.toMutableList()
        if (currentList.contains(interest)) {
            currentList.remove(interest)
        } else {
            currentList.add(interest)
        }
        _selectedInterests.value = currentList
    }

    fun selectFavoriteTeam(team: F1Team) {
        _favoriteTeam.value = team
        nextStep()
    }

    fun setAccessibility(needs: Boolean) {
        _needsAccessibility.value = needs
    }

    fun nextStep() {
        if (_currentStep.value < 4) {
            _currentStep.value += 1
        }
    }
    
    fun previousStep() {
        if (_currentStep.value > 0) {
            _currentStep.value -= 1
        }
    }
    
    fun completeQuiz() {
        finishOnboarding()
    }

    private fun finishOnboarding() {
        _isConfiguring.value = true
        viewModelScope.launch {
            // Generate Profile logic
            val answers = OnboardingAnswers(
                userType = _userType.value,
                transportMethod = _transportMethod.value,
                interests = _selectedInterests.value,
                favoriteTeam = _favoriteTeam.value,
                needsAccessibility = _needsAccessibility.value
            )
            val layout = profileGenerator.generateDefaultLayout(answers)

            // Simulate "Configuration" magic and algorithm processing
            delay(2500)

            // Save preferences
            userPreferences.setDashboardLayout(layout.widgets)
            userPreferences.setFavoriteTeam(_favoriteTeam.value.name)
            userPreferences.setAvoidStairs(_needsAccessibility.value)
            userPreferences.setOnboardingCompleted(true)

            _isConfiguring.value = false
            _onboardingComplete.value = true
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/orders/ClickCollectScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.orders

import android.location.Location
import android.util.Log
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.animateColorAsState
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.data.firestorelike.FirestoreLikeApi
import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import kotlinx.coroutines.delay

/**
 * Pantalla Click & Collect ‚Äî Pedir comida y recoger en un punto del circuito.
 *
 * Flujo:
 * 1. Usuario ve los puntos de recogida (stands) con tiempo estimado
 * 2. Selecciona un stand ‚Üí se abre el men√∫ (OrdersScreen)
 * 3. Tras pedir, vuelve aqu√≠ con tracking en vivo del pedido
 * 4. Cuando est√° listo ‚Üí se muestra la direcci√≥n para ir al stand
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ClickCollectScreen(
    onNavigateBack: () -> Unit = {},
    onNavigateToOrders: (String) -> Unit = {}, // standId
    onNavigateToMyOrders: () -> Unit = {}
) {
    // ‚îÄ‚îÄ Stands del circuito ‚Äî datos reales del backend ‚îÄ‚îÄ
    var stands by remember { mutableStateOf<List<FoodStand>>(emptyList()) }
    var isLoadingStands by remember { mutableStateOf(true) }

    LaunchedEffect(Unit) {
        try {
            val response = FirestoreLikeClient.api.read("food_stands")
            stands = response.mapNotNull { map ->
                try {
                    FoodStand(
                        id = map["id"]?.toString() ?: return@mapNotNull null,
                        name = map["name"]?.toString() ?: "",
                        description = map["description"]?.toString() ?: "",
                        latitude = (map["latitude"] as? Number)?.toDouble() ?: 0.0,
                        longitude = (map["longitude"] as? Number)?.toDouble() ?: 0.0,
                        zone = map["zone"]?.toString() ?: "",
                        waitMinutes = (map["waitMinutes"] as? Number)?.toInt() ?: 10,
                        rating = (map["rating"] as? Number)?.toFloat() ?: 4.0f,
                        isOpen = map["isOpen"] as? Boolean ?: true
                    )
                } catch (_: Exception) { null }
            }
        } catch (e: Exception) {
            Log.w("ClickCollectScreen", "Error cargando stands: ${e.message}. Sin datos de stands.")
            stands = emptyList()
        }
        isLoadingStands = false
    }

    // ‚îÄ‚îÄ Estado ‚îÄ‚îÄ
    var selectedStand by remember { mutableStateOf<FoodStand?>(null) }
    var activeOrder by remember { mutableStateOf<CollectOrder?>(null) }
    var showOrderTracker by remember { mutableStateOf(false) }

    // Simular progreso del pedido activo ‚Äî En producci√≥n, esto se consultar√≠a al backend
    LaunchedEffect(activeOrder) {
        if (activeOrder != null && activeOrder?.status != CollectOrderStatus.DELIVERED) {
            delay(15_000)
            activeOrder = activeOrder?.copy(status = CollectOrderStatus.PREPARING)
            // Guardar estado en backend
            try {
                activeOrder?.let {
                    FirestoreLikeClient.api.upsert(FirestoreLikeApi.UpsertRequest(
                        table = "orders",
                        data = mapOf("id" to it.orderId, "standId" to it.standId, "status" to it.status.name, "pickupCode" to it.pickupCode)
                    ))
                }
            } catch (_: Exception) {}
            delay(20_000)
            activeOrder = activeOrder?.copy(status = CollectOrderStatus.READY)
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Click & Collect") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Volver")
                    }
                },
                actions = {
                    // Bot√≥n para ver mis pedidos
                    Badge(containerColor = MaterialTheme.colorScheme.primary) {
                        IconButton(onClick = onNavigateToMyOrders) {
                            Icon(Icons.Default.Receipt, "Mis pedidos")
                        }
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .verticalScroll(rememberScrollState())
        ) {
            // ‚îÄ‚îÄ Pedido activo ‚îÄ‚îÄ
            AnimatedVisibility(visible = activeOrder != null) {
                activeOrder?.let { order ->
                    ActiveOrderCard(
                        order = order,
                        stand = stands.find { it.id == order.standId },
                        onTrack = { showOrderTracker = true }
                    )
                }
            }

            // ‚îÄ‚îÄ Header ‚îÄ‚îÄ
            Text(
                text = "üìç Puntos de recogida",
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.padding(16.dp)
            )

            // ‚îÄ‚îÄ Filtros r√°pidos ‚îÄ‚îÄ
            LazyRow(
                contentPadding = PaddingValues(horizontal = 16.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                val filters = listOf("üçî Todo", "üçï Comida", "üç∫ Bebidas", "üç¶ Dulces", "‚ö° R√°pido")
                items(filters) { filter ->
                    FilterChip(
                        onClick = { /* Filter logic */ },
                        label = { Text(filter) },
                        selected = filter == "üçî Todo"
                    )
                }
            }

            Spacer(modifier = Modifier.height(12.dp))

            // ‚îÄ‚îÄ Lista de stands ‚îÄ‚îÄ
            stands.forEach { stand ->
                StandCard(
                    stand = stand,
                    isSelected = selectedStand?.id == stand.id,
                    onSelect = { selectedStand = stand },
                    onOrder = {
                        // Simular crear pedido (en producci√≥n ‚Üí navegar a OrdersScreen)
                        activeOrder = CollectOrder(
                            orderId = "ORD-${System.currentTimeMillis() % 10000}",
                            standId = stand.id,
                            standName = stand.name,
                            status = CollectOrderStatus.CONFIRMED,
                            estimatedMinutes = stand.waitMinutes + 5,
                            pickupCode = "GR-${(100..999).random()}"
                        )
                        onNavigateToOrders(stand.id)
                    }
                )
            }

            Spacer(modifier = Modifier.height(80.dp))
        }
    }

    // ‚îÄ‚îÄ Bottom Sheet: Tracker ‚îÄ‚îÄ
    if (showOrderTracker && activeOrder != null) {
        OrderTrackerSheet(
            order = activeOrder!!,
            stand = stands.find { it.id == activeOrder!!.standId },
            onDismiss = { showOrderTracker = false },
            onCollected = {
                activeOrder = activeOrder?.copy(status = CollectOrderStatus.DELIVERED)
                showOrderTracker = false
            }
        )
    }
}

// ‚îÄ‚îÄ Componentes ‚îÄ‚îÄ

@Composable
private fun StandCard(
    stand: FoodStand,
    isSelected: Boolean,
    onSelect: () -> Unit,
    onOrder: () -> Unit
) {
    val borderColor by animateColorAsState(
        if (isSelected) MaterialTheme.colorScheme.primary
        else MaterialTheme.colorScheme.outlineVariant,
        label = "border"
    )

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 4.dp)
            .clickable { onSelect() },
        colors = CardDefaults.cardColors(
            containerColor = if (stand.isOpen)
                MaterialTheme.colorScheme.surface
            else MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)
        ),
        border = if (isSelected) CardDefaults.outlinedCardBorder().copy(
            width = 2.dp
        ) else null
    ) {
        Row(
            modifier = Modifier.padding(12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Emoji grande
            Text(
                text = stand.name.take(2),
                fontSize = 32.sp,
                modifier = Modifier.width(48.dp),
                textAlign = TextAlign.Center
            )

            Spacer(modifier = Modifier.width(12.dp))

            // Info
            Column(modifier = Modifier.weight(1f)) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(
                        text = stand.name,
                        style = MaterialTheme.typography.titleSmall,
                        fontWeight = FontWeight.Bold
                    )
                    if (!stand.isOpen) {
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = "CERRADO",
                            style = MaterialTheme.typography.labelSmall,
                            color = MaterialTheme.colorScheme.error
                        )
                    }
                }
                Text(
                    text = stand.description,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    // Tiempo espera
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Icon(
                            Icons.Default.Schedule,
                            contentDescription = null,
                            modifier = Modifier.size(14.dp),
                            tint = if (stand.waitMinutes > 10)
                                MaterialTheme.colorScheme.error
                            else Color(0xFF4CAF50)
                        )
                        Text(
                            text = " ${stand.waitMinutes} min",
                            style = MaterialTheme.typography.labelSmall
                        )
                    }
                    // Rating
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Icon(
                            Icons.Default.Star,
                            contentDescription = null,
                            modifier = Modifier.size(14.dp),
                            tint = Color(0xFFFFC107)
                        )
                        Text(
                            text = " ${stand.rating}",
                            style = MaterialTheme.typography.labelSmall
                        )
                    }
                    // Ubicaci√≥n
                    Text(
                        text = "üìç ${stand.zone}",
                        style = MaterialTheme.typography.labelSmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            // Bot√≥n pedir
            if (stand.isOpen) {
                FilledTonalButton(
                    onClick = onOrder,
                    modifier = Modifier.padding(start = 8.dp)
                ) {
                    Text("Pedir")
                }
            }
        }
    }
}

@Composable
private fun ActiveOrderCard(
    order: CollectOrder,
    stand: FoodStand?,
    onTrack: () -> Unit
) {
    val statusColor = when (order.status) {
        CollectOrderStatus.CONFIRMED -> Color(0xFF2196F3)
        CollectOrderStatus.PREPARING -> Color(0xFFFF9800)
        CollectOrderStatus.READY -> Color(0xFF4CAF50)
        CollectOrderStatus.DELIVERED -> Color.Gray
    }

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
            .clickable { onTrack() },
        colors = CardDefaults.cardColors(containerColor = statusColor.copy(alpha = 0.1f))
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Box(
                    modifier = Modifier
                        .size(12.dp)
                        .clip(CircleShape)
                        .background(statusColor)
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = order.statusText(),
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold,
                    color = statusColor
                )
                Spacer(modifier = Modifier.weight(1f))
                Text(
                    text = order.pickupCode,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
            }
            Spacer(modifier = Modifier.height(4.dp))
            Text(
                text = "${stand?.name ?: order.standName} ‚Ä¢ ~${order.estimatedMinutes} min",
                style = MaterialTheme.typography.bodySmall
            )

            if (order.status == CollectOrderStatus.READY) {
                Spacer(modifier = Modifier.height(8.dp))
                Button(
                    onClick = onTrack,
                    modifier = Modifier.fillMaxWidth(),
                    colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF4CAF50))
                ) {
                    Icon(Icons.Default.Place, contentDescription = null)
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Ir a recoger")
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun OrderTrackerSheet(
    order: CollectOrder,
    stand: FoodStand?,
    onDismiss: () -> Unit,
    onCollected: () -> Unit
) {
    ModalBottomSheet(onDismissRequest = onDismiss) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Status steps
            val steps = listOf("Confirmado", "Preparando", "¬°Listo!")
            val currentStep = when (order.status) {
                CollectOrderStatus.CONFIRMED -> 0
                CollectOrderStatus.PREPARING -> 1
                CollectOrderStatus.READY, CollectOrderStatus.DELIVERED -> 2
            }

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                steps.forEachIndexed { index, label ->
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Box(
                            modifier = Modifier
                                .size(32.dp)
                                .clip(CircleShape)
                                .background(
                                    if (index <= currentStep) Color(0xFF4CAF50)
                                    else MaterialTheme.colorScheme.outlineVariant
                                ),
                            contentAlignment = Alignment.Center
                        ) {
                            if (index < currentStep) {
                                Icon(
                                    Icons.Default.Check,
                                    contentDescription = null,
                                    tint = Color.White,
                                    modifier = Modifier.size(20.dp)
                                )
                            } else {
                                Text(
                                    "${index + 1}",
                                    color = Color.White,
                                    fontSize = 14.sp,
                                    fontWeight = FontWeight.Bold
                                )
                            }
                        }
                        Spacer(modifier = Modifier.height(4.dp))
                        Text(label, style = MaterialTheme.typography.labelSmall)
                    }
                }
            }

            Spacer(modifier = Modifier.height(24.dp))

            // C√≥digo de recogida grande
            Text("C√≥digo de recogida", style = MaterialTheme.typography.labelMedium)
            Text(
                text = order.pickupCode,
                style = MaterialTheme.typography.displaySmall,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.primary
            )

            Spacer(modifier = Modifier.height(16.dp))

            // Info del stand
            if (stand != null) {
                Text("üìç ${stand.name}", style = MaterialTheme.typography.titleMedium)
                Text(stand.zone, style = MaterialTheme.typography.bodySmall)
            }

            Spacer(modifier = Modifier.height(24.dp))

            if (order.status == CollectOrderStatus.READY) {
                Button(
                    onClick = onCollected,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("‚úÖ Ya lo tengo")
                }
            }

            Spacer(modifier = Modifier.height(16.dp))
        }
    }
}

// ‚îÄ‚îÄ Modelos locales ‚îÄ‚îÄ

private data class FoodStand(
    val id: String,
    val name: String,
    val description: String,
    val latitude: Double,
    val longitude: Double,
    val zone: String,
    val waitMinutes: Int,
    val rating: Float,
    val isOpen: Boolean
)

private data class CollectOrder(
    val orderId: String,
    val standId: String,
    val standName: String,
    val status: CollectOrderStatus,
    val estimatedMinutes: Int,
    val pickupCode: String
) {
    fun statusText(): String = when (status) {
        CollectOrderStatus.CONFIRMED -> "Pedido confirmado"
        CollectOrderStatus.PREPARING -> "En preparaci√≥n..."
        CollectOrderStatus.READY -> "¬°Listo para recoger!"
        CollectOrderStatus.DELIVERED -> "Recogido ‚úì"
    }
}

private enum class CollectOrderStatus {
    CONFIRMED, PREPARING, READY, DELIVERED
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/orders/MyOrdersScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.orders

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.theme.*
import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import com.georacing.georacing.data.firestorelike.FirestoreLikeApi
import com.google.firebase.auth.FirebaseAuth
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONArray

data class OrderItem(
    val productId: String,
    val name: String,
    val quantity: Int,
    val unitPrice: Double
)

data class OrderTicket(
    val id: String,
    val orderId: String,
    val status: String,
    val itemsSummary: String,
    val items: List<OrderItem>,
    val total: Double,
    val createdAt: String
)

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MyOrdersScreen(navController: NavController) {
    val user = FirebaseAuth.getInstance().currentUser
    var orders by remember { mutableStateOf<List<OrderTicket>>(emptyList()) }
    var isLoading by remember { mutableStateOf(true) }

    LaunchedEffect(Unit) {
        if (user == null) return@LaunchedEffect
        withContext(Dispatchers.IO) {
            try {
                val api = FirestoreLikeClient.api
                val result = api.get(
                    FirestoreLikeApi.GetRequest(
                        table = "orders",
                        where = mapOf("user_uid" to user.uid)
                    )
                )
                
                // Sort by date desc (assuming generic string sort works for ISO dates, or we parse)
                // We'll trust backend order or sort client side
                
                orders = result.mapNotNull {
                    try {
                        val itemsJson = it["items_json"] as? String ?: "[]"
                        // Parse JSON into individual items
                        var summaryText = ""
                        val parsedItems = mutableListOf<OrderItem>()
                        try {
                             val jsonArray = JSONArray(itemsJson)
                             for (i in 0 until jsonArray.length()) {
                                 val obj = jsonArray.getJSONObject(i)
                                 val qty = obj.optInt("quantity", 1)
                                 val productId = obj.optString("product_id", "")
                                 val name = obj.optString("name", "Producto #${productId.take(6)}")
                                 val unitPrice = obj.optDouble("unit_price", 0.0)
                                 parsedItems.add(OrderItem(productId, name, qty, unitPrice))
                             }
                             summaryText = "${parsedItems.size} art√≠culos"
                        } catch (e: Exception) { summaryText = "Varios productos" }

                        OrderTicket(
                            id = it["id"] as? String ?: "",
                            orderId = it["order_id"] as? String ?: "???",
                            status = it["status"] as? String ?: "PENDING",
                            itemsSummary = summaryText,
                            items = parsedItems,
                            total = (it["total_amount"] as? Number)?.toDouble() ?: 0.0,
                            createdAt = it["created_at"] as? String ?: ""
                        )
                    } catch (e: Exception) { null }
                }.sortedByDescending { it.createdAt }
                
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                isLoading = false
            }
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        CarbonBackground()
        
        Scaffold(
            topBar = {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                        .glassSmall(shape = RoundedCornerShape(16.dp))
                        .padding(horizontal = 16.dp, vertical = 12.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        IconButton(onClick = { navController.navigateUp() }) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Atr√°s", tint = Color(0xFFF8FAFC))
                        }
                        Spacer(modifier = Modifier.width(4.dp))
                        Box(
                            modifier = Modifier
                                .size(8.dp)
                                .background(Color(0xFFE8253A), shape = RoundedCornerShape(50))
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = "MIS PEDIDOS",
                            style = MaterialTheme.typography.titleMedium.copy(
                                fontWeight = FontWeight.ExtraBold,
                                letterSpacing = 1.5.sp
                            ),
                            color = Color(0xFFF8FAFC)
                        )
                    }
                }
            },
            containerColor = Color.Transparent
        ) { padding ->
            if (isLoading) {
                Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator(color = Color(0xFFE8253A))
                }
            } else if (orders.isEmpty()) {
                Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    Text("No tienes pedidos recientes", color = Color(0xFF64748B), fontWeight = FontWeight.Bold)
                }
            } else {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(padding)
                        .padding(horizontal = 16.dp),
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    // Separate Ready from Others
                    val readyOrders = orders.filter { it.status == "READY" }
                    val activeOrders = orders.filter { it.status == "PAID" || it.status == "PREPARING" }
                    val history = orders.filter { it.status == "DELIVERED" }

                    if (readyOrders.isNotEmpty()) {
                        item { Header("LISTO PARA RECOGER") }
                        items(readyOrders) { OrderCard(it, true) }
                    }
                    
                    if (activeOrders.isNotEmpty()) {
                         item { Header("EN PREPARACI√ìN") }
                         items(activeOrders) { OrderCard(it, false) }
                    }
                    
                    if (history.isNotEmpty()) {
                        item { Header("HISTORIAL") }
                        items(history) { OrderCard(it, false) }
                    }
                }
            }
        }
    }
}

@Composable
fun Header(text: String) {
    Row(
        verticalAlignment = Alignment.CenterVertically,
        modifier = Modifier.padding(top = 16.dp, bottom = 8.dp)
    ) {
        Box(
            modifier = Modifier
                .size(8.dp)
                .background(Color(0xFFE8253A), shape = RoundedCornerShape(50))
        )
        Spacer(modifier = Modifier.width(8.dp))
        Text(
            text = text.uppercase(),
            style = MaterialTheme.typography.labelMedium.copy(
                letterSpacing = 1.5.sp
            ),
            color = Color(0xFF64748B),
            fontWeight = FontWeight.ExtraBold
        )
    }
}

@Composable
fun OrderCard(order: OrderTicket, isReady: Boolean) {
    var isExpanded by remember { mutableStateOf(false) }
    val rotationAngle by animateFloatAsState(
        targetValue = if (isExpanded) 180f else 0f,
        animationSpec = spring(stiffness = Spring.StiffnessMedium),
        label = "chevron"
    )

    val borderColor = when {
        isReady -> Color(0xFF22C55E)
        order.status == "PREPARING" -> Color(0xFFFFA726) // Amber
        order.status == "PAID" -> Color(0xFFD4A84B) // Gold
        else -> Color(0xFF64748B).copy(alpha=0.3f)
    }
    
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .liquidGlass(shape = RoundedCornerShape(16.dp))
            .border(1.dp, borderColor, RoundedCornerShape(16.dp))
            .clickable { isExpanded = !isExpanded }
            .padding(20.dp)
    ) {
        Column {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = if (isReady) "TICKET DE RECOGIDA" else "PEDIDO #${order.orderId.takeLast(4)}",
                        style = MaterialTheme.typography.labelSmall.copy(letterSpacing = 1.5.sp),
                        color = if(isReady) Color(0xFF22C55E) else Color(0xFF64748B),
                        fontWeight = FontWeight.ExtraBold
                    )
                    Text(
                        text = "#${order.orderId.takeLast(8).uppercase()}",
                        style = MaterialTheme.typography.headlineMedium,
                        fontWeight = FontWeight.Black,
                        color = Color(0xFFF8FAFC)
                    )
                }
                
                Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    if (isReady) {
                        Box(modifier = Modifier.background(Color(0xFF22C55E), RoundedCornerShape(8.dp)).padding(horizontal = 12.dp, vertical = 6.dp)) {
                            Text("LISTO", color = Color(0xFF080810), fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                        }
                    } else {
                        val statusText = when(order.status) {
                            "PAID" -> "EN COLA"
                            "PREPARING" -> "COCINANDO..."
                            "DELIVERED" -> "ENTREGADO"
                            else -> order.status
                        }
                        val statusColor = if(order.status == "PREPARING") Color(0xFFFFA726) else Color(0xFF64748B)
                        Text(
                            text = statusText,
                            style = MaterialTheme.typography.bodyMedium.copy(letterSpacing = 1.sp),
                            color = statusColor,
                            fontWeight = FontWeight.ExtraBold
                        )
                    }
                    Icon(
                        Icons.Default.KeyboardArrowDown,
                        contentDescription = if (isExpanded) "Contraer" else "Expandir",
                        tint = Color(0xFF64748B),
                        modifier = Modifier.graphicsLayer { rotationZ = rotationAngle }
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                 Text(order.itemsSummary, color = Color(0xFFF8FAFC), fontWeight = FontWeight.Bold)
                 Text("‚Ç¨${"%.2f".format(order.total)}", color = Color(0xFFE8253A), fontWeight = FontWeight.ExtraBold)
            }
            
            // ‚îÄ‚îÄ Expandable Items (iOS parity: OrderRowView) ‚îÄ‚îÄ
            AnimatedVisibility(
                visible = isExpanded && order.items.isNotEmpty(),
                enter = fadeIn() + expandVertically(),
                exit = fadeOut() + shrinkVertically()
            ) {
                Column(modifier = Modifier.padding(top = 12.dp)) {
                    HorizontalDivider(color = Color(0xFF64748B).copy(alpha = 0.3f))
                    Spacer(modifier = Modifier.height(10.dp))
                    order.items.forEach { item ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 4.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                "${item.quantity}x",
                                color = Color(0xFFFFA726),
                                fontWeight = FontWeight.Bold,
                                style = MaterialTheme.typography.bodyMedium,
                                modifier = Modifier.width(36.dp)
                            )
                            Text(
                                item.name,
                                color = Color(0xFFF8FAFC),
                                style = MaterialTheme.typography.bodyMedium,
                                modifier = Modifier.weight(1f)
                            )
                            Text(
                                "‚Ç¨${"%.2f".format(item.unitPrice * item.quantity)}",
                                color = Color(0xFF64748B),
                                style = MaterialTheme.typography.bodyMedium
                            )
                        }
                    }
                }
            }
            
            if (isReady) {
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    "Muestra este c√≥digo en la barra",
                    style = MaterialTheme.typography.bodySmall,
                    color = Color(0xFF22C55E),
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.align(Alignment.CenterHorizontally)
                )
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/orders/OrderConfirmationScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.orders

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.theme.*
import kotlinx.coroutines.delay
import java.util.UUID

@Composable
fun OrderConfirmationScreen(
    navController: NavController,
    orderId: String
) {
    // Generate a fake pickup number for demo
    val pickupNumber = remember { (100..999).random() }
    val stallNumber = remember { (1..12).random() }
    
    // Confetti/Animation effect state if we wanted to be fancy
    
    Box(modifier = Modifier.fillMaxSize()) {
        CarbonBackground()
        
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            
            // Ticket Card
            Card(
                colors = CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
                shape = RoundedCornerShape(16.dp),
                modifier = Modifier
                    .fillMaxWidth()
                    .border(1.dp, Color(0xFF22C55E).copy(alpha = 0.5f), RoundedCornerShape(16.dp))
                    .padding(bottom = 32.dp)
            ) {
                Column(
                    modifier = Modifier.padding(24.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    // Accent dot + title
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Box(
                            modifier = Modifier
                                .size(10.dp)
                                .clip(CircleShape)
                                .background(Color(0xFF22C55E))
                        )
                        Spacer(modifier = Modifier.width(10.dp))
                        Text(
                            text = "ORDER CONFIRMED",
                            style = MaterialTheme.typography.titleLarge.copy(
                                fontWeight = FontWeight.Black,
                                letterSpacing = 1.5.sp
                            ),
                            color = Color(0xFF22C55E)
                        )
                    }
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = "READY FOR PICKUP IN 10 MIN",
                        style = MaterialTheme.typography.labelSmall.copy(letterSpacing = 1.5.sp),
                        color = Color(0xFF64748B),
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(32.dp))
                    
                    // QR Code Simulation (Procedural Drawing)
                    Box(
                        modifier = Modifier
                            .size(200.dp)
                            .border(4.dp, Color(0xFFF8FAFC), RoundedCornerShape(8.dp))
                            .background(Color(0xFFF8FAFC), RoundedCornerShape(8.dp))
                            .padding(8.dp)
                    ) {
                        FakeQrCanvas()
                    }
                    
                    Spacer(modifier = Modifier.height(24.dp))
                    
                    Text(
                        text = "ORDER #$orderId",
                        style = MaterialTheme.typography.bodyMedium.copy(
                            fontFamily = androidx.compose.ui.text.font.FontFamily.Monospace,
                            letterSpacing = 1.sp
                        ),
                        color = Color(0xFFF8FAFC),
                        fontWeight = FontWeight.Bold
                    )
                    
                    HorizontalDivider(
                        modifier = Modifier.padding(vertical = 16.dp),
                        color = Color(0xFF64748B).copy(alpha = 0.3f)
                    )
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                         Column(horizontalAlignment = Alignment.CenterHorizontally) {
                             Text(
                                 "PICKUP AT",
                                 style = MaterialTheme.typography.labelSmall.copy(letterSpacing = 1.5.sp),
                                 color = Color(0xFF64748B),
                                 fontWeight = FontWeight.Bold
                             )
                             Text(
                                 "STALL $stallNumber",
                                 style = MaterialTheme.typography.titleLarge,
                                 fontWeight = FontWeight.ExtraBold,
                                 color = Color(0xFFF8FAFC)
                             )
                         }
                         Column(horizontalAlignment = Alignment.CenterHorizontally) {
                             Text(
                                 "YOUR NUMBER",
                                 style = MaterialTheme.typography.labelSmall.copy(letterSpacing = 1.5.sp),
                                 color = Color(0xFF64748B),
                                 fontWeight = FontWeight.Bold
                             )
                             Text(
                                 "#$pickupNumber",
                                 style = MaterialTheme.typography.titleLarge,
                                 fontWeight = FontWeight.Black,
                                 color = Color(0xFFE8253A)
                             )
                         }
                    }
                }
            }
            
            Button(
                onClick = { 
                    // Clear stack back to Home or Orders
                    navController.navigate(com.georacing.georacing.ui.navigation.Screen.Home.route) {
                        popUpTo(com.georacing.georacing.ui.navigation.Screen.Home.route) { inclusive = true }
                    }
                },
                colors = ButtonDefaults.buttonColors(containerColor = Color(0xFFE8253A)),
                modifier = Modifier.fillMaxWidth().height(56.dp),
                shape = RoundedCornerShape(12.dp)
            ) {
                Text(
                    "VOLVER AL PADDOCK",
                    fontWeight = FontWeight.ExtraBold,
                    letterSpacing = 1.sp,
                    color = Color(0xFFF8FAFC)
                )
            }
        }
    }
}

@Composable
fun FakeQrCanvas() {
    Canvas(modifier = Modifier.fillMaxSize()) {
        val cellSize = size.width / 25
        val matrixSize = 25
        
        val qrDark = Color(0xFF080810)
        val qrLight = Color(0xFFF8FAFC)
        
        // Draw Finder Patterns (Corners)
        drawRect(qrDark, topLeft = Offset(0f, 0f), size = Size(cellSize * 7, cellSize * 7))
        drawRect(qrLight, topLeft = Offset(cellSize, cellSize), size = Size(cellSize * 5, cellSize * 5))
        drawRect(qrDark, topLeft = Offset(cellSize * 2, cellSize * 2), size = Size(cellSize * 3, cellSize * 3))

        drawRect(qrDark, topLeft = Offset(size.width - cellSize * 7, 0f), size = Size(cellSize * 7, cellSize * 7))
        drawRect(qrLight, topLeft = Offset(size.width - cellSize * 6, cellSize), size = Size(cellSize * 5, cellSize * 5))
        drawRect(qrDark, topLeft = Offset(size.width - cellSize * 5, cellSize * 2), size = Size(cellSize * 3, cellSize * 3))

        drawRect(qrDark, topLeft = Offset(0f, size.height - cellSize * 7), size = Size(cellSize * 7, cellSize * 7))
        drawRect(qrLight, topLeft = Offset(cellSize, size.height - cellSize * 6), size = Size(cellSize * 5, cellSize * 5))
        drawRect(qrDark, topLeft = Offset(cellSize * 2, size.height - cellSize * 5), size = Size(cellSize * 3, cellSize * 3))

        // Random Data Noise
        for (i in 0 until matrixSize) {
            for (j in 0 until matrixSize) {
                // Avoid Finder Patterns areas
                val inTopLeft = i < 8 && j < 8
                val inTopRight = i > 16 && j < 8
                val inBottomLeft = i < 8 && j > 16
                
                if (!inTopLeft && !inTopRight && !inBottomLeft) {
                    if ((i + j * 3).hashCode() % 2 == 0) {
                        drawRect(
                            color = qrDark,
                            topLeft = Offset(i * cellSize, j * cellSize),
                            size = Size(cellSize, cellSize)
                        )
                    }
                }
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/orders/OrdersScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.orders

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.navigationBarsPadding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Remove
import androidx.compose.material.icons.filled.ShoppingCart
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.Receipt
import androidx.compose.material3.*
import androidx.compose.material3.pulltorefresh.PullToRefreshBox
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.data.billing.BillingManager
import com.georacing.georacing.data.billing.FakePaymentProcessor
import com.georacing.georacing.data.billing.PaymentResult
import com.georacing.georacing.ui.components.background.CarbonBackground
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import com.georacing.georacing.ui.theme.*
import com.georacing.georacing.data.orders.OrdersRepositoryImpl
import com.georacing.georacing.domain.orders.OrderLine
import com.google.firebase.auth.FirebaseAuth
import kotlinx.coroutines.launch

data class Product(
    val id: String,
    val name: String,
    val price: Double,
    val category: String,
    val iconEmoji: String,
    val isAvailable: Boolean = true
)

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun OrdersScreen(navController: NavController) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    
    // Dynamic Products State
    var products by remember { mutableStateOf<List<Product>>(emptyList()) }
    // ... [existing fetching logic] ...
    
    // Fetch Products from Backend
    LaunchedEffect(Unit) {
        kotlinx.coroutines.GlobalScope.launch(kotlinx.coroutines.Dispatchers.IO) {
            try {
                val api = com.georacing.georacing.data.firestorelike.FirestoreLikeClient.api
                val rawProducts = api.get(com.georacing.georacing.data.firestorelike.FirestoreLikeApi.GetRequest(table = "products", where = null))
                
                val fetched = rawProducts.mapNotNull { it ->
                    try {
                        Product(
                            id = it["id"] as? String ?: return@mapNotNull null,
                            name = it["name"] as? String ?: "Producto",
                            price = (it["price"] as? Number)?.toDouble() ?: 0.0,
                            category = it["category"] as? String ?: "General",
                            iconEmoji = it["emoji"] as? String ?: "üì¶",
                            isAvailable = when(val stock = it["in_stock"]) {
                                is Boolean -> stock
                                is Number -> stock.toInt() == 1
                                else -> true 
                            }
                        )
                    } catch(e: Exception) { null }
                }
                
                // Update UI on Main Thread
                kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.Main) {
                    products = fetched
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
    
    var cart by remember { mutableStateOf(mutableMapOf<String, Int>()) }
    val total = cart.entries.sumOf { (id, qty) ->
        products.find { it.id == id }?.price?.times(qty) ?: 0.0
    }

    // Billing Integration (Kept for reference but bypassed for Demo)
    val billingResult by BillingManager.billingFlowResult.collectAsState()
    val purchases by BillingManager.purchases.collectAsState()
    
    // Payment State
    var isProcessingPayment by remember { mutableStateOf(false) }
    var processingMessage by remember { mutableStateOf("Conectando con banco...") }

    // Repository
    val repository = remember { OrdersRepositoryImpl() }
    val userUid = remember { FirebaseAuth.getInstance().currentUser?.uid ?: "anonymous" }

    // Function to process payment
    fun processCheckout() {
        scope.launch {
            isProcessingPayment = true
            FakePaymentProcessor.processPayment(total).collect { result ->
                when (result) {
                     is PaymentResult.Processing -> {
                         processingMessage = "Procesando pago..."
                     }
                     is PaymentResult.Success -> {
                         processingMessage = "¬°Pago Completado!"
                         // Create Order locally
                         val currentCart = cart.toMap()
                         val orderLines = currentCart.mapNotNull { (id, qty) ->
                            val product = products.find { it.id == id }
                            if (product != null) {
                                OrderLine(product.id, qty, product.price)
                            } else null
                         }
                         
                         val orderId = java.util.UUID.randomUUID().toString()
                         // Fire and forget save (demo)
                         launch {
                             repository.createOrder(
                                 userUid = userUid,
                                 items = orderLines,
                                 totalAmount = total,
                                 paymentToken = "DEMO_TOKEN_$orderId"
                             )
                         }
                         
                         cart.clear()
                         isProcessingPayment = false
                         // Navigate to Confirmation
                         navController.navigate("order_confirmation/$orderId")
                     }
                     is PaymentResult.Error -> {
                         isProcessingPayment = false
                         // Show error snackbar logic here if needed
                     }
                     else -> {}
                }
            }
        }
    }

    // Old Billing LaunchedEffect removed as we use FakeProcessor for Demo
    
    Box(modifier = Modifier.fillMaxSize()) {
        OrdersScreenContent(
            products = products,
            cart = cart,
            total = total,
            onAddProduct = { product -> cart = cart.toMutableMap().apply { this[product.id] = (this[product.id] ?: 0) + 1 } },
            onRemoveProduct = { product -> 
                cart = cart.toMutableMap().apply { 
                    val currentQty = this[product.id] ?: 0
                    if (currentQty > 1) this[product.id] = currentQty - 1 else remove(product.id) 
                } 
            },
            onCheckout = { processCheckout() },
            onNavigateBack = { navController.navigateUp() },
            onNavigateMyOrders = { navController.navigate(com.georacing.georacing.ui.navigation.Screen.MyOrders.route) },
            showSuccessDialog = false, // We use navigation now
            onDismissSuccessDialog = { } 
        )
        
        // Processing Overlay
        if (isProcessingPayment) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(Color(0xFF080810).copy(alpha = 0.9f))
                    .clickable(enabled = false) {}, // content blocker
                contentAlignment = Alignment.Center
            ) {
                 Column(horizontalAlignment = Alignment.CenterHorizontally) {
                     CircularProgressIndicator(color = Color(0xFFE8253A), modifier = Modifier.size(48.dp))
                     Spacer(modifier = Modifier.height(24.dp))
                     Text(
                         text = processingMessage,
                         style = MaterialTheme.typography.titleMedium,
                         color = Color(0xFFF8FAFC),
                         fontWeight = FontWeight.ExtraBold,
                         letterSpacing = 1.sp
                     )
                 }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun OrdersScreenContent(
    products: List<Product>,
    cart: Map<String, Int>,
    total: Double,
    onAddProduct: (Product) -> Unit,
    onRemoveProduct: (Product) -> Unit,
    onCheckout: () -> Unit,
    onNavigateBack: () -> Unit,
    onNavigateMyOrders: () -> Unit,
    showSuccessDialog: Boolean,
    onDismissSuccessDialog: () -> Unit
) {
    Box(modifier = Modifier.fillMaxSize()) {
        CarbonBackground()
        
        Scaffold(
            topBar = {
                // Custom Glass Top Bar
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                        .glassSmall(shape = RoundedCornerShape(16.dp))
                        .padding(horizontal = 16.dp, vertical = 12.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        IconButton(onClick = onNavigateBack) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Atr√°s", tint = Color(0xFFF8FAFC))
                        }
                        
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            Box(
                                modifier = Modifier
                                    .size(8.dp)
                                    .clip(CircleShape)
                                    .background(Color(0xFFE8253A))
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                text = "PEDIDOS EXPRESS",
                                style = MaterialTheme.typography.titleMedium.copy(
                                    fontWeight = FontWeight.ExtraBold,
                                    letterSpacing = 1.5.sp
                                ),
                                color = Color(0xFFF8FAFC)
                            )
                        }
                        
                        IconButton(onClick = onNavigateMyOrders) {
                             Icon(androidx.compose.material.icons.Icons.Default.Receipt, "Mis Pedidos", tint = Color(0xFFF8FAFC))
                        }
                    }
                }
            },
            containerColor = Color.Transparent,
            bottomBar = {
                if (cart.isNotEmpty()) {
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                            .navigationBarsPadding() // Proper inset handling
                            .liquidGlass(shape = RoundedCornerShape(24.dp), level = GlassLevel.L2)
                            .padding(20.dp)
                    ) {
                        Row(
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            Column {
                                Text(
                                    text = "TOTAL A PAGAR",
                                    style = MaterialTheme.typography.labelMedium,
                                    color = Color(0xFF64748B),
                                    letterSpacing = 1.5.sp,
                                    fontWeight = FontWeight.Bold
                                )
                                Text(
                                    text = "‚Ç¨%.2f".format(total),
                                    style = MaterialTheme.typography.headlineMedium,
                                    fontWeight = FontWeight.Black,
                                    color = Color(0xFF22C55E)
                                )
                            }
                            
                            Button(
                                onClick = onCheckout,
                                colors = ButtonDefaults.buttonColors(
                                    containerColor = Color(0xFFE8253A)
                                ),
                                shape = RoundedCornerShape(12.dp),
                                modifier = Modifier.height(56.dp)
                            ) {
                                Icon(Icons.Default.ShoppingCart, contentDescription = "Carrito de compras", tint = Color(0xFFF8FAFC))
                                Spacer(modifier = Modifier.width(8.dp))
                                Text("PAGAR", fontWeight = FontWeight.ExtraBold, letterSpacing = 1.sp, color = Color(0xFFF8FAFC))
                            }
                        }
                    }
                }
            }
        ) { padding ->
            var isRefreshing by remember { mutableStateOf(false) }
            val refreshScope = rememberCoroutineScope()
            PullToRefreshBox(
                isRefreshing = isRefreshing,
                onRefresh = {
                    isRefreshing = true
                    refreshScope.launch { delay(1500); isRefreshing = false }
                },
                modifier = Modifier.fillMaxSize().padding(padding)
            ) {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(horizontal = 16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp),
                contentPadding = PaddingValues(bottom = 16.dp) // Content padding
            ) {
                 item {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.padding(vertical = 8.dp)
                    ) {
                        Box(
                            modifier = Modifier
                                .size(8.dp)
                                .clip(CircleShape)
                                .background(Color(0xFFE8253A))
                        )
                        Spacer(modifier = Modifier.width(10.dp))
                        Text(
                            text = "TU MEN√ö",
                            style = MaterialTheme.typography.headlineSmall.copy(
                                fontWeight = FontWeight.ExtraBold,
                                letterSpacing = 1.5.sp
                            ),
                            color = Color(0xFFF8FAFC)
                        )
                    }
                }
                
                items(products) { product ->
                    val qty = cart[product.id] ?: 0
                    ProductGlassCard(
                        product = product,
                        quantity = qty,
                        onAdd = { onAddProduct(product) },
                        onRemove = { onRemoveProduct(product) }

                    )
                }
            }
        }
        
        // Success Dialog
        if (showSuccessDialog) {
             AlertDialog(
                onDismissRequest = onDismissSuccessDialog,
                containerColor = Color(0xFF14141C),
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Icon(Icons.Default.CheckCircle, contentDescription = "Pedido confirmado", tint = Color(0xFF22C55E), modifier = Modifier.size(32.dp))
                        Spacer(modifier = Modifier.width(12.dp))
                        Text(
                            "¬°Pedido Realizado!",
                            color = Color(0xFFF8FAFC),
                            fontWeight = FontWeight.ExtraBold
                        )
                    }
                },
                text = {
                    Text(
                        "Tu pedido se ha enviado a cocina. Recibir√°s una notificaci√≥n cuando est√© listo.",
                        color = Color(0xFF64748B)
                    )
                },
                confirmButton = {
                    TextButton(onClick = onDismissSuccessDialog) {
                        Text("ENTENDIDO", color = Color(0xFFE8253A), fontWeight = FontWeight.ExtraBold, letterSpacing = 1.sp)
                    }
                },
                modifier = Modifier.border(1.dp, Color(0xFF22C55E), RoundedCornerShape(24.dp))
            )
        }
        }
    }
}

@androidx.compose.ui.tooling.preview.Preview(showBackground = true)
@Composable
fun OrdersScreenPreview() {
    val dummyProducts = listOf(
        Product("1", "Hamburguesa Geo", 12.50, "Food", "üçî", true),
        Product("2", "Cola Zero", 3.00, "Drink", "ü•§", true),
        Product("3", "Papas Fritas", 4.50, "Side", "üçü", false)
    )
    val dummyCart = mapOf("1" to 2, "2" to 1)
    
    GeoRacingTheme {
        OrdersScreenContent(
            products = dummyProducts,
            cart = dummyCart,
            total = 28.0,
            onAddProduct = {},
            onRemoveProduct = {},
            onCheckout = {},
            onNavigateBack = {},
            onNavigateMyOrders = {},
            showSuccessDialog = false,
            onDismissSuccessDialog = {}
        )
    }
}

@Composable
fun ProductGlassCard(
    product: Product,
    quantity: Int,
    onAdd: () -> Unit,
    onRemove: () -> Unit
) {
    val isAvailable = product.isAvailable
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .liquidGlass(shape = RoundedCornerShape(20.dp))
            .padding(16.dp)
            .alpha(if (isAvailable) 1f else 0.5f)
    ) {
        Row(
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween,
            modifier = Modifier.fillMaxWidth()
        ) {
            // Icon & Info
            Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.weight(1f)) {
                Box(
                    modifier = Modifier
                        .size(48.dp)
                        .clip(RoundedCornerShape(12.dp))
                        .background(if (isAvailable) Color(0xFFF8FAFC).copy(alpha = 0.1f) else Color(0xFFEF4444).copy(alpha = 0.1f)),
                    contentAlignment = Alignment.Center
                ) {
                    Text(product.iconEmoji, fontSize = 24.sp, modifier = Modifier.then(if(!isAvailable) Modifier.alpha(0.5f) else Modifier))
                }
                
                Spacer(modifier = Modifier.width(16.dp))
                
                Column {
                    Text(
                        text = product.name,
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.ExtraBold,
                        color = if (isAvailable) Color(0xFFF8FAFC) else Color(0xFF64748B)
                    )
                    if (isAvailable) {
                        Text(
                            text = "‚Ç¨%.2f".format(product.price),
                            style = MaterialTheme.typography.bodyMedium,
                            color = Color(0xFFE8253A),
                            fontWeight = FontWeight.Bold
                        )
                    } else {
                        Text(
                            text = "AGOTADO",
                            style = MaterialTheme.typography.bodyMedium.copy(letterSpacing = 1.5.sp),
                            color = Color(0xFFEF4444),
                            fontWeight = FontWeight.Black
                        )
                    }
                }
            }
            
            // Controls
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                 if (quantity > 0) {
                    IconButton(
                        onClick = onRemove,
                        modifier = Modifier
                            .size(32.dp)
                            .border(1.dp, Color(0xFF64748B), CircleShape)
                    ) {
                        Icon(Icons.Default.Remove, contentDescription = "Quitar uno", tint = Color(0xFFF8FAFC), modifier = Modifier.size(16.dp))
                    }
                    
                    Text(
                        text = "$quantity",
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.ExtraBold,
                        color = Color(0xFFF8FAFC)
                    )
                 }
                
                IconButton(
                    onClick = { if (isAvailable) onAdd() },
                    enabled = isAvailable,
                    modifier = Modifier
                        .size(32.dp)
                        .background(if (isAvailable) Color(0xFFE8253A) else Color(0xFF64748B), CircleShape)
                ) {
                    Icon(Icons.Default.Add, contentDescription = "A√±adir uno", tint = Color(0xFFF8FAFC), modifier = Modifier.size(16.dp))
                }
            }
        }
    }
}




```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/parking/ParkingScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.parking

import android.annotation.SuppressLint
import android.content.Intent
import android.net.Uri
import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.draw.drawWithContent
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.compose.ui.window.DialogProperties
import androidx.navigation.NavController
import com.georacing.georacing.data.parking.ParkingLocation
import com.georacing.georacing.data.parking.ParkingRepository
import com.georacing.georacing.ui.components.GlassCard
import com.georacing.georacing.ui.components.HomeIconButton
import com.georacing.georacing.ui.components.RacingButton
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.*
import com.google.android.gms.location.LocationServices
import com.google.android.gms.location.Priority
import com.google.android.gms.tasks.CancellationTokenSource
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import java.text.SimpleDateFormat
import java.util.*

@Composable
fun ParkingScreen(
    navController: NavController,
    parkingRepository: ParkingRepository? = null
) {
    val backdrop = LocalBackdrop.current
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val repo = remember { parkingRepository ?: ParkingRepository(context) }
    val parkingLocation by repo.parkingLocation.collectAsState(initial = null)

    var isSaving by remember { mutableStateOf(false) }
    var saveError by remember { mutableStateOf<String?>(null) }
    var screenVisible by remember { mutableStateOf(false) }
    LaunchedEffect(Unit) { screenVisible = true }

    Box(modifier = Modifier.fillMaxSize()) {
        CarbonBackground()

        Column(modifier = Modifier.fillMaxSize()) {
            // ‚îÄ‚îÄ Glass Top Bar ‚îÄ‚îÄ
            LiquidTopBar(
                backdrop = backdrop,
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Atr√°s", tint = TextPrimary)
                    }
                },
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Box(
                            modifier = Modifier
                                .size(8.dp)
                                .clip(CircleShape)
                                .background(AccentParking)
                        )
                        Spacer(Modifier.width(10.dp))
                        Text(
                            "MI COCHE",
                            color = TextPrimary,
                            fontSize = 16.sp,
                            fontWeight = FontWeight.ExtraBold,
                            letterSpacing = 2.sp
                        )
                    }
                },
                actions = {
                    HomeIconButton {
                        navController.navigate(Screen.Home.route) {
                            popUpTo(Screen.Home.route) { inclusive = true }
                        }
                    }
                }
            )

            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(horizontal = 20.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Spacer(Modifier.height(24.dp))

                AnimatedVisibility(
                    visible = screenVisible,
                    enter = fadeIn(tween(600)) + scaleIn(tween(600), initialScale = 0.9f)
                ) {
                    if (parkingLocation != null) {
                        PremiumParkingCard(
                            location = parkingLocation!!,
                            onNavigate = {
                                val gmmIntentUri = Uri.parse(
                                    "google.navigation:q=${parkingLocation!!.latitude},${parkingLocation!!.longitude}&mode=w"
                                )
                                val mapIntent = Intent(Intent.ACTION_VIEW, gmmIntentUri)
                                mapIntent.setPackage("com.google.android.apps.maps")
                                if (mapIntent.resolveActivity(context.packageManager) != null) {
                                    context.startActivity(mapIntent)
                                } else {
                                    context.startActivity(Intent(
                                        Intent.ACTION_VIEW,
                                        Uri.parse("https://www.google.com/maps/dir/?api=1&destination=${parkingLocation!!.latitude},${parkingLocation!!.longitude}&travelmode=walking")
                                    ))
                                }
                            },
                            onClear = { scope.launch { repo.clearParking() } }
                        )
                    } else {
                        PremiumNoParkingCard(
                            isSaving = isSaving,
                            error = saveError,
                            onSaveLocation = {
                                scope.launch {
                                    isSaving = true
                                    saveError = null
                                    try {
                                        val location = getCurrentLocation(context)
                                        if (location != null) {
                                            repo.saveParkingLocation(
                                                ParkingLocation(location.first, location.second, System.currentTimeMillis(), null)
                                            )
                                        } else {
                                            saveError = "No se pudo obtener la ubicaci√≥n. Verifica los permisos GPS."
                                        }
                                    } catch (e: Exception) {
                                        saveError = "Error: ${e.message}"
                                    }
                                    isSaving = false
                                }
                            }
                        )
                    }
                }

                Spacer(Modifier.height(24.dp))

                // Info card
                AnimatedVisibility(
                    visible = screenVisible,
                    enter = fadeIn(tween(800, 200)) + slideInVertically(tween(800, 200)) { it / 3 }
                ) {
                    GlassCard(
                        modifier = Modifier.fillMaxWidth(),
                        accentColor = NeonCyan
                    ) {
                        Text(
                            "C√ìMO FUNCIONA",
                            fontSize = 10.sp,
                            fontWeight = FontWeight.ExtraBold,
                            letterSpacing = 2.sp,
                            color = TextTertiary
                        )
                        Spacer(Modifier.height(10.dp))
                        val tips = listOf(
                            "Al desconectar Android Auto, se preguntar√° si guardar la ubicaci√≥n",
                            "Tambi√©n puedes guardar manualmente desde esta pantalla",
                            "Toca \"Navegar al coche\" para que Maps te gu√≠e de vuelta"
                        )
                        tips.forEach { tip ->
                            Row(modifier = Modifier.padding(vertical = 3.dp)) {
                                Box(
                                    modifier = Modifier
                                        .padding(top = 6.dp)
                                        .size(4.dp)
                                        .clip(CircleShape)
                                        .background(NeonCyan)
                                )
                                Spacer(Modifier.width(10.dp))
                                Text(tip, fontSize = 12.sp, color = TextSecondary, lineHeight = 18.sp)
                            }
                        }
                    }
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Premium Parking Location Card
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumParkingCard(
    location: ParkingLocation,
    onNavigate: () -> Unit,
    onClear: () -> Unit
) {
    val timeAgo = remember(location.timestamp) { getRelativeTimeString(location.timestamp) }
    var showDeleteConfirm by remember { mutableStateOf(false) }

    // Pulse animation for car circle
    val infiniteTransition = rememberInfiniteTransition(label = "car_pulse")
    val pulseScale by infiniteTransition.animateFloat(
        initialValue = 0.95f, targetValue = 1.05f,
        animationSpec = infiniteRepeatable(tween(2000, easing = EaseInOutCubic), RepeatMode.Reverse),
        label = "pulse"
    )

    GlassCard(
        modifier = Modifier.fillMaxWidth(),
        accentColor = StatusGreen
    ) {
        Column(
            modifier = Modifier.fillMaxWidth(),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Car icon with glow
            Box(
                modifier = Modifier
                    .size(100.dp)
                    .graphicsLayer { scaleX = pulseScale; scaleY = pulseScale }
                    .drawBehind {
                        drawCircle(
                            brush = Brush.radialGradient(
                                listOf(StatusGreen.copy(alpha = 0.15f), Color.Transparent)
                            ),
                            radius = size.width
                        )
                    }
                    .clip(CircleShape)
                    .background(
                        Brush.radialGradient(
                            listOf(StatusGreen.copy(alpha = 0.2f), CarbonBlack)
                        )
                    )
                    .border(1.dp, StatusGreen.copy(alpha = 0.3f), CircleShape),
                contentAlignment = Alignment.Center
            ) {
                Icon(Icons.Default.DirectionsCar, "Coche", tint = StatusGreen, modifier = Modifier.size(42.dp))
            }

            Spacer(Modifier.height(16.dp))

            Text(
                "COCHE APARCADO",
                fontSize = 18.sp,
                fontWeight = FontWeight.ExtraBold,
                letterSpacing = 2.sp,
                color = StatusGreen
            )

            Spacer(Modifier.height(8.dp))

            Row(verticalAlignment = Alignment.CenterVertically) {
                Icon(Icons.Default.LocationOn, null, tint = TextTertiary, modifier = Modifier.size(14.dp))
                Spacer(Modifier.width(4.dp))
                Text(
                    "${String.format("%.5f", location.latitude)}, ${String.format("%.5f", location.longitude)}",
                    fontSize = 11.sp, color = TextTertiary
                )
            }
            Text("Guardado $timeAgo", fontSize = 10.sp, color = TextTertiary.copy(alpha = 0.6f), modifier = Modifier.padding(top = 2.dp))

            Spacer(Modifier.height(20.dp))

            // Navigate button
            RacingButton(
                text = "NAVEGAR AL COCHE",
                onClick = onNavigate,
                icon = Icons.Default.Navigation,
                color = StatusGreen
            )

            Spacer(Modifier.height(10.dp))

            // Clear button
            Box(
                modifier = Modifier
                    .clip(RoundedCornerShape(10.dp))
                    .clickable { showDeleteConfirm = true }
                    .padding(horizontal = 16.dp, vertical = 8.dp),
                contentAlignment = Alignment.Center
            ) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Icon(Icons.Default.Delete, null, tint = StatusRed.copy(alpha = 0.6f), modifier = Modifier.size(16.dp))
                    Spacer(Modifier.width(6.dp))
                    Text("Borrar ubicaci√≥n", fontSize = 12.sp, color = StatusRed.copy(alpha = 0.6f))
                }
            }
        }
    }

    if (showDeleteConfirm) {
        PremiumDeleteDialog(
            onConfirm = { showDeleteConfirm = false; onClear() },
            onDismiss = { showDeleteConfirm = false }
        )
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Premium No Parking Card
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumNoParkingCard(
    isSaving: Boolean,
    error: String?,
    onSaveLocation: () -> Unit
) {
    GlassCard(modifier = Modifier.fillMaxWidth()) {
        Column(
            modifier = Modifier.fillMaxWidth(),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Empty state icon
            Box(
                modifier = Modifier
                    .size(100.dp)
                    .clip(CircleShape)
                    .background(MetalGrey.copy(alpha = 0.3f))
                    .border(0.5.dp, Color.White.copy(alpha = 0.08f), CircleShape),
                contentAlignment = Alignment.Center
            ) {
                Icon(Icons.Default.LocalParking, null, tint = TextTertiary, modifier = Modifier.size(42.dp))
            }

            Spacer(Modifier.height(16.dp))

            Text(
                "SIN UBICACI√ìN",
                fontSize = 18.sp,
                fontWeight = FontWeight.ExtraBold,
                letterSpacing = 2.sp,
                color = TextPrimary
            )

            Spacer(Modifier.height(8.dp))

            Text(
                "Guarda la ubicaci√≥n de tu coche para no perderlo en el circuito.",
                fontSize = 13.sp,
                color = TextTertiary,
                textAlign = TextAlign.Center,
                lineHeight = 18.sp
            )

            if (error != null) {
                Spacer(Modifier.height(10.dp))
                Text(error, fontSize = 11.sp, color = StatusRed)
            }

            Spacer(Modifier.height(20.dp))

            RacingButton(
                text = if (isSaving) "GUARDANDO..." else "GUARDAR UBICACI√ìN ACTUAL",
                onClick = onSaveLocation,
                icon = Icons.Default.LocationOn,
                enabled = !isSaving
            )
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Premium Delete Dialog
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumDeleteDialog(
    onConfirm: () -> Unit,
    onDismiss: () -> Unit
) {
    var dialogVisible by remember { mutableStateOf(false) }
    LaunchedEffect(Unit) { dialogVisible = true }

    val dialogAlpha by animateFloatAsState(
        targetValue = if (dialogVisible) 1f else 0f,
        animationSpec = tween(250),
        label = "del_alpha"
    )

    Dialog(
        onDismissRequest = onDismiss,
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black.copy(alpha = 0.6f))
                .clickable(
                    interactionSource = remember { MutableInteractionSource() },
                    indication = null,
                    onClick = onDismiss
                ),
            contentAlignment = Alignment.Center
        ) {
            Box(
                modifier = Modifier
                    .fillMaxWidth(0.85f)
                    .graphicsLayer { alpha = dialogAlpha }
                    .clip(RoundedCornerShape(20.dp))
                    .background(
                        Brush.verticalGradient(listOf(Color(0xFF1A1A24), Color(0xFF12121A))),
                        RoundedCornerShape(20.dp)
                    )
                    .border(0.5.dp, StatusRed.copy(alpha = 0.2f), RoundedCornerShape(20.dp))
                    .drawWithContent {
                        drawContent()
                        drawRect(
                            Brush.verticalGradient(
                                listOf(Color.White.copy(alpha = 0.03f), Color.Transparent),
                                startY = 0f, endY = size.height * 0.3f
                            )
                        )
                    }
                    .clickable(
                        interactionSource = remember { MutableInteractionSource() },
                        indication = null, onClick = {}
                    )
                    .padding(24.dp)
            ) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    Text("¬øBorrar ubicaci√≥n?", fontSize = 18.sp, fontWeight = FontWeight.ExtraBold, color = TextPrimary)
                    Spacer(Modifier.height(10.dp))
                    Text(
                        "Se eliminar√° la ubicaci√≥n guardada de tu coche. No podr√°s navegar de vuelta.",
                        fontSize = 13.sp, color = TextTertiary, textAlign = TextAlign.Center
                    )
                    Spacer(Modifier.height(20.dp))
                    Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                        Box(
                            modifier = Modifier
                                .weight(1f)
                                .clip(RoundedCornerShape(10.dp))
                                .background(MetalGrey.copy(alpha = 0.5f))
                                .clickable(onClick = onDismiss)
                                .padding(vertical = 12.dp),
                            contentAlignment = Alignment.Center
                        ) {
                            Text("CANCELAR", fontSize = 12.sp, fontWeight = FontWeight.ExtraBold, letterSpacing = 1.sp, color = TextTertiary)
                        }
                        Box(
                            modifier = Modifier
                                .weight(1f)
                                .clip(RoundedCornerShape(10.dp))
                                .background(StatusRed.copy(alpha = 0.2f))
                                .border(0.5.dp, StatusRed.copy(alpha = 0.3f), RoundedCornerShape(10.dp))
                                .clickable(onClick = onConfirm)
                                .padding(vertical = 12.dp),
                            contentAlignment = Alignment.Center
                        ) {
                            Text("BORRAR", fontSize = 12.sp, fontWeight = FontWeight.ExtraBold, letterSpacing = 1.sp, color = StatusRed)
                        }
                    }
                }
            }
        }
    }
}

@SuppressLint("MissingPermission")
private suspend fun getCurrentLocation(context: android.content.Context): Pair<Double, Double>? {
    return try {
        val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
        if (androidx.core.content.ContextCompat.checkSelfPermission(
                context, android.Manifest.permission.ACCESS_FINE_LOCATION
            ) != android.content.pm.PackageManager.PERMISSION_GRANTED
        ) return null

        val location = fusedLocationClient.getCurrentLocation(
            Priority.PRIORITY_HIGH_ACCURACY,
            CancellationTokenSource().token
        ).await()

        if (location != null) {
            Pair(location.latitude, location.longitude)
        } else {
            val lastLocation = fusedLocationClient.lastLocation.await()
            lastLocation?.let { Pair(it.latitude, it.longitude) }
        }
    } catch (e: Exception) { null }
}

private fun getRelativeTimeString(timestamp: Long): String {
    val diff = System.currentTimeMillis() - timestamp
    return when {
        diff < 60_000 -> "hace un momento"
        diff < 3600_000 -> "hace ${diff / 60_000} min"
        diff < 86400_000 -> "hace ${diff / 3600_000} hora(s)"
        else -> SimpleDateFormat("dd/MM HH:mm", Locale.getDefault()).format(Date(timestamp))
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/poi/PoiListScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.poi

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.pulltorefresh.PullToRefreshBox
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.runtime.rememberCoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import androidx.compose.foundation.layout.statusBarsPadding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.material.icons.filled.Schedule
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.FilterChip
import androidx.compose.material3.FilterChipDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import androidx.navigation.NavController
import com.georacing.georacing.domain.repository.PoiRepository
import com.georacing.georacing.domain.model.Poi
import com.georacing.georacing.domain.model.PoiType

import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LiquidPill
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.kyant.backdrop.Backdrop

// Racing Dark Theme Colors
private val RacingAccent = Color(0xFF06B6D4)    // NeonCyan
private val SearchBarBg = Color(0xFF14141C)       // Dark surface
private val SearchBarText = Color(0xFFF8FAFC)     // Light text
private val ChipBg = Color(0xFF14141C)            // Dark surface
private val ChipBgSelected = Color(0xFF14141C).copy(alpha = 0.8f)
private val ChipText = Color(0xFFF8FAFC)          // Light text
private val SubtleGray = Color(0xFF64748B)        // Slate

// Category data with emojis
data class PoiCategoryChip(
    val emoji: String,
    val label: String,
    val type: PoiType?
)

private val poiCategoryChips = listOf(
    PoiCategoryChip("üöª", "Ba√±os", PoiType.WC),
    PoiCategoryChip("üçî", "Comida", PoiType.FOOD),
    PoiCategoryChip("üëï", "Merch", PoiType.MERCH),
    PoiCategoryChip("üéüÔ∏è", "Accesos", PoiType.GATE),
    PoiCategoryChip("üÖøÔ∏è", "Parking", PoiType.PARKING),
    PoiCategoryChip("üéä", "Fan Zone", PoiType.FANZONE)
)

// Helper function to get emoji for POI type
private fun getEmojiForType(type: PoiType): String {
    return when (type) {
        PoiType.WC -> "üöª"
        PoiType.FOOD -> "üçî"
        PoiType.MERCH -> "üëï"
        PoiType.GATE -> "üéüÔ∏è"
        PoiType.ACCESS -> "üéüÔ∏è"
        PoiType.PARKING -> "üÖøÔ∏è"
        PoiType.FANZONE -> "üéä"
        PoiType.SERVICE -> "üîß"
        PoiType.EXIT -> "üö™"
        PoiType.OTHER -> "üìç"
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PoiListScreen(
    navController: NavController,
    poiRepository: PoiRepository
) {
    val viewModel: PoiViewModel = viewModel(
        factory = viewModelFactory {
            initializer {
                PoiViewModel(poiRepository)
            }
        }
    )

    val pois by viewModel.visiblePois.collectAsState()
    val selectedType by viewModel.selectedType.collectAsState()
    val backdrop = LocalBackdrop.current

    Box(modifier = Modifier.fillMaxSize()) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .background(Color(0xFF080810))
        ) {
            // Add top padding for status bar + floating pill
            Spacer(modifier = Modifier.statusBarsPadding())
            Spacer(modifier = Modifier.height(72.dp))
            
            // Filter Chips
            LazyRow(
                contentPadding = PaddingValues(horizontal = 16.dp, vertical = 12.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                item {
                    LiquidPill(
                        backdrop = backdrop,
                        modifier = Modifier.clickable { viewModel.filterByType(null) },
                        surfaceColor = if (selectedType == null) RacingAccent.copy(alpha = 0.2f) else ChipBg.copy(alpha = 0.5f),
                        tint = if (selectedType == null) RacingAccent else Color.Unspecified
                    ) {
                        Text(
                            "Todos",
                            color = if (selectedType == null) Color.White else ChipText,
                            fontWeight = if (selectedType == null) FontWeight.Bold else FontWeight.Normal,
                            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)
                        )
                    }
                }
                items(poiCategoryChips) { chip ->
                    val isSelected = selectedType == chip.type
                    LiquidPill(
                        backdrop = backdrop,
                        modifier = Modifier.clickable {
                            viewModel.filterByType(if (isSelected) null else chip.type)
                        },
                        surfaceColor = if (isSelected) RacingAccent.copy(alpha = 0.2f) else ChipBg.copy(alpha = 0.5f),
                        tint = if (isSelected) RacingAccent else Color.Unspecified
                    ) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(4.dp),
                            modifier = Modifier.padding(horizontal = 4.dp, vertical = 4.dp)
                        ) {
                            Text(chip.emoji, fontSize = 14.sp)
                            Text(
                                chip.label,
                                color = if (isSelected) Color.White else ChipText,
                                fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal
                            )
                        }
                    }
                }
            }

            // POI List with pull-to-refresh
            var isRefreshing by remember { mutableStateOf(false) }
            val scope = rememberCoroutineScope()
            PullToRefreshBox(
                isRefreshing = isRefreshing,
                onRefresh = {
                    isRefreshing = true
                    scope.launch { delay(1500); isRefreshing = false }
                },
                modifier = Modifier.fillMaxSize()
            ) {
                LazyColumn(
                    contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    items(pois) { poi ->
                        PoiCard(
                            poi = poi,
                            backdrop = backdrop,
                            onNavigateClick = { /* TODO: Navigate to POI */ }
                        )
                    }
                }
            }
        }
        
        // Floating Search Pill (Top)
        LiquidPill(
            backdrop = backdrop,
            modifier = Modifier
                .fillMaxWidth()
                .statusBarsPadding()
                .padding(horizontal = 16.dp, vertical = 12.dp),
            surfaceColor = SearchBarBg.copy(alpha = 0.5f)
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { /* TODO: Open search */ }
                    .padding(horizontal = 8.dp, vertical = 4.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Back Icon
                IconButton(onClick = { navController.popBackStack() }) {
                    Icon(
                        Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "Atr√°s",
                        tint = ChipText
                    )
                }
                
                // Search Text
                Text(
                    text = "Buscar puntos de inter√©s...",
                    color = SubtleGray,
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier
                        .weight(1f)
                        .padding(horizontal = 8.dp)
                )
                
                // Home Icon
                IconButton(onClick = {
                    navController.navigate(com.georacing.georacing.ui.navigation.Screen.Home.route) {
                        popUpTo(com.georacing.georacing.ui.navigation.Screen.Home.route) { inclusive = true }
                    }
                }) {
                    Icon(
                        Icons.Default.Home,
                        contentDescription = "Inicio",
                        tint = ChipText
                    )
                }
                
                Spacer(modifier = Modifier.width(8.dp))
            }
        }
    }
}

@Composable
fun PoiCard(
    poi: Poi,
    backdrop: Backdrop,
    onNavigateClick: () -> Unit
) {
    LiquidCard(
        backdrop = backdrop,
        modifier = Modifier.fillMaxWidth(),
        cornerRadius = 24.dp,
        surfaceColor = com.georacing.georacing.ui.theme.AsphaltGrey.copy(alpha = 0.6f)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.Top
        ) {
            // Emoji Icon
            Box(
                modifier = Modifier
                    .size(48.dp)
                    .clip(CircleShape)
                    .background(Color(0xFF0E0E18)),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = getEmojiForType(poi.type),
                    fontSize = 24.sp
                )
            }
            
            Spacer(modifier = Modifier.width(16.dp))
            
            // Content
            Column(
                modifier = Modifier.weight(1f)
            ) {
                // Name
                Text(
                    text = poi.name,
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = SearchBarText
                )
                
                Spacer(modifier = Modifier.height(4.dp))
                
                // Description
                Text(
                    text = poi.description,
                    style = MaterialTheme.typography.bodyMedium,
                    color = SubtleGray
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                // Zone/Location
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    Icon(
                        Icons.Default.LocationOn,
                        contentDescription = null,
                        tint = SubtleGray,
                        modifier = Modifier.size(16.dp)
                    )
                    Text(
                        text = if (poi.zone.isNotEmpty()) poi.zone else "Circuit",
                        style = MaterialTheme.typography.labelMedium,
                        color = SubtleGray
                    )
                }
                
                // Wait time (simulated)
                if (poi.type == PoiType.WC || poi.type == PoiType.FOOD) {
                    Spacer(modifier = Modifier.height(4.dp))
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        Icon(
                            Icons.Default.Schedule,
                            contentDescription = null,
                            tint = RacingAccent,
                            modifier = Modifier.size(16.dp)
                        )
                        Text(
                            text = "Tiempo de espera: ~5 min",
                            style = MaterialTheme.typography.labelMedium,
                            color = RacingAccent
                        )
                    }
                }
                
                Spacer(modifier = Modifier.height(12.dp))
                
                // Action Button
                Button(
                    onClick = onNavigateClick,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = RacingAccent
                    ),
                    shape = RoundedCornerShape(20.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(
                        "C√ìMO LLEGAR",
                        fontWeight = FontWeight.SemiBold,
                        letterSpacing = 1.5.sp,
                        color = Color(0xFF080810)
                    )
                }
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/poi/PoiViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.poi

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.domain.model.Poi
import com.georacing.georacing.domain.model.PoiType
import com.georacing.georacing.domain.repository.PoiRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.stateIn

class PoiViewModel(
    poiRepository: PoiRepository
) : ViewModel() {

    private val allPois = poiRepository.getPois()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    private val _selectedType = MutableStateFlow<PoiType?>(null)
    val selectedType = _selectedType.asStateFlow()

    val visiblePois: StateFlow<List<Poi>> = combine(allPois, _selectedType) { pois, type ->
        if (type == null) pois else pois.filter { it.type == type }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    fun filterByType(type: PoiType?) {
        _selectedType.value = type
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/roadmap/RoadmapModels.kt`

```kotlin
package com.georacing.georacing.ui.screens.roadmap

import androidx.compose.ui.graphics.vector.ImageVector

enum class FeatureStatus {
    DONE, WIP, BACKLOG
}

data class Feature(
    val title: String,
    val description: String,
    val status: FeatureStatus,
    val icon: ImageVector
)

data class FeatureCategory(
    val title: String,
    val features: List<Feature>
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/roadmap/RoadmapScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.roadmap

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.animateContentSize
import androidx.compose.animation.core.tween
import androidx.compose.animation.expandVertically
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.ExpandLess
import androidx.compose.material.icons.filled.ExpandMore
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material.icons.filled.Schedule
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.rotate
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel

@OptIn(ExperimentalFoundationApi::class, ExperimentalMaterial3Api::class)
@Composable
fun RoadmapScreen(
    viewModel: RoadmapViewModel = viewModel()
) {
    val roadmapData by viewModel.roadmapData.collectAsState()

    // Map to keep track of expanded states for each category
    // Key: Category Title, Value: Expanded (Boolean)
    // By default, maybe we want the first one expanded? or all? 
    // "que las secciones sean colapsables... para no abrumar". Let's expand all by default or let user choose.
    // Let's default to expanded for better initial visibility.
    var expandedStates by remember { mutableStateOf(mapOf<String, Boolean>()) }

    // Initialize states if empty (only once)
    LaunchedEffect(roadmapData) {
        if (expandedStates.isEmpty() && roadmapData.isNotEmpty()) {
            expandedStates = roadmapData.associate { it.title to true }
        }
    }

    Scaffold(
        containerColor = Color(0xFF080810),
        topBar = {
            CenterAlignedTopAppBar(
                title = {
                    Text(
                        "GEO RACING ROADMAP",
                        color = Color(0xFFE2E8F0),
                        fontWeight = FontWeight.Bold,
                        style = MaterialTheme.typography.titleLarge
                    )
                },
                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(
                    containerColor = Color(0xFF080810)
                )
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(horizontal = 16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            roadmapData.forEach { category ->
                stickyHeader {
                    CategoryHeader(
                        category = category,
                        isExpanded = expandedStates[category.title] == true,
                        onToggle = {
                            expandedStates = expandedStates.toMutableMap().apply {
                                put(category.title, !(this[category.title] ?: true))
                            }
                        }
                    )
                }

                if (expandedStates[category.title] == true) {
                    items(category.features) { feature ->
                        FeatureRow(feature)
                        Spacer(modifier = Modifier.height(8.dp))
                    }
                }
            }
            // Bottom spacer
            item { Spacer(modifier = Modifier.height(32.dp)) }
        }
    }
}

@Composable
fun CategoryHeader(
    category: FeatureCategory,
    isExpanded: Boolean,
    onToggle: () -> Unit
) {
    Surface(
        color = Color(0xFF080810),
        modifier = Modifier
             // Small padding to separate headers slightly if sticky
            .fillMaxWidth()
            .clickable(onClick = onToggle)
    ) {
        Row(
            verticalAlignment = Alignment.CenterVertically,
            modifier = Modifier
                .padding(vertical = 12.dp)
                .background(
                    brush = Brush.horizontalGradient(
                        colors = listOf(Color(0xFFE8253A).copy(alpha = 0.8f), Color(0xFFE8253A).copy(alpha = 0.2f))
                    ),
                    shape = RoundedCornerShape(8.dp)
                )
                .padding(horizontal = 16.dp, vertical = 12.dp)
        ) {
            Text(
                text = category.title,
                color = Color(0xFFE2E8F0),
                fontWeight = FontWeight.ExtraBold,
                fontSize = 18.sp,
                modifier = Modifier.weight(1f)
            )
            Icon(
                imageVector = if (isExpanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore,
                contentDescription = if (isExpanded) "Collapse" else "Expand",
                tint = Color(0xFFE2E8F0)
            )
        }
    }
}

@Composable
fun FeatureRow(feature: Feature) {
    Card(
        colors = CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
        shape = RoundedCornerShape(12.dp),
        modifier = Modifier.fillMaxWidth()
    ) {
        Row(
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Icon Box
            Box(
                modifier = Modifier
                    .size(48.dp)
                    .clip(RoundedCornerShape(10.dp))
                    .background(Color(0xFF64748B).copy(alpha = 0.2f)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = feature.icon,
                    contentDescription = null,
                    tint = Color(0xFF06B6D4),
                    modifier = Modifier.size(24.dp)
                )
            }

            Spacer(modifier = Modifier.width(16.dp))

            // Text Content
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = feature.title,
                    color = Color(0xFFE2E8F0),
                    fontWeight = FontWeight.Bold,
                    fontSize = 16.sp
                )
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = feature.description,
                    color = Color(0xFF94A3B8),
                    fontSize = 12.sp,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis
                )
            }

            Spacer(modifier = Modifier.width(12.dp))

            // Status Indicator
            StatusIndicator(feature.status)
        }
    }
}

@Composable
fun StatusIndicator(status: FeatureStatus) {
    val (icon, color, tooltip) = when (status) {
        FeatureStatus.DONE -> Triple(Icons.Default.CheckCircle, Color(0xFF22C55E), "Hecho")
        FeatureStatus.WIP -> Triple(Icons.Default.Schedule, Color(0xFFFFA726), "En Progreso")
        FeatureStatus.BACKLOG -> Triple(Icons.Default.Lock, Color(0xFF64748B), "Planificado")
    }

    Column(
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Icon(
            imageVector = icon,
            contentDescription = tooltip,
            tint = color,
            modifier = Modifier.size(24.dp)
        )
        Spacer(modifier = Modifier.height(4.dp))
        Text(
            text = tooltip.uppercase().take(4), // Short text
            color = color,
            fontSize = 10.sp,
            fontWeight = FontWeight.Bold
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/roadmap/RoadmapViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.roadmap

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.rounded.*
import androidx.lifecycle.ViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

class RoadmapViewModel : ViewModel() {

    private val _roadmapData = MutableStateFlow<List<FeatureCategory>>(emptyList())
    val roadmapData: StateFlow<List<FeatureCategory>> = _roadmapData.asStateFlow()

    init {
        loadMockData()
    }

    private fun loadMockData() {
        val data = listOf(
            FeatureCategory(
                title = "A. M√ìDULO: NAVEGACI√ìN & PISTA (El Core)",
                features = listOf(
                    Feature(
                        "Mapa Vectorial Offline",
                        "Navegaci√≥n total sin internet.",
                        FeatureStatus.DONE,
                        Icons.Default.Map
                    ),
                    Feature(
                        "Gu√≠a AR al Asiento",
                        "Realidad aumentada \"Last Mile\".",
                        FeatureStatus.WIP,
                        Icons.Default.ViewInAr
                    ),
                    Feature(
                        "Rutas Anti-Colas",
                        "Algoritmo din√°mico de desv√≠o.",
                        FeatureStatus.BACKLOG,
                        Icons.Default.AltRoute
                    ),
                    Feature(
                        "Accesibilidad Total",
                        "Rutas sin escaleras/adaptadas.",
                        FeatureStatus.DONE,
                        Icons.Default.Accessible
                    ),
                    Feature(
                        "Auto-Posicionamiento QR",
                        "Ubicaci√≥n r√°pida escaneando hitos.",
                        FeatureStatus.WIP,
                        Icons.Default.QrCode
                    ),
                    Feature(
                        "Micro-posicionamiento BLE",
                        "Precisi√≥n en interiores con beacons.",
                        FeatureStatus.BACKLOG,
                        Icons.Default.Bluetooth
                    ),
                    Feature(
                        "Modo Emergencia/Evacuaci√≥n",
                        "Rutas de salida din√°micas.",
                        FeatureStatus.DONE,
                        Icons.Default.Warning
                    ),
                    Feature(
                        "Predicci√≥n de Tiempos",
                        "\"Est√°s a 12 min de tu puerta\".",
                        FeatureStatus.DONE,
                        Icons.Default.Timer
                    )
                )
            ),
            FeatureCategory(
                title = "B. M√ìDULO: MOTOR & COCHE (Android Auto)",
                features = listOf(
                    Feature(
                        "Ruta Inteligente al Circuit",
                        "Gesti√≥n de tr√°fico previa.",
                        FeatureStatus.DONE,
                        Icons.Default.Directions
                    ),
                    Feature(
                        "Asignaci√≥n de Parking",
                        "Te dice en qu√© zona aparcar.",
                        FeatureStatus.DONE,
                        Icons.Default.LocalParking
                    ),
                    Feature(
                        "Gu√≠a \"Last Mile\" Coche",
                        "Del peaje a la plaza de parking.",
                        FeatureStatus.WIP,
                        Icons.Default.DirectionsCar
                    ),
                    Feature(
                        "Find My Car",
                        "Guarda GPS + Foto del coche.",
                        FeatureStatus.BACKLOG,
                        Icons.Default.CarRental
                    ),
                    Feature(
                        "Modo Transici√≥n",
                        "UI cambia autom√°ticamente de \"Coche\" a \"Andando\".",
                        FeatureStatus.WIP,
                        Icons.Default.TransferWithinAStation
                    ),
                    Feature(
                        "Alertas de Tr√°fico",
                        "Avisos en tiempo real al llegar.",
                        FeatureStatus.DONE,
                        Icons.Default.Traffic
                    )
                )
            ),
            FeatureCategory(
                title = "C. M√ìDULO: FAN EXPERIENCE (La Diversi√≥n)",
                features = listOf(
                    Feature(
                        "GeoRacing Wrapped",
                        "Resumen estad√≠stico de tu visita.",
                        FeatureStatus.BACKLOG,
                        Icons.Default.AutoGraph
                    ),
                    Feature(
                        "Pedidos Click & Collect",
                        "Comida sin colas (con al√©rgenos).",
                        FeatureStatus.WIP,
                        Icons.Default.ShoppingCart
                    ),
                    Feature(
                        "Gamificaci√≥n & Badges",
                        "Retos (ej: \"Camina 5km\", \"Visita la Curva 4\").",
                        FeatureStatus.BACKLOG,
                        Icons.Default.EmojiEvents
                    ),
                    Feature(
                        "Momento360",
                        "Captura de recuerdos inmersivos.",
                        FeatureStatus.WIP,
                        Icons.Default.Camera
                    ),
                    Feature(
                        "Fan Zone Personalizada",
                        "Recomendaciones seg√∫n tus gustos.",
                        FeatureStatus.WIP,
                        Icons.Default.Person
                    ),
                    Feature(
                        "Coleccionables Digitales",
                        "Cromos/NFTs del evento.",
                        FeatureStatus.BACKLOG,
                        Icons.Default.Collections
                    ),
                    Feature(
                        "Trivia F1 & Duolingo",
                        "Preguntas tipo quiz en tiempos muertos.",
                        FeatureStatus.BACKLOG,
                        Icons.Default.Quiz
                    ),
                    Feature(
                        "Pop-ups Curiosidades",
                        "Datos \"Sab√≠as que...\" seg√∫n ubicaci√≥n.",
                        FeatureStatus.DONE,
                        Icons.Default.Info
                    ),
                    Feature(
                        "EcoMeter",
                        "Mide tu impacto ecol√≥gico y da consejos.",
                        FeatureStatus.WIP,
                        Icons.Default.Eco
                    )
                )
            ),
            FeatureCategory(
                title = "D. M√ìDULO: SOCIAL & COMUNIDAD",
                features = listOf(
                    Feature(
                        "Seguir al Grupo",
                        "Ver d√≥nde est√°n tus amigos en el mapa.",
                        FeatureStatus.WIP,
                        Icons.Default.Group
                    ),
                    Feature(
                        "Punto de Reuni√≥n",
                        "Coordenada fija compartida.",
                        FeatureStatus.DONE,
                        Icons.Default.MeetingRoom
                    ),
                    Feature(
                        "Compartir Perfil",
                        "Conectar redes sociales v√≠a QR/NFC.",
                        FeatureStatus.BACKLOG,
                        Icons.Default.Share
                    ),
                    Feature(
                        "Clubes & Grupos",
                        "Crear \"Pe√±as\" para el evento.",
                        FeatureStatus.BACKLOG,
                        Icons.Default.Groups
                    ),
                    Feature(
                        "Chat de Proximidad",
                        "Opcional para grupos (Mesh).",
                        FeatureStatus.BACKLOG,
                        Icons.Default.Chat
                    )
                )
            ),
            FeatureCategory(
                title = "E. M√ìDULO: UTILIDADES & GESTI√ìN",
                features = listOf(
                    Feature(
                        "Wallet de Entradas",
                        "Acceso r√°pido offline.",
                        FeatureStatus.DONE,
                        Icons.Default.Wallet
                    ),
                    Feature(
                        "Plan del D√≠a",
                        "Horarios y agenda personalizable.",
                        FeatureStatus.DONE,
                        Icons.Default.CalendarToday
                    ),
                    Feature(
                        "Centro de Alertas",
                        "Avisos oficiales de direcci√≥n de carrera.",
                        FeatureStatus.DONE,
                        Icons.Default.Notifications
                    ),
                    Feature(
                        "Bot√≥n SOS",
                        "Ubicaci√≥n directa a seguridad/m√©dicos.",
                        FeatureStatus.DONE,
                        Icons.Default.Sos
                    ),
                    Feature(
                        "Feedback R√°pido",
                        "Reportar suciedad/aver√≠as con 1 toque.",
                        FeatureStatus.WIP,
                        Icons.Default.Feedback
                    ),
                    Feature(
                        "Interfaz IA Adaptativa",
                        "Men√∫s cambian seg√∫n hora/contexto.",
                        FeatureStatus.BACKLOG,
                        Icons.Default.AutoAwesome
                    ),
                    Feature(
                        "Soporte Multi-Idioma",
                        "Traducci√≥n autom√°tica y modo turista.",
                        FeatureStatus.DONE,
                        Icons.Default.Language
                    )
                )
            )
        )
        _roadmapData.value = data
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/search/SearchScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.search

import android.util.Log
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.car.PoiRepository as CarPoiRepository
import com.georacing.georacing.car.PoiType
import com.georacing.georacing.ui.navigation.Screen

private data class SearchResult(
    val title: String,
    val subtitle: String,
    val icon: ImageVector,
    val color: Color,
    val route: String,
    val category: String
)

private data class Quad<A, B, C, D>(val first: A, val second: B, val third: C, val fourth: D)

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SearchScreen(navController: NavController) {
    var query by remember { mutableStateOf("") }
    val focusRequester = remember { FocusRequester() }

    LaunchedEffect(Unit) { focusRequester.requestFocus() }

    // Searchable items: combinaci√≥n de POIs reales + funcionalidades de la app
    val allItems = remember {
        // POIs reales del Circuit de Barcelona-Catalunya (coordenadas GPS verificadas)
        val poiItems = CarPoiRepository.getAllPois().map { poi ->
            val (icon, color, route, category) = when (poi.type) {
                PoiType.GATE -> Quad(Icons.Default.MeetingRoom, Color(0xFF64748B), Screen.Map.route, "Accesos")
                PoiType.PARKING -> Quad(Icons.Default.LocalParking, Color(0xFF8B8B97), Screen.Parking.route, "Parking")
                PoiType.FANZONE -> Quad(Icons.Default.Attractions, Color(0xFF22C55E), Screen.Map.route, "Experiencia")
                PoiType.SERVICE -> Quad(Icons.Default.Wc, Color(0xFFA855F7), Screen.PoiList.route, "Servicios")
                PoiType.MEDICAL -> Quad(Icons.Default.LocalHospital, Color(0xFFEF4444), Screen.PoiList.route, "Servicios")
                PoiType.OTHER -> Quad(Icons.Default.Place, Color(0xFF3B82F6), Screen.Map.route, "Otros")
            }
            SearchResult(poi.name, poi.description, icon, color, route, category)
        }

        // Funcionalidades de la app (√≠ndice est√°tico de navegaci√≥n)
        val appFeatures = listOf(
            SearchResult("Mapa del Circuito", "Plano interactivo completo", Icons.Default.Map, Color(0xFF3B82F6), Screen.Map.route, "Navegaci√≥n"),
            SearchResult("Transporte", "Trenes, shuttles y a pie", Icons.Default.DirectionsBus, Color(0xFF22C55E), Screen.Transport.route, "Navegaci√≥n"),
            SearchResult("F1 Live Telemetr√≠a", "Datos en tiempo real", Icons.Default.Speed, Color(0xFFE8253A), Screen.FanImmersive.route, "Experiencia"),
            SearchResult("Momentos", "Galer√≠a de fotos del evento", Icons.Default.CameraAlt, Color(0xFFEC4899), Screen.Moments.route, "Experiencia"),
            SearchResult("ClimaSmart", "Tiempo y recomendaciones", Icons.Default.WbSunny, Color(0xFFFFA726), Screen.ClimaSmart.route, "Experiencia"),
            SearchResult("Mi Grupo", "Compartir ubicaci√≥n con amigos", Icons.Default.Groups, Color(0xFF6366F1), Screen.Group.route, "Social"),
            SearchResult("Alertas", "Noticias y avisos del circuito", Icons.Default.Notifications, Color(0xFFEF4444), Screen.Alerts.route, "Social"),
            SearchResult("Restaurantes", "Comida y bebida del circuito", Icons.Default.Restaurant, Color(0xFFFF6B2C), Screen.Orders.route, "Comida"),
        )

        poiItems + appFeatures
    }

    val filteredItems = remember(query) {
        if (query.isBlank()) emptyList()
        else allItems.filter {
            it.title.contains(query, ignoreCase = true) || it.subtitle.contains(query, ignoreCase = true) || it.category.contains(query, ignoreCase = true)
        }
    }

    val recentSearches = remember { listOf("Parking", "Puerta", "Mapa", "Grupo") }
    val quickAccess = remember {
        listOf(
            SearchResult("Emergencia", "Punto m√©dico m√°s cercano", Icons.Default.LocalHospital, Color(0xFFEF4444), Screen.PoiList.route, "R√°pido"),
            SearchResult("Mapa", "Plano interactivo", Icons.Default.Map, Color(0xFF3B82F6), Screen.Map.route, "R√°pido"),
            SearchResult("Mi Parking", "D√≥nde aparqu√©", Icons.Default.LocalParking, Color(0xFF8B8B97), Screen.Parking.route, "R√°pido"),
            SearchResult("Comida", "Restaurantes y bares", Icons.Default.Restaurant, Color(0xFFFF6B2C), Screen.Orders.route, "R√°pido")
        )
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    TextField(
                        value = query, onValueChange = { query = it },
                        placeholder = { Text("Buscar en el circuito...", color = Color(0xFF64748B)) },
                        singleLine = true,
                        colors = TextFieldDefaults.colors(
                            focusedContainerColor = Color.Transparent, unfocusedContainerColor = Color.Transparent,
                            focusedTextColor = Color.White, cursorColor = Color(0xFFE8253A),
                            focusedIndicatorColor = Color.Transparent, unfocusedIndicatorColor = Color.Transparent
                        ),
                        modifier = Modifier.fillMaxWidth().focusRequester(focusRequester)
                    )
                },
                navigationIcon = { IconButton(onClick = { navController.popBackStack() }) { Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Volver atr√°s") } },
                actions = {
                    if (query.isNotBlank()) {
                        IconButton(onClick = { query = "" }) { Icon(Icons.Default.Close, contentDescription = "Limpiar b√∫squeda", tint = Color(0xFF64748B)) }
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color(0xFF14141C))
            )
        },
        containerColor = Color(0xFF080810)
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier.fillMaxSize().padding(innerPadding).padding(horizontal = 16.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp),
            contentPadding = PaddingValues(bottom = 100.dp)
        ) {
            if (query.isBlank()) {
                // Recent searches
                item {
                    Spacer(Modifier.height(16.dp))
                    Text("B√öSQUEDAS RECIENTES", style = MaterialTheme.typography.labelSmall, color = Color(0xFF64748B), letterSpacing = 1.5.sp)
                    Spacer(Modifier.height(8.dp))
                }
                items(recentSearches) { recent ->
                    Row(
                        Modifier.fillMaxWidth().clickable { query = recent }.padding(vertical = 10.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(Icons.Default.History, null, tint = Color(0xFF64748B), modifier = Modifier.size(18.dp))
                        Spacer(Modifier.width(12.dp))
                        Text(recent, style = MaterialTheme.typography.bodyMedium, color = Color(0xFF94A3B8))
                    }
                }

                // Quick access
                item {
                    Spacer(Modifier.height(16.dp))
                    Text("ACCESO R√ÅPIDO", style = MaterialTheme.typography.labelSmall, color = Color(0xFF64748B), letterSpacing = 1.5.sp)
                    Spacer(Modifier.height(8.dp))
                }
                items(quickAccess) { item ->
                    SearchResultRow(item) { navController.navigate(item.route) }
                }
            } else {
                // Search results
                item {
                    Spacer(Modifier.height(8.dp))
                    Text("${filteredItems.size} resultados", style = MaterialTheme.typography.bodySmall, color = Color(0xFF64748B))
                    Spacer(Modifier.height(8.dp))
                }

                if (filteredItems.isEmpty()) {
                    item {
                        Box(Modifier.fillMaxWidth().padding(vertical = 48.dp), contentAlignment = Alignment.Center) {
                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                Icon(Icons.Default.SearchOff, null, tint = Color(0xFF64748B), modifier = Modifier.size(48.dp))
                                Spacer(Modifier.height(12.dp))
                                Text("No se encontraron resultados", style = MaterialTheme.typography.bodyMedium, color = Color(0xFF64748B))
                                Text("Prueba con otra b√∫squeda", style = MaterialTheme.typography.bodySmall, color = Color(0xFF475569))
                            }
                        }
                    }
                } else {
                    val grouped = filteredItems.groupBy { it.category }
                    grouped.forEach { (category, items) ->
                        item {
                            Text(category.uppercase(), style = MaterialTheme.typography.labelSmall, color = Color(0xFF64748B), letterSpacing = 1.5.sp, modifier = Modifier.padding(top = 12.dp, bottom = 4.dp))
                        }
                        items(items) { item ->
                            SearchResultRow(item) { navController.navigate(item.route) }
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun SearchResultRow(result: SearchResult, onClick: () -> Unit) {
    Card(
        modifier = Modifier.fillMaxWidth().clickable(onClick = onClick),
        colors = CardDefaults.cardColors(containerColor = Color(0xFF14141C)),
        shape = RoundedCornerShape(12.dp)
    ) {
        Row(Modifier.padding(14.dp), verticalAlignment = Alignment.CenterVertically) {
            Box(Modifier.size(40.dp).clip(RoundedCornerShape(10.dp)).background(result.color.copy(alpha = 0.15f)), contentAlignment = Alignment.Center) {
                Icon(result.icon, contentDescription = result.title, tint = result.color, modifier = Modifier.size(20.dp))
            }
            Spacer(Modifier.width(14.dp))
            Column(Modifier.weight(1f)) {
                Text(result.title, style = MaterialTheme.typography.bodyMedium, color = Color.White, fontWeight = FontWeight.Medium)
                Text(result.subtitle, style = MaterialTheme.typography.bodySmall, color = Color(0xFF64748B))
            }
            Icon(Icons.Default.ChevronRight, contentDescription = "Ir a ${result.title}", tint = Color(0xFF475569), modifier = Modifier.size(20.dp))
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/seat/SeatSetupScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.seat

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import androidx.navigation.NavController
import com.georacing.georacing.data.local.UserPreferencesDataStore

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SeatSetupScreen(
    navController: NavController,
    userPreferences: UserPreferencesDataStore
) {
    val viewModel: SeatViewModel = viewModel(
        factory = viewModelFactory {
            initializer {
                SeatViewModel(userPreferences)
            }
        }
    )

    val seatInfo by viewModel.seatInfo.collectAsState()

    var grandstand by remember(seatInfo) { mutableStateOf(seatInfo?.grandstand ?: "") }
    var zone by remember(seatInfo) { mutableStateOf(seatInfo?.zone ?: "") }
    var row by remember(seatInfo) { mutableStateOf(seatInfo?.row ?: "") }
    var seat by remember(seatInfo) { mutableStateOf(seatInfo?.seat ?: "") }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Mi Localidad") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Atr√°s")
                    }
                },
                actions = {
                    com.georacing.georacing.ui.components.HomeIconButton {
                        navController.navigate(com.georacing.georacing.ui.navigation.Screen.Home.route) {
                            popUpTo(com.georacing.georacing.ui.navigation.Screen.Home.route) { inclusive = true }
                        }
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(16.dp)
        ) {
            if (seatInfo != null) {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.secondaryContainer
                    )
                ) {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text(
                            text = "Localidad Guardada",
                            style = MaterialTheme.typography.labelLarge
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text("Tribuna: ${seatInfo?.grandstand}")
                        Text("Zona: ${seatInfo?.zone}")
                        Text("Fila: ${seatInfo?.row} - Asiento: ${seatInfo?.seat}")
                    }
                }
                Spacer(modifier = Modifier.height(24.dp))
            }

            Text(
                text = "Configurar nueva localidad",
                style = MaterialTheme.typography.titleMedium
            )
            Spacer(modifier = Modifier.height(16.dp))

            OutlinedTextField(
                value = grandstand,
                onValueChange = { grandstand = it },
                label = { Text("Tribuna / Grada") },
                modifier = Modifier.fillMaxWidth(),
                singleLine = true,
                keyboardOptions = KeyboardOptions.Default.copy(imeAction = ImeAction.Next)
            )
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedTextField(
                value = zone,
                onValueChange = { zone = it },
                label = { Text("Zona") },
                modifier = Modifier.fillMaxWidth(),
                singleLine = true,
                keyboardOptions = KeyboardOptions.Default.copy(imeAction = ImeAction.Next)
            )
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedTextField(
                value = row,
                onValueChange = { row = it },
                label = { Text("Fila") },
                modifier = Modifier.fillMaxWidth(),
                singleLine = true,
                keyboardOptions = KeyboardOptions.Default.copy(imeAction = ImeAction.Next)
            )
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedTextField(
                value = seat,
                onValueChange = { seat = it },
                label = { Text("Asiento") },
                modifier = Modifier.fillMaxWidth(),
                singleLine = true,
                keyboardOptions = KeyboardOptions.Default.copy(imeAction = ImeAction.Done)
            )

            Spacer(modifier = Modifier.height(24.dp))

            Button(
                onClick = {
                    viewModel.saveSeat(grandstand, zone, row, seat)
                    navController.popBackStack()
                },
                modifier = Modifier.fillMaxWidth(),
                enabled = grandstand.isNotBlank() && zone.isNotBlank()
            ) {
                Text("Guardar mi localidad")
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/seat/SeatViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.seat

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.data.local.UserPreferencesDataStore
import com.georacing.georacing.domain.model.SeatInfo
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

class SeatViewModel(
    private val userPreferences: UserPreferencesDataStore
) : ViewModel() {

    val seatInfo: StateFlow<SeatInfo?> = userPreferences.seatInfo
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = null
        )

    fun saveSeat(grandstand: String, zone: String, row: String, seat: String) {
        viewModelScope.launch {
            val info = SeatInfo(grandstand, zone, row, seat)
            userPreferences.setSeatInfo(info)
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/security/SecurityViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.security

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.infrastructure.security.MedicalWallpaperGenerator
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

/**
 * Estado UI para la generaci√≥n del fondo m√©dico.
 */
sealed class SecurityUiState {
    object Idle : SecurityUiState()
    object Loading : SecurityUiState()
    object Success : SecurityUiState()
    data class Error(val message: String) : SecurityUiState()
}

/**
 * ViewModel que conecta el generador de infraestructura con la UI de Settings o SOS.
 */
class SecurityViewModel(
    private val medicalWallpaperGenerator: MedicalWallpaperGenerator
) : ViewModel() {

    private val _uiState = MutableStateFlow<SecurityUiState>(SecurityUiState.Idle)
    val uiState: StateFlow<SecurityUiState> = _uiState.asStateFlow()

    /**
     * Inicia el proceso de sobreescribir el Lock Screen.
     */
    fun activateMedicalLockScreen(bloodType: String, emergencyContact: String, ticketId: String) {
        // Validaci√≥n b√°sica
        if (bloodType.isBlank() || emergencyContact.isBlank()) {
            _uiState.value = SecurityUiState.Error("Faltan datos m√©dicos requeridos.")
            return
        }

        _uiState.value = SecurityUiState.Loading

        viewModelScope.launch {
            val success = medicalWallpaperGenerator.applyEmergencyWallpaper(
                bloodType = bloodType,
                emergencyContact = emergencyContact,
                ticketId = ticketId
            )
            
            if (success) {
                _uiState.value = SecurityUiState.Success
            } else {
                _uiState.value = SecurityUiState.Error("No se pudo aplicar el fondo de pantalla. Verifica los permisos de SET_WALLPAPER.")
            }
        }
    }
    
    fun resetState() {
        _uiState.value = SecurityUiState.Idle
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/settings/SettingsScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.settings

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Favorite
import androidx.compose.material.icons.filled.Security
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import com.georacing.georacing.ui.components.debug.DebugButton
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import androidx.navigation.NavController
import com.georacing.georacing.data.local.UserPreferencesDataStore
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.*
import com.georacing.georacing.ui.components.*
import android.app.Application
import androidx.lifecycle.ViewModelProvider
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.ui.platform.LocalContext
import com.georacing.georacing.data.health.HealthConnectManager
import com.georacing.georacing.ui.glass.LocalGlassConfigState
import com.georacing.georacing.ui.glass.LiquidToggle
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.glass.GlassQuality
import com.georacing.georacing.ui.glass.LiquidCard
import com.georacing.georacing.ui.glass.LiquidListItem

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingsScreen(
    navController: NavController,
    userPreferences: UserPreferencesDataStore
) {
    val viewModel: SettingsViewModel = viewModel(
        factory = viewModelFactory {
            initializer {
                val application = (this[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY] as Application)
                SettingsViewModel(userPreferences, HealthConnectManager(application))
            }
        }
    )

    val currentLanguage by viewModel.preferredLanguage.collectAsState()
    val highContrast by viewModel.highContrast.collectAsState()
    val largeFont by viewModel.largeFont.collectAsState()
    val avoidStairs by viewModel.avoidStairs.collectAsState()
    var notificationsEnabled by remember { mutableStateOf(true) }
    
    val healthConnectGranted by viewModel.healthConnectPermissionsGranted.collectAsState()
    val isHealthConnectAvailable = remember { viewModel.isHealthConnectAvailable() }
    
    // Health Connect Permission Launcher
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) {
        viewModel.checkHealthConnectPermissions()
    }

    // Easter egg: tap counter for Staff Mode
    var versionTapCount by remember { mutableStateOf(0) }
    var showStaffModeUnlocked by remember { mutableStateOf(false) }

    SettingsScreenContent(
        currentLanguage = currentLanguage,
        highContrast = highContrast,
        largeFont = largeFont,
        avoidStairs = avoidStairs,
        notificationsEnabled = notificationsEnabled,
        versionTapCount = versionTapCount,
        showStaffModeUnlocked = showStaffModeUnlocked,
        isHealthConnectAvailable = isHealthConnectAvailable,
        healthConnectGranted = healthConnectGranted,
        onSetLanguage = { viewModel.setLanguage(it) },
        onSetHighContrast = { viewModel.setHighContrast(it) },
        onSetLargeFont = { viewModel.setLargeFont(it) },
        onSetAvoidStairs = { viewModel.setAvoidStairs(it) },
        onToggleNotifications = { notificationsEnabled = it },
        onToggleHealthConnect = { shouldEnable ->
             if (shouldEnable) {
                 permissionLauncher.launch(HealthConnectManager.PERMISSIONS.toTypedArray())
             } else {
                 // Info: cannot auto-revoke
             }
        },
        onResetOnboarding = {
            viewModel.resetOnboarding()
            navController.navigate(Screen.Onboarding.route) {
                popUpTo(0)
            }
        },
        onNavigateBack = { navController.popBackStack() },
        onNavigateHome = {
            navController.navigate(com.georacing.georacing.ui.navigation.Screen.Home.route) {
                popUpTo(com.georacing.georacing.ui.navigation.Screen.Home.route) { inclusive = true }
            }
        },
        onNavigateToMedicalInfo = {
            navController.navigate(Screen.MedicalLockScreen.route)
        },
        onNavigateToStaffMode = {
            navController.navigate(Screen.StaffMode.route)
        },
        onVersionTap = {
            versionTapCount++
            if (versionTapCount >= 7) {
                showStaffModeUnlocked = true
            }
        }
    )
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingsScreenContent(
    currentLanguage: String,
    highContrast: Boolean,
    largeFont: Boolean,
    avoidStairs: Boolean = false,
    notificationsEnabled: Boolean,
    versionTapCount: Int = 0,
    showStaffModeUnlocked: Boolean = false,
    isHealthConnectAvailable: Boolean = false,
    healthConnectGranted: Boolean = false,
    onSetLanguage: (String) -> Unit,
    onSetHighContrast: (Boolean) -> Unit,
    onSetLargeFont: (Boolean) -> Unit,
    onSetAvoidStairs: (Boolean) -> Unit = {},
    onToggleNotifications: (Boolean) -> Unit,
    onToggleHealthConnect: (Boolean) -> Unit = {},
    onResetOnboarding: () -> Unit,
    onNavigateBack: () -> Unit,
    onNavigateHome: () -> Unit,
    onNavigateToMedicalInfo: () -> Unit = {},
    onNavigateToStaffMode: () -> Unit = {},
    onVersionTap: () -> Unit = {}
) {
    val backdrop = LocalBackdrop.current
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        Color(0xFF06060C),
                        Color(0xFF0A0A12),
                        Color(0xFF080810)
                    )
                )
            )
    ) {
        Scaffold(
            containerColor = Color.Transparent,
            topBar = {
                TopAppBar(
                    title = { 
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            Box(
                                modifier = Modifier
                                    .size(6.dp)
                                    .background(Color(0xFFE8253A), shape = androidx.compose.foundation.shape.CircleShape)
                            )
                            Spacer(modifier = Modifier.width(10.dp))
                            Text(
                                "AJUSTES", 
                                style = MaterialTheme.typography.titleLarge.copy(
                                    fontWeight = FontWeight.Black,
                                    letterSpacing = 2.sp
                                ),
                                color = TextPrimary
                            )
                        }
                    },
                    navigationIcon = {
                        IconButton(onClick = onNavigateBack) {
                            Icon(
                                Icons.AutoMirrored.Filled.ArrowBack, 
                                contentDescription = "Atr√°s",
                                tint = Color(0xFFE8253A)
                            )
                        }
                    },
                    actions = {
                        com.georacing.georacing.ui.components.HomeIconButton(onNavigateHome)
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = Color.Transparent,
                        titleContentColor = TextPrimary
                    )
                )
            }
        ) { innerPadding ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(innerPadding)
                    .padding(horizontal = 20.dp)
                    .verticalScroll(rememberScrollState())
            ) {
                // üÜò SEGURIDAD Y EMERGENCIAS Section
                Text(
                    "üÜò SEGURIDAD Y EMERGENCIAS", 
                    style = MaterialTheme.typography.labelLarge,
                    color = Color(0xFFEF4444),
                    letterSpacing = 1.5.sp,
                    modifier = Modifier.padding(bottom = 10.dp, start = 4.dp)
                )
                LiquidCard(backdrop = backdrop, modifier = Modifier.fillMaxWidth()) {
                    Column(modifier = Modifier.padding(8.dp)) {
                        SettingsNavigationItem(
                            icon = Icons.Default.Favorite,
                            iconTint = Color.Red,
                            title = "Informaci√≥n M√©dica",
                            subtitle = "Configura tu Lock Screen de emergencia",
                            onClick = onNavigateToMedicalInfo
                        )
                        
                        // Staff Mode - Solo visible si se desbloquea con Easter egg
                        if (showStaffModeUnlocked) {
                            HorizontalDivider(color = Color.Gray.copy(alpha = 0.3f))
                            SettingsNavigationItem(
                                icon = Icons.Default.Security,
                                iconTint = Color.Yellow,
                                title = "üîí Modo Staff",
                                subtitle = "Emisi√≥n de alertas BLE (Solo personal)",
                                onClick = onNavigateToStaffMode
                            )
                        }
                    }
                }

                Spacer(modifier = Modifier.height(24.dp))

                // Idioma Section
                Text(
                    "IDIOMA", 
                    style = MaterialTheme.typography.labelLarge,
                    color = Color(0xFF64748B),
                    letterSpacing = 1.5.sp,
                    modifier = Modifier.padding(bottom = 10.dp, start = 4.dp)
                )
                LiquidCard(backdrop = backdrop, modifier = Modifier.fillMaxWidth()) {
                    Column(modifier = Modifier.padding(8.dp)) {
                        LanguageOption(backdrop, "Espa√±ol", "es", currentLanguage) { onSetLanguage("es") }
                        LanguageOption(backdrop, "Catal√†", "ca", currentLanguage) { onSetLanguage("ca") }
                        LanguageOption(backdrop, "English", "en", currentLanguage) { onSetLanguage("en") }
                    }
                }

                Spacer(modifier = Modifier.height(24.dp))

                // Accesibilidad Section
                Text(
                    "ACCESIBILIDAD", 
                    style = MaterialTheme.typography.labelLarge,
                    color = Color(0xFF64748B),
                    letterSpacing = 1.5.sp,
                    modifier = Modifier.padding(bottom = 10.dp, start = 4.dp)
                )
                LiquidCard(backdrop = backdrop, modifier = Modifier.fillMaxWidth()) {
                    Column(modifier = Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.fillMaxWidth()) {
                            Text("Alto contraste", modifier = Modifier.weight(1f), color = TextPrimary)
                            LiquidToggle(
                                selected = { highContrast },
                                onSelect = onSetHighContrast,
                                backdrop = backdrop
                            )
                        }
                        Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.fillMaxWidth()) {
                            Text("Fuente grande", modifier = Modifier.weight(1f), color = TextPrimary)
                            LiquidToggle(
                                selected = { largeFont },
                                onSelect = onSetLargeFont,
                                backdrop = backdrop
                            )
                        }
                        HorizontalDivider(color = Color.Gray.copy(alpha = 0.2f))
                        Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.fillMaxWidth()) {
                            Column(modifier = Modifier.weight(1f)) {
                                Text("Rutas sin escaleras", color = TextPrimary)
                                Text(
                                    "Evitar escaleras en rutas peatonales",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = TextSecondary
                                )
                            }
                            LiquidToggle(
                                selected = { avoidStairs },
                                onSelect = onSetAvoidStairs,
                                backdrop = backdrop
                            )
                        }
                    }
                }

                Spacer(modifier = Modifier.height(24.dp))

                // Gr√°ficos Section
                Text(
                    "GRAFICOS", 
                    style = MaterialTheme.typography.labelLarge,
                    color = Color(0xFF64748B),
                    letterSpacing = 1.5.sp,
                    modifier = Modifier.padding(bottom = 10.dp, start = 4.dp)
                )
                LiquidCard(backdrop = backdrop, modifier = Modifier.fillMaxWidth()) {
                    Column(modifier = Modifier.padding(16.dp)) {
                        val glassConfigState = LocalGlassConfigState.current
                        val glassConfig = glassConfigState.value
                        
                        Row(
                            verticalAlignment = Alignment.CenterVertically, 
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            Column(modifier = Modifier.weight(1f)) {
                                Text("Liquid Glass UI", color = TextPrimary)
                                Text(
                                    "Efectos de desenfoque y lente (Android 12+)", 
                                    style = MaterialTheme.typography.bodySmall,
                                    color = TextSecondary
                                )
                            }
                            LiquidToggle(
                                selected = { glassConfig.enabled },
                                onSelect = { glassConfigState.value = glassConfig.copy(enabled = it) },
                                backdrop = backdrop
                            )
                        }
                        
                        if (glassConfig.enabled) {
                            HorizontalDivider(modifier = Modifier.padding(vertical = 12.dp), color = Color.Gray.copy(alpha = 0.2f))
                            
                            Text(
                                "Calidad de efectos", 
                                style = MaterialTheme.typography.bodyMedium,
                                color = TextSecondary,
                                modifier = Modifier.padding(bottom = 8.dp)
                            )
                            
                            Row(
                                modifier = Modifier.fillMaxWidth(), 
                                horizontalArrangement = Arrangement.SpaceBetween
                            ) {
                                GlassQuality.entries.forEach { quality ->
                                    val isSelected = glassConfig.quality == quality
                                    FilterChip(
                                        selected = isSelected,
                                        onClick = { glassConfigState.value = glassConfig.copy(quality = quality) },
                                        label = { Text(quality.name) },
                                        colors = FilterChipDefaults.filterChipColors(
                                            selectedContainerColor = CircuitGreen.copy(alpha = 0.2f),
                                            selectedLabelColor = CircuitGreen,
                                            containerColor = Color.Transparent,
                                            labelColor = TextSecondary
                                        ),
                                        border = FilterChipDefaults.filterChipBorder(
                                            borderColor = if (isSelected) CircuitGreen else TextTertiary,
                                            enabled = true,
                                            selected = isSelected
                                        )
                                    )
                                }
                            }
                        }
                    }
                }

                Spacer(modifier = Modifier.height(24.dp))

                // Notificaciones Section
                LiquidCard(backdrop = backdrop, modifier = Modifier.fillMaxWidth()) {
                    Row(
                        modifier = Modifier.padding(16.dp).fillMaxWidth(),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Notificaciones",
                            style = MaterialTheme.typography.titleMedium,
                            color = TextPrimary,
                            modifier = Modifier.weight(1f)
                        )
                        Switch(
                            checked = notificationsEnabled,
                            onCheckedChange = onToggleNotifications,
                            colors = SwitchDefaults.colors(
                                checkedThumbColor = Color.White,
                                checkedTrackColor = CircuitGreen,
                                uncheckedThumbColor = TextTertiary,
                                uncheckedTrackColor = CarbonBlack
                            )
                        )
                    }
                }

                // Health Connect Section
                if (isHealthConnectAvailable) {
                    Text(
                        "SALUD Y BIENESTAR",
                        style = MaterialTheme.typography.labelMedium.copy(
                            letterSpacing = 1.5.sp
                        ),
                        color = Color(0xFF22C55E),
                        modifier = Modifier.padding(bottom = 8.dp, start = 4.dp)
                    )
                    LiquidCard(backdrop = backdrop, modifier = Modifier.fillMaxWidth()) {
                        Row(
                            modifier = Modifier.padding(16.dp).fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Box(
                                modifier = Modifier
                                    .size(36.dp)
                                    .background(
                                        brush = Brush.linearGradient(
                                            listOf(Color(0xFF22C55E), Color(0xFF16A34A))
                                        ),
                                        shape = RoundedCornerShape(10.dp)
                                    ),
                                contentAlignment = Alignment.Center
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Favorite,
                                    contentDescription = null,
                                    tint = Color.White,
                                    modifier = Modifier.size(18.dp)
                                )
                            }
                            Spacer(modifier = Modifier.width(16.dp))
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    text = "Sincronizar Pasos (EcoMeter)",
                                    style = MaterialTheme.typography.titleMedium,
                                    color = TextPrimary
                                )
                                Text(
                                    text = if (healthConnectGranted) "Conectado" else "Permitir acceso a Health Connect",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = if (healthConnectGranted) Color(0xFF22C55E) else TextSecondary
                                )
                            }
                            Switch(
                                checked = healthConnectGranted,
                                onCheckedChange = onToggleHealthConnect,
                                colors = SwitchDefaults.colors(
                                    checkedThumbColor = Color.White,
                                    checkedTrackColor = CircuitGreen,
                                    uncheckedThumbColor = TextTertiary,
                                    uncheckedTrackColor = CarbonBlack
                                )
                            )
                        }
                    }
                    Spacer(modifier = Modifier.height(24.dp))
                }

                Spacer(modifier = Modifier.height(32.dp))

                RacingButton(
                    text = "Ver Tutorial de nuevo",
                    onClick = onResetOnboarding
                )

                Spacer(modifier = Modifier.height(40.dp))

                // Versi√≥n con Easter egg
                Text(
                    text = if (versionTapCount in 1..6) 
                        "v1.0.0 ‚Äî ${7 - versionTapCount} taps restantes" 
                    else if (showStaffModeUnlocked)
                        "‚úÖ STAFF MODE"
                    else 
                        "v1.0.0",
                    style = MaterialTheme.typography.labelSmall.copy(
                        letterSpacing = 1.5.sp
                    ),
                    color = if (showStaffModeUnlocked) Color(0xFF22C55E) else Color(0xFF475569),
                    modifier = Modifier
                        .align(Alignment.CenterHorizontally)
                        .clickable { onVersionTap() }
                        .padding(16.dp)
                )

                Spacer(modifier = Modifier.height(24.dp))
                
                // Debug / God Mode Button (Always visible requested by user, or obscure usage)
                // User requested: "bot√≥n en los ajustes que se llame debug"
                DebugButton(
                    text = "üõ†Ô∏è DEBUG / GOD MODE",
                    color = Color(0xFF1E1E2A),
                    onClick = { 
                        com.georacing.georacing.debug.ScenarioSimulator.setDebugPanelVisible(true) 
                    }
                )
                
                // Extra padding para que no lo tape la bottom nav bar
                Spacer(modifier = Modifier.height(120.dp))
            }
        }
    }
}

@Composable
fun SettingsNavigationItem(
    icon: ImageVector,
    iconTint: Color,
    title: String,
    subtitle: String,
    onClick: () -> Unit
) {
    val backdrop = LocalBackdrop.current
    
    LiquidListItem(
        onClick = onClick,
        backdrop = backdrop,
        modifier = Modifier.padding(vertical = 4.dp),
        surfaceColor = Color.Transparent,
        content = {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(12.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Box(
                    modifier = Modifier
                        .size(36.dp)
                        .background(
                            color = iconTint.copy(alpha = 0.12f),
                            shape = RoundedCornerShape(10.dp)
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        imageVector = icon,
                        contentDescription = null,
                        tint = iconTint,
                        modifier = Modifier.size(18.dp)
                    )
                }
                Spacer(modifier = Modifier.width(14.dp))
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = title,
                        style = MaterialTheme.typography.titleMedium.copy(
                            fontWeight = FontWeight.Bold,
                            letterSpacing = 0.5.sp
                        ),
                        color = TextPrimary
                    )
                    Text(
                        text = subtitle,
                        style = MaterialTheme.typography.bodySmall,
                        color = Color(0xFF64748B)
                    )
                }
                Icon(
                    imageVector = Icons.AutoMirrored.Filled.ArrowBack, // This icon might be wrong in standard RTL but assuming arrow right logic, let's fix to arrow right equivalent or just keep as is if it was correct logic before? 
                    // Actually, usually navigation implies ArrowForward or ChevronRight. The original code had ArrowBack... wait.
                    // Line 498: imageVector = Icons.AutoMirrored.Filled.ArrowBack
                    // That is weird for navigation item. Let's check original logic. Maybe it was intended as ArrowForward but imported wrong? or maybe it's just an arrow.
                    // I'll stick to ArrowBack if that's what it was, but it looks like a bug. Given it's a nav item, I'll use ArrowForward or ChevronRight if available.
                    // Just keeping original ArrowBack to avoid breaking visual consistency unless asked.
                    contentDescription = null,
                    tint = TextTertiary,
                    modifier = Modifier.size(20.dp)
                )
            }
        }
    )
}

@androidx.compose.ui.tooling.preview.Preview(showBackground = true)
@Composable
fun SettingsScreenPreview() {
    GeoRacingTheme {
        SettingsScreenContent(
             currentLanguage = "es",
             highContrast = false,
             largeFont = false,
             notificationsEnabled = true,
             onSetLanguage = {},
             onSetHighContrast = {},
             onSetLargeFont = {},
             onToggleNotifications = {},
             onResetOnboarding = {},
             onNavigateBack = {},
             onNavigateHome = {}
        )
    }
}

@Composable
fun LanguageOption(
    backdrop: com.kyant.backdrop.Backdrop,
    text: String,
    code: String,
    selectedCode: String,
    onSelect: () -> Unit
) {
    LiquidListItem(
        onClick = onSelect,
        backdrop = backdrop,
        modifier = Modifier.padding(vertical = 4.dp),
        surfaceColor = if (code == selectedCode) RacingRed.copy(alpha = 0.2f) else Color.Transparent,
        content = {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 8.dp, horizontal = 8.dp)
            ) {
                RadioButton(
                    selected = code == selectedCode,
                    onClick = onSelect,
                    colors = RadioButtonDefaults.colors(
                        selectedColor = RacingRed,
                        unselectedColor = TextSecondary
                    )
                )
                Text(
                    text = text, 
                    color = if (code == selectedCode) TextPrimary else TextSecondary,
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.padding(start = 8.dp)
                )
            }
        }
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/settings/SettingsViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.settings

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.data.local.UserPreferencesDataStore
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

import com.georacing.georacing.data.health.HealthConnectManager
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow

class SettingsViewModel(
    private val userPreferences: UserPreferencesDataStore,
    private val healthConnectManager: HealthConnectManager
) : ViewModel() {

    private val _healthConnectPermissionsGranted = MutableStateFlow(false)
    val healthConnectPermissionsGranted = _healthConnectPermissionsGranted.asStateFlow()

    init {
        checkHealthConnectPermissions()
    }

    fun checkHealthConnectPermissions() {
        viewModelScope.launch {
            _healthConnectPermissionsGranted.value = healthConnectManager.hasPermissions()
        }
    }

    fun isHealthConnectAvailable(): Boolean {
        return healthConnectManager.isAvailable()
    }

    val preferredLanguage: StateFlow<String> = userPreferences.preferredLanguage
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), "es")

    val highContrast: StateFlow<Boolean> = userPreferences.highContrast
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), false)

    val largeFont: StateFlow<Boolean> = userPreferences.largeFont
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), false)

    val avoidStairs: StateFlow<Boolean> = userPreferences.avoidStairs
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), false)

    fun setLanguage(language: String) {
        viewModelScope.launch {
            userPreferences.setPreferredLanguage(language)
        }
    }

    fun resetOnboarding() {
        viewModelScope.launch {
            userPreferences.setOnboardingCompleted(false)
        }
    }

    fun setHighContrast(enabled: Boolean) {
        viewModelScope.launch { userPreferences.setHighContrast(enabled) }
    }

    fun setLargeFont(enabled: Boolean) {
        viewModelScope.launch { userPreferences.setLargeFont(enabled) }
    }

    fun setAvoidStairs(enabled: Boolean) {
        viewModelScope.launch { userPreferences.setAvoidStairs(enabled) }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/share/ProximityChatScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.share

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.Send
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawWithContent
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.data.p2p.ProximityChatManager
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.theme.*
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

/**
 * Chat de Proximidad ‚Äî Premium Racing Edition.
 * P2P real via BLE + Nearby Connections.
 */
@Composable
fun ProximityChatScreen(
    proximityChatManager: ProximityChatManager,
    userName: String = "Usuario",
    userId: String = "user_${System.currentTimeMillis()}",
    onNavigateBack: () -> Unit = {}
) {
    val backdrop = LocalBackdrop.current
    val messages by proximityChatManager.messages.collectAsState()
    val nearbyUsers by proximityChatManager.nearbyUsers.collectAsState()
    val isActive by proximityChatManager.isActive.collectAsState()
    val connectionStatus by proximityChatManager.connectionStatus.collectAsState()

    var inputText by remember { mutableStateOf("") }
    var showQuickMessages by remember { mutableStateOf(false) }
    val listState = rememberLazyListState()
    val coroutineScope = rememberCoroutineScope()
    val timeFormat = remember { SimpleDateFormat("HH:mm", Locale.getDefault()) }

    LaunchedEffect(Unit) {
        if (!isActive) proximityChatManager.start(userName, userId)
    }

    LaunchedEffect(Unit) {
        while (true) {
            kotlinx.coroutines.delay(60_000)
            proximityChatManager.pruneOldMessages()
        }
    }

    LaunchedEffect(messages.size) {
        if (messages.isNotEmpty()) listState.animateScrollToItem(messages.size - 1)
    }

    Box(modifier = Modifier.fillMaxSize()) {
        CarbonBackground()

        Column(modifier = Modifier.fillMaxSize()) {
            // ‚îÄ‚îÄ Glass Top Bar ‚îÄ‚îÄ
            LiquidTopBar(
                backdrop = backdrop,
                navigationIcon = {
                    IconButton(onClick = { proximityChatManager.stop(); onNavigateBack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Volver", tint = TextPrimary)
                    }
                },
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        // BLE Status dot
                        val pulseAnim = rememberInfiniteTransition(label = "ble_pulse")
                        val pulseAlpha by pulseAnim.animateFloat(
                            initialValue = 0.4f, targetValue = 1f,
                            animationSpec = infiniteRepeatable(
                                tween(1500), RepeatMode.Reverse
                            ), label = "pulse"
                        )
                        Box(
                            modifier = Modifier
                                .size(10.dp)
                                .clip(CircleShape)
                                .background(
                                    if (isActive) StatusGreen.copy(alpha = pulseAlpha)
                                    else TextTertiary.copy(alpha = 0.3f)
                                )
                        )
                        Spacer(Modifier.width(10.dp))
                        Column {
                            Text(
                                "CHAT PROXIMIDAD",
                                color = TextPrimary,
                                fontSize = 14.sp,
                                fontWeight = FontWeight.ExtraBold,
                                letterSpacing = 1.5.sp
                            )
                            Text(
                                connectionStatus.uppercase(),
                                color = if (nearbyUsers.isNotEmpty()) StatusGreen else TextTertiary,
                                fontSize = 9.sp,
                                fontWeight = FontWeight.Bold,
                                letterSpacing = 1.sp
                            )
                        }
                    }
                },
                actions = {
                    // Nearby count badge
                    if (nearbyUsers.isNotEmpty()) {
                        Box(
                            modifier = Modifier
                                .clip(RoundedCornerShape(50))
                                .background(StatusGreen.copy(alpha = 0.15f))
                                .border(0.5.dp, StatusGreen.copy(alpha = 0.3f), RoundedCornerShape(50))
                                .padding(horizontal = 8.dp, vertical = 3.dp)
                        ) {
                            Text(
                                "${nearbyUsers.size} cerca",
                                fontSize = 9.sp,
                                fontWeight = FontWeight.ExtraBold,
                                letterSpacing = 0.5.sp,
                                color = StatusGreen
                            )
                        }
                        Spacer(Modifier.width(8.dp))
                    }
                }
            )

            // ‚îÄ‚îÄ Content ‚îÄ‚îÄ
            Box(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
            ) {
                when {
                    !isActive -> {
                        // Connecting state
                        Column(
                            modifier = Modifier.align(Alignment.Center),
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            val rotateAnim = rememberInfiniteTransition(label = "scan")
                            val rotation by rotateAnim.animateFloat(
                                initialValue = 0f, targetValue = 360f,
                                animationSpec = infiniteRepeatable(tween(3000, easing = LinearEasing)),
                                label = "rotate"
                            )
                            Icon(
                                Icons.Default.Bluetooth,
                                contentDescription = null,
                                tint = NeonCyan,
                                modifier = Modifier
                                    .size(48.dp)
                                    .graphicsLayer { rotationZ = rotation }
                            )
                            Spacer(Modifier.height(20.dp))
                            Text(
                                "BUSCANDO DISPOSITIVOS",
                                color = TextPrimary,
                                fontSize = 14.sp,
                                fontWeight = FontWeight.ExtraBold,
                                letterSpacing = 2.sp
                            )
                            Spacer(Modifier.height(6.dp))
                            Text(
                                "Conectando via Bluetooth...",
                                color = TextTertiary,
                                fontSize = 12.sp
                            )
                        }
                    }
                    messages.isEmpty() -> {
                        // Empty state
                        Column(
                            modifier = Modifier.align(Alignment.Center),
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Box(
                                modifier = Modifier
                                    .size(72.dp)
                                    .clip(RoundedCornerShape(20.dp))
                                    .background(NeonCyan.copy(alpha = 0.08f))
                                    .border(0.5.dp, NeonCyan.copy(alpha = 0.2f), RoundedCornerShape(20.dp)),
                                contentAlignment = Alignment.Center
                            ) {
                                Icon(
                                    Icons.Default.Forum,
                                    contentDescription = null,
                                    tint = NeonCyan,
                                    modifier = Modifier.size(32.dp)
                                )
                            }
                            Spacer(Modifier.height(20.dp))
                            Text(
                                "SIN MENSAJES",
                                color = TextPrimary,
                                fontSize = 16.sp,
                                fontWeight = FontWeight.ExtraBold,
                                letterSpacing = 2.sp
                            )
                            Spacer(Modifier.height(8.dp))
                            Text(
                                if (nearbyUsers.isNotEmpty())
                                    "Hay ${nearbyUsers.size} personas cerca ‚Äî ¬°s√© el primero!"
                                else "Esperando a que alguien se acerque...",
                                color = TextTertiary,
                                fontSize = 13.sp,
                                textAlign = TextAlign.Center,
                                modifier = Modifier.padding(horizontal = 40.dp)
                            )
                        }
                    }
                    else -> {
                        LazyColumn(
                            modifier = Modifier.fillMaxSize(),
                            state = listState,
                            contentPadding = PaddingValues(horizontal = 14.dp, vertical = 10.dp),
                            verticalArrangement = Arrangement.spacedBy(6.dp)
                        ) {
                            // BLE info banner
                            item {
                                Box(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .padding(bottom = 10.dp)
                                        .clip(RoundedCornerShape(12.dp))
                                        .background(NeonCyan.copy(alpha = 0.06f))
                                        .border(0.5.dp, NeonCyan.copy(alpha = 0.15f), RoundedCornerShape(12.dp))
                                        .padding(10.dp)
                                ) {
                                    Row(verticalAlignment = Alignment.CenterVertically) {
                                        Icon(
                                            Icons.Default.BluetoothSearching,
                                            null,
                                            tint = NeonCyan,
                                            modifier = Modifier.size(14.dp)
                                        )
                                        Spacer(Modifier.width(8.dp))
                                        Text(
                                            "P2P REAL VIA BLUETOOTH ‚Äî ~50M ALCANCE",
                                            color = NeonCyan.copy(alpha = 0.7f),
                                            fontSize = 9.sp,
                                            fontWeight = FontWeight.Bold,
                                            letterSpacing = 1.sp
                                        )
                                    }
                                }
                            }
                            items(messages, key = { it.id }) { message ->
                                PremiumChatBubble(
                                    senderName = message.senderName,
                                    text = message.text,
                                    time = timeFormat.format(Date(message.timestamp)),
                                    isMe = message.isMe
                                )
                            }
                        }
                    }
                }
            }

            // ‚îÄ‚îÄ Premium Quick Messages ‚îÄ‚îÄ
            AnimatedVisibility(
                visible = showQuickMessages,
                enter = fadeIn(tween(200)) + expandVertically(tween(300)),
                exit = fadeOut(tween(200)) + shrinkVertically(tween(300))
            ) {
                LazyRow(
                    contentPadding = PaddingValues(horizontal = 14.dp, vertical = 6.dp),
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    modifier = Modifier.background(CarbonBlack.copy(alpha = 0.6f))
                ) {
                    items(proximityChatManager.quickMessages.size) { index ->
                        Box(
                            modifier = Modifier
                                .clip(RoundedCornerShape(50))
                                .background(AccentSocial.copy(alpha = 0.1f))
                                .border(0.5.dp, AccentSocial.copy(alpha = 0.25f), RoundedCornerShape(50))
                                .clickable {
                                    proximityChatManager.sendQuickMessage(index)
                                    showQuickMessages = false
                                }
                                .padding(horizontal = 14.dp, vertical = 8.dp)
                        ) {
                            Text(
                                proximityChatManager.quickMessages[index],
                                fontSize = 12.sp,
                                color = AccentSocial,
                                fontWeight = FontWeight.Bold
                            )
                        }
                    }
                }
            }

            // ‚îÄ‚îÄ Premium Input Bar ‚îÄ‚îÄ
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .liquidGlass(shape = RoundedCornerShape(0.dp), showBorder = false)
                    .padding(horizontal = 12.dp, vertical = 8.dp)
            ) {
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    // Quick messages toggle
                    Box(
                        modifier = Modifier
                            .size(40.dp)
                            .clip(CircleShape)
                            .background(
                                if (showQuickMessages) AccentSocial.copy(alpha = 0.2f)
                                else MetalGrey.copy(alpha = 0.3f)
                            )
                            .clickable { showQuickMessages = !showQuickMessages },
                        contentAlignment = Alignment.Center
                    ) {
                        Icon(
                            if (showQuickMessages) Icons.Default.Close else Icons.Default.EmojiEmotions,
                            "Mensajes r√°pidos",
                            tint = if (showQuickMessages) AccentSocial else TextTertiary,
                            modifier = Modifier.size(20.dp)
                        )
                    }

                    Spacer(Modifier.width(8.dp))

                    // Text input
                    OutlinedTextField(
                        value = inputText,
                        onValueChange = { inputText = it.take(200) },
                        modifier = Modifier.weight(1f),
                        placeholder = {
                            Text(
                                "Mensaje a los cercanos...",
                                color = TextTertiary,
                                fontSize = 14.sp
                            )
                        },
                        maxLines = 2,
                        shape = RoundedCornerShape(20.dp),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedTextColor = TextPrimary,
                            unfocusedTextColor = TextPrimary,
                            focusedBorderColor = RacingRed.copy(alpha = 0.5f),
                            unfocusedBorderColor = Color.White.copy(alpha = 0.08f),
                            focusedContainerColor = MetalGrey.copy(alpha = 0.2f),
                            unfocusedContainerColor = MetalGrey.copy(alpha = 0.15f),
                            cursorColor = RacingRed
                        ),
                        enabled = isActive
                    )

                    Spacer(Modifier.width(8.dp))

                    // Send button
                    val canSend = inputText.isNotBlank() && isActive
                    Box(
                        modifier = Modifier
                            .size(44.dp)
                            .clip(CircleShape)
                            .background(
                                if (canSend) Brush.linearGradient(listOf(RacingRed, RacingRedBright))
                                else Brush.linearGradient(listOf(MetalGrey, PitLaneGrey))
                            )
                            .clickable(enabled = canSend) {
                                if (inputText.isNotBlank()) {
                                    proximityChatManager.sendMessage(inputText.trim())
                                    inputText = ""
                                }
                            },
                        contentAlignment = Alignment.Center
                    ) {
                        Icon(
                            Icons.AutoMirrored.Filled.Send,
                            "Enviar",
                            tint = if (canSend) Color.White else TextTertiary,
                            modifier = Modifier.size(20.dp)
                        )
                    }
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Premium Chat Bubble
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumChatBubble(
    senderName: String,
    text: String,
    time: String,
    isMe: Boolean
) {
    val alignment = if (isMe) Alignment.End else Alignment.Start
    val bubbleShape = RoundedCornerShape(
        topStart = 16.dp,
        topEnd = 16.dp,
        bottomStart = if (isMe) 16.dp else 4.dp,
        bottomEnd = if (isMe) 4.dp else 16.dp
    )

    Column(
        modifier = Modifier.fillMaxWidth(),
        horizontalAlignment = alignment
    ) {
        if (!isMe) {
            Text(
                senderName.uppercase(),
                fontSize = 9.sp,
                fontWeight = FontWeight.ExtraBold,
                letterSpacing = 1.sp,
                color = NeonCyan,
                modifier = Modifier.padding(start = 10.dp, bottom = 3.dp)
            )
        }

        Box(
            modifier = Modifier
                .widthIn(max = 280.dp)
                .clip(bubbleShape)
                .background(
                    if (isMe) {
                        Brush.linearGradient(
                            listOf(
                                RacingRed.copy(alpha = 0.25f),
                                RacingRedDark.copy(alpha = 0.15f)
                            )
                        )
                    } else {
                        Brush.linearGradient(
                            listOf(
                                MetalGrey.copy(alpha = 0.4f),
                                AsphaltGrey.copy(alpha = 0.3f)
                            )
                        )
                    },
                    bubbleShape
                )
                .border(
                    0.5.dp,
                    if (isMe) RacingRed.copy(alpha = 0.2f)
                    else Color.White.copy(alpha = 0.06f),
                    bubbleShape
                )
                .drawWithContent {
                    drawContent()
                    drawRect(
                        Brush.verticalGradient(
                            listOf(Color.White.copy(alpha = 0.03f), Color.Transparent),
                            startY = 0f,
                            endY = size.height * 0.4f
                        )
                    )
                }
                .padding(horizontal = 14.dp, vertical = 10.dp)
        ) {
            Column {
                Text(
                    text,
                    color = TextPrimary,
                    fontSize = 14.sp,
                    lineHeight = 20.sp
                )
                Spacer(Modifier.height(3.dp))
                Text(
                    time,
                    color = TextTertiary,
                    fontSize = 9.sp,
                    fontWeight = FontWeight.Bold,
                    textAlign = TextAlign.End,
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/share/QRScannerScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.share

import android.Manifest
import android.util.Log
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.content.ContextCompat
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.isGranted
import com.google.accompanist.permissions.rememberPermissionState
import com.google.zxing.BinaryBitmap
import com.google.zxing.MultiFormatReader
import com.google.zxing.PlanarYUVLuminanceSource
import com.google.zxing.common.HybridBinarizer
import java.nio.ByteBuffer
import java.util.concurrent.Executors

@OptIn(ExperimentalMaterial3Api::class, ExperimentalPermissionsApi::class)
@Composable
fun QRScannerScreen(
    navController: NavController,
    viewModel: ShareQRViewModel = viewModel(
        factory = object : androidx.lifecycle.ViewModelProvider.Factory {
            override fun <T : androidx.lifecycle.ViewModel> create(modelClass: Class<T>, extras: androidx.lifecycle.viewmodel.CreationExtras): T {
                val app = extras[androidx.lifecycle.ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY] as android.app.Application
                return ShareQRViewModel(
                     userPreferences = com.georacing.georacing.data.local.UserPreferencesDataStore(app.applicationContext)
                ) as T
            }
        }
    )
) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    val cameraPermissionState = rememberPermissionState(Manifest.permission.CAMERA)
    
    val isLoading by viewModel.isLoading.collectAsState()
    val errorMessage by viewModel.errorMessage.collectAsState()
    
    var scannedCode by remember { mutableStateOf<String?>(null) }
    var hasScanned by remember { mutableStateOf(false) }
    
    // Solicitar permiso de c√°mara al entrar
    LaunchedEffect(Unit) {
        if (!cameraPermissionState.status.isGranted) {
            cameraPermissionState.launchPermissionRequest()
        }
    }
    
    // Procesar c√≥digo escaneado
    LaunchedEffect(scannedCode) {
        if (scannedCode != null && !hasScanned) {
            hasScanned = true
            viewModel.joinSessionByCode(scannedCode!!)
            
            // Esperar a que termine y navegar al mapa
            kotlinx.coroutines.delay(1500)
            navController.navigate("group") {
                popUpTo("qr_scanner") { inclusive = true }
            }
        }
    }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Escanear c√≥digo QR") },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Volver")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            when {
                !cameraPermissionState.status.isGranted -> {
                    // Sin permiso de c√°mara
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(24.dp),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Text(
                            text = "Permiso de c√°mara necesario",
                            style = MaterialTheme.typography.titleMedium
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        Button(onClick = { cameraPermissionState.launchPermissionRequest() }) {
                            Text("Conceder permiso")
                        }
                    }
                }
                
                isLoading -> {
                    // Procesando c√≥digo
                    Column(
                        modifier = Modifier.fillMaxSize(),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        CircularProgressIndicator()
                        Spacer(modifier = Modifier.height(16.dp))
                        Text("Uni√©ndose al grupo...")
                    }
                }
                
                else -> {
                    // Vista de c√°mara
                    CameraPreview(
                        onQRCodeScanned = { code ->
                            if (scannedCode == null) {
                                scannedCode = code
                            }
                        }
                    )
                    
                    // Overlay con instrucciones
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .align(Alignment.TopCenter)
                            .padding(24.dp)
                    ) {
                        Card(
                            colors = CardDefaults.cardColors(
                                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)
                            )
                        ) {
                            Text(
                                text = "Apunta la c√°mara al c√≥digo QR",
                                modifier = Modifier.padding(16.dp),
                                style = MaterialTheme.typography.bodyLarge
                            )
                        }
                    }
                }
            }
            
            // Mostrar error si hay
            errorMessage?.let { error ->
                Snackbar(
                    modifier = Modifier
                        .align(Alignment.BottomCenter)
                        .padding(16.dp),
                    action = {
                        TextButton(onClick = { viewModel.clearError() }) {
                            Text("OK")
                        }
                    }
                ) {
                    Text(error)
                }
            }
        }
    }
}

@Composable
fun CameraPreview(
    onQRCodeScanned: (String) -> Unit
) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    val cameraProviderFuture = remember { ProcessCameraProvider.getInstance(context) }
    var cameraError by remember { mutableStateOf<String?>(null) }

    Box(modifier = Modifier.fillMaxSize()) {
    AndroidView(
        factory = { ctx ->
            val previewView = PreviewView(ctx)
            val executor = Executors.newSingleThreadExecutor()
            
            cameraProviderFuture.addListener({
                val cameraProvider = cameraProviderFuture.get()
                
                val preview = Preview.Builder().build().also {
                    it.setSurfaceProvider(previewView.surfaceProvider)
                }
                
                val imageAnalyzer = ImageAnalysis.Builder()
                    .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                    .build()
                    .also {
                        it.setAnalyzer(executor, QRCodeAnalyzer { qrCode ->
                            onQRCodeScanned(qrCode)
                        })
                    }
                
                val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA
                
                try {
                    cameraProvider.unbindAll()
                    cameraProvider.bindToLifecycle(
                        lifecycleOwner,
                        cameraSelector,
                        preview,
                        imageAnalyzer
                    )
                } catch (e: Exception) {
                    Log.e("QRScanner", "Error iniciando c√°mara", e)
                    cameraError = "Error al iniciar la c√°mara. Reint√©ntalo."
                }
            }, ContextCompat.getMainExecutor(ctx))
            
            previewView
        },
        modifier = Modifier.fillMaxSize()
    )

    cameraError?.let { error ->
        Card(
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .padding(16.dp),
            colors = CardDefaults.cardColors(
                containerColor = MaterialTheme.colorScheme.errorContainer
            )
        ) {
            Text(
                text = error,
                modifier = Modifier.padding(16.dp),
                color = MaterialTheme.colorScheme.onErrorContainer,
                style = MaterialTheme.typography.bodyMedium
            )
        }
    }
    } // Box
}

class QRCodeAnalyzer(
    private val onQRCodeScanned: (String) -> Unit
) : ImageAnalysis.Analyzer {
    
    private val reader = MultiFormatReader()
    private var lastScannedCode: String? = null
    private var lastScanTime = 0L
    
    @androidx.annotation.OptIn(ExperimentalGetImage::class)
    override fun analyze(imageProxy: ImageProxy) {
        val mediaImage = imageProxy.image
        if (mediaImage != null) {
            try {
                val buffer = mediaImage.planes[0].buffer
                val bytes = ByteArray(buffer.remaining())
                buffer.get(bytes)
                
                val source = PlanarYUVLuminanceSource(
                    bytes,
                    mediaImage.width,
                    mediaImage.height,
                    0, 0,
                    mediaImage.width,
                    mediaImage.height,
                    false
                )
                
                val binaryBitmap = BinaryBitmap(HybridBinarizer(source))
                
                try {
                    val result = reader.decode(binaryBitmap)
                    val currentTime = System.currentTimeMillis()
                    
                    // Evitar escaneos duplicados (cooldown de 2 segundos)
                    if (result.text != lastScannedCode || currentTime - lastScanTime > 2000) {
                        lastScannedCode = result.text
                        lastScanTime = currentTime
                        onQRCodeScanned(result.text)
                    }
                } catch (e: Exception) {
                    // No se encontr√≥ c√≥digo QR en este frame
                }
            } catch (e: Exception) {
                Log.e("QRCodeAnalyzer", "Error analizando imagen", e)
            }
        }
        
        imageProxy.close()
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/share/ShareQRScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.share

import android.graphics.Bitmap
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.QrCode
import androidx.compose.material.icons.filled.QrCodeScanner
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.material.icons.filled.Stop
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.georacing.georacing.ui.components.HomeIconButton
import com.georacing.georacing.ui.components.*
import com.georacing.georacing.ui.theme.*
import com.georacing.georacing.ui.navigation.Screen
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ShareQRScreen(
    navController: NavController,
    groupId: String,
    viewModel: ShareQRViewModel = viewModel(
        factory = object : androidx.lifecycle.ViewModelProvider.Factory {
            override fun <T : androidx.lifecycle.ViewModel> create(modelClass: Class<T>, extras: androidx.lifecycle.viewmodel.CreationExtras): T {
                val app = extras[androidx.lifecycle.ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY] as android.app.Application
                return ShareQRViewModel(
                     userPreferences = com.georacing.georacing.data.local.UserPreferencesDataStore(app.applicationContext)
                ) as T
            }
        }
    )
) {
    val currentSession by viewModel.currentSession.collectAsState()
    val qrBitmap by viewModel.qrBitmap.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()
    val errorMessage by viewModel.errorMessage.collectAsState()
    val groupMembers by viewModel.groupMembers.collectAsState()
    
    LaunchedEffect(groupId) {
        viewModel.loadSessionIfActive(groupId)
    }
    
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    listOf(Color(0xFF080810), Color(0xFF0A0A16), Color(0xFF080810))
                )
            )
    ) {
        Scaffold(
            containerColor = Color.Transparent,
            topBar = {
                TopAppBar(
                    title = { 
                        Text(
                            "COMPARTIR P2P",
                            style = MaterialTheme.typography.titleLarge.copy(
                                fontWeight = FontWeight.Black,
                                letterSpacing = 1.5.sp
                            ),
                            color = Color(0xFFF8FAFC)
                        ) 
                    },
                    navigationIcon = {
                        IconButton(onClick = { 
                            viewModel.deactivateCurrentSession()
                            navController.popBackStack()
                        }) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Atr√°s", tint = Color(0xFFF8FAFC))
                        }
                    },
                    actions = {
                        HomeIconButton {
                            navController.navigate(Screen.Home.route) {
                                popUpTo(Screen.Home.route) { inclusive = true }
                            }
                        }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = Color.Transparent,
                        titleContentColor = Color(0xFFF8FAFC)
                    )
                )
            }
        ) { padding ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
                    .padding(16.dp)
                    .verticalScroll(rememberScrollState()),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Top
            ) {
                // T√≠tulo
                Text(
                    text = "COMPARTIR CON QR",
                    style = MaterialTheme.typography.headlineMedium,
                    fontWeight = FontWeight.Black,
                    color = Color(0xFFF8FAFC),
                    letterSpacing = 1.5.sp
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Text(
                    text = "Comparte tu ubicaci√≥n durante el evento del d√≠a",
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center,
                    color = Color(0xFF64748B)
                )
                
                Spacer(modifier = Modifier.height(24.dp))
                
                // Tarjeta con QR
                GlassCard(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 8.dp)
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(24.dp),
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        if (isLoading) {
                            CircularProgressIndicator(color = Color(0xFFE8253A))
                            Spacer(modifier = Modifier.height(16.dp))
                            Text("Generando c√≥digo QR...", color = Color(0xFF64748B), letterSpacing = 0.5.sp)
                        } else if (qrBitmap != null && currentSession != null) {
                            // Mostrar QR
                            QRCodeDisplay(
                                bitmap = qrBitmap!!,
                                session = currentSession!!
                            )
                        } else {
                            // Sin sesi√≥n activa
                            Box(
                                modifier = Modifier
                                    .size(120.dp)
                                    .background(Color(0xFF06B6D4).copy(alpha = 0.1f), RoundedCornerShape(24.dp)),
                                contentAlignment = Alignment.Center
                            ) {
                                Icon(
                                    imageVector = Icons.Default.QrCode,
                                    contentDescription = null,
                                    modifier = Modifier.size(64.dp),
                                    tint = Color(0xFF06B6D4).copy(alpha = 0.6f)
                                )
                            }
                            
                            Spacer(modifier = Modifier.height(16.dp))
                            
                            Text(
                                text = "No hay c√≥digo QR activo",
                                style = MaterialTheme.typography.titleMedium,
                                color = Color(0xFFF8FAFC),
                                fontWeight = FontWeight.Bold,
                                letterSpacing = 0.5.sp
                            )
                            
                            Spacer(modifier = Modifier.height(8.dp))
                            
                            Text(
                                text = "Genera uno nuevo para compartir tu ubicaci√≥n hoy",
                                style = MaterialTheme.typography.bodySmall,
                                textAlign = TextAlign.Center,
                                color = Color(0xFF64748B)
                            )
                        }
                    }
                }
                
                Spacer(modifier = Modifier.height(24.dp))
                
                // Botones de acci√≥n
                if (currentSession != null) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        OutlinedButton(
                            onClick = { viewModel.deactivateCurrentSession() },
                            modifier = Modifier.weight(1f).height(56.dp),
                            colors = ButtonDefaults.outlinedButtonColors(contentColor = Color(0xFFEF4444)),
                            border = androidx.compose.foundation.BorderStroke(1.dp, Color(0xFFEF4444)),
                            shape = RoundedCornerShape(12.dp)
                        ) {
                            Icon(Icons.Default.Stop, contentDescription = null)
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("Desactivar", fontWeight = FontWeight.Bold, letterSpacing = 0.5.sp)
                        }
                        
                        RacingButton(
                            text = "Renovar",
                            onClick = { viewModel.generateQRSession(groupId, Date()) },
                            modifier = Modifier.weight(1f)
                        )
                    }
                } else {
                    RacingButton(
                        text = "Generar C√≥digo QR",
                        onClick = { viewModel.generateQRSession(groupId, Date()) },
                        modifier = Modifier.fillMaxWidth()
                    )
                }
                
                Spacer(modifier = Modifier.height(32.dp))
                
                // Lista de miembros que se han unido
                if (groupMembers.isNotEmpty()) {
                    HorizontalDivider(color = Color(0xFF14141C))
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Text(
                        text = "MIEMBROS UNIDOS (${groupMembers.size})",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Black,
                        color = Color(0xFF64748B),
                        letterSpacing = 1.5.sp
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    GlassCard(modifier = Modifier.fillMaxWidth()) {
                        Column(modifier = Modifier.padding(8.dp)) {
                            groupMembers.forEach { member ->
                                Row(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .padding(12.dp),
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    Box(
                                        modifier = Modifier
                                            .size(36.dp)
                                            .background(Color(0xFF06B6D4).copy(alpha = 0.15f), RoundedCornerShape(10.dp)),
                                        contentAlignment = Alignment.Center
                                    ) {
                                        Icon(
                                            imageVector = Icons.Default.Person,
                                            contentDescription = null,
                                            modifier = Modifier.size(20.dp),
                                            tint = Color(0xFF06B6D4)
                                        )
                                    }
                                    Spacer(modifier = Modifier.width(12.dp))
                                    Text(
                                        text = member.displayName,
                                        style = MaterialTheme.typography.bodyMedium,
                                        color = Color(0xFFF8FAFC),
                                        fontWeight = FontWeight.SemiBold
                                    )
                                }
                            }
                        }
                    }
                }
                
                Spacer(modifier = Modifier.height(16.dp))
                
                // Divider
                HorizontalDivider(color = Color(0xFF14141C))
                
                Spacer(modifier = Modifier.height(24.dp))
                
                // Secci√≥n para escanear
                Text(
                    text = "¬øTIENES UN C√ìDIGO QR?",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Black,
                    color = Color(0xFFF8FAFC),
                    letterSpacing = 1.sp
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Text(
                    text = "Escan√©alo para unirte a un grupo y ver ubicaciones",
                    style = MaterialTheme.typography.bodySmall,
                    textAlign = TextAlign.Center,
                    color = Color(0xFF64748B)
                )
                
                Spacer(modifier = Modifier.height(16.dp))
                
                OutlinedButton(
                    onClick = { 
                        // TODO: Implementar esc√°ner QR con CameraX
                        navController.navigate("qr_scanner")
                    },
                    modifier = Modifier.fillMaxWidth().height(56.dp),
                    shape = RoundedCornerShape(12.dp),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = Color(0xFFF8FAFC)),
                    border = androidx.compose.foundation.BorderStroke(1.dp, Color(0xFF06B6D4))
                ) {
                    Icon(Icons.Default.QrCodeScanner, contentDescription = null, tint = Color(0xFF06B6D4))
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("ESCANEAR C√ìDIGO QR", fontWeight = FontWeight.Bold, letterSpacing = 1.sp)
                }
                
                // Mostrar errores
                errorMessage?.let { error ->
                    Spacer(modifier = Modifier.height(16.dp))
                    GlassCard(modifier = Modifier.fillMaxWidth()) {
                        Text(
                            text = error,
                            modifier = Modifier.padding(16.dp),
                            color = Color(0xFFEF4444),
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun QRCodeDisplay(
    bitmap: Bitmap,
    session: com.georacing.georacing.data.model.ShareSession
) {
    val dateFormat = SimpleDateFormat("dd/MM/yyyy HH:mm", Locale.getDefault())
    
    Column(
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // QR Code - NEEDS WHITE BACKGROUND
        Box(
            modifier = Modifier
                .size(280.dp)
                .background(Color.White, RoundedCornerShape(16.dp))
                .padding(16.dp)
        ) {
            Image(
                bitmap = bitmap.asImageBitmap(),
                contentDescription = "C√≥digo QR",
                modifier = Modifier.fillMaxSize()
            )
        }
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // Info de la sesi√≥n
        Text(
            text = "V√ÅLIDO HASTA:",
            style = MaterialTheme.typography.labelMedium,
            color = Color(0xFF64748B),
            letterSpacing = 1.5.sp,
            fontWeight = FontWeight.Bold
        )
        
        Text(
            text = dateFormat.format(session.expiresAt.toDate()),
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Black,
            color = Color(0xFFE8253A)
        )
        
        Spacer(modifier = Modifier.height(8.dp))
        
        Text(
            text = "Creado por: ${session.ownerName}",
            style = MaterialTheme.typography.bodySmall,
            color = Color(0xFF64748B)
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/share/ShareQRViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.share

import android.graphics.Bitmap
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.data.model.ShareSession
import com.georacing.georacing.data.repository.NetworkGroupRepository
import com.georacing.georacing.data.repository.ShareSessionRepository
import com.google.zxing.BarcodeFormat
import com.google.zxing.EncodeHintType
import com.google.zxing.qrcode.QRCodeWriter
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import java.util.*

/**
 * ViewModel para gestionar sesiones QR (Simplificado para usar API NAS)
 */
class ShareQRViewModel(
    private val repository: NetworkGroupRepository = NetworkGroupRepository(),
    private val userPreferences: com.georacing.georacing.data.local.UserPreferencesDataStore
) : ViewModel() {
    
    // ... existing StateFlows ...
    private val _currentSession = MutableStateFlow<ShareSession?>(null)
    val currentSession: StateFlow<ShareSession?> = _currentSession.asStateFlow()
    
    private val _qrBitmap = MutableStateFlow<Bitmap?>(null)
    val qrBitmap: StateFlow<Bitmap?> = _qrBitmap.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
    
    private val _errorMessage = MutableStateFlow<String?>(null)
    val errorMessage: StateFlow<String?> = _errorMessage.asStateFlow()
    
    private val _groupMembers = MutableStateFlow<List<GroupMember>>(emptyList())
    val groupMembers: StateFlow<List<GroupMember>> = _groupMembers.asStateFlow()

    // Repositorio dedicado para sesiones QR
    private val shareRepository = ShareSessionRepository()
    
    companion object {
        private const val TAG = "ShareQRViewModel"
        private const val QR_SIZE = 512
    }
    
    data class GroupMember(
        val userId: String,
        val displayName: String,
        val photoUrl: String,
        val joinedAt: Date
    )
    
    fun createNewGroup(groupName: String) {
        _isLoading.value = true
        viewModelScope.launch {
            try {
                val groupId = UUID.randomUUID().toString().substring(0, 8).uppercase()
                val currentUser = com.google.firebase.auth.FirebaseAuth.getInstance().currentUser
                val userId = currentUser?.uid ?: "anon_${UUID.randomUUID()}"
                
                repository.createGroup(groupId, userId, groupName)
                
                // Persist
                userPreferences.setActiveGroupId(groupId)
                
                // Setup Session
                generateQRSession(groupId)
                
                Log.d(TAG, "Group Created: $groupId ($groupName)")
            } catch (e: Exception) {
                _errorMessage.value = "Error creating group: ${e.message}"
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    fun loadSessionIfActive(groupId: String) {
        if (_currentSession.value == null) {
            generateQRSession(groupId)
        }
    }
    
    fun generateQRSession(groupId: String, eventDate: Date = Date()) {
        _isLoading.value = true
        viewModelScope.launch {
            try {
                val sessionId = groupId
                val session = ShareSession(
                    sessionId = sessionId,
                    ownerId = "current",
                    ownerName = "User",
                    eventDate = com.google.firebase.Timestamp(eventDate),
                    expiresAt = com.google.firebase.Timestamp(Date(System.currentTimeMillis() + 86400000)),
                    createdAt = com.google.firebase.Timestamp.now(),
                    isActive = true,
                    groupId = groupId
                )
                _currentSession.value = session
                generateQRCode(groupId)
                listenToGroupMembers(groupId)
            } catch (e: Exception) {
                 _errorMessage.value = "Error: ${e.message}"
            } finally {
                _isLoading.value = false
            }
        }
    }

    private fun listenToGroupMembers(groupId: String) {
        viewModelScope.launch {
             val currentUser = com.google.firebase.auth.FirebaseAuth.getInstance().currentUser
             val currentUserId = currentUser?.uid
             repository.getGroupMembers(groupId).collectLatest { locations ->
                 _groupMembers.value = locations.map { loc ->
                     GroupMember(
                         userId = loc.userId,
                         displayName = loc.displayName ?: "Usuario",
                         photoUrl = loc.photoUrl ?: "",
                         joinedAt = loc.lastUpdated.toDate()
                     )
                 }
             }
        }
    }
    
    fun joinSessionByCode(code: String) {
        _isLoading.value = true
        viewModelScope.launch {
            try {
                // El c√≥digo escaneado es el sessionId (que actualmente es igual al groupId)
                val result = shareRepository.joinSessionGroup(code)
                
                if (result.isSuccess) {
                    val groupId = result.getOrNull()!!
                    userPreferences.setActiveGroupId(groupId)
                    Log.d(TAG, "‚úÖ Unido al grupo exitosamente: $groupId")
                } else {
                    val exception = result.exceptionOrNull()
                    Log.e(TAG, "‚ùå Error uni√©ndose al grupo con c√≥digo: $code", exception)
                    _errorMessage.value = "Error al unirse: ${exception?.message ?: "Desconocido"}"
                }
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Excepci√≥n en joinSessionByCode", e)
                _errorMessage.value = "Error: ${e.message}"
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    // ... generateQRCode ...
    private fun generateQRCode(content: String) {
        try {
            val hints = mapOf(
                EncodeHintType.CHARACTER_SET to "UTF-8",
                EncodeHintType.MARGIN to 1
            )
            val writer = QRCodeWriter()
            val bitMatrix = writer.encode(content, BarcodeFormat.QR_CODE, QR_SIZE, QR_SIZE, hints)
            val bitmap = Bitmap.createBitmap(QR_SIZE, QR_SIZE, Bitmap.Config.RGB_565)
            for (x in 0 until QR_SIZE) {
                for (y in 0 until QR_SIZE) {
                    bitmap.setPixel(x, y, if (bitMatrix[x, y]) android.graphics.Color.BLACK else android.graphics.Color.WHITE)
                }
            }
            _qrBitmap.value = bitmap
        } catch (e: Exception) {
            _errorMessage.value = "Error generating QR: ${e.message}"
        }
    }

    fun clearError() { _errorMessage.value = null }
    fun deactivateCurrentSession() { _currentSession.value = null; _qrBitmap.value = null }
    override fun onCleared() { super.onCleared(); deactivateCurrentSession() }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/share/WrappedScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.share

import android.content.Intent
import android.util.Log
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.clickable
import androidx.compose.animation.core.*
import androidx.compose.animation.fadeIn
import androidx.compose.animation.slideInVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.georacing.georacing.data.firestorelike.FirestoreLikeClient
import com.georacing.georacing.data.gamification.GamificationRepository
import com.georacing.georacing.data.health.HealthConnectManager
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.theme.*

/**
 * GeoRacing Wrapped ‚Äî Resumen post-evento con DATOS REALES.
 * Premium version con CarbonBackground + LiquidGlass.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun WrappedScreen(
    onNavigateBack: () -> Unit = {},
    healthConnectManager: HealthConnectManager? = null,
    gamificationRepository: GamificationRepository? = null
) {
    val backdrop = LocalBackdrop.current
    val context = LocalContext.current

    // ‚îÄ‚îÄ Datos reales ‚îÄ‚îÄ
    var stepsCount by remember { mutableIntStateOf(0) }
    var distanceWalkedKm by remember { mutableStateOf(0.0) }
    var achievementsUnlocked by remember { mutableIntStateOf(0) }
    var totalAchievements by remember { mutableIntStateOf(0) }
    var totalXP by remember { mutableIntStateOf(0) }
    var level by remember { mutableIntStateOf(1) }
    var ordersPlaced by remember { mutableIntStateOf(0) }
    var totalSpent by remember { mutableStateOf(0.0) }
    var photosCount by remember { mutableIntStateOf(0) }
    var isLoading by remember { mutableStateOf(true) }
    var showContent by remember { mutableStateOf(false) }

    val eventName = "GP de Espa√±a 2025"
    val circuitName = "Circuit de Barcelona-Catalunya"

    // Cargar datos reales
    LaunchedEffect(Unit) {
        // 1. HealthConnect ‚Äî pasos y distancia
        try {
            healthConnectManager?.let { hc ->
                val metrics = hc.readDailyMetrics()
                stepsCount = metrics.steps.toInt()
                distanceWalkedKm = metrics.distanceMeters / 1000.0
            }
        } catch (e: Exception) {
            Log.w("WrappedScreen", "HealthConnect no disponible: ${e.message}")
        }

        // 2. Gamification ‚Äî logros
        try {
            gamificationRepository?.let { repo ->
                val profile = repo.profile.value
                achievementsUnlocked = profile.achievements.count { it.isUnlocked }
                totalAchievements = profile.achievements.size
                totalXP = profile.totalXP
                level = profile.level
            }
        } catch (e: Exception) {
            Log.w("WrappedScreen", "Gamification error: ${e.message}")
        }

        // 3. Backend ‚Äî pedidos y fotos
        try {
            val orders = FirestoreLikeClient.api.read("orders")
            ordersPlaced = orders.size
            totalSpent = orders.sumOf { (it["total"] as? Number)?.toDouble() ?: 0.0 }
        } catch (e: Exception) {
            Log.w("WrappedScreen", "No se pudieron cargar pedidos: ${e.message}")
        }

        try {
            val photos = FirestoreLikeClient.api.read("moments")
            photosCount = photos.size
        } catch (e: Exception) {
            Log.w("WrappedScreen", "No se pudieron cargar fotos: ${e.message}")
        }

        isLoading = false
        showContent = true
    }

    val co2Saved = "%.1f".format(distanceWalkedKm * 0.21)

    Box(Modifier.fillMaxSize()) {
        CarbonBackground()

        Column(Modifier.fillMaxSize()) {
            // ‚îÄ‚îÄ Premium LiquidTopBar ‚îÄ‚îÄ
            LiquidTopBar(
                backdrop = backdrop,
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Volver", tint = TextPrimary)
                    }
                },
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Box(Modifier.size(8.dp).clip(CircleShape).background(ChampagneGold))
                        Spacer(Modifier.width(10.dp))
                        Column {
                            Text("TU WRAPPED", style = MaterialTheme.typography.titleMedium, color = TextPrimary, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                            Text(eventName, style = MaterialTheme.typography.labelSmall, color = TextTertiary)
                        }
                    }
                },
                actions = {
                    IconButton(onClick = {
                        val shareText = buildShareText(
                            eventName, circuitName, stepsCount, distanceWalkedKm,
                            achievementsUnlocked, totalAchievements, photosCount,
                            ordersPlaced, co2Saved
                        )
                        val sendIntent = Intent().apply {
                            action = Intent.ACTION_SEND
                            putExtra(Intent.EXTRA_TEXT, shareText)
                            type = "text/plain"
                        }
                        context.startActivity(Intent.createChooser(sendIntent, "Compartir mi Wrapped"))
                    }) {
                        Icon(Icons.Default.Share, "Compartir", tint = ChampagneGold)
                    }
                }
            )

            if (isLoading) {
                Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        val pulseAnim = rememberInfiniteTransition(label = "p")
                        val pulseScale by pulseAnim.animateFloat(
                            initialValue = 0.8f, targetValue = 1.2f,
                            animationSpec = infiniteRepeatable(tween(800), RepeatMode.Reverse), label = "s"
                        )
                        Box(
                            Modifier
                                .size(64.dp)
                                .graphicsLayer { scaleX = pulseScale; scaleY = pulseScale }
                                .drawBehind {
                                    drawCircle(ChampagneGold.copy(alpha = 0.15f), radius = size.minDimension / 2)
                                },
                            contentAlignment = Alignment.Center
                        ) {
                            CircularProgressIndicator(color = ChampagneGold, strokeWidth = 3.dp, modifier = Modifier.size(40.dp))
                        }
                        Spacer(Modifier.height(16.dp))
                        Text("Recopilando tus datos reales...", color = TextTertiary, fontSize = 12.sp, letterSpacing = 1.sp)
                    }
                }
            } else {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .verticalScroll(rememberScrollState())
                        .padding(horizontal = 16.dp)
                ) {
                    Spacer(Modifier.height(8.dp))

                    // ‚îÄ‚îÄ Hero Header Card ‚îÄ‚îÄ
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(600)) + slideInVertically(tween(600)) { 50 }
                    ) {
                        Box(
                            Modifier
                                .fillMaxWidth()
                                .clip(RoundedCornerShape(24.dp))
                                .liquidGlass(RoundedCornerShape(24.dp), GlassLevel.L3, accentGlow = RacingRed)
                        ) {
                            Box(
                                Modifier
                                    .fillMaxWidth()
                                    .background(
                                        Brush.verticalGradient(
                                            listOf(RacingRed.copy(alpha = 0.12f), NeonPurple.copy(alpha = 0.05f), Color.Transparent)
                                        )
                                    )
                                    .padding(28.dp),
                                contentAlignment = Alignment.Center
                            ) {
                                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                    Text("üèÅ", fontSize = 56.sp)
                                    Spacer(Modifier.height(8.dp))
                                    Text(
                                        eventName,
                                        style = MaterialTheme.typography.headlineSmall,
                                        fontWeight = FontWeight.Black,
                                        color = TextPrimary,
                                        letterSpacing = 0.5.sp
                                    )
                                    Text(circuitName, style = MaterialTheme.typography.bodyMedium, color = TextSecondary)
                                    Spacer(Modifier.height(12.dp))
                                    Row(
                                        Modifier
                                            .clip(RoundedCornerShape(20.dp))
                                            .background(RacingRed.copy(alpha = 0.15f))
                                            .padding(horizontal = 16.dp, vertical = 6.dp),
                                        verticalAlignment = Alignment.CenterVertically
                                    ) {
                                        Text("Nivel $level", color = RacingRed, fontWeight = FontWeight.Black, fontSize = 14.sp)
                                        Spacer(Modifier.width(8.dp))
                                        Text("¬∑", color = TextTertiary)
                                        Spacer(Modifier.width(8.dp))
                                        Text("${totalXP} XP", color = ChampagneGold, fontWeight = FontWeight.Bold, fontSize = 14.sp)
                                    }
                                }
                            }
                        }
                    }

                    Spacer(Modifier.height(20.dp))

                    // ‚îÄ‚îÄ Movement Section ‚îÄ‚îÄ
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(500, 200)) + slideInVertically(tween(500, 200)) { 30 }
                    ) {
                        PremiumWrappedSection(
                            title = "TU MOVIMIENTO",
                            icon = Icons.Default.DirectionsWalk,
                            accentColor = StatusGreen
                        ) {
                            if (stepsCount == 0 && distanceWalkedKm == 0.0) {
                                Text("Sin datos de HealthConnect. Activa los permisos.", style = MaterialTheme.typography.bodySmall, color = TextTertiary)
                            } else {
                                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                                    PremiumStatBubble("Pasos", if (stepsCount > 1000) "${stepsCount / 1000}K" else "$stepsCount", "ü¶∂", StatusGreen)
                                    PremiumStatBubble("Andado", "%.1f km".format(distanceWalkedKm), "üö∂", ElectricBlue)
                                }
                            }
                        }
                    }

                    Spacer(Modifier.height(12.dp))

                    // ‚îÄ‚îÄ Achievements Section ‚îÄ‚îÄ
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(500, 350)) + slideInVertically(tween(500, 350)) { 30 }
                    ) {
                        PremiumWrappedSection(
                            title = "LOGROS",
                            icon = Icons.Default.EmojiEvents,
                            accentColor = ChampagneGold
                        ) {
                            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                                PremiumStatBubble("Logros", "$achievementsUnlocked/$totalAchievements", "üèÖ", ChampagneGold)
                                PremiumStatBubble("Fotos", "$photosCount", "üì∏", NeonPurple)
                                PremiumStatBubble("Nivel", "$level", "‚≠ê", RacingRed)
                            }
                        }
                    }

                    Spacer(Modifier.height(12.dp))

                    // ‚îÄ‚îÄ Gastron√≥mico Section ‚îÄ‚îÄ
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(500, 500)) + slideInVertically(tween(500, 500)) { 30 }
                    ) {
                        PremiumWrappedSection(
                            title = "GASTRON√ìMICO",
                            icon = Icons.Default.Restaurant,
                            accentColor = NeonCyan
                        ) {
                            if (ordersPlaced == 0) {
                                Text("No has realizado pedidos a√∫n.", style = MaterialTheme.typography.bodySmall, color = TextTertiary)
                            } else {
                                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                                    PremiumStatBubble("Pedidos", "$ordersPlaced", "üõí", NeonCyan)
                                    PremiumStatBubble("Gastado", "%.1f‚Ç¨".format(totalSpent), "üí∞", StatusGreen)
                                }
                            }
                        }
                    }

                    Spacer(Modifier.height(12.dp))

                    // ‚îÄ‚îÄ Eco Impact Section ‚îÄ‚îÄ
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(500, 650)) + slideInVertically(tween(500, 650)) { 30 }
                    ) {
                        Box(
                            Modifier
                                .fillMaxWidth()
                                .clip(RoundedCornerShape(18.dp))
                                .liquidGlass(RoundedCornerShape(18.dp), GlassLevel.L2, accentGlow = StatusGreen)
                        ) {
                            Box(
                                Modifier
                                    .fillMaxWidth()
                                    .background(
                                        Brush.horizontalGradient(
                                            listOf(StatusGreen.copy(alpha = 0.06f), Color.Transparent)
                                        )
                                    )
                                    .padding(20.dp)
                            ) {
                                Row(verticalAlignment = Alignment.CenterVertically) {
                                    Box(
                                        Modifier
                                            .size(52.dp)
                                            .clip(RoundedCornerShape(16.dp))
                                            .background(StatusGreen.copy(alpha = 0.12f))
                                            .drawBehind {
                                                drawCircle(StatusGreen.copy(alpha = 0.06f), radius = size.minDimension * 0.9f)
                                            },
                                        contentAlignment = Alignment.Center
                                    ) {
                                        Text("üå±", fontSize = 28.sp)
                                    }
                                    Spacer(Modifier.width(16.dp))
                                    Column {
                                        Text(
                                            "$co2Saved kg CO‚ÇÇ ahorrados",
                                            style = MaterialTheme.typography.titleMedium,
                                            fontWeight = FontWeight.Black,
                                            color = StatusGreen
                                        )
                                        Text(
                                            "Caminando en vez de usar transporte motorizado",
                                            style = MaterialTheme.typography.bodySmall,
                                            color = TextSecondary,
                                            lineHeight = 16.sp
                                        )
                                    }
                                }
                            }
                        }
                    }

                    Spacer(Modifier.height(12.dp))

                    Text(
                        "Datos reales ¬∑ HealthConnect + Backend",
                        style = MaterialTheme.typography.labelSmall,
                        color = TextTertiary.copy(alpha = 0.5f),
                        modifier = Modifier.fillMaxWidth(),
                        textAlign = TextAlign.Center
                    )

                    Spacer(Modifier.height(20.dp))

                    // ‚îÄ‚îÄ Share Button ‚îÄ‚îÄ
                    AnimatedVisibility(
                        visible = showContent,
                        enter = fadeIn(tween(500, 800)) + slideInVertically(tween(500, 800)) { 20 }
                    ) {
                        Box(
                            Modifier
                                .fillMaxWidth()
                                .height(52.dp)
                                .clip(RoundedCornerShape(14.dp))
                                .background(
                                    Brush.horizontalGradient(listOf(RacingRed, Color(0xFFFF4D6D)))
                                )
                                .clickable {
                                    val shareText = buildShareText(eventName, circuitName, stepsCount, distanceWalkedKm, achievementsUnlocked, totalAchievements, photosCount, ordersPlaced, co2Saved)
                                    val sendIntent = Intent().apply { action = Intent.ACTION_SEND; putExtra(Intent.EXTRA_TEXT, shareText); type = "text/plain" }
                                    context.startActivity(Intent.createChooser(sendIntent, "Compartir"))
                                },
                            contentAlignment = Alignment.Center
                        ) {
                            Row(verticalAlignment = Alignment.CenterVertically) {
                                Icon(Icons.Default.Share, null, tint = TextPrimary, modifier = Modifier.size(20.dp))
                                Spacer(Modifier.width(10.dp))
                                Text("COMPARTIR MI WRAPPED", color = TextPrimary, fontWeight = FontWeight.Black, letterSpacing = 1.sp)
                            }
                        }
                    }

                    Spacer(Modifier.height(100.dp))
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚îÄ‚îÄ Premium Composables ‚îÄ‚îÄ
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumWrappedSection(
    title: String,
    icon: ImageVector,
    accentColor: Color,
    content: @Composable ColumnScope.() -> Unit
) {
    Box(
        Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(18.dp))
            .liquidGlass(RoundedCornerShape(18.dp), GlassLevel.L2, accentGlow = accentColor)
    ) {
        Column(Modifier.padding(20.dp)) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Box(
                    Modifier
                        .size(32.dp)
                        .clip(RoundedCornerShape(10.dp))
                        .background(accentColor.copy(alpha = 0.12f)),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(icon, null, tint = accentColor, modifier = Modifier.size(16.dp))
                }
                Spacer(Modifier.width(10.dp))
                Text(
                    title,
                    style = MaterialTheme.typography.labelMedium,
                    color = TextTertiary,
                    letterSpacing = 2.sp,
                    fontWeight = FontWeight.Black
                )
            }
            Spacer(Modifier.height(16.dp))
            content()
        }
    }
}

@Composable
private fun PremiumStatBubble(label: String, value: String, emoji: String, color: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Box(
            Modifier
                .size(68.dp)
                .clip(CircleShape)
                .background(color.copy(alpha = 0.1f))
                .drawBehind {
                    drawCircle(color.copy(alpha = 0.06f), radius = size.minDimension / 1.5f)
                },
            contentAlignment = Alignment.Center
        ) {
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                Text(emoji, fontSize = 18.sp)
                Text(value, fontSize = 14.sp, fontWeight = FontWeight.Black, color = color)
            }
        }
        Spacer(Modifier.height(6.dp))
        Text(label, style = MaterialTheme.typography.labelSmall, color = TextTertiary, fontSize = 10.sp)
    }
}

private fun buildShareText(
    eventName: String, circuitName: String, steps: Int, distKm: Double,
    achievementsUnl: Int, achievementsTotal: Int, photos: Int, orders: Int, co2: String
): String = """
üèÅ Mi GeoRacing Wrapped ‚Äî $eventName

üö∂ ${"%.1f".format(distKm)} km andados ($steps pasos)
üèÜ $achievementsUnl/$achievementsTotal logros desbloqueados
üì∏ $photos momentos capturados
üõí $orders pedidos realizados
üå± $co2 kg CO‚ÇÇ ahorrados

¬°Descarga GeoRacing y vive el circuito! üèéÔ∏è
#GeoRacing #Wrapped #${eventName.replace(" ", "")}
""".trimIndent()

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/splash/SplashScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.splash

import android.util.Log
import androidx.compose.animation.core.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavHostController
import com.georacing.georacing.data.firebase.FirebaseInitializer
import com.georacing.georacing.ui.navigation.Screen
import kotlinx.coroutines.delay

@Composable
fun SplashScreen(navController: NavHostController) {
    var progress by remember { mutableFloatStateOf(0f) }
    var startAnimation by remember { mutableStateOf(false) }
    var statusMessage by remember { mutableStateOf("Iniciando...") }
    
    val alpha by animateFloatAsState(
        targetValue = if (startAnimation) 1f else 0f,
        animationSpec = tween(durationMillis = 800, easing = FastOutSlowInEasing),
        label = "fade"
    )
    
    val carScale by animateFloatAsState(
        targetValue = if (startAnimation) 1f else 0.5f,
        animationSpec = spring(dampingRatio = Spring.DampingRatioMediumBouncy, stiffness = Spring.StiffnessLow),
        label = "scale"
    )
    
    val carOffsetY by animateDpAsState(
        targetValue = if (startAnimation) 0.dp else 50.dp,
        animationSpec = spring(dampingRatio = Spring.DampingRatioMediumBouncy),
        label = "offsetY"
    )
    
    LaunchedEffect(Unit) {
        startAnimation = true
        delay(300)
        
        // FASE 1: Verificar Firebase
        statusMessage = "Inicializando Firebase..."
        progress = 0.3f
        
        val firebaseInitialized = FirebaseInitializer.verifyInitialization()
        
        if (!firebaseInitialized) {
            Log.e("SplashScreen", "Firebase no inicializado")
            statusMessage = "Error de conexi√≥n"
            delay(1500)
        }
        
        // FASE 2: Verificar si hay usuario logueado con Google
        statusMessage = "Verificando sesi√≥n..."
        progress = 0.6f
        delay(500)
        
        val authService = com.georacing.georacing.data.firebase.FirebaseAuthService()
        val currentUser = authService.getCurrentUser()
        
        progress = 0.9f
        statusMessage = "Preparando experiencia..."
        delay(500)
        
        progress = 1f
        statusMessage = "¬°Listo!"
        delay(300)
        
        // Decidir navegaci√≥n basada en si hay usuario
        if (currentUser != null && !currentUser.isAnonymous) {
            // Usuario con Google logueado ‚Üí ir a Home
            Log.d("SplashScreen", "‚úÖ Usuario Google logueado: ${currentUser.email}")
            
            // Garantizar que la DB SQL tiene los datos (importante tras reinstalaci√≥n de app)
            try {
                kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {
                    com.georacing.georacing.data.repository.NetworkUserRepository().registerUser(
                        uid = currentUser.uid,
                        name = currentUser.displayName,
                        email = currentUser.email,
                        photoUrl = currentUser.photoUrl?.toString()
                    )
                }
            } catch (e: Exception) {
                Log.w("SplashScreen", "Error registrando usuario en background", e)
            }

            Log.d("SplashScreen", "Navegando a Home...")
            navController.navigate(Screen.Home.route) {
                popUpTo(0) { inclusive = true }
            }
        } else {
            // Sin usuario o an√≥nimo ‚Üí ir a Login
            Log.d("SplashScreen", "‚ùå Sin usuario con Google ‚Üí Login")
            Log.d("SplashScreen", "Usuario actual: $currentUser")
            Log.d("SplashScreen", "Es an√≥nimo: ${currentUser?.isAnonymous}")
            Log.d("SplashScreen", "Navegando a Login (route=${Screen.Login.route})...")
            navController.navigate(Screen.Login.route) {
                popUpTo(0) { inclusive = true }
            }
        }
    }
    
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        Color(0xFF06060C),
                        Color(0xFF0A0A12),
                        Color(0xFF080810)
                    )
                )
            ),
        contentAlignment = Alignment.Center
    ) {
        // ‚îÄ‚îÄ Ambient racing glow ‚îÄ‚îÄ
        Canvas(modifier = Modifier.fillMaxSize()) {
            // Red accent glow top-right
            drawCircle(
                brush = Brush.radialGradient(
                    colors = listOf(
                        Color(0xFFE8253A).copy(alpha = 0.06f),
                        Color.Transparent
                    ),
                    center = Offset(size.width * 0.8f, size.height * 0.15f),
                    radius = size.width * 0.5f
                ),
                radius = size.width * 0.5f,
                center = Offset(size.width * 0.8f, size.height * 0.15f)
            )
            // Cyan glow bottom-left
            drawCircle(
                brush = Brush.radialGradient(
                    colors = listOf(
                        Color(0xFF00E5FF).copy(alpha = 0.03f),
                        Color.Transparent
                    ),
                    center = Offset(size.width * 0.2f, size.height * 0.8f),
                    radius = size.width * 0.4f
                ),
                radius = size.width * 0.4f,
                center = Offset(size.width * 0.2f, size.height * 0.8f)
            )
        }
        
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center,
            modifier = Modifier
                .padding(32.dp)
                .graphicsLayer(alpha = alpha)
        ) {
            // F1 Car Icon
            F1CarIcon(modifier = Modifier
                .width(220.dp)
                .height(90.dp)
                .offset(y = carOffsetY)
                .graphicsLayer(scaleX = carScale, scaleY = carScale)
            )
            
            Spacer(modifier = Modifier.height(36.dp))
            
            // Title with racing accent dot
            Row(verticalAlignment = Alignment.CenterVertically) {
                Box(
                    modifier = Modifier
                        .size(10.dp)
                        .background(Color(0xFFE8253A), shape = CircleShape)
                )
                Spacer(modifier = Modifier.width(10.dp))
                Text(
                    text = "GEORACING",
                    fontSize = 34.sp,
                    fontWeight = FontWeight.Black,
                    letterSpacing = 3.sp,
                    color = Color.White
                )
            }
            
            Text(
                text = "CIRCUIT DE BARCELONA CATALUNYA",
                fontSize = 12.sp,
                fontWeight = FontWeight.Bold,
                letterSpacing = 2.sp,
                color = Color(0xFF64748B),
                modifier = Modifier.padding(top = 8.dp)
            )
            
            Spacer(modifier = Modifier.height(56.dp))
            
            // Rev Counter Loader
            RevCounterLoader(progress = progress)
            
            Spacer(modifier = Modifier.height(20.dp))
            
            Text(
                text = "${(progress * 100).toInt()}%",
                fontSize = 20.sp,
                fontWeight = FontWeight.ExtraBold,
                letterSpacing = 1.sp,
                color = Color(0xFFE8253A)
            )
            
            Spacer(modifier = Modifier.height(10.dp))
            
            // Mensaje de estado
            Text(
                text = statusMessage.uppercase(),
                fontSize = 11.sp,
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.5.sp,
                color = Color(0xFF475569),
                modifier = Modifier.alpha(0.9f)
            )
        }
    }
}

@Composable
fun F1CarIcon(modifier: Modifier = Modifier) {
    Canvas(modifier = modifier) {
        val width = size.width
        val height = size.height
        
        // Centrar el dibujo y ajustar escala
        val viewBoxWidth = 200f
        val viewBoxHeight = 60f
        val scaleX = width / viewBoxWidth
        val scaleY = height / viewBoxHeight
        val scale = scaleX.coerceAtMost(scaleY)
        
        // Centrar el contenido
        val offsetX = (width - viewBoxWidth * scale) / 2f
        val offsetY = (height - viewBoxHeight * scale) / 2f
        
        // Perfil lateral del F1
        val mainBodyPath = Path().apply {
            moveTo(5f * scale + offsetX, 45f * scale + offsetY)
            lineTo(35f * scale + offsetX, 45f * scale + offsetY)
            lineTo(35f * scale + offsetX, 40f * scale + offsetY)
            lineTo(55f * scale + offsetX, 35f * scale + offsetY)
            cubicTo(
                70f * scale + offsetX, 30f * scale + offsetY,
                85f * scale + offsetX, 25f * scale + offsetY,
                95f * scale + offsetX, 25f * scale + offsetY
            )
            lineTo(105f * scale + offsetX, 25f * scale + offsetY)
            lineTo(110f * scale + offsetX, 10f * scale + offsetY)
            cubicTo(
                120f * scale + offsetX, 10f * scale + offsetY,
                135f * scale + offsetX, 12f * scale + offsetY,
                150f * scale + offsetX, 20f * scale + offsetY
            )
            lineTo(170f * scale + offsetX, 22f * scale + offsetY)
            lineTo(170f * scale + offsetX, 5f * scale + offsetY)
            lineTo(195f * scale + offsetX, 5f * scale + offsetY)
            lineTo(195f * scale + offsetX, 25f * scale + offsetY)
            lineTo(180f * scale + offsetX, 35f * scale + offsetY)
            lineTo(195f * scale + offsetX, 45f * scale + offsetY)
            lineTo(195f * scale + offsetX, 50f * scale + offsetY)
            lineTo(45f * scale + offsetX, 50f * scale + offsetY)
            lineTo(35f * scale + offsetX, 50f * scale + offsetY)
            lineTo(35f * scale + offsetX, 45f * scale + offsetY)
            close()
        }
        
        drawPath(
            path = mainBodyPath,
            color = Color(0xFFE8253A),
            style = Stroke(width = 3f * scale, cap = StrokeCap.Round, join = StrokeJoin.Round)
        )
        
        // Detalle del Halo
        drawLine(
            color = Color(0xFFFF3352),
            start = Offset(95f * scale + offsetX, 25f * scale + offsetY),
            end = Offset(115f * scale + offsetX, 25f * scale + offsetY),
            strokeWidth = 2f * scale,
            cap = StrokeCap.Round
        )
        
        // Ruedas (arcos estilizados) - rueda trasera
        val rearWheelPath = Path().apply {
            moveTo(35f * scale + offsetX, 50f * scale + offsetY)
            arcTo(
                rect = androidx.compose.ui.geometry.Rect(
                    left = 35f * scale + offsetX,
                    top = 40f * scale + offsetY,
                    right = 55f * scale + offsetX,
                    bottom = 60f * scale + offsetY
                ),
                startAngleDegrees = 0f,
                sweepAngleDegrees = 180f,
                forceMoveTo = false
            )
        }
        
        drawPath(
            path = rearWheelPath,
            color = Color(0xFFE8253A).copy(alpha = 0.5f),
            style = Stroke(width = 2.5f * scale, cap = StrokeCap.Round)
        )
        
        // Rueda delantera
        val frontWheelPath = Path().apply {
            moveTo(155f * scale + offsetX, 50f * scale + offsetY)
            arcTo(
                rect = androidx.compose.ui.geometry.Rect(
                    left = 155f * scale + offsetX,
                    top = 38f * scale + offsetY,
                    right = 185f * scale + offsetX,
                    bottom = 62f * scale + offsetY
                ),
                startAngleDegrees = 0f,
                sweepAngleDegrees = 180f,
                forceMoveTo = false
            )
        }
        
        drawPath(
            path = frontWheelPath,
            color = Color(0xFFE8253A).copy(alpha = 0.5f),
            style = Stroke(width = 2.5f * scale, cap = StrokeCap.Round)
        )
    }
}

@Composable
fun RevCounterLoader(progress: Float, modifier: Modifier = Modifier) {
    val animatedProgress by animateFloatAsState(
        targetValue = progress,
        animationSpec = tween(durationMillis = 400, easing = FastOutSlowInEasing),
        label = "progress"
    )
    
    // Glow pulse on the arc
    val infiniteTransition = rememberInfiniteTransition(label = "rev_glow")
    val glowAlpha by infiniteTransition.animateFloat(
        initialValue = 0.4f,
        targetValue = 0.8f,
        animationSpec = infiniteRepeatable(
            animation = tween(800, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "glow_alpha"
    )
    
    Box(
        modifier = modifier.size(110.dp),
        contentAlignment = Alignment.Center
    ) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            val strokeWidth = 6f
            val glowStroke = 12f
            val radius = size.minDimension / 2 - glowStroke / 2
            val centerX = size.width / 2
            val centerY = size.height / 2
            
            // Background arc
            drawArc(
                color = Color(0xFF1E293B),
                startAngle = 135f,
                sweepAngle = 270f,
                useCenter = false,
                style = Stroke(width = strokeWidth, cap = StrokeCap.Round),
                topLeft = Offset(centerX - radius, centerY - radius),
                size = androidx.compose.ui.geometry.Size(radius * 2, radius * 2)
            )
            
            // Glow behind progress arc
            val sweepAngle = 270f * animatedProgress
            drawArc(
                color = Color(0xFFE8253A).copy(alpha = glowAlpha * 0.3f),
                startAngle = 135f,
                sweepAngle = sweepAngle,
                useCenter = false,
                style = Stroke(width = glowStroke, cap = StrokeCap.Round),
                topLeft = Offset(centerX - radius, centerY - radius),
                size = androidx.compose.ui.geometry.Size(radius * 2, radius * 2)
            )
            
            // Progress arc
            drawArc(
                brush = Brush.sweepGradient(
                    colors = listOf(
                        Color(0xFFE8253A),
                        Color(0xFFFF3352),
                        Color(0xFFE8253A)
                    )
                ),
                startAngle = 135f,
                sweepAngle = sweepAngle,
                useCenter = false,
                style = Stroke(width = strokeWidth, cap = StrokeCap.Round),
                topLeft = Offset(centerX - radius, centerY - radius),
                size = androidx.compose.ui.geometry.Size(radius * 2, radius * 2)
            )
            
            // Tick marks around the arc
            val tickCount = 20
            for (i in 0 until tickCount) {
                val angle = 135f + (270f / tickCount) * i
                val angleRad = Math.toRadians(angle.toDouble())
                val innerR = radius - 8f
                val outerR = radius + 4f
                val tickAlpha = if (i.toFloat() / tickCount <= animatedProgress) 0.5f else 0.1f
                drawLine(
                    color = Color.White.copy(alpha = tickAlpha),
                    start = Offset(
                        centerX + innerR * kotlin.math.cos(angleRad).toFloat(),
                        centerY + innerR * kotlin.math.sin(angleRad).toFloat()
                    ),
                    end = Offset(
                        centerX + outerR * kotlin.math.cos(angleRad).toFloat(),
                        centerY + outerR * kotlin.math.sin(angleRad).toFloat()
                    ),
                    strokeWidth = if (i % 5 == 0) 2f else 1f
                )
            }
        }
        
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text(
                text = "RPM",
                fontSize = 11.sp,
                fontWeight = FontWeight.ExtraBold,
                letterSpacing = 2.sp,
                color = Color(0xFF475569)
            )
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/staff/StaffControlScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.staff

import android.widget.Toast
import androidx.compose.animation.core.RepeatMode
import androidx.compose.animation.core.animateFloat
import androidx.compose.animation.core.infiniteRepeatable
import androidx.compose.animation.core.rememberInfiniteTransition
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import com.georacing.georacing.debug.ScenarioSimulator
import java.text.SimpleDateFormat
import java.util.*

// Racing Theme Colors
private val RacingRed = Color(0xFFE8253A)
private val WarningOrange = Color(0xFFF97316)
private val NeonCyan = Color(0xFF06B6D4)
private val NominalGreen = Color(0xFF22C55E)
private val RacingBorder = Color(0xFF1E293B)
private val ConsoleBg = Color(0xFF0E0E18)
private val ConsoleText = Color(0xFF06B6D4)
private val SlateLabel = Color(0xFF64748B)
private val OffWhite = Color(0xFFF8FAFC)
private val DeepBg = Color(0xFF080810)
private val SurfaceDark = Color(0xFF14141C)
private val RacingGradient = Brush.verticalGradient(listOf(Color(0xFF080810), Color(0xFF0A0A16), Color(0xFF080810)))

@Composable
fun StaffControlScreen() {
    val context = LocalContext.current
    
    var showPinDialog by remember { mutableStateOf(true) }
    var isAuthenticated by remember { mutableStateOf(false) }
    
    // Observe ScenarioSimulator states for console
    val isNetworkDead by ScenarioSimulator.isNetworkDead.collectAsState()
    val crowdIntensity by ScenarioSimulator.crowdIntensity.collectAsState()
    val isAtGate by ScenarioSimulator.isAtGate.collectAsState()
    val batteryLevel by ScenarioSimulator.forcedBatteryLevel.collectAsState()
    
    // Console log state
    var consoleLog by remember { mutableStateOf(listOf("SYS > Centro de Mando Online")) }
    
    fun log(message: String) {
        val timestamp = SimpleDateFormat("HH:mm:ss", Locale.getDefault()).format(Date())
        consoleLog = (consoleLog + "[$timestamp] $message").takeLast(8)
    }

    if (showPinDialog) {
        SecurityPinDialog(
            onDismiss = { },
            onSuccess = {
                isAuthenticated = true
                showPinDialog = false
                log("AUTH > ‚úÖ Acceso autorizado. Nivel: ADMIN")
            }
        )
    }

    if (isAuthenticated) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .background(RacingGradient)
                .statusBarsPadding()
                .navigationBarsPadding()
                .verticalScroll(rememberScrollState())
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Header
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column {
                    Text(
                        "CENTRO DE MANDO",
                        color = OffWhite,
                        fontSize = 24.sp,
                        fontWeight = FontWeight.Black,
                        letterSpacing = 2.sp
                    )
                    Text(
                        "OPERACIONES ‚Ä¢ SIMULADOR",
                        color = SlateLabel,
                        fontSize = 12.sp,
                        letterSpacing = 1.5.sp
                    )
                }
                
                // Live Status Indicator
                val pulse = rememberInfiniteTransition(label = "pulse")
                val alpha by pulse.animateFloat(
                    initialValue = 0.4f, targetValue = 1f,
                    animationSpec = infiniteRepeatable(tween(800), RepeatMode.Reverse),
                    label = "alpha"
                )
                Box(
                    modifier = Modifier
                        .size(12.dp)
                        .background(
                            when {
                                isNetworkDead -> RacingRed.copy(alpha)
                                crowdIntensity > 0.5f -> WarningOrange.copy(alpha)
                                else -> NominalGreen.copy(alpha)
                            },
                            RoundedCornerShape(6.dp)
                        )
                )
            }
            
            Spacer(modifier = Modifier.height(24.dp))
            
            // =============================================
            // EMERGENCY BUTTON: KILL NETWORK
            // =============================================
            EmergencyButton(
                text = "üö® SIMULAR CA√çDA DE RED",
                description = "Activa protocolo offline",
                color = RacingRed,
                isActive = isNetworkDead,
                onClick = {
                    ScenarioSimulator.killNetwork()
                    log("NET > ‚ö†Ô∏è RED CA√çDA - ERROR 503")
                }
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // =============================================
            // WARNING BUTTON: CROWD SURGE
            // =============================================
            EmergencyButton(
                text = "üë• SIMULAR AGLOMERACI√ìN",
                description = "Densidad alta en acceso principal",
                color = WarningOrange,
                isActive = crowdIntensity > 0.5f,
                onClick = {
                    ScenarioSimulator.triggerCrowdSurge()
                    log("CROWD > ‚ö†Ô∏è DENSIDAD CR√çTICA 90%")
                }
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // =============================================
            // INFO BUTTON: GATE ARRIVAL
            // =============================================
            EmergencyButton(
                text = "üìç FORZAR LLEGADA A PUERTA",
                description = "Dispara entrada inteligente",
                color = NeonCyan,
                isActive = isAtGate,
                onClick = {
                    ScenarioSimulator.arriveAtGate()
                    log("GATE > üö™ Llegada detectada Gate-3")
                }
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // =============================================
            // NOMINAL: RESET ALL
            // =============================================
            EmergencyButton(
                text = "‚úÖ SISTEMAS NOMINALES",
                description = "Restablecer operaciones normales",
                color = NominalGreen,
                isActive = false,
                onClick = {
                    ScenarioSimulator.resetAll()
                    ScenarioSimulator.restoreNetwork()
                    ScenarioSimulator.resetCrowd()
                    ScenarioSimulator.resetGate()
                    log("SYS > ‚úÖ Todos los sistemas NOMINAL")
                }
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // =============================================
            // CAR DISCONNECT SIMULATION
            // =============================================
            val carConnectionManager = remember { com.georacing.georacing.infrastructure.car.CarConnectionManager(context) }
            
            EmergencyButton(
                text = "üîå SIMULAR DESCONEXI√ìN COCHE",
                description = "Trigger handover sin cable USB",
                color = Color(0xFF8B5CF6), // Purple
                isActive = false,
                onClick = {
                    carConnectionManager.triggerHandover()
                    log("CAR > üöó Handover triggered! Parking saved")
                    Toast.makeText(context, "Handover activado", Toast.LENGTH_SHORT).show()
                }
            )
            
            Spacer(modifier = Modifier.height(24.dp))
            
            // =============================================
            // CONSOLE OUTPUT
            // =============================================
            Text(
                "TERMINAL DE ESTADO",
                color = SlateLabel,
                fontSize = 10.sp,
                fontWeight = FontWeight.Bold,
                letterSpacing = 1.5.sp,
                modifier = Modifier.align(Alignment.Start)
            )
            Spacer(modifier = Modifier.height(8.dp))
            
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(180.dp)
                    .border(1.dp, RacingBorder, RoundedCornerShape(8.dp))
                    .background(ConsoleBg, RoundedCornerShape(8.dp))
                    .padding(12.dp)
            ) {
                Column {
                    // Current Status Line
                    val statusText = when {
                        isNetworkDead -> "STATUS: NETWORK ERROR 503 ‚ö†Ô∏è"
                        crowdIntensity > 0.5f -> "STATUS: CROWD DENSITY CRITICAL ‚ö†Ô∏è"
                        isAtGate -> "STATUS: AT GATE - DEPLOYING SMART ENTRY"
                        batteryLevel != null && batteryLevel!! <= 20 -> "STATUS: BATTERY SURVIVAL MODE"
                        else -> "STATUS: ALL SYSTEMS OPERATIONAL ‚úì"
                    }
                    
                    Text(
                        statusText,
                        color = when {
                            isNetworkDead -> RacingRed
                            crowdIntensity > 0.5f -> WarningOrange
                            isAtGate -> NeonCyan
                            else -> NominalGreen
                        },
                        fontSize = 14.sp,
                        fontWeight = FontWeight.Bold,
                        fontFamily = FontFamily.Monospace
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    Divider(color = RacingBorder, thickness = 1.dp)
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    // Log entries
                    consoleLog.forEach { line ->
                        Text(
                            line,
                            color = ConsoleText,
                            fontSize = 11.sp,
                            fontFamily = FontFamily.Monospace,
                            lineHeight = 16.sp
                        )
                    }
                }
            }
            
            Spacer(modifier = Modifier.height(32.dp))
        }
    }
}

@Composable
private fun EmergencyButton(
    text: String,
    description: String,
    color: Color,
    isActive: Boolean,
    onClick: () -> Unit
) {
    val borderWidth = if (isActive) 3.dp else 1.dp
    val borderColor = if (isActive) color else RacingBorder
    
    Button(
        onClick = onClick,
        colors = ButtonDefaults.buttonColors(
            containerColor = if (isActive) color.copy(alpha = 0.15f) else SurfaceDark
        ),
        shape = RoundedCornerShape(12.dp),
        modifier = Modifier
            .fillMaxWidth()
            .height(90.dp)
            .border(borderWidth, borderColor, RoundedCornerShape(12.dp)),
        contentPadding = PaddingValues(16.dp)
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text(
                text,
                color = if (isActive) color else OffWhite,
                fontWeight = FontWeight.Black,
                fontSize = 18.sp,
                letterSpacing = 0.5.sp
            )
            Spacer(modifier = Modifier.height(4.dp))
            Text(
                description,
                color = SlateLabel,
                fontSize = 12.sp,
                letterSpacing = 0.5.sp
            )
            if (isActive) {
                Text(
                    "‚óè ACTIVO",
                    color = color,
                    fontSize = 10.sp,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

@Composable
fun SecurityPinDialog(onDismiss: () -> Unit, onSuccess: () -> Unit) {
    var pin by remember { mutableStateOf("") }
    
    Dialog(onDismissRequest = onDismiss) {
        Card(
            colors = CardDefaults.cardColors(containerColor = SurfaceDark),
            shape = RoundedCornerShape(16.dp)
        ) {
            Column(
                modifier = Modifier.padding(24.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Icon(
                    Icons.Filled.Lock, 
                    contentDescription = null, 
                    tint = RacingRed,
                    modifier = Modifier.size(48.dp)
                )
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    "ACCESO RESTRINGIDO",
                    color = OffWhite,
                    fontWeight = FontWeight.Bold,
                    fontSize = 18.sp,
                    letterSpacing = 1.5.sp
                )
                Text(
                    "SOLO PERSONAL AUTORIZADO",
                    color = SlateLabel,
                    fontSize = 12.sp,
                    letterSpacing = 1.5.sp
                )
                Spacer(modifier = Modifier.height(24.dp))
                
                TextField(
                    value = pin,
                    onValueChange = { if (it.length <= 4) pin = it },
                    placeholder = { Text("PIN (1234)", color = SlateLabel) },
                    singleLine = true,
                    colors = TextFieldDefaults.colors(
                        focusedContainerColor = DeepBg,
                        unfocusedContainerColor = DeepBg,
                        focusedTextColor = OffWhite,
                        unfocusedTextColor = OffWhite,
                        cursorColor = RacingRed
                    ),
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(24.dp))
                
                Button(
                    onClick = {
                        if (pin == "1234") {
                            onSuccess()
                        }
                    },
                    colors = ButtonDefaults.buttonColors(containerColor = RacingRed),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("ACCEDER", fontWeight = FontWeight.Bold)
                }
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/staff/StaffControlViewModel.kt`

```kotlin
package com.georacing.georacing.ui.screens.staff

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.georacing.georacing.domain.usecase.BroadcastEmergencyUseCase
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

/**
 * ViewModel del Panel de Control del Staff.
 * Gestiona el estado de emisi√≥n de la "Baliza Humana" (Dynamic Infrastructure).
 */
class StaffControlViewModel(
    private val broadcastEmergencyUseCase: BroadcastEmergencyUseCase
) : ViewModel() {

    private val _isBroadcasting = MutableStateFlow(false)
    val isBroadcasting: StateFlow<Boolean> = _isBroadcasting.asStateFlow()

    private val _broadcastError = MutableStateFlow<String?>(null)
    val broadcastError: StateFlow<String?> = _broadcastError.asStateFlow()

    private var broadcastJob: Job? = null

    /**
     * Alterna la emisi√≥n BLE ON/OFF.
     * (Asume que la UI ya ha validado permisos BLUETOOTH_ADVERTISE).
     * @param isEvacuation Determina si el payload es EVACUATE o DANGER.
     */
    fun toggleBeacon(isEvacuation: Boolean = true) {
        if (_isBroadcasting.value) {
            stopBeacon()
        } else {
            startBeacon(isEvacuation)
        }
    }

    private fun startBeacon(isEvacuation: Boolean) {
        // Cancelar trabajo anterior si existiera
        broadcastJob?.cancel()
        _broadcastError.value = null

        broadcastJob = viewModelScope.launch {
            broadcastEmergencyUseCase(isEvacuation).collect { isSuccess ->
                if (isSuccess) {
                    _isBroadcasting.value = true
                } else {
                    _isBroadcasting.value = false
                    _broadcastError.value = "Error al iniciar la Baliza BLE. Aseg√∫rate de tener el Bluetooth activado."
                }
            }
        }
    }

    private fun stopBeacon() {
        broadcastJob?.cancel()
        _isBroadcasting.value = false
    }

    override fun onCleared() {
        super.onCleared()
        stopBeacon()
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/staff/StaffModeScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.staff

import androidx.compose.animation.animateColorAsState
import androidx.compose.animation.core.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.scale
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.data.ble.BeaconAdvertiser

// Racing Theme Colors
private val RacingRed = Color(0xFFE8253A)
private val NeonCyan = Color(0xFF06B6D4)
private val NeonOrange = Color(0xFFF97316)
private val RacingGreen = Color(0xFF22C55E)
private val SlateLabel = Color(0xFF64748B)
private val OffWhite = Color(0xFFF8FAFC)
private val DeepBg = Color(0xFF080810)
private val SurfaceDark = Color(0xFF14141C)
private val SurfaceAlt = Color(0xFF0E0E18)
private val GoldAccent = Color(0xFFD4A84B)
private val RacingGradient = Brush.verticalGradient(listOf(Color(0xFF080810), Color(0xFF0A0A16), Color(0xFF080810)))

/**
 * üÜò Staff Mode Screen - Pantalla oculta para personal del circuito.
 * 
 * Permite activar el modo "Danger Broadcast" que emite se√±ales BLE
 * de emergencia para alertar a otros dispositivos cercanos.
 * 
 * Acceso: Settings > 7 taps en versi√≥n (Easter egg style)
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun StaffModeScreen(
    navController: NavController
) {
    val context = LocalContext.current
    
    // BLE Advertiser
    val beaconAdvertiser = remember { BeaconAdvertiser(context) }
    val advertisingState by beaconAdvertiser.advertisingState.collectAsState()
    
    // State
    var isDangerModeActive by remember { mutableStateOf(false) }
    var selectedZone by remember { mutableStateOf(1) }
    var selectedAlertLevel by remember { mutableStateOf(BeaconAdvertiser.MODE_EVACUATION) }
    var selectedSection by remember { mutableIntStateOf(0) } // iOS parity: 0=Alerts, 1=Beacons, 2=Status, 3=BLE Broadcast
    
    // Beacon toggles state (iOS parity: beaconsSection)
    val beaconToggles = remember {
        mutableStateMapOf(
            "main_entrance" to true,
            "grandstand_a" to true,
            "grandstand_b" to true,
            "paddock" to true,
            "pit_lane" to false
        )
    }
    
    // Animaci√≥n de pulso cuando est√° activo
    val infiniteTransition = rememberInfiniteTransition(label = "pulse")
    val pulseScale by infiniteTransition.animateFloat(
        initialValue = 1f,
        targetValue = 1.1f,
        animationSpec = infiniteRepeatable(
            animation = tween(500, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "pulseScale"
    )
    
    val backgroundColor by animateColorAsState(
        targetValue = if (isDangerModeActive) Color(0xFF3B0A0A) else DeepBg,
        animationSpec = tween(500),
        label = "bgColor"
    )
    
    // Zonas del circuito
    val zones = listOf(
        1 to "Tribuna Principal",
        2 to "Zona Paddock",
        3 to "Curva 1-3",
        4 to "Curva 4-6",
        5 to "Curva 7-9",
        6 to "Recta Principal",
        7 to "Zona Hospitality",
        8 to "Parking General"
    )
    
    // Niveles de alerta
    val alertLevels = listOf(
        BeaconAdvertiser.MODE_WARNING to "‚ö†Ô∏è Precauci√≥n",
        BeaconAdvertiser.MODE_DANGER to "üî¥ Peligro",
        BeaconAdvertiser.MODE_EVACUATION to "üÜò Evacuaci√≥n"
    )
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { 
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Icon(
                            Icons.Default.Security,
                            contentDescription = "Modo Staff",
                            tint = GoldAccent
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            "MODO STAFF",
                            color = OffWhite,
                            fontWeight = FontWeight.Bold,
                            letterSpacing = 1.5.sp
                        )
                    }
                },
                navigationIcon = {
                    IconButton(onClick = { 
                        beaconAdvertiser.stopAdvertising()
                        navController.popBackStack() 
                    }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Atr√°s", tint = OffWhite)
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = SurfaceDark
                )
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .background(backgroundColor)
                .padding(padding)
        ) {
            // ‚îÄ‚îÄ iOS parity: Segmented Control (Alerts / Beacons / Status / BLE) ‚îÄ‚îÄ
            val sectionLabels = listOf("Alertas", "Balizas", "Estado", "BLE")
            TabRow(
                selectedTabIndex = selectedSection,
                containerColor = SurfaceDark,
                contentColor = OffWhite
            ) {
                sectionLabels.forEachIndexed { index, label ->
                    Tab(
                        selected = selectedSection == index,
                        onClick = { selectedSection = index },
                        text = {
                            Text(
                                label,
                                fontWeight = if (selectedSection == index) FontWeight.Bold else FontWeight.Normal,
                                fontSize = 13.sp
                            )
                        }
                    )
                }
            }

            when (selectedSection) {
                0 -> StaffAlertsSection()
                1 -> StaffBeaconsSection(beaconToggles)
                2 -> StaffStatusSection()
                3 -> StaffBLEBroadcastSection(
                    isDangerModeActive = isDangerModeActive,
                    onToggle = { isDangerModeActive = it },
                    selectedZone = selectedZone,
                    onZoneChange = { selectedZone = it },
                    selectedAlertLevel = selectedAlertLevel,
                    onAlertLevelChange = { selectedAlertLevel = it },
                    zones = zones,
                    alertLevels = alertLevels,
                    beaconAdvertiser = beaconAdvertiser,
                    advertisingState = advertisingState,
                    pulseScale = pulseScale,
                    backgroundColor = backgroundColor
                )
            }
        }
    }
}

// ‚îÄ‚îÄ iOS parity: Alerts Section (send alerts to all users) ‚îÄ‚îÄ
@Composable
private fun StaffAlertsSection() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text(
            "ENVIAR ALERTA",
            style = MaterialTheme.typography.titleMedium,
            color = OffWhite,
            fontWeight = FontWeight.Bold,
            letterSpacing = 1.sp
        )

        StaffAlertButton(
            icon = Icons.Default.Warning,
            title = "Alerta General",
            description = "Enviar mensaje a todos los usuarios",
            color = Color(0xFFFBBF24)
        )
        StaffAlertButton(
            icon = Icons.Default.LocalFireDepartment,
            title = "Emergencia",
            description = "Activar protocolo de emergencia",
            color = Color(0xFFEF4444)
        )
        StaffAlertButton(
            icon = Icons.Default.Campaign,
            title = "Anuncio",
            description = "Enviar informaci√≥n general",
            color = Color(0xFF3B82F6)
        )
    }
}

@Composable
private fun StaffAlertButton(
    icon: ImageVector,
    title: String,
    description: String,
    color: Color
) {
    Card(
        colors = CardDefaults.cardColors(containerColor = Color(0xFF1E1E2E)),
        shape = RoundedCornerShape(12.dp),
        onClick = { /* TODO: send alert via API */ }
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                icon,
                contentDescription = null,
                tint = color,
                modifier = Modifier.size(36.dp)
            )
            Spacer(Modifier.width(16.dp))
            Column(modifier = Modifier.weight(1f)) {
                Text(title, style = MaterialTheme.typography.titleSmall, color = OffWhite, fontWeight = FontWeight.Bold)
                Text(description, style = MaterialTheme.typography.bodySmall, color = SlateLabel)
            }
            Icon(Icons.Default.ChevronRight, null, tint = SlateLabel)
        }
    }
}

// ‚îÄ‚îÄ iOS parity: Beacons Section (toggle beacons on/off) ‚îÄ‚îÄ
@Composable
private fun StaffBeaconsSection(beaconToggles: MutableMap<String, Boolean>) {
    val beaconNames = mapOf(
        "main_entrance" to "Entrada Principal",
        "grandstand_a" to "Tribuna A",
        "grandstand_b" to "Tribuna B",
        "paddock" to "Paddock",
        "pit_lane" to "Pit Lane"
    )

    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text(
            "CONTROL DE BALIZAS",
            style = MaterialTheme.typography.titleMedium,
            color = OffWhite,
            fontWeight = FontWeight.Bold,
            letterSpacing = 1.sp
        )

        beaconNames.forEach { (id, name) ->
            val isOn = beaconToggles[id] ?: false
            Card(
                colors = CardDefaults.cardColors(containerColor = Color(0xFF1E1E2E)),
                shape = RoundedCornerShape(12.dp)
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Box(
                        modifier = Modifier
                            .size(10.dp)
                            .clip(CircleShape)
                            .background(if (isOn) RacingGreen else Color(0xFFEF4444))
                    )
                    Spacer(Modifier.width(12.dp))
                    Text(name, color = OffWhite, style = MaterialTheme.typography.bodyLarge, modifier = Modifier.weight(1f))
                    Switch(
                        checked = isOn,
                        onCheckedChange = { beaconToggles[id] = it },
                        colors = SwitchDefaults.colors(
                            checkedTrackColor = NeonOrange,
                            checkedThumbColor = OffWhite
                        )
                    )
                }
            }
        }
    }
}

// ‚îÄ‚îÄ iOS parity: Status Section (circuit overview) ‚îÄ‚îÄ
@Composable
private fun StaffStatusSection() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text(
            "ESTADO DEL CIRCUITO",
            style = MaterialTheme.typography.titleMedium,
            color = OffWhite,
            fontWeight = FontWeight.Bold,
            letterSpacing = 1.sp
        )

        StaffStatusCard("Estado Actual", "BANDERA VERDE", Icons.Default.Flag, RacingGreen)
        StaffStatusCard("Usuarios Activos", "1,234", Icons.Default.People, Color(0xFF3B82F6))
        StaffStatusCard("Alertas Pendientes", "3", Icons.Default.NotificationsActive, NeonOrange)
        StaffStatusCard("Balizas Activas", "12/15", Icons.Default.Bluetooth, Color(0xFFA855F7))
    }
}

@Composable
private fun StaffStatusCard(title: String, value: String, icon: ImageVector, color: Color) {
    Card(
        colors = CardDefaults.cardColors(containerColor = Color(0xFF1E1E2E)),
        shape = RoundedCornerShape(12.dp)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(icon, null, tint = color, modifier = Modifier.size(36.dp))
            Spacer(Modifier.width(16.dp))
            Column {
                Text(title, style = MaterialTheme.typography.bodySmall, color = SlateLabel)
                Text(value, style = MaterialTheme.typography.titleMedium, color = OffWhite, fontWeight = FontWeight.Bold)
            }
        }
    }
}

// ‚îÄ‚îÄ Original BLE Broadcast Section (refactored from old single-view) ‚îÄ‚îÄ
@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun StaffBLEBroadcastSection(
    isDangerModeActive: Boolean,
    onToggle: (Boolean) -> Unit,
    selectedZone: Int,
    onZoneChange: (Int) -> Unit,
    selectedAlertLevel: Int,
    onAlertLevelChange: (Int) -> Unit,
    zones: List<Pair<Int, String>>,
    alertLevels: List<Pair<Int, String>>,
    beaconAdvertiser: BeaconAdvertiser,
    advertisingState: String,
    pulseScale: Float,
    backgroundColor: Color
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
            // Warning Card
            Card(
                colors = CardDefaults.cardColors(
                    containerColor = NeonOrange.copy(alpha = 0.12f)
                ),
                shape = RoundedCornerShape(12.dp)
            ) {
                Row(
                    modifier = Modifier.padding(16.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        Icons.Default.Warning,
                        contentDescription = "Advertencia",
                        tint = NeonOrange,
                        modifier = Modifier.size(32.dp)
                    )
                    Spacer(modifier = Modifier.width(12.dp))
                    Text(
                        "SOLO PARA PERSONAL AUTORIZADO\nUsar solo en emergencias reales.",
                        color = NeonOrange,
                        style = MaterialTheme.typography.bodyMedium,
                        letterSpacing = 0.5.sp
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Selector de Zona
            Text(
                "SELECCIONAR ZONA",
                style = MaterialTheme.typography.titleMedium,
                color = SlateLabel,
                letterSpacing = 1.5.sp,
                fontWeight = FontWeight.Bold
            )
            
            var zoneExpanded by remember { mutableStateOf(false) }
            ExposedDropdownMenuBox(
                expanded = zoneExpanded,
                onExpandedChange = { if (!isDangerModeActive) zoneExpanded = it }
            ) {
                OutlinedTextField(
                    value = zones.find { it.first == selectedZone }?.second ?: "Zona $selectedZone",
                    onValueChange = {},
                    readOnly = true,
                    enabled = !isDangerModeActive,
                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = zoneExpanded) },
                    modifier = Modifier
                        .fillMaxWidth()
                        .menuAnchor(),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = RacingRed,
                        unfocusedBorderColor = SlateLabel,
                        focusedTextColor = OffWhite,
                        unfocusedTextColor = OffWhite
                    )
                )
                ExposedDropdownMenu(
                    expanded = zoneExpanded,
                    onDismissRequest = { zoneExpanded = false }
                ) {
                    zones.forEach { (id, name) ->
                        DropdownMenuItem(
                            text = { Text("$id - $name") },
                            onClick = {
                                onZoneChange(id)
                                zoneExpanded = false
                            }
                        )
                    }
                }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Selector de Nivel de Alerta
            Text(
                "NIVEL DE ALERTA",
                style = MaterialTheme.typography.titleMedium,
                color = SlateLabel,
                letterSpacing = 1.5.sp,
                fontWeight = FontWeight.Bold
            )
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                alertLevels.forEach { (level, label) ->
                    FilterChip(
                        selected = selectedAlertLevel == level,
                        onClick = { if (!isDangerModeActive) onAlertLevelChange(level) },
                        label = { Text(label) },
                        enabled = !isDangerModeActive,
                        modifier = Modifier.weight(1f),
                        colors = FilterChipDefaults.filterChipColors(
                            selectedContainerColor = when (level) {
                                BeaconAdvertiser.MODE_WARNING -> NeonOrange
                                BeaconAdvertiser.MODE_DANGER -> Color(0xFFEF4444)
                                else -> RacingRed
                            }
                        )
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(32.dp))
            
            // Bot√≥n Principal de Emergencia
            Box(
                contentAlignment = Alignment.Center,
                modifier = Modifier
                    .size(200.dp)
                    .scale(if (isDangerModeActive) pulseScale else 1f)
            ) {
                Button(
                    onClick = {
                        if (isDangerModeActive) {
                            beaconAdvertiser.stopAdvertising()
                            onToggle(false)
                        } else {
                            beaconAdvertiser.startDangerAdvertising(
                                staffId = "STAFF_001",
                                zoneId = selectedZone,
                                alertMode = selectedAlertLevel
                            )
                            onToggle(true)
                        }
                    },
                    modifier = Modifier.fillMaxSize(),
                    shape = CircleShape,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = if (isDangerModeActive) SlateLabel else RacingRed
                    )
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Icon(
                            if (isDangerModeActive) Icons.Default.Close else Icons.Default.Warning,
                            contentDescription = null,
                            modifier = Modifier.size(64.dp),
                            tint = OffWhite
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            if (isDangerModeActive) "DETENER" else "ACTIVAR\nALERTA",
                            textAlign = TextAlign.Center,
                            fontWeight = FontWeight.Bold,
                            fontSize = 18.sp,
                            letterSpacing = 1.5.sp,
                            color = OffWhite
                        )
                    }
                }
            }
            
            // Estado actual
            Card(
                colors = CardDefaults.cardColors(
                    containerColor = SurfaceDark
                ),
                shape = RoundedCornerShape(12.dp)
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        "ESTADO BLE",
                        style = MaterialTheme.typography.labelMedium,
                        color = SlateLabel,
                        letterSpacing = 1.5.sp
                    )
                    Text(
                        advertisingState,
                        style = MaterialTheme.typography.titleMedium,
                        color = if (isDangerModeActive) Color(0xFFEF4444) else RacingGreen,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
            
            if (isDangerModeActive) {
                Spacer(modifier = Modifier.height(16.dp))
                
                Card(
                    colors = CardDefaults.cardColors(
                        containerColor = RacingRed.copy(alpha = 0.2f)
                    ),
                    shape = RoundedCornerShape(12.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            "‚ö†Ô∏è BROADCAST ACTIVO ‚ö†Ô∏è",
                            style = MaterialTheme.typography.titleLarge,
                            color = OffWhite,
                            fontWeight = FontWeight.Bold,
                            letterSpacing = 1.5.sp
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            "Zona: ${zones.find { it.first == selectedZone }?.second}",
                            color = OffWhite
                        )
                        Text(
                            "Nivel: ${alertLevels.find { it.first == selectedAlertLevel }?.second}",
                            color = OffWhite
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            "Los dispositivos cercanos recibir√°n esta alerta",
                            color = SlateLabel,
                            style = MaterialTheme.typography.bodySmall,
                            textAlign = TextAlign.Center
                        )
                    }
                }
            }
            
            // ‚îÄ‚îÄ Mapa visual de estados de zonas ‚îÄ‚îÄ
            Spacer(modifier = Modifier.height(32.dp))
            
            Text(
                "MAPA DE ESTADOS",
                style = MaterialTheme.typography.titleMedium,
                color = SlateLabel,
                letterSpacing = 1.5.sp,
                fontWeight = FontWeight.Bold
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Estado de cada zona (la zona activa aparece en su nivel de alerta)
            val zoneStates = remember(isDangerModeActive, selectedZone, selectedAlertLevel) {
                zones.map { (id, name) ->
                    val state = if (isDangerModeActive && id == selectedZone) {
                        when (selectedAlertLevel) {
                            BeaconAdvertiser.MODE_WARNING -> ZoneState.WARNING
                            BeaconAdvertiser.MODE_DANGER -> ZoneState.DANGER
                            BeaconAdvertiser.MODE_EVACUATION -> ZoneState.EVACUATION
                            else -> ZoneState.NORMAL
                        }
                    } else {
                        ZoneState.NORMAL
                    }
                    ZoneInfo(id, name, state)
                }
            }
            
            Card(
                colors = CardDefaults.cardColors(containerColor = SurfaceDark),
                shape = RoundedCornerShape(12.dp)
            ) {
                Column(modifier = Modifier.padding(12.dp)) {
                    // Mapa esquem√°tico del circuito con zonas coloreadas
                    CircuitZoneMap(
                        zoneStates = zoneStates,
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(200.dp)
                    )
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    // Leyenda
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceEvenly
                    ) {
                        ZoneLegendItem("Normal", RacingGreen)
                        ZoneLegendItem("Precauci√≥n", NeonOrange)
                        ZoneLegendItem("Peligro", Color(0xFFEF4444))
                        ZoneLegendItem("Evacuaci√≥n", RacingRed)
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    // Lista de zonas con estado
                    zoneStates.forEach { zone ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 4.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Box(
                                modifier = Modifier
                                    .size(12.dp)
                                    .background(zone.state.color, CircleShape)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                "${zone.id} - ${zone.name}",
                                style = MaterialTheme.typography.bodySmall,
                                color = OffWhite,
                                modifier = Modifier.weight(1f)
                            )
                            Text(
                                zone.state.label,
                                style = MaterialTheme.typography.labelSmall,
                                color = zone.state.color,
                                fontWeight = FontWeight.Bold
                            )
                        }
                    }
                }
            }
        }
    }

// ‚îÄ‚îÄ Modelos de estado de zona ‚îÄ‚îÄ

private enum class ZoneState(val label: String, val color: Color) {
    NORMAL("Normal", Color(0xFF22C55E)),
    WARNING("Precauci√≥n", Color(0xFFF97316)),
    DANGER("Peligro", Color(0xFFEF4444)),
    EVACUATION("Evacuaci√≥n", Color(0xFFE8253A))
}

private data class ZoneInfo(
    val id: Int,
    val name: String,
    val state: ZoneState
)

@Composable
private fun ZoneLegendItem(label: String, color: Color) {
    Row(verticalAlignment = Alignment.CenterVertically) {
        Box(
            modifier = Modifier
                .size(8.dp)
                .background(color, CircleShape)
        )
        Spacer(modifier = Modifier.width(4.dp))
        Text(
            label,
            style = MaterialTheme.typography.labelSmall,
            color = Color(0xFF94A3B8),
            fontSize = 10.sp
        )
    }
}

/**
 * Mapa esquem√°tico del circuito con zonas coloreadas seg√∫n su estado de alerta.
 * Dise√±o simplificado representando la forma del Circuit de Barcelona-Catalunya.
 */
@Composable
private fun CircuitZoneMap(
    zoneStates: List<ZoneInfo>,
    modifier: Modifier = Modifier
) {
    val pulseTransition = rememberInfiniteTransition(label = "zonePulse")
    val pulseAlpha by pulseTransition.animateFloat(
        initialValue = 0.4f,
        targetValue = 1.0f,
        animationSpec = infiniteRepeatable(
            animation = tween(600),
            repeatMode = RepeatMode.Reverse
        ),
        label = "pulseAlpha"
    )
    
    Canvas(modifier = modifier) {
        val w = size.width
        val h = size.height
        val padding = 16.dp.toPx()
        
        // Fondo del circuito (forma ovalada simplificada)
        drawRoundRect(
            color = Color(0xFF0E0E18),
            topLeft = Offset(padding, padding),
            size = Size(w - padding * 2, h - padding * 2),
            cornerRadius = androidx.compose.ui.geometry.CornerRadius(24.dp.toPx())
        )
        
        // Borde del circuito
        drawRoundRect(
            color = Color(0xFF2A2A3A),
            topLeft = Offset(padding, padding),
            size = Size(w - padding * 2, h - padding * 2),
            cornerRadius = androidx.compose.ui.geometry.CornerRadius(24.dp.toPx()),
            style = Stroke(width = 2.dp.toPx())
        )
        
        // Posiciones relativas de cada zona en el mapa esquem√°tico
        val zonePositions = listOf(
            Offset(w * 0.5f, h * 0.2f),   // 1: Tribuna Principal (arriba centro)
            Offset(w * 0.75f, h * 0.25f),  // 2: Zona Paddock (arriba derecha)
            Offset(w * 0.85f, h * 0.5f),   // 3: Curva 1-3 (derecha)
            Offset(w * 0.7f, h * 0.75f),   // 4: Curva 4-6 (abajo derecha)
            Offset(w * 0.3f, h * 0.75f),   // 5: Curva 7-9 (abajo izquierda)
            Offset(w * 0.5f, h * 0.5f),    // 6: Recta Principal (centro)
            Offset(w * 0.25f, h * 0.25f),  // 7: Zona Hospitality (arriba izquierda)
            Offset(w * 0.15f, h * 0.5f)    // 8: Parking General (izquierda)
        )
        
        zonePositions.forEachIndexed { index, pos ->
            if (index < zoneStates.size) {
                val zone = zoneStates[index]
                val radius = 18.dp.toPx()
                val alpha = if (zone.state == ZoneState.EVACUATION) pulseAlpha else 0.8f
                
                // Halo de la zona
                drawCircle(
                    color = zone.state.color.copy(alpha = alpha * 0.3f),
                    radius = radius * 1.6f,
                    center = pos
                )
                
                // Punto de la zona
                drawCircle(
                    color = zone.state.color.copy(alpha = alpha),
                    radius = radius,
                    center = pos
                )
                
                // Borde
                drawCircle(
                    color = Color.White.copy(alpha = 0.3f),
                    radius = radius,
                    center = pos,
                    style = Stroke(width = 1.dp.toPx())
                )
            }
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/traffic/RouteTrafficScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.traffic

import androidx.compose.animation.animateColorAsState
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.data.repository.NetworkTrafficRepository
import com.georacing.georacing.domain.model.RouteTraffic
import com.georacing.georacing.domain.model.RouteTrafficStatus
import com.georacing.georacing.domain.model.ZoneOccupancy
import com.georacing.georacing.domain.model.ZoneOccupancyStatus
import kotlinx.coroutines.delay

// Theme Colors
private val DeepBg = Color(0xFF080810)
private val SurfaceDark = Color(0xFF14141C)
private val OffWhite = Color(0xFFF8FAFC)
private val NeonCyan = Color(0xFF06B6D4)
private val NeonGreen = Color(0xFF22C55E)
private val NeonYellow = Color(0xFFF59E0B)
private val NeonRed = Color(0xFFEF4444)
private val NeonPurple = Color(0xFF8B5CF6)
private val SlateLabel = Color(0xFF94A3B8)

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun RouteTrafficScreen(
    navController: NavController
) {
    val repository = remember { NetworkTrafficRepository() }

    var routes by remember { mutableStateOf<List<RouteTraffic>>(emptyList()) }
    var zones by remember { mutableStateOf<List<ZoneOccupancy>>(emptyList()) }
    var isLoading by remember { mutableStateOf(true) }
    var selectedTab by remember { mutableIntStateOf(0) }

    // Polling cada 15 segundos
    LaunchedEffect(Unit) {
        while (true) {
            try {
                isLoading = true
                routes = repository.getRoutes()
                zones = repository.getZoneTraffic()
            } catch (_: Exception) { }
            isLoading = false
            delay(15000)
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Icon(Icons.Default.Traffic, contentDescription = null, tint = NeonCyan)
                        Spacer(Modifier.width(8.dp))
                        Text("Tr√°fico del Circuito", color = OffWhite, fontWeight = FontWeight.Bold)
                    }
                },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Atr√°s", tint = OffWhite)
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = SurfaceDark)
            )
        },
        containerColor = DeepBg
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
        ) {
            // Tabs: Rutas / Zonas
            TabRow(
                selectedTabIndex = selectedTab,
                containerColor = SurfaceDark,
                contentColor = NeonCyan,
                modifier = Modifier.fillMaxWidth()
            ) {
                Tab(selected = selectedTab == 0, onClick = { selectedTab = 0 }) {
                    Row(
                        modifier = Modifier.padding(12.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(Icons.Default.Route, contentDescription = null, modifier = Modifier.size(18.dp))
                        Spacer(Modifier.width(6.dp))
                        Text("Rutas", fontWeight = FontWeight.Medium)
                    }
                }
                Tab(selected = selectedTab == 1, onClick = { selectedTab = 1 }) {
                    Row(
                        modifier = Modifier.padding(12.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(Icons.Default.Map, contentDescription = null, modifier = Modifier.size(18.dp))
                        Spacer(Modifier.width(6.dp))
                        Text("Zonas", fontWeight = FontWeight.Medium)
                    }
                }
            }

            if (isLoading && routes.isEmpty()) {
                Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator(color = NeonCyan)
                }
            } else {
                when (selectedTab) {
                    0 -> RoutesTab(routes)
                    1 -> ZonesTab(zones)
                }
            }
        }
    }
}

@Composable
private fun RoutesTab(routes: List<RouteTraffic>) {
    if (routes.isEmpty()) {
        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            Text("No hay datos de rutas", color = SlateLabel)
        }
        return
    }

    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(12.dp),
        verticalArrangement = Arrangement.spacedBy(10.dp)
    ) {
        items(routes, key = { it.id }) { route ->
            RouteCard(route)
        }
    }
}

@Composable
private fun RouteCard(route: RouteTraffic) {
    val statusColor = when (route.status) {
        RouteTrafficStatus.OPERATIVA -> NeonGreen
        RouteTrafficStatus.SATURADA -> NeonYellow
        RouteTrafficStatus.CERRADA -> NeonRed
        RouteTrafficStatus.MANTENIMIENTO -> NeonPurple
    }

    val capacityPct = route.capacityPercentage.coerceIn(0, 100)
    val barColor by animateColorAsState(
        when {
            capacityPct >= 90 -> NeonRed
            capacityPct >= 70 -> NeonYellow
            else -> NeonGreen
        },
        label = "barColor"
    )

    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = SurfaceDark),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(modifier = Modifier.padding(14.dp)) {
            // Header: nombre + status
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(route.name, color = OffWhite, fontWeight = FontWeight.SemiBold, fontSize = 15.sp)
                    Spacer(Modifier.height(2.dp))
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Text(route.origin, color = SlateLabel, fontSize = 12.sp)
                        Icon(Icons.Default.ArrowForward, contentDescription = null, tint = SlateLabel, modifier = Modifier.size(14.dp).padding(horizontal = 2.dp))
                        Text(route.destination, color = SlateLabel, fontSize = 12.sp)
                    }
                }
                Surface(
                    shape = RoundedCornerShape(6.dp),
                    color = statusColor.copy(alpha = 0.2f)
                ) {
                    Text(
                        route.status.name,
                        color = statusColor,
                        fontSize = 11.sp,
                        fontWeight = FontWeight.Bold,
                        modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)
                    )
                }
            }

            Spacer(Modifier.height(10.dp))

            // Usuarios activos
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text("Usuarios activos", color = SlateLabel, fontSize = 13.sp)
                Text(
                    "${route.activeUsers}",
                    color = if (route.capacityPercentage >= 80) NeonRed else OffWhite,
                    fontWeight = FontWeight.Bold,
                    fontSize = 20.sp
                )
            }

            Spacer(Modifier.height(8.dp))

            // Barra de capacidad
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Capacidad", color = SlateLabel, fontSize = 12.sp)
                Text("$capacityPct%", color = OffWhite, fontSize = 12.sp, fontWeight = FontWeight.Medium)
            }
            Spacer(Modifier.height(4.dp))
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(6.dp)
                    .clip(RoundedCornerShape(3.dp))
                    .background(Color(0xFF1E1E2A))
            ) {
                Box(
                    modifier = Modifier
                        .fillMaxHeight()
                        .fillMaxWidth(fraction = capacityPct / 100f)
                        .clip(RoundedCornerShape(3.dp))
                        .background(barColor)
                )
            }

            Spacer(Modifier.height(10.dp))

            // M√©tricas
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                MetricChip("üö∂", "${route.velocity} m/s")
                MetricChip("üìè", "${route.distance}m")
                MetricChip("‚è±", if (route.estimatedTime > 0) "${route.estimatedTime} min" else "‚Äì")
            }
        }
    }
}

@Composable
private fun ZonesTab(zones: List<ZoneOccupancy>) {
    if (zones.isEmpty()) {
        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            Text("No hay datos de zonas", color = SlateLabel)
        }
        return
    }

    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(12.dp),
        verticalArrangement = Arrangement.spacedBy(10.dp)
    ) {
        items(zones, key = { it.id }) { zone ->
            ZoneCard(zone)
        }
    }
}

@Composable
private fun ZoneCard(zone: ZoneOccupancy) {
    val statusColor = when (zone.status) {
        ZoneOccupancyStatus.ABIERTA, ZoneOccupancyStatus.OPERATIVA -> NeonGreen
        ZoneOccupancyStatus.SATURADA -> NeonYellow
        ZoneOccupancyStatus.CERRADA -> NeonRed
        ZoneOccupancyStatus.MANTENIMIENTO -> NeonPurple
    }

    val pct = zone.occupancyPercentage.coerceIn(0, 100)
    val barColor by animateColorAsState(
        when {
            pct >= 85 -> NeonRed
            pct >= 60 -> NeonYellow
            else -> NeonGreen
        },
        label = "zoneBarColor"
    )

    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = SurfaceDark),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(modifier = Modifier.padding(14.dp)) {
            // Header
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(zone.name, color = OffWhite, fontWeight = FontWeight.SemiBold, fontSize = 15.sp)
                    Spacer(Modifier.height(2.dp))
                    Text("Tipo: ${zone.type}", color = SlateLabel, fontSize = 12.sp)
                }
                Surface(
                    shape = RoundedCornerShape(6.dp),
                    color = statusColor.copy(alpha = 0.2f)
                ) {
                    Text(
                        zone.status.name,
                        color = statusColor,
                        fontSize = 11.sp,
                        fontWeight = FontWeight.Bold,
                        modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)
                    )
                }
            }

            Spacer(Modifier.height(10.dp))

            // Ocupaci√≥n
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Ocupaci√≥n", color = SlateLabel, fontSize = 12.sp)
                Text(
                    "${zone.currentOccupancy} / ${zone.capacity}",
                    color = OffWhite,
                    fontSize = 12.sp,
                    fontWeight = FontWeight.Medium
                )
            }
            Spacer(Modifier.height(4.dp))
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(6.dp)
                    .clip(RoundedCornerShape(3.dp))
                    .background(Color(0xFF1E1E2A))
            ) {
                Box(
                    modifier = Modifier
                        .fillMaxHeight()
                        .fillMaxWidth(fraction = pct / 100f)
                        .clip(RoundedCornerShape(3.dp))
                        .background(barColor)
                )
            }
            Text("$pct%", color = barColor, fontSize = 11.sp, modifier = Modifier.align(Alignment.End))

            Spacer(Modifier.height(10.dp))

            // M√©tricas
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                MetricChip("üå°Ô∏è", "${zone.temperature}¬∞C")
                MetricChip("‚è≥", "${zone.waitTime} min")
                MetricChip("‚¨ÜÔ∏è", "${zone.entryRate}/min")
                MetricChip("‚¨áÔ∏è", "${zone.exitRate}/min")
            }
        }
    }
}

@Composable
private fun MetricChip(emoji: String, value: String) {
    Surface(
        shape = RoundedCornerShape(8.dp),
        color = Color(0xFF1E1E2A)
    ) {
        Row(
            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(emoji, fontSize = 13.sp)
            Spacer(Modifier.width(4.dp))
            Text(value, color = OffWhite, fontSize = 12.sp, fontWeight = FontWeight.Medium)
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/screens/transport/TransportScreen.kt`

```kotlin
package com.georacing.georacing.ui.screens.transport

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawWithContent
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.georacing.georacing.ui.components.HomeIconButton
import com.georacing.georacing.ui.components.background.CarbonBackground
import com.georacing.georacing.ui.glass.LiquidTopBar
import com.georacing.georacing.ui.glass.LocalBackdrop
import com.georacing.georacing.ui.navigation.Screen
import com.georacing.georacing.ui.theme.*
import kotlinx.coroutines.delay
import java.time.LocalTime
import java.time.format.DateTimeFormatter

private enum class TransportType(val label: String, val icon: ImageVector, val color: Color) {
    TRAIN("Tren", Icons.Default.Train, ElectricBlue),
    SHUTTLE("Shuttle", Icons.Default.DirectionsBus, StatusGreen),
    WALKING("A pie", Icons.Default.DirectionsWalk, NeonOrange)
}

private data class TransportSchedule(
    val type: TransportType,
    val line: String,
    val origin: String,
    val destination: String,
    val departures: List<String>,
    val duration: String,
    val status: TransportStatus,
    val notes: String = ""
)

private enum class TransportStatus(val label: String, val color: Color) {
    ON_TIME("Puntual", StatusGreen),
    DELAYED("Retraso 5'", StatusAmber),
    CROWDED("Lleno", StatusRed),
    EXTRA("Refuerzo", ElectricBlue)
}

@Composable
fun TransportScreen(navController: NavController) {
    val backdrop = LocalBackdrop.current
    var selectedType by remember { mutableStateOf<TransportType?>(null) }
    var isLoading by remember { mutableStateOf(true) }
    var screenVisible by remember { mutableStateOf(false) }

    LaunchedEffect(Unit) { delay(300); isLoading = false; screenVisible = true }

    val schedules = remember {
        listOf(
            TransportSchedule(TransportType.TRAIN, "R2 Nord", "Barcelona Passeig de Gr√†cia", "Montmel√≥", listOf("08:12", "08:42", "09:12", "09:42", "10:12", "10:42", "11:12"), "45 min", TransportStatus.ON_TIME, "Cada 30 min. Bajar en estaci√≥n Montmel√≥."),
            TransportSchedule(TransportType.TRAIN, "R2 Nord", "Granollers Centre", "Montmel√≥", listOf("08:25", "08:55", "09:25", "09:55", "10:25", "10:55"), "8 min", TransportStatus.ON_TIME, "Frecuencia cada 30 min."),
            TransportSchedule(TransportType.SHUTTLE, "Shuttle A", "Estaci√≥n Montmel√≥", "Puerta Principal Circuito", listOf("08:30", "08:45", "09:00", "09:15", "09:30", "09:45", "10:00", "10:15", "10:30"), "10 min", TransportStatus.ON_TIME, "Servicio gratuito con entrada. Cada 15 min."),
            TransportSchedule(TransportType.SHUTTLE, "Shuttle B", "Parking P4 (La Roca Village)", "Puerta Norte Circuito", listOf("08:00", "08:30", "09:00", "09:30", "10:00", "10:30"), "15 min", TransportStatus.EXTRA, "Servicio adicional para eventos especiales."),
            TransportSchedule(TransportType.SHUTTLE, "Shuttle C", "Pl. Catalunya (Barcelona)", "Circuito Directo", listOf("07:00", "08:00", "09:00"), "55 min", TransportStatus.CROWDED, "Bus directo sin paradas. Reserva online recomendada."),
            TransportSchedule(TransportType.WALKING, "Ruta a pie", "Estaci√≥n Montmel√≥", "Puerta Principal", listOf("Libre"), "25 min", TransportStatus.ON_TIME, "1.8 km por camino se√±alizado. Seguir indicaciones naranja.")
        )
    }

    val filteredSchedules = if (selectedType != null) schedules.filter { it.type == selectedType } else schedules

    Box(modifier = Modifier.fillMaxSize()) {
        CarbonBackground()

        Column(modifier = Modifier.fillMaxSize()) {
            // ‚îÄ‚îÄ Glass Top Bar ‚îÄ‚îÄ
            LiquidTopBar(
                backdrop = backdrop,
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Volver", tint = TextPrimary)
                    }
                },
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Box(
                            modifier = Modifier
                                .size(8.dp)
                                .clip(CircleShape)
                                .background(NeonCyan)
                        )
                        Spacer(Modifier.width(10.dp))
                        Text(
                            "TRANSPORTE",
                            color = TextPrimary,
                            fontSize = 16.sp,
                            fontWeight = FontWeight.ExtraBold,
                            letterSpacing = 2.sp
                        )
                    }
                },
                actions = {
                    HomeIconButton {
                        navController.navigate(Screen.Home.route) {
                            popUpTo(Screen.Home.route) { inclusive = true }
                        }
                    }
                }
            )

            if (isLoading) {
                Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator(color = NeonCyan, strokeWidth = 2.dp)
                }
            } else {
                LazyColumn(
                    modifier = Modifier.fillMaxSize().padding(horizontal = 16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp),
                    contentPadding = PaddingValues(top = 8.dp, bottom = 100.dp)
                ) {
                    // Location header
                    item {
                        AnimatedVisibility(
                            visible = screenVisible,
                            enter = fadeIn(tween(500)) + slideInVertically(tween(500)) { -it / 3 }
                        ) {
                            Row(verticalAlignment = Alignment.CenterVertically) {
                                Icon(Icons.Default.LocationOn, null, tint = RacingRed, modifier = Modifier.size(14.dp))
                                Spacer(Modifier.width(6.dp))
                                Text(
                                    "CIRCUIT DE BARCELONA-CATALUNYA ¬∑ MONTMEL√ì",
                                    fontSize = 9.sp,
                                    fontWeight = FontWeight.Bold,
                                    letterSpacing = 1.5.sp,
                                    color = TextTertiary
                                )
                            }
                        }
                    }

                    // Info banner
                    item {
                        AnimatedVisibility(
                            visible = screenVisible,
                            enter = fadeIn(tween(600, 100)) + slideInVertically(tween(600, 100)) { it / 3 }
                        ) {
                            Box(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .clip(RoundedCornerShape(14.dp))
                                    .background(ElectricBlue.copy(alpha = 0.06f))
                                    .border(0.5.dp, ElectricBlue.copy(alpha = 0.15f), RoundedCornerShape(14.dp))
                                    .padding(14.dp)
                            ) {
                                Row(verticalAlignment = Alignment.CenterVertically) {
                                    Icon(Icons.Default.Info, null, tint = ElectricBlue, modifier = Modifier.size(18.dp))
                                    Spacer(Modifier.width(10.dp))
                                    Text(
                                        "Pr√≥ximo shuttle desde Montmel√≥ en 12 min",
                                        fontSize = 13.sp,
                                        color = ElectricBlue,
                                        fontWeight = FontWeight.Bold
                                    )
                                }
                            }
                        }
                    }

                    // Filter chips
                    item {
                        AnimatedVisibility(
                            visible = screenVisible,
                            enter = fadeIn(tween(600, 200)) + slideInVertically(tween(600, 200)) { it / 3 }
                        ) {
                            Column {
                                Text(
                                    "FILTRAR POR TIPO",
                                    fontSize = 9.sp,
                                    fontWeight = FontWeight.Bold,
                                    letterSpacing = 2.sp,
                                    color = TextTertiary
                                )
                                Spacer(Modifier.height(8.dp))
                                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                                    PremiumFilterChip("TODOS", TextSecondary, selectedType == null) { selectedType = null }
                                    TransportType.entries.forEach { type ->
                                        PremiumFilterChip(type.label.uppercase(), type.color, selectedType == type) {
                                            selectedType = if (selectedType == type) null else type
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Schedule cards with staggered anim
                    itemsIndexed(filteredSchedules) { index, schedule ->
                        var cardVisible by remember { mutableStateOf(false) }
                        LaunchedEffect(Unit) { delay(index * 60L + 300L); cardVisible = true }
                        AnimatedVisibility(
                            visible = cardVisible,
                            enter = fadeIn(spring(dampingRatio = 0.8f)) +
                                    slideInVertically(spring(dampingRatio = 0.7f)) { it / 2 }
                        ) {
                            PremiumTransportCard(schedule)
                        }
                    }

                    // Tips card
                    item {
                        Spacer(Modifier.height(8.dp))
                        Box(
                            modifier = Modifier
                                .fillMaxWidth()
                                .liquidGlass(shape = RoundedCornerShape(16.dp))
                                .padding(16.dp)
                        ) {
                            Column {
                                Text(
                                    "CONSEJOS DE TRANSPORTE",
                                    fontSize = 10.sp,
                                    fontWeight = FontWeight.ExtraBold,
                                    letterSpacing = 2.sp,
                                    color = TextTertiary
                                )
                                Spacer(Modifier.height(10.dp))
                                val tips = listOf(
                                    "Llega al menos 1h antes del evento",
                                    "La T-casual funciona para R2 Nord",
                                    "Evita AP-7 salida 14 en hora punta",
                                    "Shuttle gratuito con entrada al circuito",
                                    "Parking P1 y P2 se llenan antes de las 10:00"
                                )
                                tips.forEach { tip ->
                                    Row(modifier = Modifier.padding(vertical = 2.dp)) {
                                        Box(
                                            modifier = Modifier
                                                .padding(top = 5.dp)
                                                .size(4.dp)
                                                .clip(CircleShape)
                                                .background(RacingRed)
                                        )
                                        Spacer(Modifier.width(8.dp))
                                        Text(tip, fontSize = 12.sp, color = TextSecondary, lineHeight = 18.sp)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Premium Transport Card
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumTransportCard(schedule: TransportSchedule) {
    val nextDeparture = remember(schedule) {
        val now = LocalTime.now()
        schedule.departures.firstOrNull { dep ->
            try { LocalTime.parse(dep, DateTimeFormatter.ofPattern("HH:mm")).isAfter(now) } catch (_: Exception) { false }
        }
    }

    Box(
        modifier = Modifier
            .fillMaxWidth()
            .liquidGlass(
                shape = RoundedCornerShape(16.dp),
                accentGlow = schedule.type.color
            )
            .padding(16.dp)
    ) {
        Column {
            Row(verticalAlignment = Alignment.CenterVertically) {
                // Type icon
                Box(
                    modifier = Modifier
                        .size(42.dp)
                        .clip(RoundedCornerShape(12.dp))
                        .background(schedule.type.color.copy(alpha = 0.12f))
                        .border(0.5.dp, schedule.type.color.copy(alpha = 0.2f), RoundedCornerShape(12.dp)),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(schedule.type.icon, schedule.type.label, tint = schedule.type.color, modifier = Modifier.size(22.dp))
                }
                Spacer(Modifier.width(12.dp))
                Column(Modifier.weight(1f)) {
                    Text(schedule.line, fontSize = 15.sp, color = TextPrimary, fontWeight = FontWeight.ExtraBold, letterSpacing = 0.5.sp)
                    Text(
                        "${schedule.origin} ‚Üí ${schedule.destination}",
                        fontSize = 11.sp,
                        color = TextTertiary,
                        maxLines = 1
                    )
                }
                // Status
                Box(
                    modifier = Modifier
                        .clip(RoundedCornerShape(50))
                        .background(schedule.status.color.copy(alpha = 0.12f))
                        .border(0.5.dp, schedule.status.color.copy(alpha = 0.25f), RoundedCornerShape(50))
                        .padding(horizontal = 8.dp, vertical = 4.dp)
                ) {
                    Text(
                        schedule.status.label.uppercase(),
                        fontSize = 8.sp,
                        fontWeight = FontWeight.ExtraBold,
                        letterSpacing = 0.5.sp,
                        color = schedule.status.color
                    )
                }
            }

            Spacer(Modifier.height(14.dp))

            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
                Column {
                    Text("DURACI√ìN", fontSize = 9.sp, fontWeight = FontWeight.Bold, letterSpacing = 1.sp, color = TextTertiary)
                    Text(schedule.duration, fontSize = 16.sp, color = TextPrimary, fontWeight = FontWeight.ExtraBold)
                }
                if (nextDeparture != null) {
                    Column(horizontalAlignment = Alignment.End) {
                        Text("PR√ìXIMA SALIDA", fontSize = 9.sp, fontWeight = FontWeight.Bold, letterSpacing = 1.sp, color = TextTertiary)
                        Text(nextDeparture, fontSize = 16.sp, color = StatusGreen, fontWeight = FontWeight.ExtraBold)
                    }
                }
            }

            if (schedule.notes.isNotBlank()) {
                Spacer(Modifier.height(10.dp))
                Text(schedule.notes, fontSize = 11.sp, color = TextTertiary, lineHeight = 16.sp)
            }

            Spacer(Modifier.height(10.dp))

            // Departure times
            LazyRow(horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                items(schedule.departures) { dep ->
                    val isPast = try { LocalTime.parse(dep, DateTimeFormatter.ofPattern("HH:mm")).isBefore(LocalTime.now()) } catch (_: Exception) { false }
                    Box(
                        modifier = Modifier
                            .clip(RoundedCornerShape(6.dp))
                            .background(if (isPast) Color.Transparent else MetalGrey.copy(alpha = 0.4f))
                            .then(
                                if (!isPast) Modifier.border(0.5.dp, Color.White.copy(alpha = 0.06f), RoundedCornerShape(6.dp))
                                else Modifier
                            )
                            .padding(horizontal = 8.dp, vertical = 4.dp)
                    ) {
                        Text(
                            dep,
                            fontSize = 11.sp,
                            fontWeight = FontWeight.Bold,
                            color = if (isPast) TextTertiary.copy(alpha = 0.3f) else TextSecondary
                        )
                    }
                }
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Premium Filter Chip
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Composable
private fun PremiumFilterChip(
    label: String,
    color: Color,
    selected: Boolean,
    onClick: () -> Unit
) {
    val bgAlpha by animateFloatAsState(if (selected) 0.2f else 0.05f, label = "bg")
    val borderAlpha by animateFloatAsState(if (selected) 0.5f else 0.08f, label = "brd")

    Box(
        modifier = Modifier
            .clip(RoundedCornerShape(50))
            .background(color.copy(alpha = bgAlpha))
            .border(0.5.dp, color.copy(alpha = borderAlpha), RoundedCornerShape(50))
            .clickable(onClick = onClick)
            .padding(horizontal = 12.dp, vertical = 6.dp)
    ) {
        Text(
            label,
            fontSize = 10.sp,
            fontWeight = FontWeight.ExtraBold,
            letterSpacing = 1.sp,
            color = color.copy(alpha = if (selected) 1f else 0.5f)
        )
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/theme/Color.kt`

```kotlin
package com.georacing.georacing.ui.theme

import androidx.compose.ui.graphics.Color

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üèéÔ∏è  GeoRacing ‚Äî Industrial Grade Color System (Phase 6)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Optimizado para visibilidad bajo luz solar directa (100k lux)
// y cero consumo de bater√≠a en OLED (Overdraw = 0).

// M√ìDULO 1: Brand Identity & Color System

// Colores Crudos (Raw Colors)
val TarmacBlack = Color(0xFF000000)      // Pure Black (OLED Pixels OFF)
val AsphaltDark = Color(0xFF121212)      // Base surfaces
val AsphaltMedium = Color(0xFF1E1E1E)    // Elevated surfaces or separators
val AsphaltLight = Color(0xFF2C2C2C)     // High emphasis borders/lines

val CatalunyaRed = Color(0xFFE5001C)     // Circuit official red (Primary CTAs & Danger)
val KerbYellow = Color(0xFFFFD700)       // Maximum contrast accents (Warnings)
val KerbWhite = Color(0xFFFFFFFF)        // Pure White (High Emphasis Text/Icons)

// Secondary semantic colors mapped to Industrial requirements
val TelemetryGreen = Color(0xFF00E676)   // Systems nominal / Success
val MutedText = Color(0xFFAAAAAA)        // Low emphasis text for telemetry metadata

// Transparent utilities (Use sparingly to avoid overdraw, only for ripples/states)
val TransparentOutline = KerbWhite.copy(alpha = 0.12f)
val TransparentRed = CatalunyaRed.copy(alpha = 0.15f)

// =========================================================================
// ‚ö†Ô∏è BACKWARD COMPATIBILITY ALIASES (Deprecated - To be refactored)
// =========================================================================
val CarbonBlack = TarmacBlack
val AsphaltGrey = AsphaltDark
val MetalGrey = AsphaltMedium
val PitLaneGrey = AsphaltLight
val RacingRed = CatalunyaRed
val RacingRedBright = CatalunyaRed
val RacingRedDark = Color(0xFFB31222)

val NeonOrange = KerbYellow
val NeonCyan = Color(0xFF00F0FF)
val NeonPurple = Color(0xFFB5179E)
val ElectricBlue = Color(0xFF4361EE)
val ChampagneGold = KerbYellow

val StatusGreen = TelemetryGreen
val StatusAmber = KerbYellow
val StatusRed = CatalunyaRed
val StatusBlue = ElectricBlue

val TextPrimary = KerbWhite
val TextSecondary = MutedText
val TextTertiary = Color(0xFF6B7280)
val TextAccent = CatalunyaRed

val InfoBlue = StatusBlue
val NeutralGrey = MutedText
val DisabledGrey = AsphaltLight
val OutlineLight = TransparentOutline
val OutlineAccent = NeonCyan.copy(alpha = 0.4f)

val AccentFood = NeonOrange
val AccentSocial = NeonPurple
val AccentSafety = StatusRed
val AccentInfo = ElectricBlue
val AccentEvent = RacingRedBright
val AccentNavigation = NeonCyan
val AccentParking = TextSecondary
val AccentMoments = Color(0xFFF72585)

val GlassSurface = AsphaltDark.copy(alpha = 0.9f) // Removed blur, just solid with slight alpha if absolutely forced
val GlassHighlight = TransparentOutline
val GlassBorder = TransparentOutline

val CircuitStop = StatusRed
val CircuitGreen = StatusGreen
val CircuitCongestion = StatusAmber

val Primary = CatalunyaRed
val Secondary = AsphaltLight
val Tertiary = KerbYellow
val Background = TarmacBlack
val Surface = AsphaltDark
val SurfaceVariant = AsphaltMedium
val OnPrimary = KerbWhite
val OnSecondary = KerbWhite
val OnBackground = KerbWhite
val OnSurface = KerbWhite
val Error = CatalunyaRed
val OnError = KerbWhite

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/theme/Dimens.kt`

```kotlin
package com.georacing.georacing.ui.theme

import androidx.compose.ui.unit.dp

// üèéÔ∏è Spacing Scale (4px base grid)
object Spacing {
    val none = 0.dp
    val xxs = 2.dp
    val xs = 4.dp
    val sm = 8.dp
    val md = 12.dp
    val lg = 16.dp
    val xl = 24.dp
    val xxl = 32.dp
    val xxxl = 48.dp
    val huge = 64.dp
    val hero = 96.dp    // Hero sections, splash
}

// Layout Constants ‚Äî Racing Dashboard
object Layout {
    val screenPadding = 20.dp     // Slightly wider for premium feel
    val cardPadding = Spacing.lg
    val sectionSpacing = Spacing.xl
    val iconSmall = 16.dp
    val iconMedium = 24.dp
    val iconLarge = 32.dp
    val iconXLarge = 48.dp
    val buttonHeight = 56.dp
    val buttonHeightCompact = 44.dp
    val pillHeight = 34.dp
    val topBarHeight = 56.dp
    val bottomBarHeight = 72.dp
    val cardElevation = 8.dp
}

// Corner Radius ‚Äî Consistent rounding
object Radius {
    val xs = 4.dp
    val sm = 8.dp
    val md = 12.dp
    val lg = 16.dp
    val xl = 24.dp
    val xxl = 28.dp    // Hero cards
    val full = 9999.dp // Circle/Pill
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/theme/LiquidModifiers.kt`

```kotlin
package com.georacing.georacing.ui.theme

import android.os.Build
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.ui.Modifier
import androidx.compose.ui.composed
import androidx.compose.ui.draw.blur
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawWithContent
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Shape
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp

enum class GlassLevel {
    L1, // Chips, Filters, Small items (Higher Opacity, subtle edge)
    L2, // Cards, Large Containers (Translucent, ambient glow)
    L3  // Hero / Premium elements (Deep translucency, accent edge)
}

/**
 * üèéÔ∏è Aplica el efecto "Liquid Glass" Premium al componente.
 * 
 * Capas del efecto:
 * 1. Background transl√∫cido con tinte azulado (profundidad)
 * 2. Inner highlight gradient (luminosidad superior)
 * 3. Borde con gradiente (specular edge)
 *
 * @param level Nivel de intensidad del glass.
 * @param showBorder Si debe mostrar el borde luminoso specular.
 * @param borderColor Color personalizado para el borde.
 * @param accentGlow Color de glow sutil en la parte superior.
 */
fun Modifier.liquidGlass(
    shape: Shape = RoundedCornerShape(16.dp),
    level: GlassLevel = GlassLevel.L2,
    showBorder: Boolean = true,
    borderColor: Color? = null,
    accentGlow: Color? = null
) = composed {
    val baseAlpha = when(level) {
        GlassLevel.L1 -> 0.82f
        GlassLevel.L2 -> 0.68f
        GlassLevel.L3 -> 0.55f
    }
    
    val borderWidth = when(level) {
        GlassLevel.L1 -> 0.5.dp
        GlassLevel.L2 -> 0.75.dp
        GlassLevel.L3 -> 1.dp
    }
    
    val glowAlpha = when(level) {
        GlassLevel.L1 -> 0.03f
        GlassLevel.L2 -> 0.05f
        GlassLevel.L3 -> 0.08f
    }
    
    // Surface color con tinte azulado para profundidad
    val surfaceColor = AsphaltGrey.copy(alpha = baseAlpha)
    val highlightColor = accentGlow ?: NeonCyan
    
    this
        .background(
            color = surfaceColor,
            shape = shape
        )
        // Inner highlight ‚Äî luz sutil en la parte superior
        .drawWithContent {
            drawContent()
            drawRect(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        highlightColor.copy(alpha = glowAlpha),
                        Color.Transparent
                    ),
                    startY = 0f,
                    endY = size.height * 0.4f
                )
            )
        }
        .then(
            if (showBorder) {
                Modifier.border(
                    width = borderWidth,
                    brush = if (borderColor != null) {
                        Brush.verticalGradient(
                            colors = listOf(
                                borderColor.copy(alpha = 0.5f),
                                borderColor.copy(alpha = 0.08f)
                            )
                        )
                    } else {
                        Brush.verticalGradient(
                            colors = listOf(
                                Color.White.copy(alpha = 0.18f),
                                Color.White.copy(alpha = 0.03f)
                            )
                        )
                    },
                    shape = shape
                )
            } else Modifier
        )
        .clip(shape)
}

/**
 * Variante m√°s ligera para elementos peque√±os (Pills, botones, chips)
 * Con borde specular sutil.
 */
fun Modifier.glassSmall(
    shape: Shape = RoundedCornerShape(50),
    color: Color = AsphaltGrey
) = composed {
    this
        .background(
            color = color.copy(alpha = 0.55f),
            shape = shape
        )
        .border(
            width = 0.5.dp,
            brush = Brush.verticalGradient(
                colors = listOf(
                    Color.White.copy(alpha = 0.15f),
                    Color.White.copy(alpha = 0.04f)
                )
            ),
            shape = shape
        )
        .clip(shape)
}

/**
 * üèéÔ∏è Efecto de acento deportivo: borde lateral con color racing.
 * Ideal para cards activas o seleccionadas.
 */
fun Modifier.racingAccent(
    color: Color = RacingRed,
    shape: Shape = RoundedCornerShape(16.dp)
) = composed {
    this
        .drawWithContent {
            drawContent()
            // L√≠nea de acento lateral izquierda
            drawLine(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        color.copy(alpha = 0.8f),
                        color.copy(alpha = 0.2f)
                    )
                ),
                start = Offset(0f, size.height * 0.15f),
                end = Offset(0f, size.height * 0.85f),
                strokeWidth = 3.dp.toPx()
            )
        }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/theme/Motion.kt`

```kotlin
package com.georacing.georacing.ui.theme

import androidx.compose.animation.core.CubicBezierEasing
import androidx.compose.animation.core.FastOutSlowInEasing
import androidx.compose.animation.core.LinearEasing
import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.spring
import androidx.compose.animation.core.tween

/**
 * üèéÔ∏è Sistema de Movimiento GeoRacing ‚Äî Premium Racing Physics
 * Define la "f√≠sica" de la interfaz con sensaci√≥n deportiva.
 */
object Motion {
    // ‚îÄ‚îÄ Durations ‚îÄ‚îÄ
    const val DurationInstant = 80        // Micro-feedback (tap, press)
    const val DurationFast = 150          // Quick transitions
    const val DurationMedium = 300        // Standard transitions
    const val DurationSlow = 500          // Emphasized transitions
    const val DurationXSlow = 800         // Map / large background transitions
    const val DurationCinematic = 1200    // Splash / hero animations

    // ‚îÄ‚îÄ Easings ‚îÄ‚îÄ
    // "Launch" ‚Äî Aggressive start, smooth landing (button presses, entries)
    val EasingLaunch = CubicBezierEasing(0.16f, 0.0f, 0.13f, 1.0f)
    
    // "Racing" ‚Äî Sharp acceleration (micro-animations)
    val EasingRacing = CubicBezierEasing(0.25f, 0.0f, 0.15f, 1.0f)
    
    // "Smooth" ‚Äî Natural flow (screen transitions, panels)
    val EasingSmooth = FastOutSlowInEasing
    
    // "Decelerate" ‚Äî Fast start, gentle stop (exit animations)
    val EasingDecelerate = CubicBezierEasing(0.0f, 0.0f, 0.2f, 1.0f)
    
    // "Overshoot" ‚Äî Sporty bounce (card entrances, FAB)
    val EasingOvershoot = CubicBezierEasing(0.34f, 1.56f, 0.64f, 1.0f)

    val EasingLinear = LinearEasing

    // ‚îÄ‚îÄ Spring Specs ‚îÄ‚îÄ
    /** Snappy spring for buttons and interactive elements */
    fun <T> springSnappy() = spring<T>(
        dampingRatio = 0.7f,
        stiffness = 600f
    )
    
    /** Bouncy spring for cards and entrance animations */
    fun <T> springBouncy() = spring<T>(
        dampingRatio = Spring.DampingRatioLowBouncy,
        stiffness = Spring.StiffnessLow
    )
    
    /** Gentle spring for large panels and navigation */
    fun <T> springGentle() = spring<T>(
        dampingRatio = 0.85f,
        stiffness = Spring.StiffnessLow
    )
    
    /** Racing spring ‚Äî aggressive with minimal bounce */
    fun <T> springRacing() = spring<T>(
        dampingRatio = 0.55f,
        stiffness = 800f
    )

    // ‚îÄ‚îÄ Animation Specs ‚îÄ‚îÄ
    fun <T> fadeIn() = tween<T>(
        durationMillis = DurationMedium,
        easing = EasingDecelerate
    )
    
    fun <T> slideSmooth() = tween<T>(
        durationMillis = DurationMedium,
        easing = EasingSmooth
    )
    
    fun <T> slideUp() = tween<T>(
        durationMillis = DurationMedium,
        easing = EasingLaunch
    )
    
    fun <T> staggeredEntry(index: Int) = tween<T>(
        durationMillis = DurationMedium,
        delayMillis = index * 50,
        easing = EasingLaunch
    )
    
    fun <T> cinematic() = tween<T>(
        durationMillis = DurationCinematic,
        easing = EasingSmooth
    )
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/theme/Theme.kt`

```kotlin
package com.georacing.georacing.ui.theme

import android.app.Activity
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Shapes
import androidx.compose.material3.darkColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.ui.unit.dp

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üèéÔ∏è  GeoRacing ‚Äî Racing Theme (Phase 6)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Forzamos un tema oscuro (darkColorScheme) por dise√±o para 
// la visibilidad y ahorro extremo en pantallas OLED.

private val RacingColorScheme = darkColorScheme(
    primary = CatalunyaRed,
    onPrimary = KerbWhite,
    secondary = AsphaltLight,
    onSecondary = KerbWhite,
    tertiary = KerbYellow,
    onTertiary = TarmacBlack,
    background = TarmacBlack,     // Black background
    onBackground = KerbWhite,
    surface = AsphaltDark,        // Cards / dialogs surface
    onSurface = KerbWhite,
    surfaceVariant = AsphaltMedium,
    onSurfaceVariant = MutedText,
    error = CatalunyaRed,
    onError = KerbWhite,
    outline = AsphaltLight
)

// Sharp logic - Zero soft borders for technical aesthetic
val RacingShapes = Shapes(
    small = RoundedCornerShape(2.dp),
    medium = RoundedCornerShape(4.dp),
    large = RoundedCornerShape(4.dp),
    extraLarge = RoundedCornerShape(8.dp)
)

@Composable
fun GeoRacingTheme(
    forceOledBlack: Boolean = false, // Modo SOS / Supervivencia extrema
    content: @Composable () -> Unit
) {
    // Si estamos en modo cr√≠tico, forzamos TODO a negro puro, ignorando las Cards de fondo Asphalt
    val finalColorScheme = if (forceOledBlack) {
        RacingColorScheme.copy(
            surface = TarmacBlack,
            surfaceVariant = TarmacBlack,
            background = TarmacBlack
        )
    } else {
        RacingColorScheme
    }

    val view = LocalView.current
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            
            // Forzar status bar y navigation bar a negro OLED
            window.statusBarColor = Color.Black.toArgb()
            window.navigationBarColor = Color.Black.toArgb()
            
            val insetsController = WindowCompat.getInsetsController(window, view)
            insetsController.isAppearanceLightStatusBars = false
            insetsController.isAppearanceLightNavigationBars = false
        }
    }

    MaterialTheme(
        colorScheme = finalColorScheme,
        typography = Typography,
        shapes = RacingShapes,
        content = content
    )
}

/**
 * üÜò Tema OLED forzado (Alias para compatibilidad con el ecosistema de supervivencia antiguo)
 */
@Composable
fun GeoRacingOLEDTheme(content: @Composable () -> Unit) {
    GeoRacingTheme(forceOledBlack = true, content = content)
}

// CompositionLocal fallbacks (mantenido por compatibilidad con Phase 1)
val LocalEnergyProfile = androidx.compose.runtime.staticCompositionLocalOf<com.georacing.georacing.domain.model.EnergyProfile> {
    com.georacing.georacing.domain.model.EnergyProfile.Performance
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/ui/theme/Type.kt`

```kotlin
package com.georacing.georacing.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üèéÔ∏è  GeoRacing ‚Äî Telemetry Typography System (Phase 6)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Dise√±ado para lectura r√°pida a 1 metro de distancia con gafas 
// de sol y vibraciones en movimiento. Sin florituras.

// Idealmente aqu√≠ se cargar√≠a una fuente Geom√©trica o Monospace, 
// utilizamos la fuente SansSerif nativa forzando pesos extremos.
val TelemetryFontFamily = FontFamily.SansSerif

val Typography = Typography(
    // ‚îÄ‚îÄ Display: Titulares grandes, m√©tricas principales (Velocidad, RPM) ‚îÄ‚îÄ
    displayLarge = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Black,
        fontSize = 57.sp,
        lineHeight = 64.sp,
        letterSpacing = (-0.25).sp
    ),
    displayMedium = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Black,
        fontSize = 45.sp,
        lineHeight = 52.sp,
        letterSpacing = 0.sp
    ),
    displaySmall = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Bold,
        fontSize = 36.sp,
        lineHeight = 44.sp,
        letterSpacing = 0.sp
    ),

    // ‚îÄ‚îÄ Headline: Cabeceras de secci√≥n de los paneles de telemetr√≠a ‚îÄ‚îÄ
    headlineLarge = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Bold,
        fontSize = 32.sp,
        lineHeight = 40.sp,
        letterSpacing = 0.sp
    ),
    headlineMedium = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Bold,
        fontSize = 28.sp,
        lineHeight = 36.sp,
        letterSpacing = 0.sp
    ),
    headlineSmall = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Bold,
        fontSize = 24.sp,
        lineHeight = 32.sp,
        letterSpacing = 0.sp
    ),

    // ‚îÄ‚îÄ Title: T√≠tulos de tarjetas y componentes ‚îÄ‚îÄ
    titleLarge = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Bold,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    titleMedium = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Bold,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.15.sp
    ),
    titleSmall = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Bold,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp
    ),

    // ‚îÄ‚îÄ Body: Lectura de descripciones largas y notificaciones (Alta legibilidad) ‚îÄ‚îÄ
    bodyLarge = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Medium,
        fontSize = 16.sp,
        lineHeight = 28.sp, // Line height holgado
        letterSpacing = 0.15.sp
    ),
    bodyMedium = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Normal,
        fontSize = 14.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.25.sp
    ),
    bodySmall = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Normal,
        fontSize = 12.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.4.sp
    ),

    // ‚îÄ‚îÄ Label: Botones, badges, etiquetas de estado (Todo may√∫sculas esperado) ‚îÄ‚îÄ
    labelLarge = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Bold,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp
    ),
    labelMedium = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Bold,
        fontSize = 12.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    ),
    labelSmall = TextStyle(
        fontFamily = TelemetryFontFamily,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
)

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/utils/DistanceCalculator.kt`

```kotlin
package com.georacing.georacing.utils

import android.location.Location
import org.maplibre.android.geometry.LatLng

/**
 * Utilidades para c√°lculo de distancias en navegaci√≥n.
 */
object DistanceCalculator {
    
    /**
     * Calcula la distancia restante desde un punto en la ruta hasta el final.
     * 
     * @param snapResult Resultado del snap (punto actual en la ruta)
     * @param routePoints Geometr√≠a completa de la ruta
     * @return Distancia en metros
     */
    fun calculateRemainingDistance(
        snapResult: SnapResult,
        routePoints: List<LatLng>
    ): Double {
        var remaining = 0.0
        
        // Sumar distancias de todos los segmentos desde el punto actual hasta el final
        for (i in snapResult.closestIndex until routePoints.size - 1) {
            val p1 = routePoints[i].toLocation()
            val p2 = routePoints[i + 1].toLocation()
            remaining += p1.distanceTo(p2).toDouble()
        }
        
        return remaining
    }
    
    /**
     * Calcula la distancia a un punto espec√≠fico de la ruta.
     * √ötil para saber cu√°ntos metros faltan para un paso/maniobra.
     * 
     * @param currentIndex √çndice actual en la ruta
     * @param targetIndex √çndice del punto objetivo
     * @param routePoints Geometr√≠a de la ruta
     */
    fun calculateDistanceBetweenIndices(
        currentIndex: Int,
        targetIndex: Int,
        routePoints: List<LatLng>
    ): Double {
        if (currentIndex >= targetIndex) return 0.0
        
        var distance = 0.0
        for (i in currentIndex until targetIndex.coerceAtMost(routePoints.size - 1)) {
            val p1 = routePoints[i].toLocation()
            val p2 = routePoints[i + 1].toLocation()
            distance += p1.distanceTo(p2).toDouble()
        }
        
        return distance
    }
    
    /**
     * Calcula distancia directa (l√≠nea recta) entre dos puntos.
     * √ötil para check r√°pido de cercan√≠a al destino.
     */
    fun calculateDirectDistance(from: Location, to: LatLng): Double {
        val toLocation = to.toLocation()
        return from.distanceTo(toLocation).toDouble()
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/utils/ETACalculator.kt`

```kotlin
package com.georacing.georacing.utils

/**
 * Calculador de ETA (Estimated Time of Arrival) estilo Google Maps.
 * 
 * IMPORTANTE: Este calculador NO usa la velocidad actual del veh√≠culo,
 * ya que esto causar√≠a que el ETA fluct√∫e constantemente.
 * 
 * En su lugar, usa el tiempo estimado de la ruta original y calcula
 * proporcionalmente cu√°nto tiempo queda seg√∫n la distancia restante.
 */
object ETACalculator {
    
    /**
     * Calcula el tiempo restante proporcionalmente a la ruta original.
     * 
     * Ejemplo:
     * - Ruta total: 15 km, 20 minutos
     * - Distancia restante: 7.5 km (50% de la ruta)
     * - Tiempo restante: 10 minutos (50% del tiempo)
     * 
     * Este m√©todo hace que el ETA sea ESTABLE y solo cambie cuando:
     * 1. Se recalcula la ruta (cada 30s o si hay off-route)
     * 2. Hay cambios significativos de tr√°fico en el servidor
     * 
     * @param remainingDistance Distancia restante en metros
     * @param totalDistance Distancia total de la ruta en metros
     * @param totalDuration Duraci√≥n total estimada de la ruta en segundos
     * @return Tiempo restante en segundos
     */
    fun calculateRemainingTime(
        remainingDistance: Double,
        totalDistance: Double,
        totalDuration: Double
    ): Double {
        if (totalDistance <= 0) return 0.0
        
        // C√°lculo proporcional
        val proportion = remainingDistance / totalDistance
        return proportion * totalDuration
    }
    
    /**
     * Calcula el tiempo restante aplicando un factor de tr√°fico.
     * 
     * FASE 3: Extensi√≥n para soportar datos de tr√°fico en tiempo real.
     * 
     * El factor de tr√°fico permite ajustar el ETA seg√∫n las condiciones actuales:
     * - trafficFactor = 1.0 -> sin tr√°fico (tiempo normal)
     * - trafficFactor = 1.2 -> tr√°fico moderado (+20% tiempo)
     * - trafficFactor = 1.5 -> tr√°fico intenso (+50% tiempo)
     * - trafficFactor = 0.8 -> tr√°fico fluido (-20% tiempo, poco com√∫n)
     * 
     * Ejemplo:
     * - ETA base: 600 segundos (10 min)
     * - Factor tr√°fico: 1.2 (tr√°fico moderado)
     * - ETA ajustado: 720 segundos (12 min)
     * 
     * Rango recomendado: 0.8 - 2.0
     * - Valores < 0.5 o > 2.5 probablemente indican datos incorrectos
     * - El factor se limita internamente a [0.5, 3.0] por seguridad
     * 
     * TODO FASE 3: Integrar con TrafficProvider real cuando est√© disponible
     * TODO FASE 3: Considerar factores de tr√°fico por segmento de ruta (no solo global)
     * 
     * @param remainingDistance Distancia restante en metros
     * @param totalDistance Distancia total de la ruta en metros
     * @param totalDuration Duraci√≥n total estimada de la ruta en segundos
     * @param trafficFactor Multiplicador de tr√°fico (1.0 = sin cambios, >1.0 = m√°s lento, <1.0 = m√°s r√°pido)
     * @return Tiempo restante en segundos ajustado por tr√°fico
     */
    fun calculateRemainingTimeWithTraffic(
        remainingDistance: Double,
        totalDistance: Double,
        totalDuration: Double,
        trafficFactor: Double
    ): Double {
        // Calcular ETA base
        val baseETA = calculateRemainingTime(remainingDistance, totalDistance, totalDuration)
        
        // Limitar factor de tr√°fico a rangos razonables (evitar datos corruptos)
        val clampedFactor = trafficFactor.coerceIn(0.5, 3.0)
        
        // Aplicar factor de tr√°fico
        return baseETA * clampedFactor
    }
    
    /**
     * Calcula el timestamp de llegada estimado.
     * 
     * @param remainingTimeSeconds Segundos restantes
     * @return Timestamp Unix en milisegundos
     */
    fun calculateArrivalTimestamp(remainingTimeSeconds: Double): Long {
        val now = System.currentTimeMillis()
        return now + (remainingTimeSeconds * 1000).toLong()
    }
    
    /**
     * Formatea el tiempo restante en formato legible.
     * 
     * Ejemplos:
     * - 45 segundos -> "1 min"
     * - 90 segundos -> "2 min"
     * - 3600 segundos -> "1 h"
     * - 5400 segundos -> "1 h 30 min"
     * - 86400 segundos -> "1 d√≠a"
     * 
     * @param seconds Segundos totales
     * @return String formateado
     */
    fun formatDuration(seconds: Double): String {
        val totalSeconds = seconds.toLong()
        
        return when {
            totalSeconds < 60 -> "1 min"
            totalSeconds < 3600 -> {
                val minutes = (totalSeconds / 60).toInt()
                "$minutes min"
            }
            totalSeconds < 86400 -> {
                val hours = (totalSeconds / 3600).toInt()
                val minutes = ((totalSeconds % 3600) / 60).toInt()
                if (minutes > 0) {
                    "$hours h $minutes min"
                } else {
                    "$hours h"
                }
            }
            else -> {
                val days = (totalSeconds / 86400).toInt()
                val hours = ((totalSeconds % 86400) / 3600).toInt()
                if (hours > 0) {
                    "$days d $hours h"
                } else {
                    "$days d√≠as"
                }
            }
        }
    }
    
    /**
     * Formatea la hora de llegada en formato HH:mm
     * 
     * @param arrivalTimestamp Timestamp Unix de llegada
     * @return String en formato "14:30"
     */
    fun formatArrivalTime(arrivalTimestamp: Long): String {
        val calendar = java.util.Calendar.getInstance()
        calendar.timeInMillis = arrivalTimestamp
        
        val hour = calendar.get(java.util.Calendar.HOUR_OF_DAY)
        val minute = calendar.get(java.util.Calendar.MINUTE)
        
        return String.format("%02d:%02d", hour, minute)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/utils/ImageUtils.kt`

```kotlin
package com.georacing.georacing.utils

import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream

/**
 * Image compression utilities to prevent ANRs and OOM errors.
 * Designed for handling high-resolution camera photos in a memory-safe way.
 */
object ImageUtils {
    
    private const val MAX_DIMENSION = 1024
    private const val JPEG_QUALITY = 60
    
    /**
     * Compresses an image from URI to a ByteArray.
     * - Resizes to max 1024x1024 maintaining aspect ratio
     * - Compresses to JPEG at 60% quality
     * - Handles EXIF rotation
     * 
     * @param context Application context for content resolver
     * @param uri URI of the image to compress
     * @return Compressed image as ByteArray, or null on failure
     */
    suspend fun compressImage(context: Context, uri: Uri): ByteArray? = withContext(Dispatchers.IO) {
        try {
            // 1. Decode bounds only first (memory efficient)
            val options = BitmapFactory.Options().apply {
                inJustDecodeBounds = true
            }
            context.contentResolver.openInputStream(uri)?.use { input ->
                BitmapFactory.decodeStream(input, null, options)
            }
            
            val originalWidth = options.outWidth
            val originalHeight = options.outHeight
            
            if (originalWidth <= 0 || originalHeight <= 0) {
                return@withContext null
            }
            
            // 2. Calculate sample size for memory-efficient loading
            val sampleSize = calculateSampleSize(originalWidth, originalHeight, MAX_DIMENSION)
            
            // 3. Decode with sample size
            val decodingOptions = BitmapFactory.Options().apply {
                inSampleSize = sampleSize
                inPreferredConfig = Bitmap.Config.RGB_565 // Uses less memory
            }
            
            val bitmap = context.contentResolver.openInputStream(uri)?.use { input ->
                BitmapFactory.decodeStream(input, null, decodingOptions)
            } ?: return@withContext null
            
            // 4. Handle EXIF rotation
            val rotatedBitmap = handleExifRotation(context, uri, bitmap)
            
            // 5. Scale to exact max dimension if still larger
            val scaledBitmap = scaleToMaxDimension(rotatedBitmap, MAX_DIMENSION)
            if (scaledBitmap !== rotatedBitmap) {
                rotatedBitmap.recycle()
            }
            
            // 6. Compress to JPEG ByteArray
            val outputStream = ByteArrayOutputStream()
            scaledBitmap.compress(Bitmap.CompressFormat.JPEG, JPEG_QUALITY, outputStream)
            
            // Cleanup
            if (scaledBitmap !== bitmap) {
                scaledBitmap.recycle()
            }
            bitmap.recycle()
            
            outputStream.toByteArray()
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }
    
    private fun calculateSampleSize(width: Int, height: Int, targetMax: Int): Int {
        var sampleSize = 1
        val maxDimension = maxOf(width, height)
        
        while (maxDimension / sampleSize > targetMax * 2) {
            sampleSize *= 2
        }
        
        return sampleSize
    }
    
    private fun handleExifRotation(context: Context, uri: Uri, bitmap: Bitmap): Bitmap {
        return try {
            val inputStream = context.contentResolver.openInputStream(uri)
            val exif = inputStream?.let { ExifInterface(it) }
            inputStream?.close()
            
            val orientation = exif?.getAttributeInt(
                ExifInterface.TAG_ORIENTATION,
                ExifInterface.ORIENTATION_NORMAL
            ) ?: ExifInterface.ORIENTATION_NORMAL
            
            val rotation = when (orientation) {
                ExifInterface.ORIENTATION_ROTATE_90 -> 90f
                ExifInterface.ORIENTATION_ROTATE_180 -> 180f
                ExifInterface.ORIENTATION_ROTATE_270 -> 270f
                else -> 0f
            }
            
            if (rotation != 0f) {
                val matrix = Matrix().apply { postRotate(rotation) }
                Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)
            } else {
                bitmap
            }
        } catch (e: Exception) {
            bitmap
        }
    }
    
    private fun scaleToMaxDimension(bitmap: Bitmap, maxDimension: Int): Bitmap {
        val width = bitmap.width
        val height = bitmap.height
        
        if (width <= maxDimension && height <= maxDimension) {
            return bitmap
        }
        
        val ratio = minOf(
            maxDimension.toFloat() / width,
            maxDimension.toFloat() / height
        )
        
        val newWidth = (width * ratio).toInt()
        val newHeight = (height * ratio).toInt()
        
        return Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/utils/MedicalLockScreenGenerator.kt`

```kotlin
package com.georacing.georacing.utils

import android.content.ContentValues
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.Typeface
import android.net.Uri
import android.os.Build
import android.os.Environment
import android.provider.MediaStore
import android.util.Log
import android.app.WallpaperManager
import com.google.zxing.BarcodeFormat
import com.google.zxing.EncodeHintType
import com.google.zxing.qrcode.QRCodeWriter
import java.io.File
import java.io.FileOutputStream
import java.io.OutputStream

/**
 * Generador de Lock Screen M√©dico.
 * 
 * Crea un Bitmap con informaci√≥n vital del usuario:
 * - QR de entrada (para identificaci√≥n)
 * - Grupo sangu√≠neo
 * - Alergias
 * - Contacto de emergencia
 * 
 * El usuario puede establecerlo como fondo de pantalla para
 * que el personal de emergencia pueda ver los datos sin desbloquear.
 */
object MedicalLockScreenGenerator {

    private const val TAG = "MedicalLockScreen"
    
    // Dimensiones est√°ndar de wallpaper (1080x1920 para Full HD)
    private const val WIDTH = 1080
    private const val HEIGHT = 1920
    private const val QR_SIZE = 400
    
    /**
     * Genera el Bitmap del Lock Screen m√©dico.
     * 
     * @param qrData Datos para el c√≥digo QR (ej: ID de entrada, URL perfil)
     * @param userName Nombre del usuario
     * @param bloodType Grupo sangu√≠neo (A+, B-, etc.)
     * @param allergies Lista de alergias separadas por coma
     * @param emergencyContact Nombre del contacto de emergencia
     * @param emergencyPhone Tel√©fono del contacto de emergencia
     * @param medicalNotes Notas adicionales
     * @return Bitmap listo para usar como wallpaper
     */
    fun generateBitmap(
        qrData: String,
        userName: String,
        bloodType: String?,
        allergies: String?,
        emergencyContact: String?,
        emergencyPhone: String?,
        medicalNotes: String? = null
    ): Bitmap {
        val bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(bitmap)
        
        // Fondo negro OLED (ahorra bater√≠a)
        canvas.drawColor(Color.BLACK)
        
        // Paints
        val titlePaint = Paint().apply {
            color = Color.RED
            textSize = 72f
            typeface = Typeface.create(Typeface.DEFAULT_BOLD, Typeface.BOLD)
            textAlign = Paint.Align.CENTER
            isAntiAlias = true
        }
        
        val subtitlePaint = Paint().apply {
            color = Color.WHITE
            textSize = 48f
            typeface = Typeface.DEFAULT_BOLD
            textAlign = Paint.Align.CENTER
            isAntiAlias = true
        }
        
        val labelPaint = Paint().apply {
            color = Color.GRAY
            textSize = 36f
            textAlign = Paint.Align.CENTER
            isAntiAlias = true
        }
        
        val valuePaint = Paint().apply {
            color = Color.WHITE
            textSize = 56f
            typeface = Typeface.DEFAULT_BOLD
            textAlign = Paint.Align.CENTER
            isAntiAlias = true
        }
        
        val bloodTypePaint = Paint().apply {
            color = Color.RED
            textSize = 120f
            typeface = Typeface.create(Typeface.DEFAULT_BOLD, Typeface.BOLD)
            textAlign = Paint.Align.CENTER
            isAntiAlias = true
        }
        
        var yPos = 150f
        
        // T√≠tulo de emergencia
        canvas.drawText("üÜò EMERGENCIA M√âDICA", WIDTH / 2f, yPos, titlePaint)
        yPos += 80f
        
        // Nombre
        canvas.drawText(userName.uppercase(), WIDTH / 2f, yPos, subtitlePaint)
        yPos += 100f
        
        // QR Code
        val qrBitmap = generateQRCode(qrData, QR_SIZE)
        val qrLeft = (WIDTH - QR_SIZE) / 2f
        canvas.drawBitmap(qrBitmap, qrLeft, yPos, null)
        yPos += QR_SIZE + 40f
        
        canvas.drawText("Escanear para identificaci√≥n", WIDTH / 2f, yPos, labelPaint)
        yPos += 100f
        
        // Grupo Sangu√≠neo (Grande y prominente)
        if (!bloodType.isNullOrBlank()) {
            canvas.drawText("GRUPO SANGU√çNEO", WIDTH / 2f, yPos, labelPaint)
            yPos += 100f
            canvas.drawText(bloodType.uppercase(), WIDTH / 2f, yPos, bloodTypePaint)
            yPos += 120f
        }
        
        // Alergias
        if (!allergies.isNullOrBlank()) {
            canvas.drawText("‚ö†Ô∏è ALERGIAS", WIDTH / 2f, yPos, labelPaint)
            yPos += 60f
            // Dividir en l√≠neas si es muy largo
            val lines = wrapText(allergies, 35)
            for (line in lines) {
                canvas.drawText(line.uppercase(), WIDTH / 2f, yPos, valuePaint)
                yPos += 70f
            }
            yPos += 30f
        }
        
        // Contacto de Emergencia
        if (!emergencyContact.isNullOrBlank() || !emergencyPhone.isNullOrBlank()) {
            canvas.drawText("üìû CONTACTO EMERGENCIA", WIDTH / 2f, yPos, labelPaint)
            yPos += 60f
            
            if (!emergencyContact.isNullOrBlank()) {
                canvas.drawText(emergencyContact, WIDTH / 2f, yPos, valuePaint)
                yPos += 70f
            }
            if (!emergencyPhone.isNullOrBlank()) {
                canvas.drawText(emergencyPhone, WIDTH / 2f, yPos, valuePaint)
                yPos += 70f
            }
            yPos += 30f
        }
        
        // Notas m√©dicas
        if (!medicalNotes.isNullOrBlank()) {
            canvas.drawText("üìã NOTAS M√âDICAS", WIDTH / 2f, yPos, labelPaint)
            yPos += 60f
            val lines = wrapText(medicalNotes, 40)
            for (line in lines) {
                canvas.drawText(line, WIDTH / 2f, yPos, valuePaint.apply { textSize = 40f })
                yPos += 50f
            }
        }
        
        // Footer
        val footerPaint = Paint().apply {
            color = Color.DKGRAY
            textSize = 28f
            textAlign = Paint.Align.CENTER
            isAntiAlias = true
        }
        canvas.drawText("GeoRacing - Circuit de Barcelona-Catalunya", WIDTH / 2f, HEIGHT - 80f, footerPaint)
        canvas.drawText("Esta informaci√≥n puede salvar una vida", WIDTH / 2f, HEIGHT - 40f, footerPaint)
        
        return bitmap
    }
    
    /**
     * Genera un c√≥digo QR como Bitmap.
     */
    private fun generateQRCode(data: String, size: Int): Bitmap {
        return try {
            val hints = mapOf(
                EncodeHintType.MARGIN to 1,
                EncodeHintType.CHARACTER_SET to "UTF-8"
            )
            val bitMatrix = QRCodeWriter().encode(data, BarcodeFormat.QR_CODE, size, size, hints)
            
            val bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888)
            for (x in 0 until size) {
                for (y in 0 until size) {
                    bitmap.setPixel(x, y, if (bitMatrix[x, y]) Color.WHITE else Color.BLACK)
                }
            }
            bitmap
        } catch (e: Exception) {
            Log.e(TAG, "Error generating QR code", e)
            // Retornar bitmap vac√≠o en caso de error
            Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888).apply {
                Canvas(this).drawColor(Color.RED)
            }
        }
    }
    
    /**
     * Divide texto largo en l√≠neas.
     */
    private fun wrapText(text: String, maxCharsPerLine: Int): List<String> {
        if (text.length <= maxCharsPerLine) return listOf(text)
        
        val words = text.split(" ")
        val lines = mutableListOf<String>()
        var currentLine = StringBuilder()
        
        for (word in words) {
            if (currentLine.length + word.length + 1 > maxCharsPerLine) {
                if (currentLine.isNotEmpty()) {
                    lines.add(currentLine.toString().trim())
                    currentLine = StringBuilder()
                }
            }
            currentLine.append(word).append(" ")
        }
        if (currentLine.isNotEmpty()) {
            lines.add(currentLine.toString().trim())
        }
        
        return lines
    }
    
    /**
     * Guarda el Bitmap en la galer√≠a.
     * 
     * @return URI del archivo guardado, o null si falla
     */
    fun saveToGallery(context: Context, bitmap: Bitmap, fileName: String = "georacing_medical_lockscreen"): Uri? {
        return try {
            val contentValues = ContentValues().apply {
                put(MediaStore.Images.Media.DISPLAY_NAME, "$fileName.png")
                put(MediaStore.Images.Media.MIME_TYPE, "image/png")
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES + "/GeoRacing")
                    put(MediaStore.Images.Media.IS_PENDING, 1)
                }
            }
            
            val resolver = context.contentResolver
            val uri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)
            
            uri?.let {
                resolver.openOutputStream(it)?.use { stream ->
                    bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
                }
                
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    contentValues.clear()
                    contentValues.put(MediaStore.Images.Media.IS_PENDING, 0)
                    resolver.update(it, contentValues, null, null)
                }
                
                Log.d(TAG, "Image saved to gallery: $uri")
            }
            
            uri
        } catch (e: Exception) {
            Log.e(TAG, "Error saving to gallery", e)
            null
        }
    }
    
    /**
     * Establece el Bitmap como fondo de pantalla de bloqueo.
     * 
     * @return true si se estableci√≥ correctamente
     */
    fun setAsLockScreenWallpaper(context: Context, bitmap: Bitmap): Boolean {
        return try {
            val wallpaperManager = WallpaperManager.getInstance(context)
            
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                wallpaperManager.setBitmap(
                    bitmap,
                    null,
                    true,
                    WallpaperManager.FLAG_LOCK
                )
            } else {
                // En versiones anteriores, solo podemos establecer ambos
                wallpaperManager.setBitmap(bitmap)
            }
            
            Log.d(TAG, "Lock screen wallpaper set successfully")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Error setting lock screen wallpaper", e)
            false
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/utils/OffRouteDetector.kt`

```kotlin
package com.georacing.georacing.utils

import android.location.Location

/**
 * Detector de situaciones "fuera de ruta" (off-route).
 * 
 * Implementa l√≥gica robusta para evitar falsos positivos:
 * - No marca off-route instant√°neamente
 * - Requiere estar fuera durante un tiempo m√≠nimo
 * - Threshold de distancia configurable
 */
object OffRouteDetector {
    
    /**
     * FASE 1.2: Threshold din√°mico seg√∫n velocidad
     * - Parking/ciudad (<40 km/h): 30m (m√°s estricto)
     * - Carretera normal (40-80 km/h): 50m (actual)
     * - Autopista (>80 km/h): 80m (m√°s permisivo, evita falsos positivos en 6 carriles)
     */
    fun dynamicOffRouteThreshold(speedKmh: Float): Double {
        return when {
            speedKmh < 40f -> 30.0
            speedKmh < 80f -> 50.0
            else -> 80.0
        }
    }
    
    /**
     * Distancia m√°xima permitida al punto m√°s cercano de la ruta (LEGACY - ahora din√°mico).
     * @deprecated Usar dynamicOffRouteThreshold(speedKmh) en su lugar
     */
    @Deprecated("Use dynamicOffRouteThreshold(speedKmh) for speed-dependent threshold")
    private const val OFF_ROUTE_THRESHOLD_METERS = 50.0
    
    /**
     * Tiempo m√≠nimo que el usuario debe estar fuera de ruta
     * antes de confirmar que realmente se desvi√≥.
     * 
     * Esto evita recalcular la ruta por:
     * - Imprecisi√≥n GPS moment√°nea
     * - T√∫neles
     * - Cambios de carril
     */
    private const val MIN_OFF_ROUTE_DURATION_MS = 3000L  // 3 segundos
    
    /**
     * Timestamp de la primera vez que detectamos off-route.
     * null = actualmente dentro de la ruta
     */
    private var firstOffRouteTime: Long? = null
    
    /**
     * √öltima ubicaci√≥n que se comprob√≥
     */
    private var lastCheckedLocation: Location? = null
    
    /**
     * Comprueba si el usuario est√° fuera de ruta de forma confirmada.
     * 
     * @param location Ubicaci√≥n GPS actual
     * @param snapResult Resultado del snap a la ruta
     * @return true si confirmamos que est√° fuera de ruta
     */
    fun checkOffRoute(
        location: Location,
        snapResult: SnapResult
    ): Boolean {
        // FASE 1.2: Usar threshold din√°mico seg√∫n velocidad
        val speedKmh = if (location.hasSpeed()) location.speed * 3.6f else 0f
        val threshold = dynamicOffRouteThreshold(speedKmh)
        
        val isCurrentlyOffRoute = snapResult.distanceToRoute > threshold
        
        if (isCurrentlyOffRoute) {
            val now = System.currentTimeMillis()
            
            if (firstOffRouteTime == null) {
                // Primera detecci√≥n de off-route
                firstOffRouteTime = now
                lastCheckedLocation = location
                return false  // Dar tiempo de gracia
            }
            
            val durationOffRoute = now - firstOffRouteTime!!
            
            if (durationOffRoute >= MIN_OFF_ROUTE_DURATION_MS) {
                // Confirmar: ha estado fuera de ruta suficiente tiempo
                android.util.Log.w(
                    "OffRouteDetector",
                    "OFF ROUTE CONFIRMED: ${snapResult.distanceToRoute}m away (threshold=${threshold}m at ${speedKmh}km/h) for ${durationOffRoute}ms"
                )
                return true
            } else {
                // A√∫n en per√≠odo de gracia
                android.util.Log.d(
                    "OffRouteDetector",
                    "OFF ROUTE WARNING: ${snapResult.distanceToRoute}m away (threshold=${threshold}m at ${speedKmh}km/h), waiting... (${durationOffRoute}ms)"
                )
                return false
            }
        } else {
            // Volvi√≥ a la ruta (o nunca sali√≥)
            if (firstOffRouteTime != null) {
                android.util.Log.i("OffRouteDetector", "Back on route")
            }
            reset()
            return false
        }
    }
    
    /**
     * Resetea el estado interno.
     * Llamar cuando:
     * - Usuario vuelve a la ruta
     * - Se recalcula la ruta
     * - Se inicia nueva navegaci√≥n
     */
    fun reset() {
        firstOffRouteTime = null
        lastCheckedLocation = null
    }
    
    /**
     * Versi√≥n alternativa con threshold personalizado.
     * √ötil para ajustar sensibilidad en diferentes escenarios.
     * 
     * @param customThresholdMeters Distancia m√°xima permitida
     * @param customDurationMs Tiempo m√≠nimo fuera de ruta
     */
    fun checkOffRouteCustom(
        location: Location,
        snapResult: SnapResult,
        customThresholdMeters: Double = OFF_ROUTE_THRESHOLD_METERS,
        customDurationMs: Long = MIN_OFF_ROUTE_DURATION_MS
    ): Boolean {
        val isCurrentlyOffRoute = snapResult.distanceToRoute > customThresholdMeters
        
        if (isCurrentlyOffRoute) {
            val now = System.currentTimeMillis()
            
            if (firstOffRouteTime == null) {
                firstOffRouteTime = now
                lastCheckedLocation = location
                return false
            }
            
            val durationOffRoute = now - firstOffRouteTime!!
            return durationOffRoute >= customDurationMs
        } else {
            reset()
            return false
        }
    }
    
    /**
     * Helper para debugging: obtener estado actual
     */
    fun getDebugInfo(): String {
        return if (firstOffRouteTime != null) {
            val duration = System.currentTimeMillis() - firstOffRouteTime!!
            "Off-route for ${duration}ms"
        } else {
            "On route"
        }
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/utils/RouteSnapper.kt`

```kotlin
package com.georacing.georacing.utils

import android.location.Location
import org.maplibre.android.geometry.LatLng

/**
 * Resultado del snap-to-route: punto m√°s cercano en la ruta
 */
data class SnapResult(
    val closestIndex: Int,           // √çndice del punto m√°s cercano
    val closestPoint: LatLng,        // Coordenadas del punto m√°s cercano
    val distanceToRoute: Double      // Distancia en metros al punto m√°s cercano
)

/**
 * Utilidad para hacer snap de la posici√≥n GPS a la ruta calculada.
 * Esto evita que el coche "salte" fuera de la l√≠nea de la ruta en el mapa.
 */
object RouteSnapper {
    
    /**
     * Encuentra el punto m√°s cercano de la ruta a la posici√≥n actual.
     * 
     * @param currentLocation Posici√≥n GPS actual
     * @param routePoints Lista de puntos que forman la geometr√≠a de la ruta
     * @return SnapResult con el punto m√°s cercano e informaci√≥n relacionada
     */
    fun snapToRoute(
        currentLocation: Location,
        routePoints: List<LatLng>
    ): SnapResult {
        if (routePoints.isEmpty()) {
            throw IllegalArgumentException("Route points cannot be empty")
        }
        
        var minDistance = Double.MAX_VALUE
        var closestIndex = 0
        var closestPoint = routePoints[0]
        
        routePoints.forEachIndexed { index, point ->
            val dist = currentLocation.distanceTo(point.toLocation()).toDouble()
            if (dist < minDistance) {
                minDistance = dist
                closestIndex = index
                closestPoint = point
            }
        }
        
        return SnapResult(
            closestIndex = closestIndex,
            closestPoint = closestPoint,
            distanceToRoute = minDistance
        )
    }
    
    /**
     * Variante optimizada que solo busca en un rango alrededor de la √∫ltima posici√≥n conocida.
     * √ötil para rutas muy largas donde no tiene sentido buscar en toda la geometr√≠a.
     * 
     * @param currentLocation Posici√≥n GPS actual
     * @param routePoints Lista de puntos de la ruta
     * @param lastKnownIndex √öltimo √≠ndice conocido (de update anterior)
     * @param searchRadius Cu√°ntos puntos buscar antes/despu√©s del lastKnownIndex
     */
    fun snapToRouteOptimized(
        currentLocation: Location,
        routePoints: List<LatLng>,
        lastKnownIndex: Int,
        searchRadius: Int = 50
    ): SnapResult {
        return snapInWindow(
            currentLocation = currentLocation,
            routePoints = routePoints,
            lastKnownIndex = lastKnownIndex,
            searchRadius = searchRadius
        )
    }
    
    /**
     * FASE 2.1: Snap adaptativo en dos pasadas.
     * 
     * Primera pasada: b√∫squeda r√°pida con ventana reducida (firstRadius).
     * Segunda pasada: si la distancia es muy grande, ampl√≠a la b√∫squeda (secondRadius).
     * 
     * Ideal para rutas con densidad variable de puntos o cuando el GPS puede haber saltado.
     * 
     * @param currentLocation Posici√≥n GPS actual
     * @param routePoints Lista completa de puntos de la ruta
     * @param lastIndex √öltimo √≠ndice conocido (de update anterior)
     * @param firstRadius Radio inicial para b√∫squeda r√°pida (puntos antes/despu√©s)
     * @param secondRadius Radio ampliado si primera pasada est√° muy lejos
     * @param distanceThresholdMeters Si distanceToRoute > threshold, hace segunda pasada
     * @return SnapResult con el mejor punto encontrado
     */
    fun snapToRouteAdaptive(
        currentLocation: Location,
        routePoints: List<LatLng>,
        lastIndex: Int,
        firstRadius: Int = 30,
        secondRadius: Int = 100,
        distanceThresholdMeters: Double = 80.0
    ): SnapResult {
        if (routePoints.isEmpty()) {
            throw IllegalArgumentException("Route points cannot be empty")
        }
        
        // PRIMERA PASADA: b√∫squeda r√°pida con ventana reducida
        val firstPassResult = snapInWindow(
            currentLocation = currentLocation,
            routePoints = routePoints,
            lastKnownIndex = lastIndex,
            searchRadius = firstRadius
        )
        
        android.util.Log.d(
            "RouteSnapper",
            "FASE 2.1 - Primera pasada (radius=$firstRadius): " +
            "index=${firstPassResult.closestIndex}, distToRoute=${firstPassResult.distanceToRoute}m"
        )
        
        // Si est√° cerca, usar resultado de primera pasada
        if (firstPassResult.distanceToRoute <= distanceThresholdMeters) {
            return firstPassResult
        }
        
        // SEGUNDA PASADA: GPS puede haber saltado, ampliar b√∫squeda
        android.util.Log.w(
            "RouteSnapper",
            "FASE 2.1 - Primera pasada muy lejos (${firstPassResult.distanceToRoute}m > ${distanceThresholdMeters}m), " +
            "ampliando b√∫squeda con radius=$secondRadius"
        )
        
        val secondPassResult = snapInWindow(
            currentLocation = currentLocation,
            routePoints = routePoints,
            lastKnownIndex = lastIndex,
            searchRadius = secondRadius
        )
        
        android.util.Log.d(
            "RouteSnapper",
            "FASE 2.1 - Segunda pasada: index=${secondPassResult.closestIndex}, " +
            "distToRoute=${secondPassResult.distanceToRoute}m"
        )
        
        // Si segunda pasada sigue muy lejos, advertir (posible off-route)
        if (secondPassResult.distanceToRoute > distanceThresholdMeters) {
            android.util.Log.w(
                "RouteSnapper",
                "FASE 2.1 - Segunda pasada tambi√©n lejos (${secondPassResult.distanceToRoute}m). " +
                "Posible off-route o GPS inestable."
            )
        }
        
        return secondPassResult
    }
    
    /**
     * Funci√≥n interna: busca el punto m√°s cercano en una ventana alrededor de lastKnownIndex.
     * Reutilizada por snapToRouteOptimized y snapToRouteAdaptive.
     */
    private fun snapInWindow(
        currentLocation: Location,
        routePoints: List<LatLng>,
        lastKnownIndex: Int,
        searchRadius: Int
    ): SnapResult {
        val startIndex = (lastKnownIndex - searchRadius).coerceAtLeast(0)
        val endIndex = (lastKnownIndex + searchRadius).coerceAtMost(routePoints.size - 1)
        
        var minDistance = Double.MAX_VALUE
        var closestIndex = lastKnownIndex.coerceIn(0, routePoints.size - 1)
        var closestPoint = routePoints[closestIndex]
        
        for (i in startIndex..endIndex) {
            val point = routePoints[i]
            val dist = currentLocation.distanceTo(point.toLocation()).toDouble()
            if (dist < minDistance) {
                minDistance = dist
                closestIndex = i
                closestPoint = point
            }
        }
        
        return SnapResult(
            closestIndex = closestIndex,
            closestPoint = closestPoint,
            distanceToRoute = minDistance
        )
    }
}

/**
 * Extension function para convertir LatLng a Location
 */
fun LatLng.toLocation(): Location {
    return Location("").apply {
        latitude = this@toLocation.latitude
        longitude = this@toLocation.longitude
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/utils/StepDetector.kt`

```kotlin
package com.georacing.georacing.utils

import com.georacing.georacing.car.RouteResult
import com.georacing.georacing.car.Step as OsrmStep
import org.maplibre.android.geometry.LatLng

/**
 * Informaci√≥n sobre el paso/maniobra actual
 */
data class StepInfo(
    val index: Int,                    // √çndice del paso en route.steps
    val step: OsrmStep,                // Objeto del paso
    val distanceToManeuver: Double     // Metros hasta la maniobra
)

/**
 * Detector del paso/instrucci√≥n actual en la navegaci√≥n.
 * Determina qu√© maniobra viene a continuaci√≥n y a qu√© distancia est√°.
 */
object StepDetector {
    
    /**
     * Encuentra el paso actual bas√°ndose en la posici√≥n en la ruta.
     * 
     * Algoritmo:
     * 1. Recorrer todos los pasos de la ruta
     * 2. Acumular la distancia de cada paso
     * 3. Comparar con el progreso actual en la ruta
     * 4. Cuando el progreso del paso > progreso actual -> ese es el pr√≥ximo paso
     * 
     * @param snapResult Posici√≥n actual en la ruta
     * @param route Ruta completa con steps
     * @return StepInfo con el paso actual y distancia a la maniobra
     */
    fun findCurrentStep(
        snapResult: SnapResult,
        route: RouteResult
    ): StepInfo {
        if (route.steps.isEmpty()) {
            throw IllegalStateException("Route has no steps")
        }
        
        var accumulatedDistance = 0.0
        val progressThroughRoute = snapResult.closestIndex.toDouble() / route.points.size
        
        for (stepIndex in route.steps.indices) {
            val step = route.steps[stepIndex]
            accumulatedDistance += step.distance
            
            // Punto de progreso donde deber√≠a estar este paso
            val stepProgressPoint = accumulatedDistance / route.distance
            
            // Si este paso est√° adelante en la ruta
            if (stepProgressPoint > progressThroughRoute) {
                // Calcular distancia exacta al paso
                val distanceToStep = calculateDistanceToStep(
                    snapResult.closestIndex,
                    stepIndex,
                    route
                )
                
                return StepInfo(
                    index = stepIndex,
                    step = step,
                    distanceToManeuver = distanceToStep.coerceAtLeast(0.0)
                )
            }
        }
        
        // Si llegamos aqu√≠, estamos en el √∫ltimo paso
        val lastStep = route.steps.last()
        val remainingDistance = DistanceCalculator.calculateRemainingDistance(
            snapResult,
            route.points
        )
        
        return StepInfo(
            index = route.steps.size - 1,
            step = lastStep,
            distanceToManeuver = remainingDistance
        )
    }
    
    /**
     * Calcula la distancia exacta desde el √≠ndice actual hasta el inicio de un paso.
     * 
     * @param currentIndex √çndice actual en route.points
     * @param stepIndex √çndice del paso objetivo
     * @param route Ruta completa
     */
    private fun calculateDistanceToStep(
        currentIndex: Int,
        stepIndex: Int,
        route: RouteResult
    ): Double {
        // Calcular en qu√© √≠ndice de points empieza este step
        var accumulatedDistance = 0.0
        for (i in 0 until stepIndex) {
            accumulatedDistance += route.steps[i].distance
        }
        
        // Convertir distancia acumulada a √≠ndice aproximado
        val progressToStep = accumulatedDistance / route.distance
        val stepStartIndex = (progressToStep * route.points.size).toInt()
            .coerceIn(0, route.points.size - 1)
        
        // Sumar distancias desde currentIndex hasta stepStartIndex
        var distToStep = 0.0
        for (i in currentIndex until stepStartIndex.coerceAtMost(route.points.size - 1)) {
            val p1 = route.points[i].toLocation()
            val p2 = route.points[i + 1].toLocation()
            distToStep += p1.distanceTo(p2).toDouble()
        }
        
        return distToStep
    }
    
    /**
     * Helper para detectar si hemos pasado un paso y debemos avanzar al siguiente.
     * 
     * @param currentStepInfo Informaci√≥n del paso actual
     * @return true si debemos avanzar al siguiente paso
     */
    fun shouldAdvanceToNextStep(currentStepInfo: StepInfo): Boolean {
        // Si estamos a menos de 20m de la maniobra, consideramos que ya la pasamos
        // (threshold peque√±o para que las instrucciones de voz sean precisas)
        return currentStepInfo.distanceToManeuver < 20.0
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/utils/TTSManager.kt`

```kotlin
package com.georacing.georacing.utils

import android.speech.tts.TextToSpeech
import android.util.Log

/**
 * Gestor de instrucciones de voz progresivas estilo Google Maps.
 * 
 * Comportamiento:
 * - 500m antes: "En 500 metros, gira a la derecha"
 * - 200m antes: "En 200 metros, gira a la derecha"
 * - 50m antes: "En 50 metros, gira a la derecha"
 * - 0m: "Gira a la derecha ahora"
 * 
 * Caracter√≠sticas:
 * - No repite la misma instrucci√≥n en el mismo umbral
 * - Solo habla cuando cambia de umbral o cambia la instrucci√≥n
 * - Cancela instrucciones anteriores si hay una nueva urgente
 */
object TTSManager {
    
    private const val TAG = "TTSManager"
    
    /**
     * Umbrales de distancia para instrucciones progresivas (en metros)
     */
    private const val THRESHOLD_FAR = 500.0
    private const val THRESHOLD_MEDIUM = 200.0
    private const val THRESHOLD_NEAR = 50.0
    private const val THRESHOLD_NOW = 0.0
    
    /**
     * FASE 1.3: Flags anti-saltos de umbral
     * Previenen que se pierdan mensajes si el usuario pasa de 600m a 150m en 1 tick
     * (por ejemplo en t√∫nel GPS o alta velocidad)
     */
    private var spoken500 = false
    private var spoken200 = false
    private var spoken50 = false
    private var spokenNow = false
    
    /**
     * Cooldown para evitar TTS repetitivo cuando el usuario est√° quieto.
     * M√≠nimo 10 segundos entre mensajes con el mismo contenido.
     */
    private var lastSpokenMessage: String? = null
    private var lastSpokenTime: Long = 0L
    private const val TTS_COOLDOWN_MS = 10000L  // 10 segundos
    
    /**
     * Estado interno para evitar repeticiones (LEGACY - ahora usamos flags)
     */
    @Deprecated("Use spoken500/200/50 flags instead")
    private var lastSpokenThreshold = -1
    private var lastInstruction: String? = null
    
    /**
     * Maneja las instrucciones de voz progresivas.
     * 
     * FASE 2.4: Refinamiento de l√≥gica anti-saltos.
     * - Solo dispara el umbral M√ÅS CERCANO aplicable en cada momento.
     * - No fuerza umbrales innecesarios cuando ya pasaste de largo.
     * - Ejemplo: 600m‚Üí150m solo dice "200m", no insiste con "500m".
     * 
     * @param instruction Texto base de la instrucci√≥n (ej: "gira a la derecha")
     * @param distanceToManeuver Distancia en metros hasta la maniobra
     * @param tts Instancia de TextToSpeech configurada
     * @param forceSpeak Forzar hablar incluso si ya se dijo en este umbral
     */
    fun handleProgressiveTTS(
        instruction: String,
        distanceToManeuver: Double,
        tts: TextToSpeech?,
        forceSpeak: Boolean = false
    ) {
        if (tts == null) {
            Log.w(TAG, "TTS not initialized")
            return
        }
        
        // FASE 2.4: Resetear flags si cambia la instrucci√≥n
        if (instruction != lastInstruction) {
            spoken500 = false
            spoken200 = false
            spoken50 = false
            spokenNow = false
            lastInstruction = instruction
            Log.d(TAG, "FASE 2.4 - Nueva instrucci√≥n: '$instruction', flags reseteados")
        }
        
        // FASE 2.4: L√≥gica refinada - solo dispara el umbral M√ÅS CERCANO aplicable
        // Se eval√∫a de CERCA a LEJOS para priorizar urgencia
        var phrase: String? = null
        
        when {
            // Umbral INMEDIATO (‚â§10m)
            distanceToManeuver <= 10 && !spokenNow -> {
                phrase = "$instruction ahora"
                spokenNow = true
                Log.d(TAG, "FASE 2.4 - Umbral NOW (‚â§10m) alcanzado")
            }
            
            // Umbral CERCA (‚â§50m)
            distanceToManeuver <= THRESHOLD_NEAR && !spoken50 -> {
                phrase = "En 50 metros, $instruction"
                spoken50 = true
                spokenNow = true  // Marcar tambi√©n "now" para evitar repetir
                Log.d(TAG, "FASE 2.4 - Umbral 50m alcanzado (dist=${distanceToManeuver.toInt()}m)")
            }
            
            // Umbral MEDIO (‚â§200m)
            distanceToManeuver <= THRESHOLD_MEDIUM && !spoken200 -> {
                phrase = "En 200 metros, $instruction"
                spoken200 = true
                spoken50 = true    // Marcar umbrales m√°s cercanos
                spokenNow = true
                Log.d(TAG, "FASE 2.4 - Umbral 200m alcanzado (dist=${distanceToManeuver.toInt()}m)")
            }
            
            // Umbral LEJOS (‚â§500m)
            distanceToManeuver <= THRESHOLD_FAR && !spoken500 -> {
                phrase = "En 500 metros, $instruction"
                spoken500 = true
                spoken200 = true   // Marcar todos los umbrales m√°s cercanos
                spoken50 = true
                spokenNow = true
                Log.d(TAG, "FASE 2.4 - Umbral 500m alcanzado (dist=${distanceToManeuver.toInt()}m)")
            }
        }
        
        // Hablar solo si hay frase nueva o se fuerza
        if (phrase != null || forceSpeak) {
            val finalPhrase = phrase ?: buildPhrase(instruction, 0)
            Log.d(TAG, "Speaking: $finalPhrase (distance: ${distanceToManeuver.toInt()}m)")
            tts.speak(finalPhrase, TextToSpeech.QUEUE_FLUSH, null, null)
        } else {
            // Log de debug: por qu√© no se habl√≥
            Log.v(TAG, "No speech: dist=${distanceToManeuver.toInt()}m, flags=[500:$spoken500, 200:$spoken200, 50:$spoken50, now:$spokenNow]")
        }
    }
    
    /**
     * Construye la frase seg√∫n el umbral de distancia.
     */
    private fun buildPhrase(baseInstruction: String, threshold: Int): String {
        return when (threshold) {
            THRESHOLD_FAR.toInt() -> "En 500 metros, $baseInstruction"
            THRESHOLD_MEDIUM.toInt() -> "En 200 metros, $baseInstruction"
            THRESHOLD_NEAR.toInt() -> "En 50 metros, $baseInstruction"
            else -> "$baseInstruction ahora"
        }
    }
    
    /**
     * Habla un mensaje √∫nico (no progresivo).
     * √ötil para anuncios como "Ruta recalculada", "Has llegado", etc.
     * 
     * Incluye cooldown de 10 segundos para evitar repeticiones molestas.
     */
    fun speak(
        message: String,
        tts: TextToSpeech?,
        interruptCurrent: Boolean = true
    ) {
        if (tts == null) {
            Log.w(TAG, "TTS not initialized")
            return
        }
        
        // üõ°Ô∏è Cooldown: No repetir el mismo mensaje en 10 segundos
        val now = System.currentTimeMillis()
        if (message == lastSpokenMessage && (now - lastSpokenTime) < TTS_COOLDOWN_MS) {
            Log.d(TAG, "TTS cooldown active, skipping: $message")
            return
        }
        
        val queueMode = if (interruptCurrent) {
            TextToSpeech.QUEUE_FLUSH
        } else {
            TextToSpeech.QUEUE_ADD
        }
        
        Log.d(TAG, "Speaking: $message")
        tts.speak(message, queueMode, null, null)
        
        // Guardar para cooldown
        lastSpokenMessage = message
        lastSpokenTime = now
    }
    
    /**
     * Resetea el estado interno.
     * Llamar cuando:
     * - Se inicia una nueva navegaci√≥n
     * - Se recalcula la ruta
     * - Se avanza al siguiente paso
     */
    fun reset() {
        // FASE 1.3: Resetear flags nuevos
        spoken500 = false
        spoken200 = false
        spoken50 = false
        spokenNow = false
        lastInstruction = null
        lastSpokenThreshold = -1  // Legacy
        // Resetear cooldown
        lastSpokenMessage = null
        lastSpokenTime = 0L
        Log.d(TAG, "TTS state reset (flags + cooldown cleared)")
    }
    
    /**
     * Cancela cualquier instrucci√≥n en cola.
     */
    fun stopSpeaking(tts: TextToSpeech?) {
        tts?.stop()
        Log.d(TAG, "TTS stopped")
    }
    
    /**
     * Traduce el tipo de maniobra a texto en espa√±ol.
     * 
     * @param maneuverType Tipo de OSRM (turn, roundabout, etc.)
     * @param modifier Modificador (left, right, sharp, slight, etc.)
     * @param streetName Nombre de la calle/vial (opcional)
     */
    fun getInstructionText(
        maneuverType: String,
        modifier: String?,
        streetName: String?
    ): String {
        val direction = when (modifier) {
            "left" -> "a la izquierda"
            "right" -> "a la derecha"
            "sharp left" -> "bruscamente a la izquierda"
            "sharp right" -> "bruscamente a la derecha"
            "slight left" -> "ligeramente a la izquierda"
            "slight right" -> "ligeramente a la derecha"
            else -> ""
        }
        
        val action = when (maneuverType) {
            "turn" -> "gira $direction"
            "depart" -> "sal $direction"
            "arrive" -> "has llegado a tu destino"
            "merge" -> "incorp√≥rate $direction"
            "on ramp" -> "toma la rampa $direction"
            "off ramp" -> "sal por la rampa $direction"
            "fork" -> "toma el desv√≠o $direction"
            "end of road" -> "al final de la v√≠a, gira $direction"
            "continue" -> "contin√∫a"
            "roundabout" -> "en la rotonda, toma la salida $direction"
            "rotary" -> "en la rotonda, toma la salida $direction"
            else -> "contin√∫a $direction"
        }
        
        return if (!streetName.isNullOrBlank() && maneuverType != "arrive") {
            "$action hacia $streetName"
        } else {
            action
        }
    }
    
    /**
     * Helper para anunciar llegada al destino.
     */
    fun announceArrival(destinationName: String, tts: TextToSpeech?) {
        speak("Has llegado a $destinationName", tts, interruptCurrent = true)
    }
    
    /**
     * Helper para anunciar recalculo de ruta.
     */
    fun announceRouteRecalculation(tts: TextToSpeech?) {
        speak("Recalculando ruta", tts, interruptCurrent = true)
    }
    
    /**
     * Helper para anunciar ruta calculada con informaci√≥n inicial.
     */
    fun announceRouteCalculated(
        distance: Double,
        duration: Double,
        firstInstruction: String,
        tts: TextToSpeech?
    ) {
        val distanceKm = (distance / 1000).toInt()
        val durationMin = (duration / 60).toInt()
        
        val message = "Ruta calculada: $distanceKm kil√≥metros, $durationMin minutos. $firstInstruction"
        speak(message, tts, interruptCurrent = true)
    }
}

```

---

## `Android_App/app/src/main/java/com/georacing/georacing/utils/VoiceAnnouncer.kt`

```kotlin
package com.georacing.georacing.utils

import android.content.Context
import android.speech.tts.TextToSpeech
import android.util.Log
import com.georacing.georacing.debug.ScenarioSimulator
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import java.util.Locale

/**
 * VoiceAnnouncer: Observa eventos del ScenarioSimulator y los anuncia por TTS.
 *
 * Dise√±ado para accesibilidad y demos inmersivas.
 * Utiliza TTSManager.speak() que ya incluye cooldown de 10s para evitar repeticiones.
 */
class VoiceAnnouncer(context: Context) {

    private val TAG = "VoiceAnnouncer"
    
    private var tts: TextToSpeech? = null
    private var isTtsReady = false
    private val scope = CoroutineScope(Dispatchers.Main + Job())
    
    // Debounce flags para evitar repeticiones al cambiar r√°pidamente
    private var lastNetworkDead = false
    private var lastCrowdHigh = false
    private var lastAtGate = false
    private var lastSurvivalMode = false
    
    init {
        tts = TextToSpeech(context) { status ->
            if (status == TextToSpeech.SUCCESS) {
                tts?.language = Locale("es", "ES")
                isTtsReady = true
                Log.d(TAG, "TTS initialized successfully")
                startObserving()
            } else {
                Log.e(TAG, "TTS initialization failed: $status")
            }
        }
    }
    
    private fun startObserving() {
        // 1. Observar fallo de red
        scope.launch {
            ScenarioSimulator.isNetworkDead
                .collectLatest { isDead ->
                    if (isDead && !lastNetworkDead) {
                        announce("Atenci√≥n. Fallo cr√≠tico de red. Activando protocolo de supervivencia offline.")
                    }
                    lastNetworkDead = isDead
                }
        }
        
        // 2. Observar intensidad de multitud
        scope.launch {
            ScenarioSimulator.crowdIntensity
                .collectLatest { intensity ->
                    val isHigh = intensity > 0.5f
                    if (isHigh && !lastCrowdHigh) {
                        announce("Alerta de flujo. Alta densidad detectada en acceso principal. Sugiriendo ruta alternativa.")
                    }
                    lastCrowdHigh = isHigh
                }
        }
        
        // 3. Observar llegada a puerta
        scope.launch {
            ScenarioSimulator.isAtGate
                .collectLatest { atGate ->
                    if (atGate && !lastAtGate) {
                        announce("Llegada a puerta detectada. Desplegando entrada inteligente.")
                    }
                    lastAtGate = atGate
                }
        }
        
        // 4. Observar bater√≠a cr√≠tica (Survival Mode = battery <= 20%)
        scope.launch {
            ScenarioSimulator.forcedBatteryLevel
                .collectLatest { batteryLevel ->
                    val isSurvival = batteryLevel != null && batteryLevel <= 20
                    if (isSurvival && !lastSurvivalMode) {
                        announce("Bater√≠a cr√≠tica. Optimizando sistemas para garantizar el retorno.")
                    }
                    lastSurvivalMode = isSurvival
                }
        }
        
        Log.d(TAG, "Started observing ScenarioSimulator states")
    }
    
    private fun announce(message: String) {
        if (isTtsReady) {
            Log.d(TAG, "Announcing: $message")
            TTSManager.speak(message, tts, interruptCurrent = true)
        } else {
            Log.w(TAG, "TTS not ready, skipping: $message")
        }
    }
    
    /**
     * Liberar recursos TTS cuando ya no se necesite.
     */
    fun shutdown() {
        tts?.stop()
        tts?.shutdown()
        tts = null
        isTtsReady = false
        Log.d(TAG, "VoiceAnnouncer shutdown")
    }
}

```

---

## `Android_App/settings.gradle.kts`

```kotlin
pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}


rootProject.name = "My Application"
include(":app")
 
```

---

## `Android_App/gradle.properties`

```
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx4096m -Dfile.encoding=UTF-8
# org.gradle.java.home=I:/Android-studio/jbr
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. For more details, visit
# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true

```

---

## `Android_App/app/src/main/AndroidManifest.xml`

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACTIVITY_RECOGNITION" />
    <uses-permission android:name="android.permission.CAMERA" />
    
    <queries>
        <package android:name="com.google.android.apps.healthdata" />
    </queries>
    
    <!-- Permisos para Nearby Connections (P2P) -->
    <uses-permission android:name="android.permission.BLUETOOTH" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" 
        tools:targetApi="s" />
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    <uses-permission android:name="android.permission.NEARBY_WIFI_DEVICES" />
    <uses-permission android:name="androidx.car.app.MAP_TEMPLATES" />
    <uses-permission android:name="androidx.car.app.NAVIGATION_TEMPLATES" />
    <uses-permission android:name="androidx.car.app.ACCESS_SURFACE" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE" />
    <uses-permission android:name="android.permission.USE_FULL_SCREEN_INTENT" />
    
    <!-- üÜò Medical Lock Screen: Establecer fondo de pantalla -->
    <uses-permission android:name="android.permission.SET_WALLPAPER" />

    <!-- üè• Health Connect - Phase 3 real integration -->
    <uses-permission android:name="android.permission.health.READ_STEPS" />
    <uses-permission android:name="android.permission.health.READ_DISTANCE" />
    
    <!-- AR Lite / QR Scanning -->
    <!-- CAMERA permission already declared above -->

    <application
        android:allowBackup="true"
        android:appCategory="game"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.GeoRacing">

        <meta-data
            android:name="com.google.android.gms.car.application"
            android:resource="@xml/automotive_app_desc" />
        <meta-data
            android:name="androidx.car.app.minCarApiLevel"
            android:value="1" />

        <meta-data
            android:name="com.google.android.gms.wallet.api.enabled"
            android:value="true" />

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.GeoRacing">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <service
            android:name=".services.StatePollingService"
            android:exported="false"
            android:foregroundServiceType="location" />

        <activity
            android:name=".ui.evacuation.EvacuationActivity"
            android:theme="@style/Theme.GeoRacing"
            android:launchMode="singleTop" />

        <service
            android:name=".car.GeoRacingCarAppService"
            android:exported="true">

            <intent-filter>
                <action android:name="androidx.car.app.CarAppService" />
                <category android:name="androidx.car.app.category.NAVIGATION" />
            </intent-filter>
        </service>

        <!-- üÜï Live Session Engine (Live Activities) -->
        <service
            android:name=".services.LiveSessionService"
            android:exported="false"
            android:foregroundServiceType="location|connectedDevice" />

        <activity
            android:name=".ui.screens.health.PrivacyPolicyActivity"
            android:exported="true"
            android:label="Pol√≠tica de Privacidad">
            <intent-filter>
                <action android:name="androidx.health.ACTION_SHOW_PERMISSIONS_RATIONALE" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW_PERMISSION_USAGE"/>
                <category android:name="android.intent.category.HEALTH_PERMISSIONS"/>
            </intent-filter>
            <intent-filter>
                <action android:name="androidx.health.connect.HealthConnectClient.ACTION_HEALTH_CONNECT_SETTINGS" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>

    </application>

</manifest>

```

